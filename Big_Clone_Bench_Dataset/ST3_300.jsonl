{"clone_type": "ST3", "method1_id": 541191, "method2_id": 656000, "code1": "public static void main (String [] argv) {\n    String to, subject = null, from = null, cc = null, bcc = null, url = null;\n    String mailhost = null;\n    String mailer = \"msgsend\";\n    String file = null;\n    String protocol = null, host = null, user = null, password = null;\n    String record = null;\n    boolean debug = false;\n    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n    int optind;\n    for (optind = 0; optind < argv.length; optind ++) {\n        if (argv [optind].equals (\"-T\")) {\n            protocol = argv [++ optind];\n        } else if (argv [optind].equals (\"-H\")) {\n            host = argv [++ optind];\n        } else if (argv [optind].equals (\"-U\")) {\n            user = argv [++ optind];\n        } else if (argv [optind].equals (\"-P\")) {\n            password = argv [++ optind];\n        } else if (argv [optind].equals (\"-M\")) {\n            mailhost = argv [++ optind];\n        } else if (argv [optind].equals (\"-f\")) {\n            record = argv [++ optind];\n        } else if (argv [optind].equals (\"-a\")) {\n            file = argv [++ optind];\n        } else if (argv [optind].equals (\"-s\")) {\n            subject = argv [++ optind];\n        } else if (argv [optind].equals (\"-o\")) {\n            from = argv [++ optind];\n        } else if (argv [optind].equals (\"-c\")) {\n            cc = argv [++ optind];\n        } else if (argv [optind].equals (\"-b\")) {\n            bcc = argv [++ optind];\n        } else if (argv [optind].equals (\"-L\")) {\n            url = argv [++ optind];\n        } else if (argv [optind].equals (\"-d\")) {\n            debug = true;\n        } else if (argv [optind].equals (\"--\")) {\n            optind ++;\n            break;\n        } else if (argv [optind].startsWith (\"-\")) {\n            System.out.println (\"Usage: msgsend [[-L store-url] | [-T prot] [-H host] [-U user] [-P passwd]]\");\n            System.out.println (\"\\t[-s subject] [-o from-address] [-c cc-addresses] [-b bcc-addresses]\");\n            System.out.println (\"\\t[-f record-mailbox] [-M transport-host] [-a attach-file] [-d] [address]\");\n            System.exit (1);\n        } else {\n            break;\n        }\n\n    }\n    try {\n        if (optind < argv.length) {\n            to = argv [optind];\n            System.out.println (\"To: \" + to);\n        } else {\n            System.out.print (\"To: \");\n            System.out.flush ();\n            to = in.readLine ();\n        }\n        if (subject == null) {\n            System.out.print (\"Subject: \");\n            System.out.flush ();\n            subject = in.readLine ();\n        } else {\n            System.out.println (\"Subject: \" + subject);\n        }\n        Properties props = System.getProperties ();\n        if (mailhost != null) props.put (\"mail.smtp.host\", mailhost);\n\n        Session session = Session.getInstance (props, null);\n        if (debug) session.setDebug (true);\n\n        Message msg = new MimeMessage (session);\n        if (from != null) msg.setFrom (new InternetAddress (from));\n        else msg.setFrom ();\n\n        msg.setRecipients (Message.RecipientType.TO, InternetAddress.parse (to, false));\n        if (cc != null) msg.setRecipients (Message.RecipientType.CC, InternetAddress.parse (cc, false));\n\n        if (bcc != null) msg.setRecipients (Message.RecipientType.BCC, InternetAddress.parse (bcc, false));\n\n        msg.setSubject (subject);\n        String text = collect (in);\n        if (file != null) {\n            MimeBodyPart mbp1 = new MimeBodyPart ();\n            mbp1.setText (text);\n            MimeBodyPart mbp2 = new MimeBodyPart ();\n            mbp2.attachFile (file);\n            MimeMultipart mp = new MimeMultipart ();\n            mp.addBodyPart (mbp1);\n            mp.addBodyPart (mbp2);\n            msg.setContent (mp);\n        } else {\n            msg.setText (text);\n        }\n        msg.setHeader (\"X-Mailer\", mailer);\n        msg.setSentDate (new Date ());\n        Transport.send (msg);\n        System.out.println (\"\\nMail was sent successfully.\");\n        if (record != null) {\n            Store store = null;\n            if (url != null) {\n                URLName urln = new URLName (url);\n                store = session.getStore (urln);\n                store.connect ();\n            } else {\n                if (protocol != null) store = session.getStore (protocol);\n                else store = session.getStore ();\n\n                if (host != null || user != null || password != null) store.connect (host, user, password);\n                else store.connect ();\n\n            }\n            Folder folder = store.getFolder (record);\n            if (folder == null) {\n                System.err.println (\"Can't get record folder.\");\n                System.exit (1);\n            }\n            if (! folder.exists ()) folder.create (Folder.HOLDS_MESSAGES);\n\n            Message [] msgs = new Message [1];\n            msgs [0] = msg;\n            folder.appendMessages (msgs);\n            System.out.println (\"Mail was recorded successfully.\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public sendhtml (String [] argv) {\n    String to, subject = null, from = null, cc = null, bcc = null, url = null;\n    String mailhost = null;\n    String mailer = \"sendhtml\";\n    String protocol = null, host = null, user = null, password = null;\n    String record = null;\n    boolean debug = false;\n    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n    int optind;\n    for (optind = 0; optind < argv.length; optind ++) {\n        if (argv [optind].equals (\"-T\")) {\n            protocol = argv [++ optind];\n        } else if (argv [optind].equals (\"-H\")) {\n            host = argv [++ optind];\n        } else if (argv [optind].equals (\"-U\")) {\n            user = argv [++ optind];\n        } else if (argv [optind].equals (\"-P\")) {\n            password = argv [++ optind];\n        } else if (argv [optind].equals (\"-M\")) {\n            mailhost = argv [++ optind];\n        } else if (argv [optind].equals (\"-f\")) {\n            record = argv [++ optind];\n        } else if (argv [optind].equals (\"-s\")) {\n            subject = argv [++ optind];\n        } else if (argv [optind].equals (\"-o\")) {\n            from = argv [++ optind];\n        } else if (argv [optind].equals (\"-c\")) {\n            cc = argv [++ optind];\n        } else if (argv [optind].equals (\"-b\")) {\n            bcc = argv [++ optind];\n        } else if (argv [optind].equals (\"-L\")) {\n            url = argv [++ optind];\n        } else if (argv [optind].equals (\"-d\")) {\n            debug = true;\n        } else if (argv [optind].equals (\"--\")) {\n            optind ++;\n            break;\n        } else if (argv [optind].startsWith (\"-\")) {\n            System.out.println (\"Usage: sendhtml [[-L store-url] | [-T prot] [-H host] [-U user] [-P passwd]]\");\n            System.out.println (\"\\t[-s subject] [-o from-address] [-c cc-addresses] [-b bcc-addresses]\");\n            System.out.println (\"\\t[-f record-mailbox] [-M transport-host] [-d] [address]\");\n            System.exit (1);\n        } else {\n            break;\n        }\n\n    }\n    try {\n        if (optind < argv.length) {\n            to = argv [optind];\n            System.out.println (\"To: \" + to);\n        } else {\n            System.out.print (\"To: \");\n            System.out.flush ();\n            to = in.readLine ();\n        }\n        if (subject == null) {\n            System.out.print (\"Subject: \");\n            System.out.flush ();\n            subject = in.readLine ();\n        } else {\n            System.out.println (\"Subject: \" + subject);\n        }\n        Properties props = System.getProperties ();\n        if (mailhost != null) props.put (\"mail.smtp.host\", mailhost);\n\n        Session session = Session.getInstance (props, null);\n        if (debug) session.setDebug (true);\n\n        Message msg = new MimeMessage (session);\n        if (from != null) msg.setFrom (new InternetAddress (from));\n        else msg.setFrom ();\n\n        msg.setRecipients (Message.RecipientType.TO, InternetAddress.parse (to, false));\n        if (cc != null) msg.setRecipients (Message.RecipientType.CC, InternetAddress.parse (cc, false));\n\n        if (bcc != null) msg.setRecipients (Message.RecipientType.BCC, InternetAddress.parse (bcc, false));\n\n        msg.setSubject (subject);\n        collect (in, msg);\n        msg.setHeader (\"X-Mailer\", mailer);\n        msg.setSentDate (new Date ());\n        Transport.send (msg);\n        System.out.println (\"\\nMail was sent successfully.\");\n        if (record != null) {\n            Store store = null;\n            if (url != null) {\n                URLName urln = new URLName (url);\n                store = session.getStore (urln);\n                store.connect ();\n            } else {\n                if (protocol != null) store = session.getStore (protocol);\n                else store = session.getStore ();\n\n                if (host != null || user != null || password != null) store.connect (host, user, password);\n                else store.connect ();\n\n            }\n            Folder folder = store.getFolder (record);\n            if (folder == null) {\n                System.err.println (\"Can't get record folder.\");\n                System.exit (1);\n            }\n            if (! folder.exists ()) folder.create (Folder.HOLDS_MESSAGES);\n\n            Message [] msgs = new Message [1];\n            msgs [0] = msg;\n            folder.appendMessages (msgs);\n            System.out.println (\"Mail was recorded successfully.\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 24854, "method2_id": 825952, "code1": "File createJar (String name, String...entries) throws IOException {\n    File jar = new File (name);\n    OutputStream out = new FileOutputStream (jar);\n    try {\n        JarOutputStream jos = new JarOutputStream (out);\n        for (String e : entries) {\n            jos.putNextEntry (new ZipEntry (e));\n            jos.write (e.getBytes ());\n        }\n        jos.close ();\n    } finally {\n        out.close ();\n    }\n    return jar;\n}\n", "code2": "File createJar (File jar, String...entries) throws IOException {\n    OutputStream out = new FileOutputStream (jar);\n    try {\n        JarOutputStream jos = new JarOutputStream (out);\n        for (String e : entries) {\n            jos.putNextEntry (new JarEntry (getPathForZipEntry (e)));\n            jos.write (getBodyForEntry (e).getBytes ());\n        }\n        jos.close ();\n    } finally {\n        out.close ();\n    }\n    return jar;\n}\n"}
{"clone_type": "ST3", "method1_id": 150662, "method2_id": 341663, "code1": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    boolean started = false;\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    cache = null;\n    znames = new Hashtable ();\n    TSIGs = new Hashtable ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken ());\n\n        if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) cache = new Cache (st.nextToken ());\n        else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) {\n            short port = Short.parseShort (st.nextToken ());\n            addUDP (port);\n            addTCP (port);\n            started = true;\n        }\n\n    }\n    if (cache == null) {\n        System.out.println (\"no cache specified\");\n        System.exit (- 1);\n    }\n    if (! started) {\n        addUDP ((short) 53);\n        addTCP ((short) 53);\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    boolean started = false;\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new Hashtable ();\n    znames = new Hashtable ();\n    TSIGs = new Hashtable ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Short (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) {\n            short port = Short.parseShort (st.nextToken ());\n            addUDP (port);\n            addTCP (port);\n            started = true;\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (! started) {\n        addUDP ((short) 53);\n        addTCP ((short) 53);\n    }\n    System.out.println (\"running\");\n}\n"}
{"clone_type": "ST3", "method1_id": 6527977, "method2_id": 17557289, "code1": "public static void copy (File in, File out) throws IOException {\n    FileChannel ic = new FileInputStream (in).getChannel ();\n    FileChannel oc = new FileOutputStream (out).getChannel ();\n    ic.transferTo (0, ic.size (), oc);\n    ic.close ();\n    oc.close ();\n}\n", "code2": "private static void copyFile (File source, File dest) throws IOException {\n    FileChannel srcChannel = new FileInputStream (source).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (dest).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 3353836, "method2_id": 21420091, "code1": "public static double [] [] transpose (double [] [] matrix) {\n    double [] [] transposed = new double [matrix [0].length] [matrix.length];\n    int mLength = matrix.length, m0Length = matrix [0].length;\n    for (int i = 0;\n    i < mLength; i ++) {\n        for (int j = 0;\n        j < m0Length; j ++) {\n            transposed [j] [i] = matrix [i] [j];\n        }\n    }\n    return transposed;\n}\n", "code2": "public Matrix transpose () {\n    Matrix X = new Matrix (n, m);\n    double [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n"}
{"clone_type": "ST3", "method1_id": 19147293, "method2_id": 21224967, "code1": "public boolean limpiarContrincantexRonda (jugadorxDivxRonda unjxdxr) {\n    int intResult = 0;\n    String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = 0 \" + \" WHERE idJugxDivxRnd = \" + unjxdxr.getIdJugxDivxRnd ();\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        intResult = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (intResult > 0);\n}\n", "code2": "public boolean crear () {\n    int result = 0;\n    String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        populatePreparedStatement (elJugador);\n        result = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (result > 0);\n}\n"}
{"clone_type": "ST3", "method1_id": 2490462, "method2_id": 14356579, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "public String getRandomGUID () {\n    MessageDigest md5 = null;\n    String valueBeforeMD5 = \"\";\n    String retValue = \"\";\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        InetAddress id = InetAddress.getLocalHost ();\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        rand = random.nextLong ();\n        sbValueBeforeMD5.append (id.toString ());\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) {\n                sb.append ('0');\n            }\n            sb.append (Integer.toHexString (b));\n        }\n        retValue = sb.toString ();\n    } catch (UnknownHostException e) {\n        System.out.println (\"Error:\" + e);\n    }\n    return retValue;\n}\n"}
{"clone_type": "ST3", "method1_id": 5869013, "method2_id": 22447616, "code1": "public Leilao insertLeilao (Leilao leilao) throws SQLException {\n    Connection conn = null;\n    String insert = \"insert into Leilao (idleilao, atividade_idatividade, datainicio, datafim) \" + \"values \" + \"(nextval('seq_leilao'), \" + leilao.getAtividade ().getIdAtividade () + \", '\" + leilao.getDataInicio () + \"', '\" + leilao.getDataFim () + \"')\";\n    try {\n        conn = connectionFactory.getConnection (true);\n        conn.setAutoCommit (false);\n        Statement stmt = conn.createStatement ();\n        Integer result = stmt.executeUpdate (insert);\n        if (result == 1) {\n            String sqlSelect = \"select last_value from seq_leilao\";\n            ResultSet rs = stmt.executeQuery (sqlSelect);\n            while (rs.next ()) {\n                leilao.setIdLeilao (rs.getInt (\"last_value\"));\n            }\n        }\n        conn.commit ();\n    } catch (SQLException e) {\n        conn.rollback ();\n        throw e;\n    } finally {\n        conn.close ();\n    }\n    return null;\n}\n", "code2": "public Usuario insertUsuario (IUsuario usuario) throws SQLException {\n    Connection conn = null;\n    String insert = \"insert into Usuario (idusuario, nome, email, telefone, cpf, login, senha) \" + \"values \" + \"(nextval('seq_usuario'), '\" + usuario.getNome () + \"', '\" + usuario.getEmail () + \"', \" + \"'\" + usuario.getTelefone () + \"', '\" + usuario.getCpf () + \"', '\" + usuario.getLogin () + \"', '\" + usuario.getSenha () + \"')\";\n    try {\n        conn = connectionFactory.getConnection (true);\n        conn.setAutoCommit (false);\n        Statement stmt = conn.createStatement ();\n        Integer result = stmt.executeUpdate (insert);\n        if (result == 1) {\n            String sqlSelect = \"select last_value from seq_usuario\";\n            ResultSet rs = stmt.executeQuery (sqlSelect);\n            while (rs.next ()) {\n                usuario.setIdUsuario (rs.getInt (\"last_value\"));\n            }\n            if (usuario instanceof Requerente) {\n                RequerenteDAO requerenteDAO = new RequerenteDAO ();\n                requerenteDAO.insertRequerente ((Requerente) usuario, conn);\n            } else if (usuario instanceof RecursoHumano) {\n                RecursoHumanoDAO recursoHumanoDAO = new RecursoHumanoDAO ();\n                recursoHumanoDAO.insertRecursoHumano ((RecursoHumano) usuario, conn);\n            }\n\n        }\n        conn.commit ();\n    } catch (SQLException e) {\n        conn.rollback ();\n        throw e;\n    } finally {\n        conn.close ();\n    }\n    return null;\n}\n"}
{"clone_type": "ST3", "method1_id": 7663603, "method2_id": 23118425, "code1": "public synchronized String encrypt (String plaintext) throws Exception {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"SHA\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new MyException (e.getMessage ());\n    }\n    try {\n        md.update (plaintext.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        throw new Exception (e.getMessage ());\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n", "code2": "public synchronized String encrypt (String plaintext) throws Exception {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"MD5\");\n    } catch (Exception e) {\n    }\n    try {\n        md.update (plaintext.getBytes (\"UTF-8\"));\n    } catch (Exception e) {\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n"}
{"clone_type": "ST3", "method1_id": 1293659, "method2_id": 10158742, "code1": "public void delete (int id) throws FidoDatabaseException {\n    try {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = fido.util.FidoDataSource.getConnection ();\n            conn.setAutoCommit (false);\n            stmt = conn.createStatement ();\n            String sql = \"delete from Instructions where InstructionId = \" + id;\n            stmt.executeUpdate (sql);\n            sql = \"delete from InstructionGroups where InstructionId = \" + id;\n            stmt.executeUpdate (sql);\n            conn.commit ();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback ();\n\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close ();\n\n            if (conn != null) conn.close ();\n\n        }\n    } catch (SQLException e) {\n        throw new FidoDatabaseException (e);\n    }\n}\n", "code2": "public void moveRuleDown (String language, String tag, int row) throws FidoDatabaseException {\n    try {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = fido.util.FidoDataSource.getConnection ();\n            conn.setAutoCommit (false);\n            stmt = conn.createStatement ();\n            int max = findMaxRank (stmt, language, tag);\n            if ((row < 1) || (row > (max - 1))) throw new IllegalArgumentException (\"Row number (\" + row + \") was not between 1 and \" + (max - 1));\n\n            stmt.executeUpdate (\"update LanguageMorphologies set Rank = -1 \" + \"where Rank = \" + row + \" and MorphologyTag = '\" + tag + \"' and \" + \"      LanguageName = '\" + language + \"'\");\n            stmt.executeUpdate (\"update LanguageMorphologies set Rank = \" + row + \"where Rank = \" + (row + 1) + \" and MorphologyTag = '\" + tag + \"' and \" + \"      LanguageName = '\" + language + \"'\");\n            stmt.executeUpdate (\"update LanguageMorphologies set Rank = \" + (row + 1) + \"where Rank = -1 and MorphologyTag = '\" + tag + \"' and \" + \"      LanguageName = '\" + language + \"'\");\n            conn.commit ();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback ();\n\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close ();\n\n            if (conn != null) conn.close ();\n\n        }\n    } catch (SQLException e) {\n        throw new FidoDatabaseException (e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 91670, "method2_id": 186072, "code1": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://prologdev1:5432/wdb\";\n    final String dbuser = \"guest2\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT value, dataProviderName, placeName, placeGeometry,\" + \"        referencetime, \" + \"        validFrom, validTo, \" + \"        valueParameterName, valueParameterUnit, \" + \"        levelParameterName, levelUnitName, levelFrom, levelTo, \" + \"        dataVersion, confidenceCode, storetime, valueid, valuetype \" + \" FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', \" + \"                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), \" + \"                NULL, \" + \"                array['instant pressure of air', \" + \"                      'instant temperature of air', \" + \"                      'instant velocity of air (u-component)', \" + \"                      'instant velocity of air (v-component)'], \" + \"                ( 2, 2, 'distance above ground', 'exact' ), \" + \"                array[-1], \" + \"                NULL::wci.returnFloat )\";\n    final String colNames [] = {\"value\", \"dataProviderName\", \"placeName\", \"referencetime\", \"validFrom\", \"validTo\", \"valueParameterName\", \"valueParameterUnit\", \"levelParameterName\", \"levelUnitName\", \"levelFrom\", \"levelTo\", \"dataVersion\"};\n    ResultSet rs = null;\n    try {\n        statement.execute (wdbInit);\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        if (rs != null) {\n            try {\n                rs.close ();\n            } catch (SQLException ex) {\n                System.out.println (\"EXCEPTION: rs.close: \" + ex);\n            }\n        }\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://prologdev1:5432/wdb\";\n    final String dbuser = \"guest2\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT value, dataProviderName, placeName, placeGeometry,\" + \"        referencetime, \" + \"        validFrom, validTo, \" + \"        valueParameterName, valueParameterUnit, \" + \"        levelParameterName, levelUnitName, levelFrom, levelTo, \" + \"        dataVersion, confidenceCode, storetime, valueid, valuetype \" + \" FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', \" + \"                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), \" + \"                NULL, \" + \"                array['instant temperature of air'], \" + \"                ( 2, 2, 'distance above ground', 'exact' ), \" + \"                array[-1], \" + \"                NULL::wci.returnOid )\";\n    final String colNames [] = {\"value\", \"dataProviderName\", \"placeName\", \"referencetime\", \"validFrom\", \"validTo\", \"valueParameterName\", \"valueParameterUnit\", \"levelParameterName\", \"levelUnitName\", \"levelFrom\", \"levelTo\"};\n    ResultSet rs = null;\n    try {\n        con.setAutoCommit (false);\n        statement.execute (wdbInit);\n        LargeObjectManager lobj = ((org.postgresql.PGConnection) con).getLargeObjectAPI ();\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            long oid = rs.getLong (\"value\");\n            LargeObject obj = lobj.open (oid, LargeObjectManager.READ);\n            byte buf [] = new byte [obj.size ()];\n            obj.read (buf, 0, obj.size ());\n            obj.close ();\n            System.out.print (\"  BLOB size: \" + buf.length);\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        try {\n            con.commit ();\n            if (rs != null) rs.close ();\n\n        } catch (SQLException ex) {\n            System.out.println (\"EXCEPTION: rs.close: \" + ex);\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 8194211, "method2_id": 18703321, "code1": "double [] [] transpose (double [] [] d) {\n    double [] [] r = new double [d [0].length] [d.length];\n    for (int i = 0;\n    i < d.length; i ++) for (int j = 0;\n    j < d [0].length; j ++) r [j] [i] = d [i] [j];\n\n    return r;\n}\n", "code2": "public static byte [] [] transpose (byte [] [] m) {\n    byte [] [] n = new byte [m [0].length] [m.length];\n    for (int j = 0;\n    j < m.length; j ++) for (int i = 0;\n    i < m [0].length; i ++) n [i] [j] = m [j] [i];\n\n    return n;\n}\n"}
{"clone_type": "ST3", "method1_id": 3609806, "method2_id": 5746450, "code1": "private static String getData (String myurl) throws Exception {\n    System.out.println (\"getdata\");\n    URL url = new URL (myurl);\n    uc = (HttpURLConnection) url.openConnection ();\n    br = new BufferedReader (new InputStreamReader (uc.getInputStream ()));\n    String temp = \"\", k = \"\";\n    while ((temp = br.readLine ()) != null) {\n        System.out.println (temp);\n        k += temp;\n    }\n    br.close ();\n    return k;\n}\n", "code2": "private String getData (String myurl) throws Exception {\n    URL url = new URL (myurl);\n    uc = (HttpURLConnection) url.openConnection ();\n    br = new BufferedReader (new InputStreamReader (uc.getInputStream ()));\n    String temp = \"\", k = \"\";\n    while ((temp = br.readLine ()) != null) {\n        k += temp;\n    }\n    br.close ();\n    return k;\n}\n"}
{"clone_type": "ST3", "method1_id": 2874892, "method2_id": 7836028, "code1": "private void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    } else {\n    }\n}\n", "code2": "private static void browseHelp () {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (new URI (TargetedProjectionPursuit.HELP_URL));\n        } catch (Exception e) {\n        }\n    } else {\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 792270, "method2_id": 889470, "code1": "public int runLoad (int requestId, int loadId, int server) throws RemoteException {\n    int ret = 0;\n    try {\n        Process P;\n        System.out.println (\"LINUX: \" + linuxPath + \"/Load1 \" + requestId);\n        System.out.println (\"java \" + linuxPath + \"/LoadId \" + requestId);\n        if (loadId == 1) P = Runtime.getRuntime ().exec (\"cr_run java LoadId \" + requestId);\n        else P = Runtime.getRuntime ().exec (\"cr_run java LoadId \" + requestId);\n\n        StringBuffer strBuf = new StringBuffer ();\n        String strLine = \"\";\n        String strLine1 = \"\";\n        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));\n        while ((strLine = outCommand.readLine ()) != null) {\n            strLine1 = strLine;\n        }\n        P.waitFor ();\n        return ret;\n    } catch (Exception e) {\n        e.printStackTrace ();\n        return - 1;\n    }\n}\n", "code2": "public int runLoad (int requestId, int loadId, int server) throws RemoteException {\n    int ret = 0;\n    try {\n        Process P;\n        System.out.println (\"LINUX: \" + linuxPath + \"/Load1 \" + requestId);\n        if (loadId == 1) P = Runtime.getRuntime ().exec (linuxPath + \"/Load1 \" + requestId);\n        else if (loadId == 2) P = Runtime.getRuntime ().exec (linuxPath + \"/Load1 \" + requestId);\n        else P = Runtime.getRuntime ().exec (linuxPath + \"/Load1 \" + requestId);\n\n        StringBuffer strBuf = new StringBuffer ();\n        String strLine = \"\";\n        String strLine1 = \"\";\n        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));\n        while ((strLine = outCommand.readLine ()) != null) {\n            strLine1 = strLine;\n        }\n        P.waitFor ();\n        return ret;\n    } catch (Exception e) {\n        e.printStackTrace ();\n        return - 1;\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 606579, "method2_id": 7412290, "code1": "private static int [] [] transpose (int [] [] matrix) {\n    int [] [] transposed = new int [matrix.length] [matrix [0].length];\n    for (int k = 0;\n    k < matrix.length; k ++) {\n        for (int j = 0;\n        j < matrix.length; j ++) {\n            transposed [j] [k] = matrix [k] [j];\n        }\n    }\n    return transposed;\n}\n", "code2": "private double [] [] getInputColumn (double [] [] vectors) {\n    double [] [] columns = new double [vectors [0].length] [vectors.length];\n    for (int i = 0;\n    i < columns.length; i ++) {\n        for (int j = 0;\n        j < columns [0].length; j ++) {\n            columns [i] [j] = vectors [j] [i];\n        }\n    }\n    return columns;\n}\n"}
{"clone_type": "ST3", "method1_id": 10589735, "method2_id": 12744196, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = random.nextLong ();\n        }\n        sbValueBeforeMD5.append (sid);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n    }\n}\n", "code2": "public RandomGUID () {\n    MessageDigest md5 = null;\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException (e.getClass ().getName () + \": \" + e.getMessage ());\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        rand = myRand.nextLong ();\n        StringBuffer sb = new StringBuffer ();\n        sb.append (s_id);\n        sb.append (\":\");\n        sb.append (Long.toString (time));\n        sb.append (\":\");\n        sb.append (Long.toString (rand));\n        md5.update (sb.toString ().getBytes ());\n        byte [] array = md5.digest ();\n        sb.setLength (0);\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        throw new RuntimeException (e.getClass ().getName () + \": \" + e.getMessage ());\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 572340, "method2_id": 792276, "code1": "public double probeEnergy () throws RemoteException {\n    float idle_energy1 = Float.parseFloat (idle_energy);\n    double utiltopower_factor1 = Double.parseDouble (utiltopower_factor);\n    double cpu_util = 10;\n    String energy = \"\";\n    double total_energy = 0;\n    try {\n        Process P = Runtime.getRuntime ().exec (linuxPath + \"/you.sh\");\n        StringBuffer strBuf = new StringBuffer ();\n        String strLine = \"\";\n        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));\n        while ((strLine = outCommand.readLine ()) != null) {\n            energy = strLine;\n        }\n        P.waitFor ();\n        cpu_util = Double.parseDouble (energy);\n        total_energy = idle_energy1 + utiltopower_factor1 * cpu_util;\n    } catch (Exception e) {\n        total_energy = - 1;\n        System.out.println (e.getMessage ());\n        e.printStackTrace ();\n    }\n    return total_energy;\n}\n", "code2": "public double probeProcessEnergy (int processId) throws RemoteException {\n    float idle_energy1 = Float.parseFloat (idle_energy);\n    double utiltopower_factor1 = Double.parseDouble (utiltopower_factor);\n    double cpu_util = 10;\n    String energy = \"\";\n    double total_energy = 0;\n    try {\n        Process P = Runtime.getRuntime ().exec (linuxPath + \"/PidCPU.sh \" + processId);\n        StringBuffer strBuf = new StringBuffer ();\n        String strLine = \"\";\n        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));\n        while ((strLine = outCommand.readLine ()) != null) {\n            energy = strLine;\n        }\n        P.waitFor ();\n        cpu_util = Double.parseDouble (energy);\n        total_energy = utiltopower_factor1 * cpu_util;\n    } catch (Exception e) {\n        total_energy = - 1;\n        System.out.println (e.getMessage ());\n        e.printStackTrace ();\n    }\n    return total_energy;\n}\n"}
{"clone_type": "ST3", "method1_id": 7246103, "method2_id": 9346447, "code1": "public static double [] [] transpose (double [] [] a) {\n    double [] [] c = new double [3] [3];\n    for (int i = 0;\n    i < 3; i ++) {\n        for (int k = 0;\n        k < 3; k ++) {\n            c [i] [k] = a [k] [i];\n        }\n    }\n    return c;\n}\n", "code2": "public static double [] [] transposeMatrix (double [] [] vector) {\n    double [] [] tm = new double [vector [0].length] [vector.length];\n    for (int i = 0;\n    i < tm.length; i ++) {\n        for (int j = 0;\n        j < tm [i].length; j ++) {\n            tm [i] [j] = vector [j] [i];\n        }\n    }\n    return tm;\n}\n"}
{"clone_type": "ST3", "method1_id": 120114, "method2_id": 207026, "code1": "public void actionPerformed (ActionEvent e) {\n    String sql = \"insert into jadwalKBM values('\" + FieldNim.getText () + \"','\" + FieldNama.getText () + \"','\" + FieldTtl.getText () + \"')\";\n    if (FieldNim.getText ().trim ().equals (\"\")) {\n        JOptionPane.showMessageDialog (frame, \"Nama Bulan Wajib diIsi\", \"Simpan Data\", JOptionPane.WARNING_MESSAGE);\n        FieldNim.requestFocus ();\n    } else {\n        try {\n            Connection connection = DriverManager.getConnection (\"jdbc:odbc:db_Sekolah\");\n            Statement statement = connection.createStatement ();\n            statement.executeUpdate (sql);\n            statement.close ();\n            FieldNim.setText (\"\");\n            FieldNama.setText (\"\");\n            FieldTtl.setText (\"\");\n            JOptionPane.showMessageDialog (frame, \"Simpan berhasil\", \"Simpan Data\", JOptionPane.WARNING_MESSAGE);\n            FieldNim.requestFocus ();\n            FieldNim.requestFocus ();\n            FieldNim.requestFocus ();\n        } catch (Exception exc) {\n            System.err.println (\"Error : \" + exc);\n        }\n    }\n}\n", "code2": "public void actionPerformed (ActionEvent e) {\n    String sql = \"delete from jjgenjang where no='\" + Fieldno.getText ().trim () + \"'\";\n    if (Fieldno.getText ().trim ().equals (\"\")) {\n        JOptionPane.showMessageDialog (frame, \"alas masih kosong!\", \"Simpan data\", JOptionPane.WARNING_MESSAGE);\n        Fieldno.requestFocus ();\n    } else {\n        try {\n            Connection conn = DriverManager.getConnection (\"jdbc:odbc:jjgenjang\");\n            Statement statement = conn.createStatement ();\n            statement.executeUpdate (sql);\n            statement.close ();\n            Fieldno.setText (\"\");\n            Fieldalas.setText (\"\");\n            Fieldtinggi.setText (\"\");\n            Fieldluas.setText (\"\");\n            Fieldalas.requestFocus ();\n        } catch (Exception exc) {\n            System.err.println (sql);\n            System.err.println (\"Error:\" + exc);\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 2467221, "method2_id": 18865693, "code1": "void copyFile (File src, File dst) throws IOException {\n    InputStream in = new FileInputStream (src);\n    OutputStream out = new FileOutputStream (dst);\n    byte [] buf = new byte [1024];\n    int len;\n    while ((len = in.read (buf)) > 0) out.write (buf, 0, len);\n\n    in.close ();\n    out.close ();\n}\n", "code2": "private static void copyFile (File inputFile, File outputFile) throws IOException {\n    FileReader in = new FileReader (inputFile);\n    FileWriter out = new FileWriter (outputFile);\n    int c;\n    while ((c = in.read ()) != - 1) out.write (c);\n\n    in.close ();\n    out.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 22259087, "method2_id": 22259089, "code1": "private Long queryServer (OWLOntology ontologyURI) throws IOException {\n    String requestString = \"http://\" + InetAddress.getLocalHost ().getHostName () + \":8080/ChangeServer\";\n    requestString += \"?query=\" + URLEncoder.encode (ontologyURI.getURI ().toString (), \"UTF-8\");\n    URL url = new URL (requestString);\n    BufferedReader input = new BufferedReader (new InputStreamReader (url.openStream ()));\n    StringBuffer returned = new StringBuffer ();\n    String str;\n    while (null != ((str = input.readLine ()))) {\n        returned.append (str);\n    }\n    input.close ();\n    return new Long (returned.toString ());\n}\n", "code2": "private ChangeCapsule fetchServer (OWLOntology ontologyURI, Long sequenceNumber) throws IOException {\n    String requestString = \"http://\" + InetAddress.getLocalHost ().getHostName () + \":8080/ChangeServer\";\n    requestString += \"?fetch=\" + URLEncoder.encode (ontologyURI.getURI ().toString (), \"UTF-8\");\n    requestString += \"&number\" + sequenceNumber;\n    URL url = new URL (requestString);\n    BufferedReader input = new BufferedReader (new InputStreamReader (url.openStream ()));\n    StringBuffer returned = new StringBuffer ();\n    String str;\n    while (null != ((str = input.readLine ()))) {\n        returned.append (str);\n    }\n    input.close ();\n    ChangeCapsule cp = new ChangeCapsule (returned.toString ());\n    return cp;\n}\n"}
{"clone_type": "ST3", "method1_id": 323161, "method2_id": 848240, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 8075170, "method2_id": 14887616, "code1": "public void newGuidSeed (boolean secure) {\n    SecureRandom sr = new SecureRandom ();\n    long secureInitializer = sr.nextLong ();\n    Random rand = new Random (secureInitializer);\n    String host_ip = \"\";\n    try {\n        host_ip = InetAddress.getLocalHost ().toString ();\n    } catch (UnknownHostException err) {\n        err.printStackTrace ();\n    }\n    MessageDigest md5 = null;\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException err) {\n        err.printStackTrace ();\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long randNumber = 0;\n        if (secure) {\n            randNumber = sr.nextLong ();\n        } else {\n            randNumber = rand.nextLong ();\n        }\n        sbBeforeMd5.append (host_ip);\n        sbBeforeMd5.append (\":\");\n        sbBeforeMd5.append (Long.toString (time));\n        sbBeforeMd5.append (\":\");\n        sbBeforeMd5.append (Long.toString (randNumber));\n        seed = sbBeforeMd5.toString ();\n        md5.update (seed.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer temp_sb = new StringBuffer ();\n        for (int i = 0;\n        i < array.length; i ++) {\n            int b = array [i] & 0xFF;\n            if (b < 0x10) temp_sb.append ('0');\n\n            temp_sb.append (Integer.toHexString (b));\n        }\n        rawGUID = temp_sb.toString ();\n    } catch (Exception err) {\n        err.printStackTrace ();\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 131242, "method2_id": 205372, "code1": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://prologdev1:5432/wdb\";\n    final String dbuser = \"guest2\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT value, dataProviderName, placeName, placeGeometry,\" + \"        referencetime, \" + \"        validFrom, validTo, \" + \"        valueParameterName, valueParameterUnit, \" + \"        levelParameterName, levelUnitName, levelFrom, levelTo, \" + \"        dataVersion, confidenceCode, storetime, valueid, valuetype \" + \" FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', \" + \"                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), \" + \"                NULL, \" + \"                array['instant temperature of air'], \" + \"                ( 2, 2, 'distance above ground', 'exact' ), \" + \"                array[-1], \" + \"                NULL::wci.returnOid )\";\n    final String colNames [] = {\"value\", \"dataProviderName\", \"placeName\", \"referencetime\", \"validFrom\", \"validTo\", \"valueParameterName\", \"valueParameterUnit\", \"levelParameterName\", \"levelUnitName\", \"levelFrom\", \"levelTo\"};\n    ResultSet rs = null;\n    try {\n        con.setAutoCommit (false);\n        statement.execute (wdbInit);\n        LargeObjectManager lobj = ((org.postgresql.PGConnection) con).getLargeObjectAPI ();\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            long oid = rs.getLong (\"value\");\n            LargeObject obj = lobj.open (oid, LargeObjectManager.READ);\n            byte buf [] = new byte [obj.size ()];\n            obj.read (buf, 0, obj.size ());\n            obj.close ();\n            System.out.print (\"  BLOB size: \" + buf.length);\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        try {\n            con.commit ();\n            if (rs != null) rs.close ();\n\n        } catch (SQLException ex) {\n            System.out.println (\"EXCEPTION: rs.close: \" + ex);\n        }\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://prologdev1:5432/wdb\";\n    final String dbuser = \"guest2\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT value, dataProviderName, placeName, placeGeometry,\" + \"        referencetime, \" + \"        validFrom, validTo, \" + \"        valueParameterName, valueParameterUnit, \" + \"        levelParameterName, levelUnitName, levelFrom, levelTo, \" + \"        dataVersion, confidenceCode, storetime, valueid, valuetype \" + \" FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', \" + \"                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), \" + \"                NULL, \" + \"                array['instant pressure of air', \" + \"                      'instant temperature of air', \" + \"                      'instant velocity of air (u-component)', \" + \"                      'instant velocity of air (v-component)'], \" + \"                ( 2, 2, 'distance above ground', 'exact' ), \" + \"                array[-1], \" + \"                NULL::wci.returnFloat )\";\n    final String colNames [] = {\"value\", \"dataProviderName\", \"placeName\", \"referencetime\", \"validFrom\", \"validTo\", \"valueParameterName\", \"valueParameterUnit\", \"levelParameterName\", \"levelUnitName\", \"levelFrom\", \"levelTo\", \"dataVersion\"};\n    ResultSet rs = null;\n    try {\n        statement.execute (wdbInit);\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        if (rs != null) {\n            try {\n                rs.close ();\n            } catch (SQLException ex) {\n                System.out.println (\"EXCEPTION: rs.close: \" + ex);\n            }\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 657801, "method2_id": 22306604, "code1": "void copyFile (String from, String to) throws IOException {\n    File destFile = new File (to);\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (from).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public static void upLoadFile (File sourceFile, File targetFile) throws IOException {\n    FileChannel inChannel = null;\n    FileChannel outChannel = null;\n    try {\n        inChannel = new FileInputStream (sourceFile).getChannel ();\n        outChannel = new FileOutputStream (targetFile).getChannel ();\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } finally {\n        try {\n            if (inChannel != null) {\n                inChannel.close ();\n            }\n            if (outChannel != null) {\n                outChannel.close ();\n            }\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 2762491, "method2_id": 2762501, "code1": "static Record newRecord (Name name, short type, short dclass, int ttl, int length, CountedDataInputStream in, Compression c) throws IOException {\n    Record rec;\n    try {\n        Class rrclass;\n        Constructor m;\n        rrclass = toClass (type);\n        m = rrclass.getConstructor (new Class [] {Name.class, Short.TYPE, Integer.TYPE, Integer.TYPE, CountedDataInputStream.class, Compression.class});\n        rec = (Record) m.newInstance (new Object [] {name, new Short (dclass), new Integer (ttl), new Integer (length), in, c});\n        return rec;\n    } catch (ClassNotFoundException e) {\n        rec = new UNKRecord (name, type, dclass, ttl, length, in, c);\n        rec.oLength = length;\n        return rec;\n    } catch (InvocationTargetException e) {\n        System.out.println (\"new record: \" + e);\n        System.out.println (e.getTargetException ());\n        return null;\n    } catch (Exception e) {\n        System.out.println (\"new record: \" + e);\n        return null;\n    }\n}\n", "code2": "public static Record fromString (Name name, short type, short dclass, int ttl, MyStringTokenizer st, Name origin) throws IOException {\n    Record rec;\n    try {\n        Class rrclass;\n        Constructor m;\n        rrclass = toClass (type);\n        m = rrclass.getConstructor (new Class [] {Name.class, Short.TYPE, Integer.TYPE, MyStringTokenizer.class, Name.class});\n        rec = (Record) m.newInstance (new Object [] {name, new Short (dclass), new Integer (ttl), st, origin});\n        return rec;\n    } catch (ClassNotFoundException e) {\n        rec = new UNKRecord (name, type, dclass, ttl, st, origin);\n        return rec;\n    } catch (InvocationTargetException e) {\n        System.out.println (\"from text: \" + e);\n        System.out.println (e.getTargetException ());\n        return null;\n    } catch (Exception e) {\n        System.out.println (\"from text: \" + e);\n        return null;\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 3978710, "method2_id": 4193495, "code1": "public static String stringOfUrl (String addr) throws IOException {\n    ByteArrayOutputStream output = new ByteArrayOutputStream ();\n    URL url = new URL (addr);\n    IOUtils.copy (url.openStream (), output);\n    return output.toString ();\n}\n", "code2": "public String stringOfUrl (String addr) throws IOException {\n    ByteArrayOutputStream output = new ByteArrayOutputStream ();\n    URL url = new URL (addr);\n    IOUtils.copy (url.openStream (), output);\n    return output.toString ();\n}\n"}
{"clone_type": "ST3", "method1_id": 1884023, "method2_id": 12744196, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "public RandomGUID () {\n    MessageDigest md5 = null;\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException (e.getClass ().getName () + \": \" + e.getMessage ());\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        rand = myRand.nextLong ();\n        StringBuffer sb = new StringBuffer ();\n        sb.append (s_id);\n        sb.append (\":\");\n        sb.append (Long.toString (time));\n        sb.append (\":\");\n        sb.append (Long.toString (rand));\n        md5.update (sb.toString ().getBytes ());\n        byte [] array = md5.digest ();\n        sb.setLength (0);\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        throw new RuntimeException (e.getClass ().getName () + \": \" + e.getMessage ());\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 2490462, "method2_id": 7960119, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGuid (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException (e);\n    }\n    long time = System.currentTimeMillis ();\n    long rand = 0;\n    if (secure) {\n        rand = secureRandom.nextLong ();\n    } else {\n        rand = random.nextLong ();\n    }\n    sbValueBeforeMD5.append (id);\n    sbValueBeforeMD5.append (\":\");\n    sbValueBeforeMD5.append (Long.toString (time));\n    sbValueBeforeMD5.append (\":\");\n    sbValueBeforeMD5.append (Long.toString (rand));\n    String valueBeforeMD5 = sbValueBeforeMD5.toString ();\n    md5.update (valueBeforeMD5.getBytes ());\n    byte [] array = md5.digest ();\n    StringBuffer sb = new StringBuffer ();\n    for (int j = 0;\n    j < array.length; ++ j) {\n        int b = array [j] & 0xFF;\n        if (b < 0x10) sb.append ('0');\n\n        sb.append (Integer.toHexString (b));\n    }\n    guid = sb.toString ();\n}\n"}
{"clone_type": "ST3", "method1_id": 21192, "method2_id": 92956, "code1": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://localhost:5432/wdb\";\n    final String dbuser = \"wcitest\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT * \" + \" FROM wci.read( array['test wci 5'], NULL, \" + \"                '2009-11-13 00:00:00+00', \" + \"                NULL, \" + \"                array['air temperature', \" + \"                      'air pressure'], \" + \"                NULL, \" + \"                array[-1], \" + \"                NULL::wci.returngid )\";\n    final String colNames [] = {\"valueParameterName\", \"validTimeFrom\"};\n    ResultSet rs = null;\n    try {\n        statement.execute (wdbInit);\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            Statement getGridStatement = con.createStatement ();\n            first = true;\n            long gridId = rs.getLong (\"value\");\n            ResultSet blobResult = getGridStatement.executeQuery (\"SELECT * FROM wci.fetch(\" + gridId + \", NULL::wci.grid)\");\n            while (blobResult.next ()) {\n                int size = blobResult.getInt (\"numberX\") + blobResult.getInt (\"numberX\");\n                InputStream blob = blobResult.getBinaryStream (\"grid\");\n                DataInputStream blobReader = new DataInputStream (blob);\n                int floatToRead = 42;\n                blobReader.skip (floatToRead * 4);\n                float value = blobReader.readFloat ();\n                System.out.print (value + \"\\t\");\n                for (String name : colNames) {\n                    data = rs.getString (name);\n                    if (first) {\n                        first = false;\n                    } else {\n                        System.out.print (\", \");\n                    }\n                    if (data != null) System.out.print (data);\n                    else System.out.print (\"\\\\N\");\n\n                }\n                System.out.print (\"  (BLOB size: \" + size + \")\");\n                System.out.println ();\n            }\n            blobResult.close ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        try {\n            if (rs != null) rs.close ();\n\n        } catch (SQLException ex) {\n            System.out.println (\"EXCEPTION: rs.close: \" + ex);\n        }\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://prologdev1:5432/wdb\";\n    final String dbuser = \"guest2\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT value, dataProviderName, placeName, placeGeometry,\" + \"        referencetime, \" + \"        validFrom, validTo, \" + \"        valueParameterName, valueParameterUnit, \" + \"        levelParameterName, levelUnitName, levelFrom, levelTo, \" + \"        dataVersion, confidenceCode, storetime, valueid, valuetype \" + \" FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', \" + \"                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), \" + \"                NULL, \" + \"                array['instant temperature of air'], \" + \"                ( 2, 2, 'distance above ground', 'exact' ), \" + \"                array[-1], \" + \"                NULL::wci.returnOid )\";\n    final String colNames [] = {\"value\", \"dataProviderName\", \"placeName\", \"referencetime\", \"validFrom\", \"validTo\", \"valueParameterName\", \"valueParameterUnit\", \"levelParameterName\", \"levelUnitName\", \"levelFrom\", \"levelTo\"};\n    ResultSet rs = null;\n    try {\n        con.setAutoCommit (false);\n        statement.execute (wdbInit);\n        LargeObjectManager lobj = ((org.postgresql.PGConnection) con).getLargeObjectAPI ();\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            long oid = rs.getLong (\"value\");\n            LargeObject obj = lobj.open (oid, LargeObjectManager.READ);\n            byte buf [] = new byte [obj.size ()];\n            obj.read (buf, 0, obj.size ());\n            obj.close ();\n            System.out.print (\"  BLOB size: \" + buf.length);\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        try {\n            con.commit ();\n            if (rs != null) rs.close ();\n\n        } catch (SQLException ex) {\n            System.out.println (\"EXCEPTION: rs.close: \" + ex);\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 6291471, "method2_id": 10878062, "code1": "private void copyFile (File f) throws IOException {\n    File newFile = new File (destdir + \"/\" + f.getName ());\n    newFile.createNewFile ();\n    FileInputStream fin = new FileInputStream (f);\n    FileOutputStream fout = new FileOutputStream (newFile);\n    int c;\n    while ((c = fin.read ()) != - 1) fout.write (c);\n\n    fin.close ();\n    fout.close ();\n}\n", "code2": "public static void copy (File source, File dest) throws Exception {\n    FileInputStream in = new FileInputStream (source);\n    FileOutputStream out = new FileOutputStream (dest);\n    int c;\n    while ((c = in.read ()) != - 1) out.write (c);\n\n    in.close ();\n    out.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 3631683, "method2_id": 6065872, "code1": "public static void zipFile (File inputFile, ZipOutputStream zipOutputStream) throws IOException {\n    byte [] buf = new byte [1024];\n    zipOutputStream.putNextEntry (new ZipEntry (inputFile.getName ()));\n    FileInputStream fileInputStream = new FileInputStream (inputFile);\n    int length;\n    while ((length = fileInputStream.read (buf)) > 0) {\n        zipOutputStream.write (buf, 0, length);\n    }\n    fileInputStream.close ();\n    zipOutputStream.closeEntry ();\n}\n", "code2": "private void copyZiptoTmpZip (ZipEntry entry, BufferedInputStream in, ZipOutputStream outputFileZip) throws IOException {\n    byte [] buf = new byte [1024];\n    outputFileZip.putNextEntry (entry);\n    int len;\n    while ((len = in.read (buf)) > 0) {\n        outputFileZip.write (buf, 0, len);\n    }\n    outputFileZip.closeEntry ();\n    in.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 48482, "method2_id": 51282, "code1": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://prologdev1:5432/wdb\";\n    final String dbuser = \"guest2\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT value, dataProviderName, placeName, placeGeometry,\" + \"        referencetime, \" + \"        validFrom, validTo, \" + \"        valueParameterName, valueParameterUnit, \" + \"        levelParameterName, levelUnitName, levelFrom, levelTo, \" + \"        dataVersion, confidenceCode, storetime, valueid, valuetype \" + \" FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', \" + \"                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), \" + \"                NULL, \" + \"                array['instant temperature of air'], \" + \"                ( 2, 2, 'distance above ground', 'exact' ), \" + \"                array[-1], \" + \"                NULL::wci.returnOid )\";\n    final String colNames [] = {\"value\", \"dataProviderName\", \"placeName\", \"referencetime\", \"validFrom\", \"validTo\", \"valueParameterName\", \"valueParameterUnit\", \"levelParameterName\", \"levelUnitName\", \"levelFrom\", \"levelTo\"};\n    ResultSet rs = null;\n    try {\n        con.setAutoCommit (false);\n        statement.execute (wdbInit);\n        LargeObjectManager lobj = ((org.postgresql.PGConnection) con).getLargeObjectAPI ();\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            long oid = rs.getLong (\"value\");\n            LargeObject obj = lobj.open (oid, LargeObjectManager.READ);\n            byte buf [] = new byte [obj.size ()];\n            obj.read (buf, 0, obj.size ());\n            obj.close ();\n            System.out.print (\"  BLOB size: \" + buf.length);\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        try {\n            con.commit ();\n            if (rs != null) rs.close ();\n\n        } catch (SQLException ex) {\n            System.out.println (\"EXCEPTION: rs.close: \" + ex);\n        }\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://localhost:5432/wdb\";\n    final String dbuser = \"wcitest\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"', 999, 999, 999 )\";\n    String sql = \" SELECT * \" + \" FROM wci.read( array['test wci 5'], NULL, \" + \"                '2009-11-13 00:00:00+00', \" + \"                NULL, \" + \"                array['air temperature', \" + \"                      'air pressure'], \" + \"                NULL, \" + \"                array[-1], \" + \"                NULL::wci.returngid )\";\n    final String colNames [] = {\"valueParameterName\", \"validTimeFrom\"};\n    ResultSet rs = null;\n    try {\n        statement.execute (wdbInit);\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            Statement getGridStatement = con.createStatement ();\n            first = true;\n            long gridId = rs.getLong (\"value\");\n            ResultSet blobResult = getGridStatement.executeQuery (\"SELECT * FROM wci.fetch(\" + gridId + \", NULL::wci.grid)\");\n            while (blobResult.next ()) {\n                int size = blobResult.getInt (\"numberX\") + blobResult.getInt (\"numberX\");\n                InputStream blob = blobResult.getBinaryStream (\"grid\");\n                DataInputStream blobReader = new DataInputStream (blob);\n                int floatToRead = 42;\n                blobReader.skip (floatToRead * 4);\n                float value = blobReader.readFloat ();\n                System.out.print (value + \"\\t\");\n                for (String name : colNames) {\n                    data = rs.getString (name);\n                    if (first) {\n                        first = false;\n                    } else {\n                        System.out.print (\", \");\n                    }\n                    if (data != null) System.out.print (data);\n                    else System.out.print (\"\\\\N\");\n\n                }\n                System.out.print (\"  (BLOB size: \" + size + \")\");\n                System.out.println ();\n            }\n            blobResult.close ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        try {\n            if (rs != null) rs.close ();\n\n        } catch (SQLException ex) {\n            System.out.println (\"EXCEPTION: rs.close: \" + ex);\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 10852631, "method2_id": 17224030, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    final StringBuilder sbValueBeforeMD5 = new StringBuilder ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        logger.fatal (\"\", e);\n        return;\n    }\n    try {\n        final long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (sId);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        final byte [] array = md5.digest ();\n        final StringBuilder sb = new StringBuilder ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            final int b = array [j] & 0xFF;\n            if (b < 0x10) {\n                sb.append ('0');\n            }\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        logger.fatal (\"\", e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 10214218, "method2_id": 11733067, "code1": "public synchronized String encrypt (String plaintext) {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace ();\n    }\n    try {\n        md.update (plaintext.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace ();\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n", "code2": "public static String sha1 (String src) {\n    MessageDigest md1 = null;\n    try {\n        md1 = MessageDigest.getInstance (\"SHA-1\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace ();\n    }\n    try {\n        md1.update (src.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace ();\n    }\n    return hex (md1.digest ());\n}\n"}
{"clone_type": "ST3", "method1_id": 13476, "method2_id": 6234218, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private long fib (long n) {\n    if (n == 0) return 0L;\n\n    if (n == 1) return 1L;\n\n    return fib (n - 1) + fib (n - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 9186576, "method2_id": 20082006, "code1": "public static void copyFile (File file, String pathExport) throws IOException {\n    File out = new File (pathExport);\n    FileChannel sourceChannel = new FileInputStream (file).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n", "code2": "public static void copyFile (File src, File dst) throws IOException {\n    FileChannel sourceChannel = new FileInputStream (src).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (dst).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 17984312, "method2_id": 23130941, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File src, File dst) throws IOException {\n    FileChannel inChannel = new FileInputStream (src).getChannel ();\n    FileChannel outChannel = new FileOutputStream (dst).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 3945916, "method2_id": 14785308, "code1": "public static String MD5 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"MD5\");\n    byte [] md5hash;\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    md5hash = md.digest ();\n    return convertToHex (md5hash);\n}\n", "code2": "public static String sha1 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 5656506, "method2_id": 10899860, "code1": "private void copyFile (File source, File target) throws IOException {\n    FileChannel srcChannel = new FileInputStream (source).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (target).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n", "code2": "public void copy (File in, File out) throws Exception {\n    FileChannel src = new FileInputStream (in).getChannel ();\n    FileChannel dest = new FileOutputStream (out).getChannel ();\n    src.transferTo (0, src.size (), dest);\n    src.close ();\n    dest.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 694024, "method2_id": 3989355, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "public static long F (int n) {\n    if (n == 0) return 0;\n\n    if (n == 1) return 1;\n\n    return F (n - 1) + F (n - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 293167, "method2_id": 569812, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 472008, "method2_id": 483411, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 8024375, "method2_id": 14091098, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        log.error (e.getMessage ());\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) {\n                sb.append ('0');\n            }\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        log.error (e.getMessage ());\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 598050, "method2_id": 1575049, "code1": "boolean deleteAll (File file) {\n    if (file.isDirectory ()) {\n        for (File f : file.listFiles ()) deleteAll (f);\n\n    }\n    return file.delete ();\n}\n", "code2": "protected void recursiveDelete (File file) {\n    if (file.isDirectory ()) {\n        for (File f : file.listFiles ()) recursiveDelete (f);\n\n    }\n    file.delete ();\n}\n"}
{"clone_type": "ST3", "method1_id": 169201, "method2_id": 834053, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 698010, "method2_id": 859719, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 5236784, "method2_id": 12171653, "code1": "public static double [] [] calcTranspose (double [] [] mat) {\n    double [] [] transpose = new double [mat [0].length] [mat.length];\n    for (int a = 0;\n    a < transpose.length; a ++) {\n        for (int b = 0;\n        b < transpose [0].length; b ++) {\n            transpose [a] [b] = mat [b] [a];\n        }\n    }\n    return transpose;\n}\n", "code2": "public static double [] [] invertMatrix (double [] [] matrix) {\n    int firstDimentionOfResultMatrix = matrix [0].length;\n    int secondDimentionOfResultMatrix = matrix.length;\n    double [] [] resultMatrix = new double [firstDimentionOfResultMatrix] [secondDimentionOfResultMatrix];\n    for (int i = 0;\n    i < matrix.length; i ++) {\n        for (int j = 0;\n        j < matrix [0].length; j ++) {\n            resultMatrix [j] [i] = matrix [i] [j];\n        }\n    }\n    return resultMatrix;\n}\n"}
{"clone_type": "ST3", "method1_id": 264493, "method2_id": 843888, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 3514286, "method2_id": 13414771, "code1": "public static String getHashedPassword (String password) {\n    try {\n        MessageDigest digest = MessageDigest.getInstance (\"MD5\");\n        digest.update (password.getBytes ());\n        BigInteger hashedInt = new BigInteger (1, digest.digest ());\n        return String.format (\"%1$032X\", hashedInt);\n    } catch (NoSuchAlgorithmException nsae) {\n        System.err.println (nsae.getMessage ());\n    }\n    return \"\";\n}\n", "code2": "@Digester(forField=\"password\")\npublic static String encriptPassword (String passwd) {\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (passwd.getBytes ());\n        BigInteger hash = new BigInteger (1, md.digest ());\n        return hash.toString (16);\n    } catch (Exception e) {\n        return null;\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 3870229, "method2_id": 12679523, "code1": "public void actionPerformed (ActionEvent evt) {\n    if (Desktop.isDesktopSupported ()) {\n        try {\n            Desktop.getDesktop ().browse (new URI (HOMEPAGE));\n        } catch (Exception e) {\n            e.printStackTrace ();\n        }\n    }\n}\n", "code2": "@Override\npublic void mouseClicked (MouseEvent e) {\n    if (Desktop.isDesktopSupported ()) {\n        try {\n            Desktop.getDesktop ().browse (new URI (this.url));\n        } catch (Exception e1) {\n            JOptionPane.showMessageDialog (this, \"Can not open website because \" + e1.getMessage (), \"iGoSyncDocs\", JOptionPane.ERROR_MESSAGE);\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 9592646, "method2_id": 14157859, "code1": "public static void copy (String path1, String path2) throws IOException {\n    FileReader in = new FileReader (path1);\n    FileWriter out = new FileWriter (path2);\n    int c;\n    while ((c = in.read ()) != - 1) out.write (c);\n\n    in.close ();\n    out.close ();\n}\n", "code2": "static void copyFile (File file, File file1) throws IOException {\n    byte abyte0 [] = new byte [512];\n    FileInputStream fileinputstream = new FileInputStream (file);\n    FileOutputStream fileoutputstream = new FileOutputStream (file1);\n    int i;\n    while ((i = fileinputstream.read (abyte0)) > 0) fileoutputstream.write (abyte0, 0, i);\n\n    fileinputstream.close ();\n    fileoutputstream.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 471760, "method2_id": 833767, "code1": "public static boolean delete (File resource) throws IOException {\n    if (resource.isDirectory ()) {\n        File [] childFiles = resource.listFiles ();\n        for (File child : childFiles) {\n            delete (child);\n        }\n    }\n    return resource.delete ();\n}\n", "code2": "private static boolean delete (File resource) throws IOException {\n    if (resource.isDirectory ()) {\n        File [] childFiles = resource.listFiles ();\n        for (File child : childFiles) {\n            delete (child);\n        }\n    }\n    return resource.delete ();\n}\n"}
{"clone_type": "ST3", "method1_id": 9909001, "method2_id": 17619207, "code1": "public double [] [] Transpose (final double [] [] a) {\n    double m [] [] = new double [a [0].length] [a.length];\n    for (int i = 0;\n    i < a.length; i ++) for (int j = 0;\n    j < a [i].length; j ++) m [j] [i] = a [i] [j];\n\n    return m;\n}\n", "code2": "public static final double [] [] transpose (final double m1 [] []) {\n    double [] [] m3 = new double [m1 [0].length] [m1.length];\n    for (int ii = 0;\n    ii < m1.length; ii ++) for (int jj = 0;\n    jj < m1 [ii].length; jj ++) m3 [jj] [ii] = m1 [ii] [jj];\n\n    return m3;\n}\n"}
{"clone_type": "ST3", "method1_id": 19993993, "method2_id": 23484507, "code1": "public static void copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n        System.out.print (\"Overwrite existing file \" + toFile.getName () + \"? (Y/N): \");\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) throw new IOException (\"FileCopy: \" + \"existing file was not overwritten.\");\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n", "code2": "public static void copy (File fromFile, File toFile) throws IOException {\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFile.getName ());\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFile.getName ());\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFile.getName ());\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    String parent = toFile.getParent ();\n    if (parent == null) parent = System.getProperty (\"user.dir\");\n\n    File dir = new File (parent);\n    if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n    if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n    if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 7019244, "method2_id": 17467777, "code1": "public static String stringOfUrl (String addr) throws IOException {\n    ByteArrayOutputStream output = new ByteArrayOutputStream ();\n    URL url = new URL (addr);\n    IOUtils.copy (url.openStream (), output);\n    return output.toString ();\n}\n", "code2": "public String stringOfUrl (String addr) throws IOException {\n    ByteArrayOutputStream output = new ByteArrayOutputStream ();\n    URL url = new URL (addr);\n    IOUtils.copy (url.openStream (), output);\n    return output.toString ();\n}\n"}
{"clone_type": "ST3", "method1_id": 206397, "method2_id": 437883, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 17514790, "method2_id": 19214556, "code1": "public final Matrix getTranspose () {\n    double [] [] newData = new double [width_] [height_];\n    for (int row = 0;\n    row < height_; row ++) {\n        for (int col = 0;\n        col < width_; col ++) {\n            newData [col] [row] = data_ [row] [col];\n        }\n    }\n    return new Matrix (newData);\n}\n", "code2": "public void transpose () {\n    for (int i = 0;\n    i < rows; i ++) {\n        for (int j = 0;\n        j < i; j ++) {\n            int t = flmat [i] [j];\n            flmat [i] [j] = flmat [j] [i];\n            flmat [j] [i] = t;\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 15193, "method2_id": 8801436, "code1": "public static void copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"Copy: no such source file: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"Copy: source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"Copy: destination file is unwriteable: \" + toFileName);\n\n        if (JOptionPane.showConfirmDialog (null, \"Overwrite File ?\", \"Overwrite File\", JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) return;\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"Copy: destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"Copy: destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"Copy: destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n", "code2": "public static void copy (File from_file, File to_file) throws IOException {\n    if (! from_file.exists ()) abort (\"FileCopy: no such source file: \" + from_file.getName ());\n\n    if (! from_file.isFile ()) abort (\"FileCopy: can't copy directory: \" + from_file.getName ());\n\n    if (! from_file.canRead ()) abort (\"FileCopy: source file is unreadable: \" + from_file.getName ());\n\n    if (to_file.isDirectory ()) to_file = new File (to_file, from_file.getName ());\n\n    if (to_file.exists ()) {\n        if (! to_file.canWrite ()) abort (\"FileCopy: destination file is unwriteable: \" + to_file.getName ());\n\n    } else {\n        String parent = to_file.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) abort (\"FileCopy: destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) abort (\"FileCopy: destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) abort (\"FileCopy: destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (from_file);\n        to = new FileOutputStream (to_file);\n        byte [] buffer = new byte [4096];\n        int bytes_read;\n        while ((bytes_read = from.read (buffer)) != - 1) {\n            to.write (buffer, 0, bytes_read);\n        }\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 383565, "method2_id": 22324341, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private long fib (long n) {\n    if (n == 0) return 0L;\n\n    if (n == 1) return 1L;\n\n    return fib (n - 1) + fib (n - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 19147300, "method2_id": 21224972, "code1": "public boolean ponerColorxRonda (int idJugadorDiv, int idRonda, int dato) {\n    int intResult = 0;\n    String sql = \"UPDATE jugadorxdivxronda \" + \" SET color = \" + dato + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        intResult = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (intResult > 0);\n}\n", "code2": "public boolean update (int idJugador, jugador jugadorModificado) {\n    int intResult = 0;\n    String sql = \"UPDATE jugador \" + \"SET apellidoPaterno = ?, apellidoMaterno = ?, nombres = ?, fechaNacimiento = ?, \" + \" pais = ?, rating = ?, sexo = ? \" + \" WHERE idJugador = \" + idJugador;\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        populatePreparedStatement (jugadorModificado);\n        intResult = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (intResult > 0);\n}\n"}
{"clone_type": "ST3", "method1_id": 3633154, "method2_id": 5031964, "code1": "public static String getHash (String userName, String pass) {\n    String hash = null;\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (userName.getBytes ());\n        hash = ISOUtil.hexString (md.digest (pass.getBytes ())).toLowerCase ();\n    } catch (NoSuchAlgorithmException e) {\n    }\n    return hash;\n}\n", "code2": "public static String md5 (String text) {\n    String encrypted = \"\";\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (text.getBytes ());\n        encrypted = hex (md.digest ());\n    } catch (NoSuchAlgorithmException nsaEx) {\n    }\n    return encrypted;\n}\n"}
{"clone_type": "ST3", "method1_id": 3419825, "method2_id": 19247466, "code1": "public static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public void copyFile (File sourceFile, File destFile) throws IOException {\n    Log.level3 (\"Copying \" + sourceFile.getPath () + \" to \" + destFile.getPath ());\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n    }\n    if (destination != null) {\n        destination.close ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 2168608, "method2_id": 16085716, "code1": "public int delete (BusinessObject o) throws DAOException {\n    int delete = 0;\n    Contact contact = (Contact) o;\n    try {\n        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery (\"DELETE_CONTACT\"));\n        pst.setInt (1, contact.getId ());\n        delete = pst.executeUpdate ();\n        if (delete <= 0) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows <= 0\");\n        } else if (delete > 1) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows > 1\");\n        }\n\n        connection.commit ();\n    } catch (SQLException e) {\n        Log.write (e.getMessage ());\n        throw new DAOException (\"A SQLException has occured\");\n    } catch (NullPointerException npe) {\n        Log.write (npe.getMessage ());\n        throw new DAOException (\"Connection null\");\n    }\n    return delete;\n}\n", "code2": "public int update (BusinessObject o) throws DAOException {\n    int update = 0;\n    Currency curr = (Currency) o;\n    try {\n        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery (\"UPDATE_CURRENCY\"));\n        pst.setString (1, curr.getName ());\n        pst.setInt (2, curr.getIdBase ());\n        pst.setDouble (3, curr.getValue ());\n        pst.setInt (4, curr.getId ());\n        update = pst.executeUpdate ();\n        if (update <= 0) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows <= 0\");\n        } else if (update > 1) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows > 1\");\n        }\n\n        connection.commit ();\n    } catch (SQLException e) {\n        Log.write (e.getMessage ());\n        throw new DAOException (\"A SQLException has occured\");\n    } catch (NullPointerException npe) {\n        Log.write (npe.getMessage ());\n        throw new DAOException (\"Connection null\");\n    }\n    return update;\n}\n"}
{"clone_type": "ST3", "method1_id": 4921634, "method2_id": 22366639, "code1": "public int update (BusinessObject o) throws DAOException {\n    int update = 0;\n    Item item = (Item) o;\n    try {\n        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery (\"UPDATE_ITEM\"));\n        pst.setString (1, item.getDescription ());\n        pst.setDouble (2, item.getUnit_price ());\n        pst.setInt (3, item.getQuantity ());\n        pst.setDouble (4, item.getVat ());\n        pst.setInt (5, item.getIdProject ());\n        if (item.getIdBill () == 0) pst.setNull (6, java.sql.Types.INTEGER);\n        else pst.setInt (6, item.getIdBill ());\n\n        pst.setInt (7, item.getIdCurrency ());\n        pst.setInt (8, item.getId ());\n        System.out.println (\"item => \" + item.getDescription () + \" \" + item.getUnit_price () + \" \" + item.getQuantity () + \" \" + item.getVat () + \" \" + item.getIdProject () + \" \" + item.getIdBill () + \" \" + item.getIdCurrency () + \" \" + item.getId ());\n        update = pst.executeUpdate ();\n        if (update <= 0) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows <= 0\");\n        } else if (update > 1) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows > 1\");\n        }\n\n        connection.commit ();\n    } catch (SQLException e) {\n        Log.write (e.getMessage ());\n        throw new DAOException (\"A SQLException has occured\");\n    } catch (NullPointerException npe) {\n        Log.write (npe.getMessage ());\n        throw new DAOException (\"Connection null\");\n    }\n    return update;\n}\n", "code2": "public int update (BusinessObject o) throws DAOException {\n    int update = 0;\n    Project project = (Project) o;\n    try {\n        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery (\"UPDATE_PROJECT\"));\n        pst.setString (1, project.getName ());\n        pst.setString (2, project.getDescription ());\n        pst.setInt (3, project.getIdAccount ());\n        pst.setInt (4, project.getIdContact ());\n        pst.setBoolean (5, project.isArchived ());\n        pst.setInt (6, project.getId ());\n        update = pst.executeUpdate ();\n        if (update <= 0) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows <= 0\");\n        } else if (update > 1) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows > 1\");\n        }\n\n        connection.commit ();\n    } catch (SQLException e) {\n        Log.write (e.getMessage ());\n        throw new DAOException (\"A SQLException has occured\");\n    } catch (NullPointerException npe) {\n        Log.write (npe.getMessage ());\n        throw new DAOException (\"Connection null\");\n    }\n    return update;\n}\n"}
{"clone_type": "ST3", "method1_id": 7574033, "method2_id": 20603864, "code1": "public static String generateHashSE (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException, DigestException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-256\");\n    byte [] hashSHA256 = new byte [32];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    md.digest (hashSHA256, 0, text.length ());\n    return convertToHex (hashSHA256);\n}\n", "code2": "public static String SHA1 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 19045087, "method2_id": 21585794, "code1": "public static void copyfile (String src, String dst) throws IOException {\n    dst = new File (dst).getAbsolutePath ();\n    new File (new File (dst).getParent ()).mkdirs ();\n    FileChannel srcChannel = new FileInputStream (src).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (dst).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n", "code2": "public static void copyFile (File source, File dest) throws IOException {\n    if (source.equals (dest)) return;\n\n    FileChannel srcChannel = new FileInputStream (source).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (dest).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 541800, "method2_id": 4328782, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "ST3", "method1_id": 10671991, "method2_id": 13949581, "code1": "public static String md5 (String value) {\n    try {\n        MessageDigest messageDigest = MessageDigest.getInstance (\"MD5\");\n        messageDigest.update (value.getBytes ());\n        return bytesToString (messageDigest.digest ());\n    } catch (Exception ex) {\n        Tools.logException (Tools.class, ex, value);\n    }\n    return value;\n}\n", "code2": "public static String cryptografar (String senha) {\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (senha.getBytes ());\n        BigInteger hash = new BigInteger (1, md.digest ());\n        senha = hash.toString (16);\n    } catch (NoSuchAlgorithmException ns) {\n        ns.printStackTrace ();\n    }\n    return senha;\n}\n"}
{"clone_type": "ST3", "method1_id": 3861343, "method2_id": 12066447, "code1": "protected void truncate (File file) {\n    LogLog.debug (\"Compression of file: \" + file.getAbsolutePath () + \" started.\");\n    if (FileUtils.isFileOlder (file, ManagementFactory.getRuntimeMXBean ().getStartTime ())) {\n        File backupRoot = new File (getBackupDir ());\n        if (! backupRoot.exists () && ! backupRoot.mkdirs ()) {\n            throw new AppenderInitializationError (\"Can't create backup dir for backup storage\");\n        }\n        SimpleDateFormat df;\n        try {\n            df = new SimpleDateFormat (getBackupDateFormat ());\n        } catch (Exception e) {\n            throw new AppenderInitializationError (\"Invalid date formate for backup files: \" + getBackupDateFormat (), e);\n        }\n        String date = df.format (new Date (file.lastModified ()));\n        File zipFile = new File (backupRoot, file.getName () + \".\" + date + \".zip\");\n        ZipOutputStream zos = null;\n        FileInputStream fis = null;\n        try {\n            zos = new ZipOutputStream (new FileOutputStream (zipFile));\n            ZipEntry entry = new ZipEntry (file.getName ());\n            entry.setMethod (ZipEntry.DEFLATED);\n            entry.setCrc (FileUtils.checksumCRC32 (file));\n            zos.putNextEntry (entry);\n            fis = FileUtils.openInputStream (file);\n            byte [] buffer = new byte [1024];\n            int readed;\n            while ((readed = fis.read (buffer)) != - 1) {\n                zos.write (buffer, 0, readed);\n            }\n        } catch (Exception e) {\n            throw new AppenderInitializationError (\"Can't create zip file\", e);\n        } finally {\n            if (zos != null) {\n                try {\n                    zos.close ();\n                } catch (IOException e) {\n                    LogLog.warn (\"Can't close zip file\", e);\n                }\n            }\n            if (fis != null) {\n                try {\n                    fis.close ();\n                } catch (IOException e) {\n                    LogLog.warn (\"Can't close zipped file\", e);\n                }\n            }\n        }\n        if (! file.delete ()) {\n            throw new AppenderInitializationError (\"Can't delete old log file \" + file.getAbsolutePath ());\n        }\n    }\n}\n", "code2": "protected void truncate (final File file) {\n    LogLog.debug (\"Compression of file: \" + file.getAbsolutePath () + \" started.\");\n    if (FileUtils.isFileOlder (file, ManagementFactory.getRuntimeMXBean ().getStartTime ())) {\n        final File backupRoot = new File (this.getBackupDir ());\n        if (! backupRoot.exists () && ! backupRoot.mkdirs ()) {\n            throw new AppenderInitializationError (\"Can't create backup dir for backup storage\");\n        }\n        SimpleDateFormat df;\n        try {\n            df = new SimpleDateFormat (this.getBackupDateFormat ());\n        } catch (final Exception e) {\n            throw new AppenderInitializationError (\"Invalid date formate for backup files: \" + this.getBackupDateFormat (), e);\n        }\n        final String date = df.format (new Date (file.lastModified ()));\n        final File zipFile = new File (backupRoot, file.getName () + \".\" + date + \".zip\");\n        ZipOutputStream zos = null;\n        FileInputStream fis = null;\n        try {\n            zos = new ZipOutputStream (new FileOutputStream (zipFile));\n            final ZipEntry entry = new ZipEntry (file.getName ());\n            entry.setMethod (ZipEntry.DEFLATED);\n            entry.setCrc (FileUtils.checksumCRC32 (file));\n            zos.putNextEntry (entry);\n            fis = FileUtils.openInputStream (file);\n            final byte [] buffer = new byte [1024];\n            int readed;\n            while ((readed = fis.read (buffer)) != - 1) {\n                zos.write (buffer, 0, readed);\n            }\n        } catch (final Exception e) {\n            throw new AppenderInitializationError (\"Can't create zip file\", e);\n        } finally {\n            if (zos != null) {\n                try {\n                    zos.close ();\n                } catch (final IOException e) {\n                    LogLog.warn (\"Can't close zip file\", e);\n                }\n            }\n            if (fis != null) {\n                try {\n                    fis.close ();\n                } catch (final IOException e) {\n                    LogLog.warn (\"Can't close zipped file\", e);\n                }\n            }\n        }\n        if (! file.delete ()) {\n            throw new AppenderInitializationError (\"Can't delete old log file \" + file.getAbsolutePath ());\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 654166, "method2_id": 834100, "code1": "static boolean clean (File dir) {\n    boolean ok = true;\n    for (File f : dir.listFiles ()) {\n        if (f.isDirectory ()) ok &= clean (f);\n\n        ok &= f.delete ();\n    }\n    return ok;\n}\n", "code2": "boolean clean (File dir) {\n    boolean ok = true;\n    for (File f : dir.listFiles ()) {\n        if (f.isDirectory ()) ok &= clean (f);\n\n        ok &= f.delete ();\n    }\n    return ok;\n}\n"}
{"clone_type": "ST3", "method1_id": 12971450, "method2_id": 19926877, "code1": "public static void copy (FileInputStream in, File destination) throws IOException {\n    FileChannel srcChannel = null;\n    FileChannel dstChannel = null;\n    try {\n        srcChannel = in.getChannel ();\n        dstChannel = new FileOutputStream (destination).getChannel ();\n        dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    } finally {\n        if (srcChannel != null) {\n            srcChannel.close ();\n        }\n        if (dstChannel != null) {\n            dstChannel.close ();\n        }\n    }\n}\n", "code2": "@Override\npublic void createCopy (File sourceFile, File destinnationFile) throws IOException {\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destinnationFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 1613935, "method2_id": 2069219, "code1": "public static boolean copyFile (File sourceFile, File destinationFile) {\n    boolean copySuccessfull = false;\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destinationFile).getChannel ();\n        long transferedBytes = destination.transferFrom (source, 0, source.size ());\n        copySuccessfull = transferedBytes == source.size () ? true : false;\n    } catch (FileNotFoundException e) {\n        e.printStackTrace ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    } finally {\n        if (source != null) {\n            try {\n                source.close ();\n            } catch (IOException e) {\n                e.printStackTrace ();\n            }\n        }\n        if (destination != null) {\n            try {\n                destination.close ();\n            } catch (IOException e) {\n                e.printStackTrace ();\n            }\n        }\n    }\n    return copySuccessfull;\n}\n", "code2": "public static void copieFichier (File fichier1, File fichier2) {\n    FileChannel in = null;\n    FileChannel out = null;\n    try {\n        in = new FileInputStream (fichier1).getChannel ();\n        out = new FileOutputStream (fichier2).getChannel ();\n        in.transferTo (0, in.size (), out);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    } finally {\n        if (in != null) {\n            try {\n                in.close ();\n            } catch (IOException e) {\n            }\n        }\n        if (out != null) {\n            try {\n                out.close ();\n            } catch (IOException e) {\n            }\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 92956, "method2_id": 183041, "code1": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://prologdev1:5432/wdb\";\n    final String dbuser = \"guest2\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT value, dataProviderName, placeName, placeGeometry,\" + \"        referencetime, \" + \"        validFrom, validTo, \" + \"        valueParameterName, valueParameterUnit, \" + \"        levelParameterName, levelUnitName, levelFrom, levelTo, \" + \"        dataVersion, confidenceCode, storetime, valueid, valuetype \" + \" FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', \" + \"                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), \" + \"                NULL, \" + \"                array['instant temperature of air'], \" + \"                ( 2, 2, 'distance above ground', 'exact' ), \" + \"                array[-1], \" + \"                NULL::wci.returnOid )\";\n    final String colNames [] = {\"value\", \"dataProviderName\", \"placeName\", \"referencetime\", \"validFrom\", \"validTo\", \"valueParameterName\", \"valueParameterUnit\", \"levelParameterName\", \"levelUnitName\", \"levelFrom\", \"levelTo\"};\n    ResultSet rs = null;\n    try {\n        con.setAutoCommit (false);\n        statement.execute (wdbInit);\n        LargeObjectManager lobj = ((org.postgresql.PGConnection) con).getLargeObjectAPI ();\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            long oid = rs.getLong (\"value\");\n            LargeObject obj = lobj.open (oid, LargeObjectManager.READ);\n            byte buf [] = new byte [obj.size ()];\n            obj.read (buf, 0, obj.size ());\n            obj.close ();\n            System.out.print (\"  BLOB size: \" + buf.length);\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        try {\n            con.commit ();\n            if (rs != null) rs.close ();\n\n        } catch (SQLException ex) {\n            System.out.println (\"EXCEPTION: rs.close: \" + ex);\n        }\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://localhost:5432/wdb\";\n    final String dbuser = \"wcitest\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT * \" + \" FROM wci.read( array['test wci 5'], 'POINT( 10.0 59.0 )', \" + \"                '2009-11-13 00:00:00+00', \" + \"                NULL, \" + \"                array['air temperature', \" + \"                      'air pressure'], \" + \"                NULL, \" + \"                array[-1], \" + \"                NULL::wci.returnFloat )\";\n    final String colNames [] = {\"value\", \"valueParameterName\", \"validTimeFrom\"};\n    ResultSet rs = null;\n    try {\n        statement.execute (wdbInit);\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        if (rs != null) {\n            try {\n                rs.close ();\n            } catch (SQLException ex) {\n                System.out.println (\"EXCEPTION: rs.close: \" + ex);\n            }\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 97436, "method2_id": 105882, "code1": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://prologdev1:5432/wdb\";\n    final String dbuser = \"guest2\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT value, dataProviderName, placeName, placeGeometry,\" + \"        referencetime, \" + \"        validFrom, validTo, \" + \"        valueParameterName, valueParameterUnit, \" + \"        levelParameterName, levelUnitName, levelFrom, levelTo, \" + \"        dataVersion, confidenceCode, storetime, valueid, valuetype \" + \" FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', \" + \"                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), \" + \"                NULL, \" + \"                array['instant temperature of air'], \" + \"                ( 2, 2, 'distance above ground', 'exact' ), \" + \"                array[-1], \" + \"                NULL::wci.returnOid )\";\n    final String colNames [] = {\"value\", \"dataProviderName\", \"placeName\", \"referencetime\", \"validFrom\", \"validTo\", \"valueParameterName\", \"valueParameterUnit\", \"levelParameterName\", \"levelUnitName\", \"levelFrom\", \"levelTo\"};\n    ResultSet rs = null;\n    try {\n        con.setAutoCommit (false);\n        statement.execute (wdbInit);\n        LargeObjectManager lobj = ((org.postgresql.PGConnection) con).getLargeObjectAPI ();\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            long oid = rs.getLong (\"value\");\n            LargeObject obj = lobj.open (oid, LargeObjectManager.READ);\n            byte buf [] = new byte [obj.size ()];\n            obj.read (buf, 0, obj.size ());\n            obj.close ();\n            System.out.print (\"  BLOB size: \" + buf.length);\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        try {\n            con.commit ();\n            if (rs != null) rs.close ();\n\n        } catch (SQLException ex) {\n            System.out.println (\"EXCEPTION: rs.close: \" + ex);\n        }\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://localhost:5432/wdb\";\n    final String dbuser = \"wcitest\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT * \" + \" FROM wci.read( array['test wci 5'], NULL, \" + \"                '2009-11-13 00:00:00+00', \" + \"                NULL, \" + \"                array['air temperature', \" + \"                      'air pressure'], \" + \"                NULL, \" + \"                array[-1], \" + \"                NULL::wci.returngid )\";\n    final String colNames [] = {\"valueParameterName\", \"validTimeFrom\"};\n    ResultSet rs = null;\n    try {\n        statement.execute (wdbInit);\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            Statement getGridStatement = con.createStatement ();\n            first = true;\n            long gridId = rs.getLong (\"value\");\n            ResultSet blobResult = getGridStatement.executeQuery (\"SELECT * FROM wci.fetch(\" + gridId + \", NULL::wci.grid)\");\n            while (blobResult.next ()) {\n                int size = blobResult.getInt (\"numberX\") + blobResult.getInt (\"numberX\");\n                InputStream blob = blobResult.getBinaryStream (\"grid\");\n                DataInputStream blobReader = new DataInputStream (blob);\n                int floatToRead = 42;\n                blobReader.skip (floatToRead * 4);\n                float value = blobReader.readFloat ();\n                System.out.print (value + \"\\t\");\n                for (String name : colNames) {\n                    data = rs.getString (name);\n                    if (first) {\n                        first = false;\n                    } else {\n                        System.out.print (\", \");\n                    }\n                    if (data != null) System.out.print (data);\n                    else System.out.print (\"\\\\N\");\n\n                }\n                System.out.print (\"  (BLOB size: \" + size + \")\");\n                System.out.println ();\n            }\n            blobResult.close ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        try {\n            if (rs != null) rs.close ();\n\n        } catch (SQLException ex) {\n            System.out.println (\"EXCEPTION: rs.close: \" + ex);\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 76607, "method2_id": 271833, "code1": "public sendhtml (String [] argv) {\n    String to, subject = null, from = null, cc = null, bcc = null, url = null;\n    String mailhost = null;\n    String mailer = \"sendhtml\";\n    String protocol = null, host = null, user = null, password = null;\n    String record = null;\n    boolean debug = false;\n    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n    int optind;\n    for (optind = 0; optind < argv.length; optind ++) {\n        if (argv [optind].equals (\"-T\")) {\n            protocol = argv [++ optind];\n        } else if (argv [optind].equals (\"-H\")) {\n            host = argv [++ optind];\n        } else if (argv [optind].equals (\"-U\")) {\n            user = argv [++ optind];\n        } else if (argv [optind].equals (\"-P\")) {\n            password = argv [++ optind];\n        } else if (argv [optind].equals (\"-M\")) {\n            mailhost = argv [++ optind];\n        } else if (argv [optind].equals (\"-f\")) {\n            record = argv [++ optind];\n        } else if (argv [optind].equals (\"-s\")) {\n            subject = argv [++ optind];\n        } else if (argv [optind].equals (\"-o\")) {\n            from = argv [++ optind];\n        } else if (argv [optind].equals (\"-c\")) {\n            cc = argv [++ optind];\n        } else if (argv [optind].equals (\"-b\")) {\n            bcc = argv [++ optind];\n        } else if (argv [optind].equals (\"-L\")) {\n            url = argv [++ optind];\n        } else if (argv [optind].equals (\"-d\")) {\n            debug = true;\n        } else if (argv [optind].equals (\"--\")) {\n            optind ++;\n            break;\n        } else if (argv [optind].startsWith (\"-\")) {\n            System.out.println (\"Usage: sendhtml [[-L store-url] | [-T prot] [-H host] [-U user] [-P passwd]]\");\n            System.out.println (\"\\t[-s subject] [-o from-address] [-c cc-addresses] [-b bcc-addresses]\");\n            System.out.println (\"\\t[-f record-mailbox] [-M transport-host] [-d] [address]\");\n            System.exit (1);\n        } else {\n            break;\n        }\n\n    }\n    try {\n        if (optind < argv.length) {\n            to = argv [optind];\n            System.out.println (\"To: \" + to);\n        } else {\n            System.out.print (\"To: \");\n            System.out.flush ();\n            to = in.readLine ();\n        }\n        if (subject == null) {\n            System.out.print (\"Subject: \");\n            System.out.flush ();\n            subject = in.readLine ();\n        } else {\n            System.out.println (\"Subject: \" + subject);\n        }\n        Properties props = System.getProperties ();\n        if (mailhost != null) props.put (\"mail.smtp.host\", mailhost);\n\n        Session session = Session.getInstance (props, null);\n        if (debug) session.setDebug (true);\n\n        Message msg = new MimeMessage (session);\n        if (from != null) msg.setFrom (new InternetAddress (from));\n        else msg.setFrom ();\n\n        msg.setRecipients (Message.RecipientType.TO, InternetAddress.parse (to, false));\n        if (cc != null) msg.setRecipients (Message.RecipientType.CC, InternetAddress.parse (cc, false));\n\n        if (bcc != null) msg.setRecipients (Message.RecipientType.BCC, InternetAddress.parse (bcc, false));\n\n        msg.setSubject (subject);\n        collect (in, msg);\n        msg.setHeader (\"X-Mailer\", mailer);\n        msg.setSentDate (new Date ());\n        Transport.send (msg);\n        System.out.println (\"\\nMail was sent successfully.\");\n        if (record != null) {\n            Store store = null;\n            if (url != null) {\n                URLName urln = new URLName (url);\n                store = session.getStore (urln);\n                store.connect ();\n            } else {\n                if (protocol != null) store = session.getStore (protocol);\n                else store = session.getStore ();\n\n                if (host != null || user != null || password != null) store.connect (host, user, password);\n                else store.connect ();\n\n            }\n            Folder folder = store.getFolder (record);\n            if (folder == null) {\n                System.err.println (\"Can't get record folder.\");\n                System.exit (1);\n            }\n            if (! folder.exists ()) folder.create (Folder.HOLDS_MESSAGES);\n\n            Message [] msgs = new Message [1];\n            msgs [0] = msg;\n            folder.appendMessages (msgs);\n            System.out.println (\"Mail was recorded successfully.\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static void main (String [] argv) {\n    String to, subject = null, from = null, cc = null, bcc = null, url = null;\n    String mailhost = null;\n    String mailer = \"msgsend\";\n    String file = null;\n    String protocol = null, host = null, user = null, password = null;\n    String record = null;\n    boolean debug = false;\n    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n    int optind;\n    for (optind = 0; optind < argv.length; optind ++) {\n        if (argv [optind].equals (\"-T\")) {\n            protocol = argv [++ optind];\n        } else if (argv [optind].equals (\"-H\")) {\n            host = argv [++ optind];\n        } else if (argv [optind].equals (\"-U\")) {\n            user = argv [++ optind];\n        } else if (argv [optind].equals (\"-P\")) {\n            password = argv [++ optind];\n        } else if (argv [optind].equals (\"-M\")) {\n            mailhost = argv [++ optind];\n        } else if (argv [optind].equals (\"-f\")) {\n            record = argv [++ optind];\n        } else if (argv [optind].equals (\"-a\")) {\n            file = argv [++ optind];\n        } else if (argv [optind].equals (\"-s\")) {\n            subject = argv [++ optind];\n        } else if (argv [optind].equals (\"-o\")) {\n            from = argv [++ optind];\n        } else if (argv [optind].equals (\"-c\")) {\n            cc = argv [++ optind];\n        } else if (argv [optind].equals (\"-b\")) {\n            bcc = argv [++ optind];\n        } else if (argv [optind].equals (\"-L\")) {\n            url = argv [++ optind];\n        } else if (argv [optind].equals (\"-d\")) {\n            debug = true;\n        } else if (argv [optind].equals (\"--\")) {\n            optind ++;\n            break;\n        } else if (argv [optind].startsWith (\"-\")) {\n            System.out.println (\"Usage: msgsend [[-L store-url] | [-T prot] [-H host] [-U user] [-P passwd]]\");\n            System.out.println (\"\\t[-s subject] [-o from-address] [-c cc-addresses] [-b bcc-addresses]\");\n            System.out.println (\"\\t[-f record-mailbox] [-M transport-host] [-a attach-file] [-d] [address]\");\n            System.exit (1);\n        } else {\n            break;\n        }\n\n    }\n    try {\n        if (optind < argv.length) {\n            to = argv [optind];\n            System.out.println (\"To: \" + to);\n        } else {\n            System.out.print (\"To: \");\n            System.out.flush ();\n            to = in.readLine ();\n        }\n        if (subject == null) {\n            System.out.print (\"Subject: \");\n            System.out.flush ();\n            subject = in.readLine ();\n        } else {\n            System.out.println (\"Subject: \" + subject);\n        }\n        Properties props = System.getProperties ();\n        if (mailhost != null) props.put (\"mail.smtp.host\", mailhost);\n\n        Session session = Session.getInstance (props, null);\n        if (debug) session.setDebug (true);\n\n        Message msg = new MimeMessage (session);\n        if (from != null) msg.setFrom (new InternetAddress (from));\n        else msg.setFrom ();\n\n        msg.setRecipients (Message.RecipientType.TO, InternetAddress.parse (to, false));\n        if (cc != null) msg.setRecipients (Message.RecipientType.CC, InternetAddress.parse (cc, false));\n\n        if (bcc != null) msg.setRecipients (Message.RecipientType.BCC, InternetAddress.parse (bcc, false));\n\n        msg.setSubject (subject);\n        String text = collect (in);\n        if (file != null) {\n            MimeBodyPart mbp1 = new MimeBodyPart ();\n            mbp1.setText (text);\n            MimeBodyPart mbp2 = new MimeBodyPart ();\n            mbp2.attachFile (file);\n            MimeMultipart mp = new MimeMultipart ();\n            mp.addBodyPart (mbp1);\n            mp.addBodyPart (mbp2);\n            msg.setContent (mp);\n        } else {\n            msg.setText (text);\n        }\n        msg.setHeader (\"X-Mailer\", mailer);\n        msg.setSentDate (new Date ());\n        Transport.send (msg);\n        System.out.println (\"\\nMail was sent successfully.\");\n        if (record != null) {\n            Store store = null;\n            if (url != null) {\n                URLName urln = new URLName (url);\n                store = session.getStore (urln);\n                store.connect ();\n            } else {\n                if (protocol != null) store = session.getStore (protocol);\n                else store = session.getStore ();\n\n                if (host != null || user != null || password != null) store.connect (host, user, password);\n                else store.connect ();\n\n            }\n            Folder folder = store.getFolder (record);\n            if (folder == null) {\n                System.err.println (\"Can't get record folder.\");\n                System.exit (1);\n            }\n            if (! folder.exists ()) folder.create (Folder.HOLDS_MESSAGES);\n\n            Message [] msgs = new Message [1];\n            msgs [0] = msg;\n            folder.appendMessages (msgs);\n            System.out.println (\"Mail was recorded successfully.\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 255647, "method2_id": 660105, "code1": "public long fib (int n) {\n    if (n <= 1) return n;\n    else return fib (n - 1) + fib (n - 2);\n\n}\n", "code2": "static long seqFib (int n) {\n    if (n <= 1) return n;\n    else return seqFib (n - 1) + seqFib (n - 2);\n\n}\n"}
{"clone_type": "ST3", "method1_id": 5090669, "method2_id": 22306604, "code1": "private static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public static void upLoadFile (File sourceFile, File targetFile) throws IOException {\n    FileChannel inChannel = null;\n    FileChannel outChannel = null;\n    try {\n        inChannel = new FileInputStream (sourceFile).getChannel ();\n        outChannel = new FileOutputStream (targetFile).getChannel ();\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } finally {\n        try {\n            if (inChannel != null) {\n                inChannel.close ();\n            }\n            if (outChannel != null) {\n                outChannel.close ();\n            }\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 12679523, "method2_id": 14560249, "code1": "@Override\npublic void mouseClicked (MouseEvent e) {\n    if (Desktop.isDesktopSupported ()) {\n        try {\n            Desktop.getDesktop ().browse (new URI (this.url));\n        } catch (Exception e1) {\n            JOptionPane.showMessageDialog (this, \"Can not open website because \" + e1.getMessage (), \"iGoSyncDocs\", JOptionPane.ERROR_MESSAGE);\n        }\n    }\n}\n", "code2": "@Override\npublic void actionPerformed (ActionEvent e) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (Exception ex) {\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 2177123, "method2_id": 15177202, "code1": "public void hyperlinkUpdate (HyperlinkEvent event) {\n    URL url = event.getURL ();\n    if (event.getEventType () == HyperlinkEvent.EventType.ENTERED && ! event.getDescription ().startsWith (\"copyUrl:\")) {\n        updatesEditorPane.setToolTipText (url.toString ());\n    } else if (event.getEventType () == HyperlinkEvent.EventType.EXITED) {\n        updatesEditorPane.setToolTipText (null);\n    } else if (event.getEventType () == HyperlinkEvent.EventType.ACTIVATED) {\n        if (event.getDescription ().startsWith (\"copyUrl:\")) {\n            String toCopy = event.getDescription ().replaceFirst (\"copyUrl:\", \"\");\n            StringSelection data = new StringSelection (toCopy);\n            Clipboard clipboard = Toolkit.getDefaultToolkit ().getSystemClipboard ();\n            clipboard.setContents (data, data);\n        } else {\n            String browser = configManager.getBrowser ();\n            if (! Desktop.isDesktopSupported ()) {\n                try {\n                    if (! browser.equals (\"\")) {\n                        Runtime.getRuntime ().exec (browser + \" \" + url.toString ());\n                    } else {\n                        Runtime.getRuntime ().exec (\"firefox \" + url.toString ());\n                    }\n                } catch (Exception ex) {\n                    JOptionPane.showMessageDialog (this, \"Unable to find a web browser, please set up one on settings window\", \"Web browser error\", JOptionPane.WARNING_MESSAGE);\n                }\n            }\n            try {\n                Desktop desktop = Desktop.getDesktop ();\n                URI uri = new URI (url.toString ());\n                desktop.browse (uri);\n            } catch (Exception e) {\n                return;\n            }\n        }\n    }\n\n}\n", "code2": "public void hyperlinkUpdate (HyperlinkEvent event) {\n    URL url = event.getURL ();\n    if (event.getEventType () == HyperlinkEvent.EventType.ENTERED && ! event.getDescription ().equals (\"login\") && ! event.getDescription ().startsWith (\"copyUrl:\")) {\n        urlsEditorPane.setToolTipText (url.toString ());\n    } else if (event.getEventType () == HyperlinkEvent.EventType.EXITED) {\n        urlsEditorPane.setToolTipText (null);\n    } else if (event.getEventType () == HyperlinkEvent.EventType.ACTIVATED) {\n        if (event.getDescription ().equals (\"login\")) {\n            if (loginWindow == null) {\n                loginWindow = new LoginWindow (this, keys, configManager, pdfDocument);\n            } else {\n                loginWindow.setVisible (true);\n            }\n        } else if (event.getDescription ().startsWith (\"copyUrl:\")) {\n            String toCopy = event.getDescription ().replaceFirst (\"copyUrl:\", \"\");\n            StringSelection data = new StringSelection (toCopy);\n            Clipboard clipboard = Toolkit.getDefaultToolkit ().getSystemClipboard ();\n            clipboard.setContents (data, data);\n        } else {\n            String browser = configManager.getBrowser ();\n            if (! Desktop.isDesktopSupported ()) {\n                try {\n                    if (! browser.equals (\"\")) {\n                        Runtime.getRuntime ().exec (browser + \" \" + url.toString ());\n                    } else {\n                        Runtime.getRuntime ().exec (\"firefox \" + url.toString ());\n                    }\n                } catch (Exception ex) {\n                    JOptionPane.showMessageDialog (this, \"Unable to find a web browser, \" + \"please set up one on settings window\", \"Web browser error\", JOptionPane.WARNING_MESSAGE);\n                }\n            }\n            try {\n                Desktop desktop = Desktop.getDesktop ();\n                URI uri = new URI (url.toString ());\n                desktop.browse (uri);\n            } catch (Exception e) {\n                return;\n            }\n        }\n\n    }\n\n}\n"}
{"clone_type": "ST3", "method1_id": 742572, "method2_id": 779185, "code1": "public void elimina (Cliente cli) throws errorSQL, errorConexionBD {\n    System.out.println (\"GestorCliente.elimina()\");\n    int id = cli.getId ();\n    String sql;\n    Statement stmt = null;\n    try {\n        gd.begin ();\n        sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n        System.out.println (\"Ejecutando: \" + sql);\n        stmt = gd.getConexion ().createStatement ();\n        stmt.executeUpdate (sql);\n        sql = \"DELETE FROM usuario WHERE cod_usuario =\" + id;\n        System.out.println (\"Ejecutando: \" + sql);\n        stmt = gd.getConexion ().createStatement ();\n        stmt.executeUpdate (sql);\n        System.out.println (\"executeUpdate\");\n        sql = \"DELETE FROM persona WHERE id =\" + id;\n        System.out.println (\"Ejecutando: \" + sql);\n        stmt = gd.getConexion ().createStatement ();\n        stmt.executeUpdate (sql);\n        gd.commit ();\n        System.out.println (\"commit\");\n        stmt.close ();\n    } catch (SQLException e) {\n        gd.rollback ();\n        throw new errorSQL (e.toString ());\n    } catch (errorConexionBD e) {\n        System.err.println (\"Error en GestorCliente.elimina(): \" + e);\n    } catch (errorSQL e) {\n        System.err.println (\"Error en GestorCliente.elimina(): \" + e);\n    }\n}\n", "code2": "public void elimina (Pedido pe) throws errorSQL, errorConexionBD {\n    System.out.println (\"GestorPedido.elimina()\");\n    int id = pe.getId ();\n    String sql;\n    Statement stmt = null;\n    try {\n        gd.begin ();\n        sql = \"DELETE FROM pedido WHERE id=\" + id;\n        System.out.println (\"Ejecutando: \" + sql);\n        stmt = gd.getConexion ().createStatement ();\n        stmt.executeUpdate (sql);\n        System.out.println (\"executeUpdate\");\n        gd.commit ();\n        System.out.println (\"commit\");\n        stmt.close ();\n    } catch (SQLException e) {\n        gd.rollback ();\n        throw new errorSQL (e.toString ());\n    } catch (errorConexionBD e) {\n        System.err.println (\"Error en GestorPedido.elimina(): \" + e);\n    } catch (errorSQL e) {\n        System.err.println (\"Error en GestorPedido.elimina(): \" + e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 207614, "method2_id": 290934, "code1": "public MNewProject (JFrame par, String projFileName, int msg) {\n    super (par, true);\n    m_dialogOK = false;\n    setSize (650, 500);\n    if (projFileName == null) reset ();\n\n    m_message = msg;\n    if (projFileName == null) {\n        m_srcLang = CommandThread.core.getPreference (OConsts.PREF_SRCLANG);\n        m_locLang = CommandThread.core.getPreference (OConsts.PREF_LOCLANG);\n        if (m_srcLang.equals (\"\")) m_srcLang = \"EN-US\";\n\n        if (m_locLang.equals (\"\")) m_locLang = \"ES\";\n\n    }\n    m_browseTarget = 0;\n    m_messageLabel = new JLabel ();\n    Box bMes = Box.createHorizontalBox ();\n    bMes.add (m_messageLabel);\n    bMes.add (Box.createHorizontalGlue ());\n    m_srcRootLabel = new JLabel ();\n    Box bSrc = Box.createHorizontalBox ();\n    bSrc.add (m_srcRootLabel);\n    bSrc.add (Box.createHorizontalGlue ());\n    m_srcBrowse = new JButton ();\n    bSrc.add (m_srcBrowse);\n    m_srcRootField = new JTextField ();\n    m_srcRootField.setEditable (false);\n    m_locRootLabel = new JLabel ();\n    Box bLoc = Box.createHorizontalBox ();\n    bLoc.add (m_locRootLabel);\n    bLoc.add (Box.createHorizontalGlue ());\n    m_locBrowse = new JButton ();\n    bLoc.add (m_locBrowse);\n    m_locRootField = new JTextField ();\n    m_locRootField.setEditable (false);\n    m_glosRootLabel = new JLabel ();\n    Box bGlos = Box.createHorizontalBox ();\n    bGlos.add (m_glosRootLabel);\n    bGlos.add (Box.createHorizontalGlue ());\n    m_glosBrowse = new JButton ();\n    bGlos.add (m_glosBrowse);\n    m_glosRootField = new JTextField ();\n    m_glosRootField.setEditable (false);\n    m_tmRootLabel = new JLabel ();\n    Box bTM = Box.createHorizontalBox ();\n    bTM.add (m_tmRootLabel);\n    bTM.add (Box.createHorizontalGlue ());\n    m_tmBrowse = new JButton ();\n    bTM.add (m_tmBrowse);\n    m_tmRootField = new JTextField ();\n    m_tmRootField.setEditable (false);\n    m_srcLangLabel = new JLabel ();\n    Box bSL = Box.createHorizontalBox ();\n    bSL.add (m_srcLangLabel);\n    bSL.add (Box.createHorizontalGlue ());\n    m_srcLangField = new JTextField ();\n    m_srcLangField.setText (m_srcLang);\n    m_locLangLabel = new JLabel ();\n    Box bLL = Box.createHorizontalBox ();\n    bLL.add (m_locLangLabel);\n    bLL.add (Box.createHorizontalGlue ());\n    m_locLangField = new JTextField ();\n    m_locLangField.setText (m_locLang);\n    m_okButton = new JButton ();\n    m_cancelButton = new JButton ();\n    Box b = Box.createVerticalBox ();\n    b.add (bMes);\n    b.add (bSrc);\n    b.add (m_srcRootField);\n    b.add (bLoc);\n    b.add (m_locRootField);\n    b.add (bGlos);\n    b.add (m_glosRootField);\n    b.add (bTM);\n    b.add (m_tmRootField);\n    b.add (bSL);\n    b.add (m_srcLangField);\n    b.add (bLL);\n    b.add (m_locLangField);\n    getContentPane ().add (b, \"North\");\n    Box b2 = Box.createHorizontalBox ();\n    b2.add (Box.createHorizontalGlue ());\n    b2.add (m_cancelButton);\n    b2.add (Box.createHorizontalStrut (5));\n    b2.add (m_okButton);\n    getContentPane ().add (b2, \"South\");\n    m_okButton.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            doOK ();\n        }}\n\n    );\n    m_cancelButton.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            doCancel ();\n        }}\n\n    );\n    m_srcBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 1;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    m_locBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 2;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    m_glosBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 3;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    m_tmBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 4;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    if (projFileName == null) {\n        NewDirectoryChooser ndc = new NewDirectoryChooser ();\n        String label;\n        label = OStrings.PP_SAVE_PROJECT_FILE;\n        ndc.setDialogTitle (label);\n        String curDir = CommandThread.core.getPreference (OConsts.PREF_CUR_DIR);\n        if (curDir != null) {\n            File dir = new File (curDir);\n            if (dir.exists () && dir.isDirectory ()) {\n                ndc.setCurrentDirectory (dir);\n            }\n        }\n        int val = ndc.showSaveDialog (this);\n        if (val != JFileChooser.APPROVE_OPTION) {\n            m_dialogCancelled = true;\n            return;\n        }\n        m_projRoot = ndc.getSelectedFile ().getAbsolutePath () + File.separator;\n        m_projFile = m_projRoot + OConsts.PROJ_FILENAME;\n        CommandThread.core.setPreference (OConsts.PREF_CUR_DIR, ndc.getSelectedFile ().getParent ());\n        m_projName = m_projFile.substring (m_projRoot.length ());\n        m_srcRoot = m_projRoot + OConsts.DEFAULT_SRC + File.separator;\n        m_locRoot = m_projRoot + OConsts.DEFAULT_LOC + File.separator;\n        m_glosRoot = m_projRoot + OConsts.DEFAULT_GLOS + File.separator;\n        m_tmRoot = m_projRoot + OConsts.DEFAULT_TM + File.separator;\n    } else {\n        m_projFile = projFileName;\n        m_projRoot = m_projFile.substring (0, m_projFile.lastIndexOf (File.separator));\n    }\n    m_projInternal = m_projRoot + OConsts.DEFAULT_INTERNAL + File.separator;\n    m_srcRootField.setText (m_srcRoot);\n    m_locRootField.setText (m_locRoot);\n    m_glosRootField.setText (m_glosRoot);\n    m_tmRootField.setText (m_tmRoot);\n    m_srcLangField.setText (m_srcLang);\n    m_locLangField.setText (m_locLang);\n    updateUIText ();\n}\n", "code2": "public MNewProject (JFrame par, String projFileName, int msg) {\n    super (par, true);\n    m_dialogOK = false;\n    setSize (650, 500);\n    m_projRoot = \"\";\n    m_projInternal = \"\";\n    m_projName = \"\";\n    m_srcRoot = \"\";\n    m_locRoot = \"\";\n    m_glosRoot = \"\";\n    m_tmRoot = \"\";\n    m_message = msg;\n    m_browseTarget = 0;\n    m_messageLabel = new JLabel ();\n    Box bMes = Box.createHorizontalBox ();\n    bMes.add (m_messageLabel);\n    bMes.add (Box.createHorizontalGlue ());\n    m_projNameLabel = new JLabel ();\n    Box bName = Box.createHorizontalBox ();\n    bName.add (m_projNameLabel);\n    bName.add (Box.createHorizontalGlue ());\n    m_projNameField = new JTextField ();\n    m_projRootLabel = new JLabel ();\n    Box bProj = Box.createHorizontalBox ();\n    bProj.add (m_projRootLabel);\n    bProj.add (Box.createHorizontalGlue ());\n    m_projRootField = new JTextField ();\n    m_projRootField.setEditable (false);\n    m_projInternalLabel = new JLabel ();\n    Box bInternal = Box.createHorizontalBox ();\n    bInternal.add (m_projInternalLabel);\n    bInternal.add (Box.createHorizontalGlue ());\n    m_projInternalField = new JTextField ();\n    m_projInternalField.setEditable (false);\n    m_srcRootLabel = new JLabel ();\n    Box bSrc = Box.createHorizontalBox ();\n    bSrc.add (m_srcRootLabel);\n    bSrc.add (Box.createHorizontalGlue ());\n    m_srcBrowse = new JButton ();\n    bSrc.add (m_srcBrowse);\n    m_srcRootField = new JTextField ();\n    m_srcRootField.setEditable (false);\n    m_locRootLabel = new JLabel ();\n    Box bLoc = Box.createHorizontalBox ();\n    bLoc.add (m_locRootLabel);\n    bLoc.add (Box.createHorizontalGlue ());\n    m_locBrowse = new JButton ();\n    bLoc.add (m_locBrowse);\n    m_locRootField = new JTextField ();\n    m_locRootField.setEditable (false);\n    m_glosRootLabel = new JLabel ();\n    Box bGlos = Box.createHorizontalBox ();\n    bGlos.add (m_glosRootLabel);\n    bGlos.add (Box.createHorizontalGlue ());\n    m_glosBrowse = new JButton ();\n    bGlos.add (m_glosBrowse);\n    m_glosRootField = new JTextField ();\n    m_glosRootField.setEditable (false);\n    m_tmRootLabel = new JLabel ();\n    Box bTM = Box.createHorizontalBox ();\n    bTM.add (m_tmRootLabel);\n    bTM.add (Box.createHorizontalGlue ());\n    m_tmBrowse = new JButton ();\n    bTM.add (m_tmBrowse);\n    m_tmRootField = new JTextField ();\n    m_tmRootField.setEditable (false);\n    m_okButton = new JButton ();\n    m_cancelButton = new JButton ();\n    Box b = Box.createVerticalBox ();\n    b.add (bMes);\n    b.add (bName);\n    b.add (m_projNameField);\n    b.add (bProj);\n    b.add (m_projRootField);\n    b.add (bInternal);\n    b.add (m_projInternalField);\n    b.add (bSrc);\n    b.add (m_srcRootField);\n    b.add (bLoc);\n    b.add (m_locRootField);\n    b.add (bGlos);\n    b.add (m_glosRootField);\n    b.add (bTM);\n    b.add (m_tmRootField);\n    getContentPane ().add (b, \"North\");\n    Box b2 = Box.createHorizontalBox ();\n    b2.add (Box.createHorizontalGlue ());\n    b2.add (m_cancelButton);\n    b2.add (Box.createHorizontalStrut (5));\n    b2.add (m_okButton);\n    getContentPane ().add (b2, \"South\");\n    m_okButton.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            doOK ();\n        }}\n\n    );\n    m_cancelButton.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            doCancel ();\n        }}\n\n    );\n    m_srcBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 1;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    m_locBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 2;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    m_glosBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 3;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    m_tmBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 4;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    if (projFileName == null) {\n        JFileChooser jfc = new JFileChooser ();\n        String label;\n        label = OStrings.PP_SAVE_PROJECT_FILE;\n        jfc.setDialogTitle (label);\n        int val = jfc.showOpenDialog (this);\n        if (val == JFileChooser.APPROVE_OPTION) {\n            m_projFile = jfc.getSelectedFile ().getAbsolutePath ();\n            if ((m_projFile == null) || (m_projFile.equals (\"\"))) {\n                m_dialogCancelled = true;\n                return;\n            }\n            if (m_projFile.endsWith (OConsts.PROJ_EXTENSION) == false) {\n                m_projFile += OConsts.PROJ_EXTENSION;\n            }\n        } else {\n            m_dialogCancelled = true;\n            return;\n        }\n        File projDir = jfc.getCurrentDirectory ();\n        m_projRoot = projDir.getAbsolutePath ();\n        m_projRoot = verifyPathString (m_projRoot, \"\");\n    } else {\n        m_projFile = projFileName;\n        m_projRoot = m_projFile.substring (0, m_projFile.lastIndexOf (File.separator));\n        m_projRoot = verifyPathString (m_projRoot, \"\");\n    }\n    m_projBase = m_projFile.substring (0, m_projFile.lastIndexOf (\".\"));\n    m_projInternal = m_projRoot + OConsts.DEFAULT_INTERNAL;\n    m_srcRoot = m_projRoot + OConsts.DEFAULT_SRC;\n    m_locRoot = m_projRoot + OConsts.DEFAULT_LOC;\n    m_glosRoot = m_projRoot + OConsts.DEFAULT_GLOS;\n    m_tmRoot = m_projRoot + OConsts.DEFAULT_TM;\n    m_projRootField.setText (m_projRoot);\n    m_projInternalField.setText (m_projInternal);\n    m_srcRootField.setText (m_srcRoot);\n    m_locRootField.setText (m_locRoot);\n    m_glosRootField.setText (m_glosRoot);\n    m_tmRootField.setText (m_tmRoot);\n    updateUIText ();\n}\n"}
{"clone_type": "ST3", "method1_id": 1966263, "method2_id": 5751314, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        closeQuietly (in);\n        closeQuietly (out);\n    }\n    return success;\n}\n"}
{"clone_type": "ST3", "method1_id": 10222828, "method2_id": 20103172, "code1": "public static String getMD5Hash (String data) {\n    MessageDigest digest;\n    try {\n        digest = java.security.MessageDigest.getInstance (\"MD5\");\n        digest.update (data.getBytes ());\n        byte [] hash = digest.digest ();\n        StringBuffer hexString = new StringBuffer ();\n        String hexChar = \"\";\n        for (int i = 0;\n        i < hash.length; i ++) {\n            hexChar = Integer.toHexString (0xFF & hash [i]);\n            if (hexChar.length () < 2) {\n                hexChar = \"0\" + hexChar;\n            }\n            hexString.append (hexChar);\n        }\n        return hexString.toString ();\n    } catch (NoSuchAlgorithmException ex) {\n        return null;\n    }\n}\n", "code2": "private String getMD5Hash (String password) {\n    String plainText = password;\n    MessageDigest mdAlgorithm;\n    StringBuffer hexString = new StringBuffer ();\n    try {\n        mdAlgorithm = MessageDigest.getInstance (\"MD5\");\n        mdAlgorithm.update (plainText.getBytes ());\n        byte [] digest = mdAlgorithm.digest ();\n        for (int i = 0;\n        i < digest.length; i ++) {\n            plainText = Integer.toHexString (0xFF & digest [i]);\n            if (plainText.length () < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append (plainText);\n        }\n    } catch (NoSuchAlgorithmException ex) {\n        ex.printStackTrace ();\n    }\n    return hexString.toString ();\n}\n"}
{"clone_type": "ST3", "method1_id": 2402, "method2_id": 11298700, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "public static long F (int n) {\n    if (n == 0) return 0;\n\n    if (n == 1) return 1;\n\n    return F (n - 1) + F (n - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 2362445, "method2_id": 23294396, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileOutputStream fos = new FileOutputStream (out);\n    FileChannel outChannel = fos.getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n        fos.flush ();\n        fos.close ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 3613198, "method2_id": 4684098, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (String sIn, String sOut) throws IOException {\n    File fIn = new File (sIn);\n    File fOut = new File (sOut);\n    FileChannel fcIn = new FileInputStream (fIn).getChannel ();\n    FileChannel fcOut = new FileOutputStream (fOut).getChannel ();\n    try {\n        fcIn.transferTo (0, fcIn.size (), fcOut);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (fcIn != null) fcIn.close ();\n\n        if (fcOut != null) fcOut.close ();\n\n    }\n    fOut.setReadable (fIn.canRead ());\n    fOut.setWritable (fIn.canWrite ());\n    fOut.setExecutable (fIn.canExecute ());\n}\n"}
{"clone_type": "ST3", "method1_id": 7458833, "method2_id": 22197335, "code1": "private void copyParseFileToCodeFile () throws IOException {\n    InputStream in = new FileInputStream (new File (filenameParse));\n    OutputStream out = new FileOutputStream (new File (filenameMisc));\n    byte [] buffer = new byte [1024];\n    int length;\n    while ((length = in.read (buffer)) > 0) out.write (buffer, 0, length);\n\n    in.close ();\n    out.close ();\n}\n", "code2": "private void copyFile (File src, File dst) throws IOException {\n    InputStream in = new FileInputStream (src);\n    OutputStream out = new FileOutputStream (dst);\n    byte [] buf = new byte [1024];\n    int len;\n    while ((len = in.read (buf)) > 0) out.write (buf, 0, len);\n\n    in.close ();\n    out.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 10685269, "method2_id": 14702119, "code1": "public static void copy (FileInputStream source, FileOutputStream target) throws IOException {\n    FileChannel sourceChannel = source.getChannel ();\n    FileChannel targetChannel = target.getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), targetChannel);\n    sourceChannel.close ();\n    targetChannel.close ();\n}\n", "code2": "public static void copyFile (String fileName, String dstPath) throws IOException {\n    FileChannel sourceChannel = new FileInputStream (fileName).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (dstPath).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 6419481, "method2_id": 14647876, "code1": "public static void copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n        System.out.print (\"Overwrite existing file \" + toFile.getName () + \"? (Y/N): \");\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) throw new IOException (\"FileCopy: \" + \"existing file was not overwritten.\");\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n", "code2": "public static void copyFile (IPath fromFileName, IPath toFileName) throws IOException {\n    File fromFile = fromFileName.toFile ();\n    File toFile = toFileName.toFile ();\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    InputStream from = null;\n    OutputStream to = null;\n    try {\n        from = new BufferedInputStream (new FileInputStream (fromFile));\n        to = new BufferedOutputStream (new FileOutputStream (toFile));\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 3386551, "method2_id": 11968328, "code1": "public static String convertStringToMD5 (String toEnc) {\n    try {\n        MessageDigest mdEnc = MessageDigest.getInstance (\"MD5\");\n        mdEnc.update (toEnc.getBytes (), 0, toEnc.length ());\n        return new BigInteger (1, mdEnc.digest ()).toString (16);\n    } catch (Exception e) {\n        return null;\n    }\n}\n", "code2": "public static String getMD5 (String _pwd) {\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (_pwd.getBytes ());\n        return toHexadecimal (new String (md.digest ()).getBytes ());\n    } catch (NoSuchAlgorithmException x) {\n        x.printStackTrace ();\n        return \"\";\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 592607, "method2_id": 810342, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 20898459, "method2_id": 22712288, "code1": "public static void copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n", "code2": "public static void fileCopy (String from_name, String to_name) throws IOException {\n    File fromFile = new File (from_name);\n    File toFile = new File (to_name);\n    if (fromFile.equals (toFile)) abort (\"cannot copy on itself: \" + from_name);\n\n    if (! fromFile.exists ()) abort (\"no such currentSourcepartName file: \" + from_name);\n\n    if (! fromFile.isFile ()) abort (\"can't copy directory: \" + from_name);\n\n    if (! fromFile.canRead ()) abort (\"currentSourcepartName file is unreadable: \" + from_name);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) abort (\"destination file is unwriteable: \" + to_name);\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) abort (\"destination directory doesn't exist: \" + parent);\n\n        File dir = new File (parent);\n        if (! dir.exists ()) abort (\"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) abort (\"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) abort (\"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytes_read;\n        while ((bytes_read = from.read (buffer)) != - 1) to.write (buffer, 0, bytes_read);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 1789229, "method2_id": 13704386, "code1": "public static final int binarySearch (Object [] a, Object key) {\n    int x1 = 0;\n    int x2 = a.length;\n    int i = x2 / 2, c;\n    while (x1 < x2) {\n        c = ((Comparable) a [i]).compareTo (key);\n        if (c == 0) {\n            return i;\n        } else if (c < 0) {\n            x1 = i + 1;\n        } else {\n            x2 = i;\n        }\n\n        i = x1 + (x2 - x1) / 2;\n    }\n    return - 1 * (i + 1);\n}\n", "code2": "public static final int binarySearch (int [] a, int key) {\n    int x1 = 0;\n    int x2 = a.length;\n    int i = x2 / 2;\n    while (x1 < x2) {\n        if (a [i] == key) {\n            return i;\n        } else if (a [i] < key) {\n            x1 = i + 1;\n        } else {\n            x2 = i;\n        }\n\n        i = x1 + (x2 - x1) / 2;\n    }\n    return - 1 * (i + 1);\n}\n"}
{"clone_type": "ST3", "method1_id": 1789232, "method2_id": 13704386, "code1": "public static final int binarySearch (Object [] a, Object key, Comparator cp) {\n    int x1 = 0;\n    int x2 = a.length;\n    int i = x2 / 2, c;\n    while (x1 < x2) {\n        c = cp.compare (a [i], key);\n        if (c == 0) {\n            return i;\n        } else if (c < 0) {\n            x1 = i + 1;\n        } else {\n            x2 = i;\n        }\n\n        i = x1 + (x2 - x1) / 2;\n    }\n    return - 1 * (i + 1);\n}\n", "code2": "public static final int binarySearch (int [] a, int key) {\n    int x1 = 0;\n    int x2 = a.length;\n    int i = x2 / 2;\n    while (x1 < x2) {\n        if (a [i] == key) {\n            return i;\n        } else if (a [i] < key) {\n            x1 = i + 1;\n        } else {\n            x2 = i;\n        }\n\n        i = x1 + (x2 - x1) / 2;\n    }\n    return - 1 * (i + 1);\n}\n"}
{"clone_type": "ST3", "method1_id": 273486, "method2_id": 307952, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (InetAddress.getByName (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (null);\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                String addrString;\n                addUDP (addr, port);\n                addTCP (addr, port);\n                if (addr == null) addrString = \"0.0.0.0\";\n                else addrString = addr.getHostAddress ();\n\n                System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Short (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Short.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Short ((short) 53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            short port = ((Short) iport.next ()).shortValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n"}
{"clone_type": "ST3", "method1_id": 10977091, "method2_id": 16167361, "code1": "public String md5 (String password) {\n    MessageDigest m = null;\n    try {\n        m = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException ex) {\n    }\n    m.update (password.getBytes (), 0, password.length ());\n    return new BigInteger (1, m.digest ()).toString (16);\n}\n", "code2": "public long getMD5Hash (String str) {\n    MessageDigest m = null;\n    try {\n        m = MessageDigest.getInstance (\"SHA-256\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace ();\n    }\n    m.update (str.getBytes (), 0, str.length ());\n    return new BigInteger (1, m.digest ()).longValue ();\n}\n"}
{"clone_type": "ST3", "method1_id": 10391639, "method2_id": 16540473, "code1": "private static void copyFile (final File sourceFile, final File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        if (! destFile.createNewFile ()) {\n            throw new IOException (\"Destination file cannot be created: \" + destFile.getPath ());\n        }\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 6409830, "method2_id": 6689657, "code1": "public static int [] [] reversalXandY (final int [] [] array) {\n    int col = array [0].length;\n    int row = array.length;\n    int [] [] result = new int [col] [row];\n    for (int y = 0;\n    y < col; y ++) {\n        for (int x = 0;\n        x < row; x ++) {\n            result [x] [y] = array [y] [x];\n        }\n    }\n    return result;\n}\n", "code2": "public static LImage [] [] getFlipHorizintalImage2D (LImage [] [] pixels) {\n    int w = pixels.length;\n    int h = pixels [0].length;\n    LImage pixel [] [] = new LImage [h] [w];\n    for (int i = 0;\n    i < h; i ++) {\n        for (int j = 0;\n        j < w; j ++) {\n            pixel [i] [j] = pixels [j] [i];\n        }\n    }\n    return pixel;\n}\n"}
{"clone_type": "ST3", "method1_id": 8047989, "method2_id": 14923488, "code1": "protected byte [] getHashedID (String ID) {\n    try {\n        MessageDigest md5 = MessageDigest.getInstance (\"MD5\");\n        md5.reset ();\n        md5.update (ID.getBytes ());\n        byte [] digest = md5.digest ();\n        byte [] bytes = new byte [WLDB_ID_SIZE];\n        for (int i = 0;\n        i < bytes.length; i ++) {\n            bytes [i] = digest [i];\n        }\n        return bytes;\n    } catch (NoSuchAlgorithmException exception) {\n        System.err.println (\"Java VM is not compatible\");\n        exit ();\n        return null;\n    }\n}\n", "code2": "public static byte [] getHashedID (String ID) {\n    try {\n        MessageDigest md5 = MessageDigest.getInstance (\"MD5\");\n        md5.reset ();\n        md5.update (ID.getBytes ());\n        byte [] digest = md5.digest ();\n        byte [] bytes = new byte [WLDB_ID_SIZE];\n        for (int i = 0;\n        i < bytes.length; i ++) {\n            bytes [i] = digest [i];\n        }\n        return bytes;\n    } catch (NoSuchAlgorithmException exception) {\n        System.err.println (\"Java VM is not compatible\");\n        return null;\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 341663, "method2_id": 402589, "code1": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    boolean started = false;\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new Hashtable ();\n    znames = new Hashtable ();\n    TSIGs = new Hashtable ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Short (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) {\n            short port = Short.parseShort (st.nextToken ());\n            addUDP (port);\n            addTCP (port);\n            started = true;\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (! started) {\n        addUDP ((short) 53);\n        addTCP ((short) 53);\n    }\n    System.out.println (\"running\");\n}\n", "code2": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    boolean started = false;\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    cache = null;\n    znames = new Hashtable ();\n    TSIGs = new Hashtable ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken ());\n\n        if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) cache = new Cache (st.nextToken ());\n        else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) {\n            short port = Short.parseShort (st.nextToken ());\n            addUDP (port);\n            addTCP (port);\n            started = true;\n        }\n\n    }\n    if (cache == null) {\n        System.out.println (\"no cache specified\");\n        System.exit (- 1);\n    }\n    if (! started) {\n        addUDP ((short) 53);\n        addTCP ((short) 53);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 2297047, "method2_id": 3148842, "code1": "private static void createPdf (String filename) {\n    Document document = new Document ();\n    try {\n        PdfWriter.getInstance (document, new FileOutputStream (filename));\n        document.open ();\n        Paragraph hello = new Paragraph (\"(English:) hello, \" + \"(Esperanto:) he, alo, saluton, (Latin:) heu, ave, \" + \"(French:) all\u00f4, (Italian:) ciao, (German:) hallo, he, heda, holla, \" + \"(Portuguese:) al\u00f4, ol\u00e1, hei, psiu, bom d\u00eda, (Dutch:) hallo, dag, \" + \"(Spanish:) ola, eh, (Catalan:) au, bah, eh, ep, \" + \"(Swedish:) hej, hejsan(Danish:) hallo, dav, davs, goddag, hej, \" + \"(Norwegian:) hei; morn, (Papiamento:) halo; hallo; k\u00ed tal, \" + \"(Faeroese:) hall\u00f3, hoyr, (Turkish:) alo, merhaba, (Albanian:) tungjatjeta\");\n        document.add (new Paragraph (\"1. To the Universe:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"2. to the World:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"3. to the Sun:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"4. to the Moon:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"5. to the Stars:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"6. To the People:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"7. to mothers and fathers:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"8. to brothers and sisters:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"9. to wives and husbands:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"10. to sons and daughters:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"11. to complete strangers:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"12. To the Animals:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"13. o cats and dogs:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"14. to birds and bees:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"15. to farm animals and wild animals:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"16. to bugs and beatles:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"17. to fish and shellfish:\"));\n        document.add (hello);\n    } catch (DocumentException de) {\n        System.err.println (de.getMessage ());\n    } catch (IOException ioe) {\n        System.err.println (ioe.getMessage ());\n    }\n    document.close ();\n}\n", "code2": "public static void main (String [] args) {\n    System.out.println (\"Chapter 13: example ThumbImage\");\n    System.out.println (\"-> Creates a PDF file with multiple pages\");\n    System.out.println (\"   and with the thumbs replaced by images.\");\n    System.out.println (\"-> jars needed: iText.jar\");\n    System.out.println (\"-> resources needed: foxdog.jpg\");\n    System.out.println (\"-> file generated in /results subdirectory:\");\n    System.out.println (\"   thumb_image.pdf\");\n    Document document = new Document ();\n    try {\n        PdfWriter writer = PdfWriter.getInstance (document, new FileOutputStream (\"results/in_action/chapter13/thumb_image.pdf\"));\n        writer.setViewerPreferences (PdfWriter.PageModeUseThumbs);\n        document.open ();\n        Paragraph hello = new Paragraph (\"(English:) hello, \" + \"(Esperanto:) he, alo, saluton, (Latin:) heu, ave, \" + \"(French:) all\u00f4, (Italian:) ciao, (German:) hallo, he, heda, holla, \" + \"(Portuguese:) al\u00f4, ol\u00e1, hei, psiu, bom d\u00eda, (Dutch:) hallo, dag, \" + \"(Spanish:) ola, eh, (Catalan:) au, bah, eh, ep, \" + \"(Swedish:) hej, hejsan(Danish:) hallo, dav, davs, goddag, hej, \" + \"(Norwegian:) hei; morn, (Papiamento:) halo; hallo; k\u00ed tal, \" + \"(Faeroese:) hall\u00f3, hoyr, (Turkish:) alo, merhaba, (Albanian:) tungjatjeta\");\n        document.add (new Paragraph (\"1. To the Universe:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"2. to the World:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"3. to the Sun:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"4. to the Moon:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"5. to the Stars:\"));\n        document.add (hello);\n        document.newPage ();\n        writer.setThumbnail (Image.getInstance (\"resources/in_action/chapter05/foxdog.jpg\"));\n        document.add (new Paragraph (\"6. To the People:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"7. to mothers and fathers:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"8. to brothers and sisters:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"9. to wives and husbands:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"10. to sons and daughters:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"11. to complete strangers:\"));\n        document.add (hello);\n        document.newPage ();\n        document.add (new Paragraph (\"12. To the Animals:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"13. o cats and dogs:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"14. to birds and bees:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"15. to farm animals and wild animals:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"16. to bugs and beatles:\"));\n        document.add (hello);\n        document.add (new Paragraph (\"17. to fish and shellfish:\"));\n        document.add (hello);\n    } catch (DocumentException de) {\n        System.err.println (de.getMessage ());\n    } catch (IOException ioe) {\n        System.err.println (ioe.getMessage ());\n    }\n    document.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 3672328, "method2_id": 23058336, "code1": "public static void copy (String sourceFile, String targetFile) throws IOException {\n    FileChannel sourceChannel = new FileInputStream (sourceFile).getChannel ();\n    FileChannel targetChannel = new FileOutputStream (targetFile).getChannel ();\n    targetChannel.transferFrom (sourceChannel, 0, sourceChannel.size ());\n    sourceChannel.close ();\n    targetChannel.close ();\n}\n", "code2": "public static void copyFile (File in, File out) throws Exception {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 7034031, "method2_id": 22271237, "code1": "private void copyFile (File sourceFile, File destFile) throws IOException {\n    if (log.isDebugEnabled ()) {\n        log.debug (\"CopyFile : Source[\" + sourceFile.getAbsolutePath () + \"] Dest[\" + destFile.getAbsolutePath () + \"]\");\n    }\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public static void copy (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 443341, "method2_id": 447509, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 3577507, "method2_id": 23390255, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 10425169, "method2_id": 12120684, "code1": "private void getRandomGUID (boolean secure, Object o) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (o.getClass ().getName ());\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5;\n    StringBuilder sbValueBeforeHash = new StringBuilder ();\n    try {\n        md5 = MessageDigest.getInstance (\"SHA-1\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new ApplicationIllegalArgumentException (e);\n    }\n    long time = System.nanoTime ();\n    long rand = 0;\n    if (secure) {\n        rand = MySecureRand.nextLong ();\n    } else {\n        rand = MyRand.nextLong ();\n    }\n    sbValueBeforeHash.append (SId);\n    sbValueBeforeHash.append (\":\");\n    sbValueBeforeHash.append (Long.toString (time));\n    sbValueBeforeHash.append (\":\");\n    sbValueBeforeHash.append (Long.toString (rand));\n    valueBeforeHash = sbValueBeforeHash.toString ();\n    md5.update (valueBeforeHash.getBytes ());\n    byte [] array = md5.digest ();\n    StringBuffer sb = new StringBuffer ();\n    for (int j = 0;\n    j < array.length; ++ j) {\n        int b = array [j] & 0xFF;\n        if (b < 0x10) {\n            sb.append ('0');\n        }\n        sb.append (Integer.toHexString (b));\n    }\n    valueAfterHash = sb.toString ();\n}\n"}
{"clone_type": "ST3", "method1_id": 2474379, "method2_id": 10750829, "code1": "public static Object [] append (Object [] source, Object obj) {\n    Object [] copy = (Object []) Array.newInstance (source.getClass ().getComponentType (), source.length + 1);\n    System.arraycopy (source, 0, copy, 0, source.length);\n    copy [source.length] = obj;\n    return copy;\n}\n", "code2": "public static Object [] addElement (Object [] a, Object o) {\n    Class clazz = a.getClass ().getComponentType ();\n    Object [] a2 = (Object []) Array.newInstance (clazz, a.length + 1);\n    System.arraycopy (a, 0, a2, 0, a.length);\n    a2 [a.length] = o;\n    return a2;\n}\n"}
{"clone_type": "ST3", "method1_id": 1162904, "method2_id": 23118425, "code1": "public byte [] computeMD5 (String plainText) throws VHException {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException ex) {\n        throw new VHException (\"The MD5 hash algorithm is not available.\", ex);\n    }\n    try {\n        md.update (plainText.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException ex) {\n        throw new VHException (\"The UTF-8 encoding is not supported.\", ex);\n    }\n    return md.digest ();\n}\n", "code2": "public synchronized String encrypt (String plaintext) throws Exception {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"MD5\");\n    } catch (Exception e) {\n    }\n    try {\n        md.update (plaintext.getBytes (\"UTF-8\"));\n    } catch (Exception e) {\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n"}
{"clone_type": "ST3", "method1_id": 438086, "method2_id": 738946, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 338138, "method2_id": 620855, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 7019245, "method2_id": 19141604, "code1": "public String streamToString (InputStream stream) throws IOException {\n    ByteArrayOutputStream output = new ByteArrayOutputStream ();\n    IOUtils.copy (stream, output);\n    return output.toString ();\n}\n", "code2": "public static String streamToString (InputStream stream) throws IOException {\n    ByteArrayOutputStream output = new ByteArrayOutputStream ();\n    IOUtils.copy (stream, output);\n    return output.toString ();\n}\n"}
{"clone_type": "ST3", "method1_id": 2530584, "method2_id": 6387775, "code1": "public static String md5 (String text) {\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (text.getBytes ());\n        return convertToHex (md.digest ());\n    } catch (Exception e) {\n        throw new RuntimeException (e.getMessage (), e);\n    }\n}\n", "code2": "public static String hashSHA1 (String value) {\n    try {\n        MessageDigest digest = MessageDigest.getInstance (\"SHA-1\");\n        digest.update (value.getBytes ());\n        BigInteger hash = new BigInteger (1, digest.digest ());\n        return hash.toString (16);\n    } catch (NoSuchAlgorithmException e) {\n    }\n    return null;\n}\n"}
{"clone_type": "ST3", "method1_id": 20091126, "method2_id": 20310134, "code1": "static File copy (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n        return out;\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 7436917, "method2_id": 16380022, "code1": "public IntChoiceFromSet randomize () {\n    for (int i = values.length - 1;\n    i > 0; i --) {\n        int j = random.nextInt (i + 1);\n        String tmp = values [i];\n        values [i] = values [j];\n        values [j] = tmp;\n    }\n    return this;\n}\n", "code2": "public void shuffle (Random rand) {\n    for (int i = cards.length - 1;\n    i >= 0; i --) {\n        int r = rand.nextInt (i + 1);\n        Card t = cards [i];\n        cards [i] = cards [r];\n        cards [r] = t;\n    }\n    nextCard = 0;\n}\n"}
{"clone_type": "ST3", "method1_id": 3535630, "method2_id": 23677185, "code1": "public static int gcd (int m, int n) {\n    if (0 == n) {\n        return m;\n    } else {\n        return gcd (n, m % n);\n    }\n}\n", "code2": "public static int gcd3 (int a, int b) {\n    if (b == 0) {\n        return 1;\n    } else {\n        return gcd3 (b, a % b);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 7317602, "method2_id": 15328073, "code1": "public static String SHA1 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n", "code2": "public static byte [] SHA1 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return sha1hash;\n}\n"}
{"clone_type": "ST3", "method1_id": 159804, "method2_id": 848240, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 525934, "method2_id": 2726811, "code1": "private static byte [] readBytes (File file) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream ();\n    try {\n        InputStream fis = new FileInputStream (file);\n        InputStream is = new BufferedInputStream (fis);\n        int count = 0;\n        byte [] buf = new byte [16384];\n        while ((count = is.read (buf)) != - 1) {\n            if (count > 0) baos.write (buf, 0, count);\n\n        }\n        is.close ();\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n    return baos.toByteArray ();\n}\n", "code2": "public static byte [] readBytes (File file) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream ();\n    try {\n        InputStream is = new BufferedInputStream (new FileInputStream (file));\n        int count = 0;\n        byte [] buf = new byte [16384];\n        while ((count = is.read (buf)) != - 1) {\n            if (count > 0) {\n                baos.write (buf, 0, count);\n            }\n        }\n        is.close ();\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n    return baos.toByteArray ();\n}\n"}
{"clone_type": "ST3", "method1_id": 569812, "method2_id": 943503, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 12046298, "method2_id": 20152107, "code1": "public int binarySearchFromTo (short key, int from, int to) {\n    int low = from;\n    int high = to;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        short midVal = get (mid);\n        if (midVal < key) low = mid + 1;\n        else if (midVal > key) high = mid - 1;\n        else return mid;\n\n    }\n    return - (low + 1);\n}\n", "code2": "public int binarySearchFromTo (long key, int from, int to) {\n    int low = from;\n    int high = to;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        long midVal = get (mid);\n        if (midVal < key) low = mid + 1;\n        else if (midVal > key) high = mid - 1;\n        else return mid;\n\n    }\n    return - (low + 1);\n}\n"}
{"clone_type": "ST3", "method1_id": 104601, "method2_id": 480187, "code1": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n", "code2": "public static void main (String [] argv) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 11370967, "method2_id": 15034107, "code1": "public void copyFile (File in, File out) throws Exception {\n    FileChannel ic = new FileInputStream (in).getChannel ();\n    FileChannel oc = new FileOutputStream (out).getChannel ();\n    ic.transferTo (0, ic.size (), oc);\n    ic.close ();\n    oc.close ();\n}\n", "code2": "private static void copyFile (File in, File out) throws Exception {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 19869683, "method2_id": 21636561, "code1": "public static String MD5 (byte [] data) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    String text = convertToHex (data);\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"MD5\");\n    byte [] md5hash = new byte [32];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    md5hash = md.digest ();\n    return convertToHex (md5hash);\n}\n", "code2": "public static String SHA1 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 13879984, "method2_id": 18616606, "code1": "public static String readFromURL (String urlStr) throws IOException {\n    URL url = new URL (urlStr);\n    StringBuilder sb = new StringBuilder ();\n    BufferedReader in = new BufferedReader (new InputStreamReader (url.openStream ()));\n    String inputLine;\n    while ((inputLine = in.readLine ()) != null) {\n        sb.append (inputLine);\n    }\n    in.close ();\n    return sb.toString ();\n}\n", "code2": "public static String read (URL url) throws IOException {\n    BufferedReader reader = new BufferedReader (new InputStreamReader (url.openStream ()));\n    StringWriter res = new StringWriter ();\n    PrintWriter writer = new PrintWriter (new BufferedWriter (res));\n    String line;\n    while ((line = reader.readLine ()) != null) {\n        writer.println (line);\n    }\n    reader.close ();\n    writer.close ();\n    return res.toString ();\n}\n"}
{"clone_type": "ST3", "method1_id": 11370967, "method2_id": 23066956, "code1": "public void copyFile (File in, File out) throws Exception {\n    FileChannel ic = new FileInputStream (in).getChannel ();\n    FileChannel oc = new FileOutputStream (out).getChannel ();\n    ic.transferTo (0, ic.size (), oc);\n    ic.close ();\n    oc.close ();\n}\n", "code2": "public static final void copyFile (File source, File destination) throws IOException {\n    FileChannel sourceChannel = new FileInputStream (source).getChannel ();\n    FileChannel targetChannel = new FileOutputStream (destination).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), targetChannel);\n    sourceChannel.close ();\n    targetChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 15328073, "method2_id": 22262998, "code1": "public static byte [] SHA1 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return sha1hash;\n}\n", "code2": "public static String SHA512 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-512\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"UTF-8\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 789019, "method2_id": 4328783, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "public int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 753882, "method2_id": 792265, "code1": "public double probeProcessEnergy (int processId) throws RemoteException {\n    float idle_energy1 = Float.parseFloat (idle_energy);\n    double utiltopower_factor1 = Double.parseDouble (utiltopower_factor);\n    double cpu_util = 10;\n    String energy = \"\";\n    double total_energy = 0;\n    try {\n        Process P = Runtime.getRuntime ().exec (linuxPath + \"/PidCPU.sh \" + processId);\n        StringBuffer strBuf = new StringBuffer ();\n        String strLine = \"\";\n        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));\n        while ((strLine = outCommand.readLine ()) != null) {\n            energy = strLine;\n        }\n        P.waitFor ();\n        cpu_util = Double.parseDouble (energy);\n        total_energy = utiltopower_factor1 * cpu_util;\n    } catch (Exception e) {\n        total_energy = - 1;\n        System.out.println (e.getMessage ());\n        e.printStackTrace ();\n    }\n    return total_energy;\n}\n", "code2": "public double probeEnergy () throws RemoteException {\n    float idle_energy1 = Float.parseFloat (idle_energy);\n    double utiltopower_factor1 = Double.parseDouble (utiltopower_factor);\n    double cpu_util = 10;\n    String energy = \"\";\n    double total_energy = 0;\n    try {\n        Process P = Runtime.getRuntime ().exec (linuxPath + \"/you.sh\");\n        StringBuffer strBuf = new StringBuffer ();\n        String strLine = \"\";\n        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));\n        while ((strLine = outCommand.readLine ()) != null) {\n            energy = strLine;\n        }\n        P.waitFor ();\n        cpu_util = Double.parseDouble (energy);\n        total_energy = idle_energy1 + utiltopower_factor1 * cpu_util;\n    } catch (Exception e) {\n        total_energy = - 1;\n        System.out.println (e.getMessage ());\n        e.printStackTrace ();\n    }\n    return total_energy;\n}\n"}
{"clone_type": "ST3", "method1_id": 10715601, "method2_id": 12408144, "code1": "public static synchronized String toSHA1 (String str) {\n    Nulls.failIfNull (str, \"Cannot create an SHA1 encryption form a NULL string\");\n    try {\n        MessageDigest md;\n        md = MessageDigest.getInstance (SHA1);\n        byte [] sha1hash = new byte [40];\n        md.update (str.getBytes (ISO_CHARSET), 0, str.length ());\n        sha1hash = md.digest ();\n        return convertToHex (sha1hash);\n    } catch (NoSuchAlgorithmException ex) {\n        ex.printStackTrace ();\n    } catch (UnsupportedEncodingException ex) {\n        ex.printStackTrace ();\n    }\n    return null;\n}\n", "code2": "public static String generateSHA1Digest (String text) {\n    try {\n        MessageDigest md;\n        md = MessageDigest.getInstance (\"SHA-1\");\n        byte [] sha1hash = new byte [40];\n        md.update (text.getBytes (\"UTF-8\"), 0, text.length ());\n        sha1hash = md.digest ();\n        return convertToHex (sha1hash);\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace ();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace ();\n    }\n    return null;\n}\n"}
{"clone_type": "ST3", "method1_id": 1612068, "method2_id": 18257889, "code1": "public Matrix transpose () {\n    Matrix X = new Matrix (n, m);\n    double [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n", "code2": "public double [] [] getMatrixFromTree (double p) {\n    double [] [] Mat = new double [numdata] [numdata];\n    for (int i = 0;\n    i < numdata; i ++) {\n        for (int j = 0;\n        j < i; j ++) {\n            Mat [i] [j] = - p * Math.log (getTreeDist (i, j));\n            Mat [j] [i] = Mat [i] [j];\n        }\n    }\n    return Mat;\n}\n"}
{"clone_type": "ST3", "method1_id": 2575374, "method2_id": 3673887, "code1": "public static void copy (File in, File out) throws Exception {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n", "code2": "public static final void copyFile (File source, File destination) throws IOException {\n    FileChannel sourceChannel = new FileInputStream (source).getChannel ();\n    FileChannel targetChannel = new FileOutputStream (destination).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), targetChannel);\n    sourceChannel.close ();\n    targetChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 128736, "method2_id": 3989355, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "public static long F (int n) {\n    if (n == 0) return 0;\n\n    if (n == 1) return 1;\n\n    return F (n - 1) + F (n - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 46272, "method2_id": 498365, "code1": "public static void main (String [] argv) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n", "code2": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 11953289, "method2_id": 19869683, "code1": "private static String hashPass (String p) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (p.getBytes (\"iso-8859-1\"), 0, p.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n", "code2": "public static String MD5 (byte [] data) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    String text = convertToHex (data);\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"MD5\");\n    byte [] md5hash = new byte [32];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    md5hash = md.digest ();\n    return convertToHex (md5hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 10369570, "method2_id": 20514481, "code1": "public static void copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n        System.out.print (\"Overwrite existing file \" + toFile.getName () + \"? (Y/N): \");\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) throw new IOException (\"FileCopy: \" + \"existing file was not overwritten.\");\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n", "code2": "public static File copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    System.out.println (\"AbsolutePath fromFile: \" + fromFile.getAbsolutePath ());\n    System.out.println (\"AbsolutePath toFile: \" + toFile.getAbsolutePath ());\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n    return toFile;\n}\n"}
{"clone_type": "ST3", "method1_id": 16142024, "method2_id": 17477951, "code1": "private static final void copyFile (File srcFile, File destDir, byte [] buffer) {\n    try {\n        File destFile = new File (destDir, srcFile.getName ());\n        InputStream in = new FileInputStream (srcFile);\n        OutputStream out = new FileOutputStream (destFile);\n        int bytesRead;\n        while ((bytesRead = in.read (buffer)) != - 1) out.write (buffer, 0, bytesRead);\n\n        in.close ();\n        out.close ();\n    } catch (IOException ioe) {\n        System.err.println (\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n    }\n}\n", "code2": "public static void copy (String inputFile, String outputFile) throws Exception {\n    try {\n        FileReader in = new FileReader (inputFile);\n        FileWriter out = new FileWriter (outputFile);\n        int c;\n        while ((c = in.read ()) != - 1) out.write (c);\n\n        in.close ();\n        out.close ();\n    } catch (Exception e) {\n        throw new Exception (\"Could not copy \" + inputFile + \" into \" + outputFile + \" because:\\n\" + e.getMessage ());\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 19044530, "method2_id": 19044531, "code1": "public void get (File fileToGet) throws IOException {\n    FTPClient ftp = new FTPClient ();\n    try {\n        int reply = 0;\n        ftp.connect (this.endpointURL, Config.getFtpPort ());\n        reply = ftp.getReplyCode ();\n        if (! FTPReply.isPositiveCompletion (reply)) {\n            ftp.disconnect ();\n            throw new IOException (\"Ftp get server refused connection.\");\n        }\n        if (! ftp.login (\"anonymous\", \"\")) {\n            ftp.logout ();\n            throw new IOException (\"FTP: server wrong passwd\");\n        }\n        ftp.setFileType (FTP.BINARY_FILE_TYPE);\n        ftp.enterLocalPassiveMode ();\n        OutputStream output = new FileOutputStream (fileToGet.getName ());\n        if (ftp.retrieveFile (fileToGet.getName (), output) != true) {\n            ftp.logout ();\n            output.close ();\n            throw new IOException (\"FTP get exception, maybe file not found\");\n        }\n        ftp.logout ();\n    } catch (Exception e) {\n        throw new IOException (e.getMessage ());\n    }\n}\n", "code2": "public void delete (String fileToDelete) throws IOException {\n    FTPClient ftp = new FTPClient ();\n    try {\n        int reply = 0;\n        ftp.connect (this.endpointURL, Config.getFtpPort ());\n        reply = ftp.getReplyCode ();\n        if (! FTPReply.isPositiveCompletion (reply)) {\n            ftp.disconnect ();\n            throw new IOException (\"Ftp delete server refused connection.\");\n        }\n        if (! ftp.login (\"anonymous\", \"\")) {\n            ftp.logout ();\n            throw new IOException (\"FTP: server wrong passwd\");\n        }\n        ftp.enterLocalPassiveMode ();\n        log.debug (\"Deleted: \" + ftp.deleteFile (fileToDelete));\n        ftp.logout ();\n    } catch (Exception e) {\n        throw new IOException (e.getMessage ());\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 255647, "method2_id": 7849131, "code1": "public long fib (int n) {\n    if (n <= 1) return n;\n    else return fib (n - 1) + fib (n - 2);\n\n}\n", "code2": "public static long fib (int n) {\n    if (n <= 1) return n;\n    else return fib (n - 1) + fib (n - 2);\n\n}\n"}
{"clone_type": "ST3", "method1_id": 18712047, "method2_id": 19462844, "code1": "public Matrix transpose () {\n    Matrix output = new Matrix (cols, rows);\n    for (int i = 0;\n    i < rows; i ++) {\n        for (int j = 0;\n        j < cols; j ++) {\n            output.contents [j] [i] = contents [i] [j];\n        }\n    }\n    return output;\n}\n", "code2": "public Matrix transpose () {\n    Matrix X = new Matrix (n, m);\n    double [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n"}
{"clone_type": "ST3", "method1_id": 65493, "method2_id": 11298700, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "public static long F (int n) {\n    if (n == 0) return 0;\n\n    if (n == 1) return 1;\n\n    return F (n - 1) + F (n - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 16579663, "method2_id": 21837100, "code1": "public void updateComponent (int id, int quantity) throws SQLException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    try {\n        Class.forName (\"com.mysql.jdbc.Driver\");\n        connection = (Connection) DriverManager.getConnection (this.jdbcURL);\n        connection.setAutoCommit (false);\n        String query = \"UPDATE components SET quantity=quantity+? WHERE comp_id=?\";\n        ps = connection.prepareStatement (query);\n        ps.setInt (1, quantity);\n        ps.setInt (2, id);\n        ps.executeUpdate ();\n        connection.commit ();\n    } catch (Exception ex) {\n        connection.rollback ();\n    } finally {\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            ps.close ();\n        } catch (Exception ex) {\n        }\n    }\n}\n", "code2": "public void saveMapping () throws SQLException {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    try {\n        Class.forName (\"com.mysql.jdbc.Driver\");\n        connection = (Connection) DriverManager.getConnection (this.jdbcURL);\n        connection.setAutoCommit (false);\n        String query = \"INSERT INTO mapping(product_id, comp_id, count) VALUES(?,?,?)\";\n        ps = (PreparedStatement) connection.prepareStatement (query);\n        ps.setInt (1, this.productId);\n        ps.setInt (2, this.componentId);\n        ps.setInt (3, 1);\n        ps.executeUpdate ();\n    } catch (Exception ex) {\n        connection.rollback ();\n    } finally {\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            ps.close ();\n        } catch (Exception ex) {\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 83588, "method2_id": 441330, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (InetAddress.getByName (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (null);\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                String addrString;\n                addUDP (addr, port);\n                addTCP (addr, port);\n                if (addr == null) addrString = \"0.0.0.0\";\n                else addrString = addr.getHostAddress ();\n\n                System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    Vector ports = new Vector ();\n    Vector addresses = new Vector ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new Hashtable ();\n    znames = new Hashtable ();\n    TSIGs = new Hashtable ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Short (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.addElement (Short.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.addElement (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.addElement (new Short ((short) 53));\n\n    if (addresses.size () == 0) addresses.addElement (null);\n\n    Enumeration eaddr = addresses.elements ();\n    while (eaddr.hasMoreElements ()) {\n        InetAddress addr = (InetAddress) eaddr.nextElement ();\n        Enumeration eport = ports.elements ();\n        while (eport.hasMoreElements ()) {\n            short port = ((Short) eport.nextElement ()).shortValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n"}
{"clone_type": "ST3", "method1_id": 254725, "method2_id": 665420, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 541801, "method2_id": 6234218, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private long fib (long n) {\n    if (n == 0) return 0L;\n\n    if (n == 1) return 1L;\n\n    return fib (n - 1) + fib (n - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 14356579, "method2_id": 23243320, "code1": "public String getRandomGUID () {\n    MessageDigest md5 = null;\n    String valueBeforeMD5 = \"\";\n    String retValue = \"\";\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        InetAddress id = InetAddress.getLocalHost ();\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        rand = random.nextLong ();\n        sbValueBeforeMD5.append (id.toString ());\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) {\n                sb.append ('0');\n            }\n            sb.append (Integer.toHexString (b));\n        }\n        retValue = sb.toString ();\n    } catch (UnknownHostException e) {\n        System.out.println (\"Error:\" + e);\n    }\n    return retValue;\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 282874, "method2_id": 543575, "code1": "public void elimina (Cliente cli) throws errorSQL, errorConexionBD {\n    System.out.println (\"GestorCliente.elimina()\");\n    int id = cli.getId ();\n    String sql;\n    Statement stmt = null;\n    try {\n        gd.begin ();\n        sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n        System.out.println (\"Ejecutando: \" + sql);\n        stmt = gd.getConexion ().createStatement ();\n        stmt.executeUpdate (sql);\n        System.out.println (\"executeUpdate\");\n        sql = \"DELETE FROM persona WHERE id =\" + id;\n        System.out.println (\"Ejecutando: \" + sql);\n        stmt.executeUpdate (sql);\n        gd.commit ();\n        System.out.println (\"commit\");\n        stmt.close ();\n    } catch (SQLException e) {\n        gd.rollback ();\n        throw new errorSQL (e.toString ());\n    } catch (errorConexionBD e) {\n        System.err.println (\"Error en GestorCliente.elimina(): \" + e);\n    } catch (errorSQL e) {\n        System.err.println (\"Error en GestorCliente.elimina(): \" + e);\n    }\n}\n", "code2": "public void elimina (Cliente cli) throws errorSQL, errorConexionBD {\n    System.out.println (\"GestorCliente.elimina()\");\n    int id = cli.getId ();\n    String sql;\n    Statement stmt = null;\n    try {\n        gd.begin ();\n        sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n        System.out.println (\"Ejecutando: \" + sql);\n        stmt = gd.getConexion ().createStatement ();\n        stmt.executeUpdate (sql);\n        sql = \"DELETE FROM usuario WHERE cod_usuario =\" + id;\n        System.out.println (\"Ejecutando: \" + sql);\n        stmt = gd.getConexion ().createStatement ();\n        stmt.executeUpdate (sql);\n        System.out.println (\"executeUpdate\");\n        sql = \"DELETE FROM persona WHERE id =\" + id;\n        System.out.println (\"Ejecutando: \" + sql);\n        stmt = gd.getConexion ().createStatement ();\n        stmt.executeUpdate (sql);\n        gd.commit ();\n        System.out.println (\"commit\");\n        stmt.close ();\n    } catch (SQLException e) {\n        gd.rollback ();\n        throw new errorSQL (e.toString ());\n    } catch (errorConexionBD e) {\n        System.err.println (\"Error en GestorCliente.elimina(): \" + e);\n    } catch (errorSQL e) {\n        System.err.println (\"Error en GestorCliente.elimina(): \" + e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 665420, "method2_id": 854534, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 59363, "method2_id": 86878, "code1": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://localhost:5432/wdb\";\n    final String dbuser = \"wcitest\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT * \" + \" FROM wci.read( array['test wci 5'], NULL, \" + \"                '2009-11-13 00:00:00+00', \" + \"                NULL, \" + \"                array['air temperature', \" + \"                      'air pressure'], \" + \"                NULL, \" + \"                array[-1], \" + \"                NULL::wci.returngid )\";\n    final String colNames [] = {\"valueParameterName\", \"validTimeFrom\"};\n    ResultSet rs = null;\n    try {\n        statement.execute (wdbInit);\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            Statement getGridStatement = con.createStatement ();\n            first = true;\n            long gridId = rs.getLong (\"value\");\n            ResultSet blobResult = getGridStatement.executeQuery (\"SELECT * FROM wci.fetch(\" + gridId + \", NULL::wci.grid)\");\n            while (blobResult.next ()) {\n                int size = blobResult.getInt (\"numberX\") + blobResult.getInt (\"numberX\");\n                InputStream blob = blobResult.getBinaryStream (\"grid\");\n                DataInputStream blobReader = new DataInputStream (blob);\n                int floatToRead = 42;\n                blobReader.skip (floatToRead * 4);\n                float value = blobReader.readFloat ();\n                System.out.print (value + \"\\t\");\n                for (String name : colNames) {\n                    data = rs.getString (name);\n                    if (first) {\n                        first = false;\n                    } else {\n                        System.out.print (\", \");\n                    }\n                    if (data != null) System.out.print (data);\n                    else System.out.print (\"\\\\N\");\n\n                }\n                System.out.print (\"  (BLOB size: \" + size + \")\");\n                System.out.println ();\n            }\n            blobResult.close ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        try {\n            if (rs != null) rs.close ();\n\n        } catch (SQLException ex) {\n            System.out.println (\"EXCEPTION: rs.close: \" + ex);\n        }\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://localhost:5432/wdb\";\n    final String dbuser = \"wcitest\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT * \" + \" FROM wci.read( array['test wci 5'], 'POINT( 10.0 59.0 )', \" + \"                '2009-11-13 00:00:00+00', \" + \"                NULL, \" + \"                array['air temperature', \" + \"                      'air pressure'], \" + \"                NULL, \" + \"                array[-1], \" + \"                NULL::wci.returnFloat )\";\n    final String colNames [] = {\"value\", \"valueParameterName\", \"validTimeFrom\"};\n    ResultSet rs = null;\n    try {\n        statement.execute (wdbInit);\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        if (rs != null) {\n            try {\n                rs.close ();\n            } catch (SQLException ex) {\n                System.out.println (\"EXCEPTION: rs.close: \" + ex);\n            }\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 10350952, "method2_id": 22487030, "code1": "public synchronized String encrypt (String plaintext) throws Exception {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"SHA\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new Exception (e.getMessage ());\n    }\n    try {\n        md.update (plaintext.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        throw new Exception (e.getMessage ());\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n", "code2": "public static synchronized String encrypt (String plaintextPassword) throws Exception {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"SHA\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new Exception (e);\n    }\n    try {\n        md.update (plaintextPassword.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        throw new Exception (e);\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n"}
{"clone_type": "ST3", "method1_id": 8561731, "method2_id": 19947818, "code1": "public boolean actualizarEstadoDivision (division div) {\n    int intResult = 0;\n    String sql = \"UPDATE divisionxTorneo \" + \" SET terminado = '1' \" + \" WHERE idDivisionxTorneo = \" + div.getidDivision ();\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        intResult = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (intResult > 0);\n}\n", "code2": "public boolean update (int idPartida, partida partidaModificada) {\n    int intResult = 0;\n    String sql = \"UPDATE partida \" + \"SET torneo_idTorneo = ?, \" + \" jugador_idJugadorNegras = ?, jugador_idJugadorBlancas = ?, \" + \" fecha = ?, \" + \" resultado = ?, \" + \" nombreBlancas = ?, nombreNegras = ?, eloBlancas = ?, eloNegras = ?, idApertura = ? \" + \" WHERE idPartida = \" + idPartida;\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        populatePreparedStatement2 (partidaModificada);\n        intResult = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (intResult > 0);\n}\n"}
{"clone_type": "ST3", "method1_id": 4106020, "method2_id": 8239780, "code1": "@Constraint(\"post: s.get().size>0\")\nprotected static void removeNewlinesForAssertStyleSystemErr (@Constraint(\"post: s.get().size<=s@pre.get().size\")\nfinal IDocument s) {\n    Pattern pattern = Pattern.compile (\"if\\\\s*\\\\(\\\\s*!\\\\s*assert(Pre|Post)Condition_(\\\\w*)_for_method_(\\\\w*)\\\\s*\\\\(([^\\\\)]*)\\\\)\\\\s*\\\\)\\\\s*\\\\{\" + \"\\\\s*System.err.println\\\\(\\\\s*\\\"(.*)\\\"\\\\s*\\\\)\\\\s*;\" + \"\\\\s*}\\\\s*\");\n    Matcher matcher = pattern.matcher (s.get ());\n    try {\n        int lengthDifference = 0;\n        while (matcher.find ()) {\n            String replacement = \"if(!assert\" + Matcher.quoteReplacement (matcher.group (1)) + \"Condition_\" + Matcher.quoteReplacement (matcher.group (2)) + \"_for_method_\" + Matcher.quoteReplacement (matcher.group (3)) + \"(\" + Matcher.quoteReplacement (matcher.group (4)) + \")){System.err.println(\\\"\" + Matcher.quoteReplacement (matcher.group (5)) + \"\\\");}\";\n            int lengthOfMatchedString = matcher.end () - matcher.start ();\n            s.replace (lengthDifference + matcher.start (), lengthOfMatchedString, replacement);\n            lengthDifference -= lengthOfMatchedString - replacement.length ();\n        }\n    } catch (BadLocationException e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "protected static void assertBugInUnGeneratorWorkAround (final IDocument source) {\n    Pattern pattern = Pattern.compile (\"assert\\\\s*assert(Pre|Post)Condition_(\\\\w*)_for_method_(\\\\w*)(\\\\s*)\\\\(([^\\\\)]*)\\\\)(\\\\s*):\" + \"(\\\\s*)\\\"([^\\\"]*|\\\\\\\\\\\")*\\\";\");\n    Matcher matcher = pattern.matcher (source.get ());\n    try {\n        int lengthDifference = 0;\n        while (matcher.find ()) {\n            String replacement = \"\";\n            int lengthOfMatchedString = matcher.end () - matcher.start ();\n            source.replace (lengthDifference + matcher.start (), lengthOfMatchedString, replacement);\n            lengthDifference -= lengthOfMatchedString - replacement.length ();\n        }\n    } catch (BadLocationException e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 14288306, "method2_id": 22739188, "code1": "public static String encrypt (String senha) {\n    try {\n        MessageDigest digest = MessageDigest.getInstance (\"MD5\");\n        digest.update (senha.getBytes ());\n        BASE64Encoder encoder = new BASE64Encoder ();\n        return encoder.encode (digest.digest ());\n    } catch (NoSuchAlgorithmException ns) {\n        ns.printStackTrace ();\n        return senha;\n    }\n}\n", "code2": "public static String getHash (String password) {\n    try {\n        MessageDigest digest = MessageDigest.getInstance (\"SHA\");\n        digest.update (password.getBytes ());\n        return new String (digest.digest ());\n    } catch (NoSuchAlgorithmException e) {\n        log.error (\"Hashing algorithm not found\");\n        return password;\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 11370967, "method2_id": 18457132, "code1": "public void copyFile (File in, File out) throws Exception {\n    FileChannel ic = new FileInputStream (in).getChannel ();\n    FileChannel oc = new FileOutputStream (out).getChannel ();\n    ic.transferTo (0, ic.size (), oc);\n    ic.close ();\n    oc.close ();\n}\n", "code2": "private static void copyFile (File src, File dst) throws IOException {\n    FileChannel in = new FileInputStream (src).getChannel ();\n    FileChannel out = new FileOutputStream (dst).getChannel ();\n    in.transferTo (0, in.size (), out);\n    in.close ();\n    out.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 430525, "method2_id": 443406, "code1": "@Override\npublic void run (int number) {\n    Method meth;\n    try {\n        meth = loadedClass.getMethod (\"run\", int.class);\n        meth.invoke (loadedClass.newInstance (), number);\n    } catch (IllegalArgumentException e) {\n        e.printStackTrace ();\n    } catch (IllegalAccessException e) {\n        e.printStackTrace ();\n    } catch (InvocationTargetException e) {\n        e.printStackTrace ();\n    } catch (InstantiationException e) {\n        e.printStackTrace ();\n    } catch (SecurityException e) {\n        e.printStackTrace ();\n    } catch (NoSuchMethodException e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public void run (int [] array) {\n    Method meth;\n    int needle = 1;\n    try {\n        meth = loadedClass.getMethod (\"run\", int [].class, int.class);\n        meth.invoke (loadedClass.newInstance (), array, needle);\n    } catch (IllegalArgumentException e) {\n        e.printStackTrace ();\n    } catch (IllegalAccessException e) {\n        e.printStackTrace ();\n    } catch (InvocationTargetException e) {\n        e.printStackTrace ();\n    } catch (InstantiationException e) {\n        e.printStackTrace ();\n    } catch (SecurityException e) {\n        e.printStackTrace ();\n    } catch (NoSuchMethodException e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 14356579, "method2_id": 15972030, "code1": "public String getRandomGUID () {\n    MessageDigest md5 = null;\n    String valueBeforeMD5 = \"\";\n    String retValue = \"\";\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        InetAddress id = InetAddress.getLocalHost ();\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        rand = random.nextLong ();\n        sbValueBeforeMD5.append (id.toString ());\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) {\n                sb.append ('0');\n            }\n            sb.append (Integer.toHexString (b));\n        }\n        retValue = sb.toString ();\n    } catch (UnknownHostException e) {\n        System.out.println (\"Error:\" + e);\n    }\n    return retValue;\n}\n", "code2": "private void getGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 3026764, "method2_id": 21438070, "code1": "public MoteDeploymentConfiguration addMoteDeploymentConfiguration (int projectDepConfID, int moteID, int programID, int radioPowerLevel) throws AdaptationException {\n    MoteDeploymentConfiguration mdc = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        String query = \"INSERT INTO MoteDeploymentConfigurations(\" + \"projectDeploymentConfigurationID, \" + \"moteID, programID, radioPowerLevel) VALUES (\" + projectDepConfID + \", \" + moteID + \", \" + programID + \", \" + radioPowerLevel + \")\";\n        connection = DriverManager.getConnection (CONN_STR);\n        statement = connection.createStatement ();\n        statement.executeUpdate (query);\n        query = \"SELECT * from MoteDeploymentConfigurations WHERE \" + \"projectDeploymentConfigurationID = \" + projectDepConfID + \" AND moteID = \" + moteID;\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Unable to select newly added config.\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        mdc = getMoteDeploymentConfiguration (resultSet);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in addMoteDeploymentConfiguration\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return mdc;\n}\n", "code2": "public ProjectDeploymentConfiguration deleteProjectDeploymentConfig (int id) throws AdaptationException {\n    ProjectDeploymentConfiguration config = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        String query = \"SELECT * FROM ProjectDeploymentConfigurations \" + \"WHERE id = \" + id;\n        connection = DriverManager.getConnection (CONN_STR);\n        statement = connection.createStatement ();\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Attempt to delete project deployment \" + \"configuration failed.\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        config = getProjectDeploymentConfiguration (resultSet);\n        query = \"DELETE FROM ProjectDeploymentConfigurations \" + \"WHERE id = \" + id;\n        statement.executeUpdate (query);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in deleteProjectDeploymentConfig\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return config;\n}\n"}
{"clone_type": "ST3", "method1_id": 14499002, "method2_id": 14598564, "code1": "public static Image [] [] getFlipHorizintalImage2D (Image [] [] pixels) {\n    int w = pixels.length;\n    int h = pixels [0].length;\n    Image pixel [] [] = new Image [h] [w];\n    for (int i = 0;\n    i < h; i ++) {\n        for (int j = 0;\n        j < w; j ++) {\n            pixel [i] [j] = pixels [j] [i];\n        }\n    }\n    return pixel;\n}\n", "code2": "public static final Object [] [] transpose (Object [] [] a) {\n    int am = a.length;\n    int an = a [0].length;\n    Object [] [] result = new Object [an] [am];\n    for (int i = 0;\n    i < am; i ++) {\n        for (int j = 0;\n        j < an; j ++) {\n            result [j] [i] = a [i] [j];\n        }\n    }\n    return result;\n}\n"}
{"clone_type": "ST3", "method1_id": 5031964, "method2_id": 20418573, "code1": "public static String md5 (String text) {\n    String encrypted = \"\";\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (text.getBytes ());\n        encrypted = hex (md.digest ());\n    } catch (NoSuchAlgorithmException nsaEx) {\n    }\n    return encrypted;\n}\n", "code2": "public static String hashMD5 (String password) {\n    String hashword = null;\n    try {\n        MessageDigest md5 = MessageDigest.getInstance (\"MD5\");\n        md5.update (password.getBytes ());\n        BigInteger hash = new BigInteger (1, md5.digest ());\n        hashword = hash.toString (16);\n    } catch (NoSuchAlgorithmException nsae) {\n    }\n    return hashword;\n}\n"}
{"clone_type": "ST3", "method1_id": 14157859, "method2_id": 16924659, "code1": "static void copyFile (File file, File file1) throws IOException {\n    byte abyte0 [] = new byte [512];\n    FileInputStream fileinputstream = new FileInputStream (file);\n    FileOutputStream fileoutputstream = new FileOutputStream (file1);\n    int i;\n    while ((i = fileinputstream.read (abyte0)) > 0) fileoutputstream.write (abyte0, 0, i);\n\n    fileinputstream.close ();\n    fileoutputstream.close ();\n}\n", "code2": "public static void copyFile (File src, File dst) throws IOException {\n    InputStream in = new FileInputStream (src);\n    OutputStream out = new FileOutputStream (dst);\n    byte [] buf = new byte [1024];\n    int len;\n    while ((len = in.read (buf)) > 0) out.write (buf, 0, len);\n\n    in.close ();\n    out.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 1977849, "method2_id": 2486619, "code1": "private void zipDir (File dir, String jarEntry, JarOutputStream jos) throws IOException {\n    String [] dirList = dir.list ();\n    for (int i = 0;\n    i < dirList.length; i ++) {\n        File f = new File (dir, dirList [i]);\n        if (f.isDirectory ()) {\n            zipDir (f, jarEntry + dirList [i] + File.separatorChar, jos);\n            continue;\n        }\n        FileInputStream fis = new FileInputStream (f);\n        ZipEntry anEntry = new ZipEntry (jarEntry + dirList [i]);\n        jos.putNextEntry (anEntry);\n        byte [] readBuffer = new byte [2156];\n        int bytesIn = 0;\n        while ((bytesIn = fis.read (readBuffer)) != - 1) {\n            jos.write (readBuffer, 0, bytesIn);\n        }\n        fis.close ();\n    }\n}\n", "code2": "public static void zipDirectory (File file, ZipOutputStream out) throws Exception {\n    String [] dirList = file.list ();\n    byte [] readBuffer = new byte [1024];\n    int bytesIn = 0;\n    for (int i = 0;\n    i < dirList.length; i ++) {\n        File f = new File (file, dirList [i]);\n        if (f.isDirectory ()) {\n            zipDirectory (f, out);\n            continue;\n        }\n        FileInputStream fis = new FileInputStream (f);\n        ZipEntry zipEntry = new ZipEntry (f.getPath ());\n        out.putNextEntry (zipEntry);\n        while ((bytesIn = fis.read (readBuffer)) != - 1) {\n            out.write (readBuffer, 0, bytesIn);\n        }\n        fis.close ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 4630754, "method2_id": 10637999, "code1": "public static int [] [] reversalXandY (final int [] [] array) {\n    int col = array [0].length;\n    int row = array.length;\n    int [] [] result = new int [col] [row];\n    for (int y = 0;\n    y < col; y ++) {\n        for (int x = 0;\n        x < row; x ++) {\n            result [x] [y] = array [y] [x];\n        }\n    }\n    return result;\n}\n", "code2": "public static final double [] [] transpose (double [] [] a) {\n    int am = a.length;\n    int an = a [0].length;\n    double [] [] result = new double [an] [am];\n    for (int i = 0;\n    i < am; i ++) {\n        for (int j = 0;\n        j < an; j ++) {\n            result [j] [i] = a [i] [j];\n        }\n    }\n    return result;\n}\n"}
{"clone_type": "ST3", "method1_id": 5751314, "method2_id": 21488869, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        closeQuietly (in);\n        closeQuietly (out);\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "ST3", "method1_id": 12849793, "method2_id": 15405473, "code1": "public static double [] [] transpose (double [] [] M) {\n    double [] [] O = new double [M [0].length] [M.length];\n    for (int i = 0;\n    i < M.length; i ++) {\n        for (int j = 0;\n        j < M [0].length; j ++) {\n            O [j] [i] = M [i] [j];\n        }\n    }\n    return O;\n}\n", "code2": "public float [] [] getSubints () {\n    int [] [] subintsInt = this.getSubints (32, 1, 32);\n    float [] [] subintsfold = new float [subintsInt [0].length] [subintsInt.length];\n    for (int i = 0;\n    i < subintsInt.length; i ++) {\n        for (int j = 0;\n        j < subintsInt [0].length; j ++) {\n            subintsfold [j] [i] = subintsInt [i] [j];\n        }\n    }\n    return subintsfold;\n}\n"}
{"clone_type": "ST3", "method1_id": 4630753, "method2_id": 6328532, "code1": "public static Image [] [] reversalXandY (final Image [] [] array) {\n    int col = array [0].length;\n    int row = array.length;\n    Image [] [] result = new Image [col] [row];\n    for (int y = 0;\n    y < col; y ++) {\n        for (int x = 0;\n        x < row; x ++) {\n            result [x] [y] = array [y] [x];\n        }\n    }\n    return result;\n}\n", "code2": "protected static float [] [] trans (float [] [] a) {\n    int am = a.length;\n    int an = a [0].length;\n    float [] [] t = new float [an] [am];\n    for (int i = 0;\n    i < am; i ++) {\n        for (int j = 0;\n        j < an; j ++) {\n            t [j] [i] = a [i] [j];\n        }\n    }\n    return t;\n}\n"}
{"clone_type": "ST3", "method1_id": 5751314, "method2_id": 16224018, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        closeQuietly (in);\n        closeQuietly (out);\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "ST3", "method1_id": 1022820, "method2_id": 14024978, "code1": "public static final String computeHash (String stringToCompile) {\n    String retVal = null;\n    try {\n        MessageDigest md5 = MessageDigest.getInstance (\"MD5\");\n        md5.reset ();\n        md5.update (stringToCompile.getBytes ());\n        byte [] result = md5.digest ();\n        StringBuffer hexString = new StringBuffer ();\n        for (int i = 0;\n        i < result.length; i ++) {\n            hexString.append (Integer.toHexString (0xFF & result [i]));\n        }\n        retVal = hexString.toString ();\n        if (log.isDebugEnabled ()) log.debug (\"MD5 hash for \\\"\" + stringToCompile + \"\\\" is: \" + retVal);\n\n    } catch (Exception exe) {\n        log.error (exe.getMessage (), exe);\n    }\n    return retVal;\n}\n", "code2": "public static final String generate (String value) {\n    try {\n        java.security.MessageDigest md = java.security.MessageDigest.getInstance (\"MD5\");\n        md.update (value.getBytes ());\n        byte [] hash = md.digest ();\n        StringBuffer hexString = new StringBuffer ();\n        for (int i = 0;\n        i < hash.length; i ++) {\n            if ((0xff & hash [i]) < 0x10) {\n                hexString.append (\"0\" + Integer.toHexString ((0xFF & hash [i])));\n            } else {\n                hexString.append (Integer.toHexString (0xFF & hash [i]));\n            }\n        }\n        value = hexString.toString ();\n    } catch (Exception nsae) {\n        nsae.printStackTrace ();\n    }\n    return value;\n}\n"}
{"clone_type": "ST3", "method1_id": 820539, "method2_id": 11298700, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "public static long F (int n) {\n    if (n == 0) return 0;\n\n    if (n == 1) return 1;\n\n    return F (n - 1) + F (n - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 338138, "method2_id": 443341, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 254725, "method2_id": 447509, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 14624541, "method2_id": 17808515, "code1": "public static String convertToSha1 (final String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n", "code2": "public static String getHashCode (String text) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"MD5\");\n    byte [] md5hash = new byte [32];\n    md.update (text.getBytes (\"UTF-8\"), 0, text.length ());\n    md5hash = md.digest ();\n    return convertToHex (md5hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 9737790, "method2_id": 14175532, "code1": "public String md5Encode (String pass) {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace ();\n    }\n    md.update (pass.getBytes ());\n    byte [] result = md.digest ();\n    return new String (result);\n}\n", "code2": "public String getLongToken (String md5Str) {\n    MessageDigest md5 = null;\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n        md5.update (md5Str.getBytes (JspRunConfig.charset));\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n    StringBuffer token = toHex (md5.digest ());\n    return token.toString ();\n}\n"}
{"clone_type": "ST3", "method1_id": 18613870, "method2_id": 23058336, "code1": "private static void copyFile (File src, File dst) throws IOException {\n    FileChannel in = new FileInputStream (src).getChannel ();\n    FileChannel out = new FileOutputStream (dst).getChannel ();\n    in.transferTo (0, in.size (), out);\n    in.close ();\n    out.close ();\n}\n", "code2": "public static void copyFile (File in, File out) throws Exception {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 161821, "method2_id": 171256, "code1": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    cache = null;\n    znames = new Hashtable ();\n    TSIGs = new Hashtable ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.equals (\"primary\")) addZone (st.nextToken ());\n        else if (keyword.equals (\"cache\")) cache = new Cache (st.nextToken ());\n        else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n\n    }\n    if (cache == null) {\n        System.out.println (\"no cache specified\");\n        System.exit (- 1);\n    }\n    addUDP ((short) 12345);\n    addTCP ((short) 12345);\n}\n", "code2": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    boolean started = false;\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    cache = null;\n    znames = new Hashtable ();\n    TSIGs = new Hashtable ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken ());\n\n        if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) cache = new Cache (st.nextToken ());\n        else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) {\n            short port = Short.parseShort (st.nextToken ());\n            addUDP (port);\n            addTCP (port);\n            started = true;\n        }\n\n    }\n    if (cache == null) {\n        System.out.println (\"no cache specified\");\n        System.exit (- 1);\n    }\n    if (! started) {\n        addUDP ((short) 53);\n        addTCP ((short) 53);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 23677136, "method2_id": 23677138, "code1": "public static void BubbleSortFloat2 (float [] num) {\n    int last_exchange;\n    int right_border = num.length - 1;\n    do {\n        last_exchange = 0;\n        for (int j = 0;\n        j < num.length - 1; j ++) {\n            if (num [j] > num [j + 1]) {\n                float temp = num [j];\n                num [j] = num [j + 1];\n                num [j + 1] = temp;\n                last_exchange = j;\n            }\n        }\n        right_border = last_exchange;\n    } while (right_border > 0);\n}\n", "code2": "public static void BubbleSortDouble2 (double [] num) {\n    int last_exchange;\n    int right_border = num.length - 1;\n    do {\n        last_exchange = 0;\n        for (int j = 0;\n        j < num.length - 1; j ++) {\n            if (num [j] > num [j + 1]) {\n                double temp = num [j];\n                num [j] = num [j + 1];\n                num [j + 1] = temp;\n                last_exchange = j;\n            }\n        }\n        right_border = last_exchange;\n    } while (right_border > 0);\n}\n"}
{"clone_type": "ST3", "method1_id": 1362131, "method2_id": 7704003, "code1": "public void moveRowDown (int row) throws FidoDatabaseException {\n    try {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = fido.util.FidoDataSource.getConnection ();\n            conn.setAutoCommit (false);\n            stmt = conn.createStatement ();\n            int max = findMaxRank (stmt);\n            if ((row < 1) || (row > (max - 1))) throw new IllegalArgumentException (\"Row number not between 1 and \" + (max - 1));\n\n            stmt.executeUpdate (\"update WordClassifications set Rank = -1 where Rank = \" + row);\n            stmt.executeUpdate (\"update WordClassifications set Rank = \" + row + \" where Rank = \" + (row + 1));\n            stmt.executeUpdate (\"update WordClassifications set Rank = \" + (row + 1) + \" where Rank = -1\");\n            conn.commit ();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback ();\n\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close ();\n\n            if (conn != null) conn.close ();\n\n        }\n    } catch (SQLException e) {\n        throw new FidoDatabaseException (e);\n    }\n}\n", "code2": "public void moveRowUp (int id, int row) throws FidoDatabaseException {\n    try {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = fido.util.FidoDataSource.getConnection ();\n            conn.setAutoCommit (false);\n            stmt = conn.createStatement ();\n            int max = findMaxRank (stmt, id);\n            if ((row < 2) || (row > max)) throw new IllegalArgumentException (\"Row number not between 2 and \" + max);\n\n            stmt.executeUpdate (\"update InstructionGroups set Rank = -1 where InstructionId = '\" + id + \"' and Rank = \" + row);\n            stmt.executeUpdate (\"update InstructionGroups set Rank = \" + row + \" where InstructionId = '\" + id + \"' and Rank = \" + (row - 1));\n            stmt.executeUpdate (\"update InstructionGroups set Rank = \" + (row - 1) + \" where InstructionId = '\" + id + \"' and Rank = -1\");\n            conn.commit ();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback ();\n\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close ();\n\n            if (conn != null) conn.close ();\n\n        }\n    } catch (SQLException e) {\n        throw new FidoDatabaseException (e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 826911, "method2_id": 834100, "code1": "static boolean clean (File dir) {\n    boolean ok = true;\n    for (File f : dir.listFiles ()) {\n        if (f.isDirectory ()) ok &= clean (f);\n\n        ok &= f.delete ();\n    }\n    return ok;\n}\n", "code2": "boolean clean (File dir) {\n    boolean ok = true;\n    for (File f : dir.listFiles ()) {\n        if (f.isDirectory ()) ok &= clean (f);\n\n        ok &= f.delete ();\n    }\n    return ok;\n}\n"}
{"clone_type": "ST3", "method1_id": 19147301, "method2_id": 21224967, "code1": "public boolean actualizarIdPartida (int idJugadorDiv, int idRonda, int idPartida) {\n    int intResult = 0;\n    String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPartida = \" + idPartida + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        intResult = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (intResult > 0);\n}\n", "code2": "public boolean crear () {\n    int result = 0;\n    String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        populatePreparedStatement (elJugador);\n        result = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (result > 0);\n}\n"}
{"clone_type": "ST3", "method1_id": 5031964, "method2_id": 10671991, "code1": "public static String md5 (String text) {\n    String encrypted = \"\";\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (text.getBytes ());\n        encrypted = hex (md.digest ());\n    } catch (NoSuchAlgorithmException nsaEx) {\n    }\n    return encrypted;\n}\n", "code2": "public static String md5 (String value) {\n    try {\n        MessageDigest messageDigest = MessageDigest.getInstance (\"MD5\");\n        messageDigest.update (value.getBytes ());\n        return bytesToString (messageDigest.digest ());\n    } catch (Exception ex) {\n        Tools.logException (Tools.class, ex, value);\n    }\n    return value;\n}\n"}
{"clone_type": "ST3", "method1_id": 6166363, "method2_id": 10277293, "code1": "private static byte [] gerarHash (String frase) {\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (frase.getBytes ());\n        return md.digest ();\n    } catch (Exception e) {\n        return null;\n    }\n}\n", "code2": "byte [] calculateDigest (String value) {\n    try {\n        MessageDigest mg = MessageDigest.getInstance (\"SHA1\");\n        mg.update (value.getBytes ());\n        return mg.digest ();\n    } catch (Exception e) {\n        throw Bark.unchecker (e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 2332, "method2_id": 97593, "code1": "public void actionPerformed (ActionEvent e) {\n    dirChooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    int i = dirChooser.showOpenDialog (getMe ());\n    if (i == JFileChooser.APPROVE_OPTION) {\n        importPathField.setText (dirChooser.getSelectedFile ().toString ());\n    }\n    load ();\n    selectAll ();\n}\n", "code2": "public void actionPerformed (ActionEvent e) {\n    dirChooser.setFileSelectionMode (JFileChooser.FILES_AND_DIRECTORIES);\n    int i = dirChooser.showOpenDialog (gimme ());\n    if (i == JFileChooser.APPROVE_OPTION) {\n        fileBrowserField.setText (dirChooser.getSelectedFile ().toString ());\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 10793696, "method2_id": 13233448, "code1": "public static String SHA1 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n", "code2": "private static String GetSHA1 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return LoginHttpPostProcessor.ConvertToHex (sha1hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 15272, "method2_id": 302955, "code1": "public static void main (String [] args) {\n    try {\n        DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance ();\n        fact.setNamespaceAware (true);\n        Transformer trs = TransformerFactory.newInstance ().newTransformer (new StreamSource (\"xslt/struts2step1.xsl\"));\n        Document src = fact.newDocumentBuilder ().parse (new File (\"project.aswp\"));\n        trs.transform (new DOMSource (src), new StreamResult (new File (\"target.xml\")));\n        trs = TransformerFactory.newInstance ().newTransformer (new StreamSource (\"xslt/struts2step2.xsl\"));\n        src = fact.newDocumentBuilder ().parse (new File (\"target.xml\"));\n        trs.transform (new DOMSource (src), new StreamResult (new File (\"target2.xml\")));\n    } catch (Exception e) {\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public static void main (String [] args) {\n    try {\n        DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance ();\n        fact.setNamespaceAware (false);\n        fact.setValidating (false);\n        Transformer trs = TransformerFactory.newInstance ().newTransformer (new StreamSource (\"xslt/importStruts2.xsl\"));\n        DocumentBuilder builder = fact.newDocumentBuilder ();\n        builder.setEntityResolver (new LocalEntityResolver ());\n        Document src = builder.parse (new File (\"/home/sylvain/struts.xml\"));\n        trs.transform (new DOMSource (src), new StreamResult (new File (\"/home/sylvain/target.xml\")));\n    } catch (Exception e) {\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 5682569, "method2_id": 23677141, "code1": "public void metodo1 () {\n    int temp;\n    boolean flagDesordenado = true;\n    while (flagDesordenado) {\n        flagDesordenado = false;\n        for (int i = 0;\n        i < this.tamanoTabla - 1; i ++) {\n            if (tabla [i] > tabla [i + 1]) {\n                flagDesordenado = true;\n                temp = tabla [i];\n                tabla [i] = tabla [i + 1];\n                tabla [i + 1] = temp;\n            }\n        }\n    }\n}\n", "code2": "public static void BubbleSortShort1 (short [] num) {\n    boolean flag = true;\n    short temp;\n    while (flag) {\n        flag = false;\n        for (int j = 0;\n        j < num.length - 1; j ++) {\n            if (num [j] > num [j + 1]) {\n                temp = num [j];\n                num [j] = num [j + 1];\n                num [j + 1] = temp;\n                flag = true;\n            }\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 8980221, "method2_id": 15461843, "code1": "public static void copyFile (File source, File dest) throws IOException {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        in.transferTo (0, in.size (), out);\n    } catch (Exception e) {\n        log.error (e, e);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 13030, "method2_id": 855132, "code1": "public static boolean delete (File resource) throws IOException {\n    if (resource.isDirectory ()) {\n        File [] childFiles = resource.listFiles ();\n        for (File child : childFiles) {\n            delete (child);\n        }\n    }\n    return resource.delete ();\n}\n", "code2": "private static boolean delete (File resource) throws IOException {\n    if (resource.isDirectory ()) {\n        File [] childFiles = resource.listFiles ();\n        for (File child : childFiles) {\n            delete (child);\n        }\n    }\n    return resource.delete ();\n}\n"}
{"clone_type": "ST3", "method1_id": 228865, "method2_id": 848240, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 350482, "method2_id": 742465, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 11032545, "method2_id": 11032546, "code1": "@Test\npublic void testCopyOverSize () throws IOException {\n    final InputStream in = new ByteArrayInputStream (TEST_DATA);\n    final ByteArrayOutputStream out = new ByteArrayOutputStream (TEST_DATA.length);\n    final int cpySize = ExtraIOUtils.copy (in, out, TEST_DATA.length + Long.SIZE);\n    assertEquals (\"Mismatched copy size\", TEST_DATA.length, cpySize);\n    final byte [] outArray = out.toByteArray ();\n    assertArrayEquals (\"Mismatched data\", TEST_DATA, outArray);\n}\n", "code2": "@Test\npublic void testCopyUnknownSize () throws IOException {\n    final InputStream in = new ByteArrayInputStream (TEST_DATA);\n    final ByteArrayOutputStream out = new ByteArrayOutputStream (TEST_DATA.length);\n    final int cpySize = ExtraIOUtils.copy (in, out, (- 1));\n    assertEquals (\"Mismatched copy size\", TEST_DATA.length, cpySize);\n    final byte [] outArray = out.toByteArray ();\n    assertArrayEquals (\"Mismatched data\", TEST_DATA, outArray);\n}\n"}
{"clone_type": "ST3", "method1_id": 203977, "method2_id": 461258, "code1": "public static void main (String [] args) {\n    if (args.length != 4) {\n        System.out.println (\"usage: java msgmultisend <to> <from> <smtp> true|false\");\n        return;\n    }\n    String to = args [0];\n    String from = args [1];\n    String host = args [2];\n    boolean debug = Boolean.valueOf (args [3]).booleanValue ();\n    Properties props = new Properties ();\n    props.put (\"mail.smtp.host\", host);\n    Session session = Session.getInstance (props, null);\n    session.setDebug (debug);\n    try {\n        MimeMessage msg = new MimeMessage (session);\n        msg.setFrom (new InternetAddress (from));\n        InternetAddress [] address = {new InternetAddress (to)};\n        msg.setRecipients (Message.RecipientType.TO, address);\n        msg.setSubject (\"JavaMail APIs Multipart Test\");\n        msg.setSentDate (new Date ());\n        MimeBodyPart mbp1 = new MimeBodyPart ();\n        mbp1.setText (msgText1);\n        MimeBodyPart mbp2 = new MimeBodyPart ();\n        mbp2.setText (msgText2, \"us-ascii\");\n        Multipart mp = new MimeMultipart ();\n        mp.addBodyPart (mbp1);\n        mp.addBodyPart (mbp2);\n        msg.setContent (mp);\n        Transport.send (msg);\n    } catch (MessagingException mex) {\n        mex.printStackTrace ();\n        Exception ex = null;\n        if ((ex = mex.getNextException ()) != null) {\n            ex.printStackTrace ();\n        }\n    }\n}\n", "code2": "public static void main (String [] args) {\n    if (args.length != 5) {\n        System.out.println (\"usage: java sendfile <to> <from> <smtp> <file> true|false\");\n        System.exit (1);\n    }\n    String to = args [0];\n    String from = args [1];\n    String host = args [2];\n    String filename = args [3];\n    boolean debug = Boolean.valueOf (args [4]).booleanValue ();\n    String msgText1 = \"Sending a file.\\n\";\n    String subject = \"Sending a file\";\n    Properties props = System.getProperties ();\n    props.put (\"mail.smtp.host\", host);\n    Session session = Session.getInstance (props, null);\n    session.setDebug (debug);\n    try {\n        MimeMessage msg = new MimeMessage (session);\n        msg.setFrom (new InternetAddress (from));\n        InternetAddress [] address = {new InternetAddress (to)};\n        msg.setRecipients (Message.RecipientType.TO, address);\n        msg.setSubject (subject);\n        MimeBodyPart mbp1 = new MimeBodyPart ();\n        mbp1.setText (msgText1);\n        MimeBodyPart mbp2 = new MimeBodyPart ();\n        mbp2.attachFile (filename);\n        Multipart mp = new MimeMultipart ();\n        mp.addBodyPart (mbp1);\n        mp.addBodyPart (mbp2);\n        msg.setContent (mp);\n        msg.setSentDate (new Date ());\n        Transport.send (msg);\n    } catch (MessagingException mex) {\n        mex.printStackTrace ();\n        Exception ex = null;\n        if ((ex = mex.getNextException ()) != null) {\n            ex.printStackTrace ();\n        }\n    } catch (IOException ioex) {\n        ioex.printStackTrace ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 3633154, "method2_id": 22098632, "code1": "public static String getHash (String userName, String pass) {\n    String hash = null;\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (userName.getBytes ());\n        hash = ISOUtil.hexString (md.digest (pass.getBytes ())).toLowerCase ();\n    } catch (NoSuchAlgorithmException e) {\n    }\n    return hash;\n}\n", "code2": "private String getMd5 (String base64image) {\n    String token = null;\n    try {\n        MessageDigest md5 = MessageDigest.getInstance (\"MD5\");\n        md5.update (base64image.getBytes ());\n        BigInteger hash = new BigInteger (1, md5.digest ());\n        token = hash.toString (16);\n    } catch (NoSuchAlgorithmException nsae) {\n    }\n    return token;\n}\n"}
{"clone_type": "ST3", "method1_id": 6409829, "method2_id": 10844851, "code1": "public static LImage [] [] reversalXandY (final LImage [] [] array) {\n    int col = array [0].length;\n    int row = array.length;\n    LImage [] [] result = new LImage [col] [row];\n    for (int y = 0;\n    y < col; y ++) {\n        for (int x = 0;\n        x < row; x ++) {\n            result [x] [y] = array [y] [x];\n        }\n    }\n    return result;\n}\n", "code2": "public static double [] [] transp (double [] [] m1) {\n    int m = m1.length;\n    int n = m1 [0].length;\n    double [] [] ret = new double [n] [m];\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            ret [j] [i] = m1 [i] [j];\n        }\n    }\n    return ret;\n}\n"}
{"clone_type": "ST3", "method1_id": 7836028, "method2_id": 19164864, "code1": "private static void browseHelp () {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (new URI (TargetedProjectionPursuit.HELP_URL));\n        } catch (Exception e) {\n        }\n    } else {\n    }\n}\n", "code2": "private static void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n        }\n    } else {\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 10067028, "method2_id": 19926877, "code1": "public static void copyFile (File source, File destination) throws IOException {\n    FileChannel in = null;\n    FileChannel out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (destination).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buffer = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buffer);\n    } finally {\n        if (in != null) {\n            in.close ();\n        }\n        if (out != null) {\n            out.close ();\n        }\n    }\n}\n", "code2": "@Override\npublic void createCopy (File sourceFile, File destinnationFile) throws IOException {\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destinnationFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 556271, "method2_id": 813588, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 12606395, "method2_id": 14338365, "code1": "public static String SHA1 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n", "code2": "private static String simpleCompute (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"utf-8\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 153021, "method2_id": 414753, "code1": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n", "code2": "public static void main (String [] argv) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 9191794, "method2_id": 18631594, "code1": "public static String md5 (String text) {\n    MessageDigest msgDigest = null;\n    try {\n        msgDigest = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new IllegalStateException (\"System doesn't support MD5 algorithm.\");\n    }\n    try {\n        msgDigest.update (text.getBytes (AlipayConfig.CharSet));\n    } catch (UnsupportedEncodingException e) {\n        throw new IllegalStateException (\"System doesn't support your  EncodingException.\");\n    }\n    byte [] bytes = msgDigest.digest ();\n    String md5Str = new String (encodeHex (bytes));\n    return md5Str;\n}\n", "code2": "public static synchronized String getMD5_Base64 (String input) {\n    MessageDigest msgDigest = null;\n    try {\n        msgDigest = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new IllegalStateException (\"System doesn't support MD5 algorithm.\");\n    }\n    try {\n        msgDigest.update (input.getBytes (\"UTF-8\"));\n    } catch (java.io.UnsupportedEncodingException ex) {\n        throw new IllegalStateException (\"System doesn't support your  EncodingException.\");\n    }\n    byte [] rawData = msgDigest.digest ();\n    byte [] encoded = Base64.encode (rawData);\n    String retValue = new String (encoded);\n    return retValue;\n}\n"}
{"clone_type": "ST3", "method1_id": 986109, "method2_id": 17663965, "code1": "public static int [] [] transpose (int [] [] M) {\n    int [] [] tM = new int [M [0].length] [M.length];\n    for (int i = 0;\n    i < tM.length; i ++) {\n        for (int j = 0;\n        j < tM [0].length; j ++) {\n            tM [i] [j] = M [j] [i];\n        }\n    }\n    return tM;\n}\n", "code2": "private double [] [] getTransponColumns (double [] [] data) {\n    double [] [] columns = new double [data [0].length] [data.length];\n    for (int i = 0;\n    i < columns.length; i ++) {\n        for (int j = 0;\n        j < columns [0].length; j ++) {\n            columns [i] [j] = data [j] [i];\n        }\n    }\n    return columns;\n}\n"}
{"clone_type": "ST3", "method1_id": 343219, "method2_id": 345493, "code1": "public static Node exampleDOMtoDOMNonRoot (String sourceID, String xslID) throws TransformerException, TransformerConfigurationException, SAXException, IOException, ParserConfigurationException, MalformedURLException {\n    TransformerFactory tfactory = TransformerFactory.newInstance ();\n    if (tfactory.getFeature (DOMSource.FEATURE)) {\n        Templates templates;\n        {\n            System.setProperty (\"javax.xml.parsers.DocumentBuilderFactory\", \"com.icl.saxon.om.DocumentBuilderFactoryImpl\");\n            DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n            System.err.println (\"Using DocumentBuilderFactory \" + dfactory.getClass ());\n            dfactory.setNamespaceAware (true);\n            DocumentBuilder docBuilder = dfactory.newDocumentBuilder ();\n            System.err.println (\"Using DocumentBuilder \" + docBuilder.getClass ());\n            org.w3c.dom.Document outNode = docBuilder.newDocument ();\n            Node doc = docBuilder.parse (new InputSource (new File (xslID).toURL ().toString ()));\n            System.err.println (\"Stylesheet document built OK\");\n            DOMSource dsource = new DOMSource (doc);\n            dsource.setSystemId (new File (xslID).toURL ().toString ());\n            templates = tfactory.newTemplates (dsource);\n        } Transformer transformer = templates.newTransformer ();\n        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n        DocumentBuilder docBuilder = dfactory.newDocumentBuilder ();\n        Document outNode = docBuilder.newDocument ();\n        Document doc = docBuilder.parse (new InputSource (new File (sourceID).toURL ().toString ()));\n        Node bar = doc.getDocumentElement ().getFirstChild ();\n        while (bar.getNodeType () != Node.ELEMENT_NODE) {\n            bar = bar.getNextSibling ();\n        }\n        System.err.println (\"Source document built OK\");\n        DOMSource ds = new DOMSource (bar);\n        ds.setSystemId (new File (sourceID).toURL ().toString ());\n        transformer.transform (ds, new DOMResult (outNode));\n        System.err.println (\"Transformation done OK\");\n        Transformer serializer = tfactory.newTransformer ();\n        serializer.transform (new DOMSource (outNode), new StreamResult (System.out));\n        return outNode;\n    } else {\n        throw new org.xml.sax.SAXNotSupportedException (\"DOM node processing not supported!\");\n    }\n}\n", "code2": "public static Node exampleDOMtoDOM (String sourceID, String xslID) throws TransformerException, TransformerConfigurationException, SAXException, IOException, ParserConfigurationException, MalformedURLException {\n    TransformerFactory tfactory = TransformerFactory.newInstance ();\n    if (tfactory.getFeature (DOMSource.FEATURE)) {\n        Templates templates;\n        {\n            System.setProperty (\"javax.xml.parsers.DocumentBuilderFactory\", \"com.icl.saxon.om.DocumentBuilderFactoryImpl\");\n            DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n            System.err.println (\"Using DocumentBuilderFactory \" + dfactory.getClass ());\n            dfactory.setNamespaceAware (true);\n            DocumentBuilder docBuilder = dfactory.newDocumentBuilder ();\n            System.err.println (\"Using DocumentBuilder \" + docBuilder.getClass ());\n            org.w3c.dom.Document outNode = docBuilder.newDocument ();\n            Node doc = docBuilder.parse (new InputSource (new File (xslID).toURL ().toString ()));\n            System.err.println (\"Stylesheet document built OK\");\n            DOMSource dsource = new DOMSource (doc);\n            dsource.setSystemId (new File (xslID).toURL ().toString ());\n            templates = tfactory.newTemplates (dsource);\n        } Transformer transformer = templates.newTransformer ();\n        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n        DocumentBuilder docBuilder = dfactory.newDocumentBuilder ();\n        org.w3c.dom.Document outNode = docBuilder.newDocument ();\n        Node doc = docBuilder.parse (new InputSource (new File (sourceID).toURL ().toString ()));\n        System.err.println (\"Source document built OK\");\n        DOMSource ds = new DOMSource (doc);\n        ds.setSystemId (new File (sourceID).toURL ().toString ());\n        transformer.transform (ds, new DOMResult (outNode));\n        System.err.println (\"Transformation done OK\");\n        Transformer serializer = tfactory.newTransformer ();\n        serializer.transform (new DOMSource (outNode), new StreamResult (System.out));\n        return outNode;\n    } else {\n        throw new org.xml.sax.SAXNotSupportedException (\"DOM node processing not supported!\");\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 14338365, "method2_id": 21827619, "code1": "private static String simpleCompute (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"utf-8\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n", "code2": "public static String SHA1 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 2575374, "method2_id": 6856298, "code1": "public static void copy (File in, File out) throws Exception {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n", "code2": "public static void copyFile (File from, File to) throws IOException {\n    ensureFile (to);\n    FileChannel srcChannel = new FileInputStream (from).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (to).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 12744196, "method2_id": 23161545, "code1": "public RandomGUID () {\n    MessageDigest md5 = null;\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException (e.getClass ().getName () + \": \" + e.getMessage ());\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        rand = myRand.nextLong ();\n        StringBuffer sb = new StringBuffer ();\n        sb.append (s_id);\n        sb.append (\":\");\n        sb.append (Long.toString (time));\n        sb.append (\":\");\n        sb.append (Long.toString (rand));\n        md5.update (sb.toString ().getBytes ());\n        byte [] array = md5.digest ();\n        sb.setLength (0);\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        throw new RuntimeException (e.getClass ().getName () + \": \" + e.getMessage ());\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 13335071, "method2_id": 13783549, "code1": "public static boolean copy (File source, File dest) {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    } catch (IOException e) {\n        e.printStackTrace ();\n        return false;\n    }\n    return true;\n}\n", "code2": "private static void copy (String sourceName, String destName) throws IOException {\n    File source = new File (sourceName);\n    File dest = new File (destName);\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 6856298, "method2_id": 20082006, "code1": "public static void copyFile (File from, File to) throws IOException {\n    ensureFile (to);\n    FileChannel srcChannel = new FileInputStream (from).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (to).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n", "code2": "public static void copyFile (File src, File dst) throws IOException {\n    FileChannel sourceChannel = new FileInputStream (src).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (dst).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 4684098, "method2_id": 12232011, "code1": "public static void copyFile (String sIn, String sOut) throws IOException {\n    File fIn = new File (sIn);\n    File fOut = new File (sOut);\n    FileChannel fcIn = new FileInputStream (fIn).getChannel ();\n    FileChannel fcOut = new FileOutputStream (fOut).getChannel ();\n    try {\n        fcIn.transferTo (0, fcIn.size (), fcOut);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (fcIn != null) fcIn.close ();\n\n        if (fcOut != null) fcOut.close ();\n\n    }\n    fOut.setReadable (fIn.canRead ());\n    fOut.setWritable (fIn.canWrite ());\n    fOut.setExecutable (fIn.canExecute ());\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 3837844, "method2_id": 14313421, "code1": "public static void synchronizeConnectionTable (int [] [] contab) {\n    int N = contab.length;\n    for (int i = 0;\n    i < N; i ++) {\n        for (int j = i + 1;\n        j < N; j ++) {\n            contab [j] [i] = contab [i] [j];\n        }\n    }\n}\n", "code2": "public RealSquareMatrix copyLowerToUpper () {\n    for (int i = 0;\n    i < cols - 1; i ++) {\n        for (int j = i + 1;\n        j < cols; j ++) {\n            flmat [i] [j] = flmat [j] [i];\n        }\n    }\n    return this;\n}\n"}
{"clone_type": "ST3", "method1_id": 1312064, "method2_id": 21493174, "code1": "public void addDir (ZipOutputStream out, String dirname) {\n    byte [] buf = new byte [1024];\n    File dir = new File (projHandler.getProjectPath () + File.separator + dirname);\n    if (dir.exists ()) {\n        try {\n            File file = new File (projHandler.getProjectPath () + File.separator + dirname);\n            File [] children = file.listFiles ();\n            for (int i = 0;\n            i < children.length; i ++) {\n                if (children [i].isFile ()) {\n                    FileInputStream fis = new FileInputStream (children [i]);\n                    out.putNextEntry (new ZipEntry (dirname.replace ('\\\\', '/') + '/' + children [i].getName ()));\n                    int len;\n                    while ((len = fis.read (buf)) > 0) {\n                        out.write (buf, 0, len);\n                    }\n                    out.closeEntry ();\n                    fis.close ();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    }\n}\n", "code2": "public void addDir (ZipOutputStream out, String dirname) throws EditorException {\n    byte [] buf = new byte [1024];\n    File dir = new File (dirname);\n    String dName = dir.getName ();\n    if (dir.exists ()) {\n        try {\n            File file = new File (dirname);\n            File [] children = file.listFiles ();\n            for (int i = 0;\n            i < children.length; i ++) {\n                if ((children [i].isFile ()) && (! children [i].getName ().endsWith (\"fop.zip\"))) {\n                    FileInputStream fis = new FileInputStream (children [i]);\n                    out.putNextEntry (new ZipEntry (dName + \"/\" + children [i].getName ()));\n                    int len;\n                    while ((len = fis.read (buf)) > 0) {\n                        out.write (buf, 0, len);\n                    }\n                    out.closeEntry ();\n                    fis.close ();\n                }\n            }\n        } catch (IOException e) {\n            String msg = \"Unable to add a directory to the ZIP output.\";\n            throw new EditorException (msg, e);\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 1388732, "method2_id": 8640120, "code1": "private void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n            p (\"IOException \");\n            e.printStackTrace ();\n        }\n    } else {\n        System.out.println (\"Desktop.isDesktopSupported() - NOT\");\n    }\n}\n", "code2": "private static void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    } else {\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 4716110, "method2_id": 16944401, "code1": "public static void copyFile (File in, File out) throws Exception {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    try {\n        sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    } finally {\n        sourceChannel.close ();\n        destinationChannel.close ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 12120684, "method2_id": 13020691, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5;\n    StringBuilder sbValueBeforeHash = new StringBuilder ();\n    try {\n        md5 = MessageDigest.getInstance (\"SHA-1\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new ApplicationIllegalArgumentException (e);\n    }\n    long time = System.nanoTime ();\n    long rand = 0;\n    if (secure) {\n        rand = MySecureRand.nextLong ();\n    } else {\n        rand = MyRand.nextLong ();\n    }\n    sbValueBeforeHash.append (SId);\n    sbValueBeforeHash.append (\":\");\n    sbValueBeforeHash.append (Long.toString (time));\n    sbValueBeforeHash.append (\":\");\n    sbValueBeforeHash.append (Long.toString (rand));\n    valueBeforeHash = sbValueBeforeHash.toString ();\n    md5.update (valueBeforeHash.getBytes ());\n    byte [] array = md5.digest ();\n    StringBuffer sb = new StringBuffer ();\n    for (int j = 0;\n    j < array.length; ++ j) {\n        int b = array [j] & 0xFF;\n        if (b < 0x10) {\n            sb.append ('0');\n        }\n        sb.append (Integer.toHexString (b));\n    }\n    valueAfterHash = sb.toString ();\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 2676364, "method2_id": 10384705, "code1": "public void reset (String componentName, int currentPilot) {\n    try {\n        PreparedStatement psta = jdbc.prepareStatement (\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \" + \"AND component_name = ?\");\n        psta.setInt (1, currentPilot);\n        psta.setString (2, componentName);\n        psta.executeUpdate ();\n        jdbc.commit ();\n    } catch (SQLException e) {\n        jdbc.rollback ();\n        log.debug (e);\n    }\n}\n", "code2": "public void reset (int currentPilot) {\n    try {\n        PreparedStatement psta = jdbc.prepareStatement (\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n        psta.setInt (1, currentPilot);\n        psta.executeUpdate ();\n        jdbc.commit ();\n    } catch (SQLException e) {\n        jdbc.rollback ();\n        log.debug (e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 10781751, "method2_id": 18712047, "code1": "public Matrix transpose () {\n    double [] [] out = new double [cols] [rows];\n    for (int i = 0;\n    i < cols; i ++) {\n        for (int j = 0;\n        j < rows; j ++) {\n            out [i] [j] = value [j] [i];\n        }\n    }\n    return new Matrix (out, cols, rows);\n}\n", "code2": "public Matrix transpose () {\n    Matrix output = new Matrix (cols, rows);\n    for (int i = 0;\n    i < rows; i ++) {\n        for (int j = 0;\n        j < cols; j ++) {\n            output.contents [j] [i] = contents [i] [j];\n        }\n    }\n    return output;\n}\n"}
{"clone_type": "ST3", "method1_id": 1362, "method2_id": 8227164, "code1": "public static int [] bubbleSort (int...a) {\n    boolean swapped;\n    do {\n        swapped = false;\n        for (int i = 0;\n        i < a.length - 1; i ++) {\n            if (a [i] > a [i + 1]) {\n                int tmp = a [i];\n                a [i] = a [i + 1];\n                a [i + 1] = tmp;\n                swapped = true;\n            }\n        }\n    } while (swapped);\n    return a;\n}\n", "code2": "static int [] bubble (int [] s) {\n    boolean f = true;\n    while (f) {\n        f = false;\n        for (int i = 0;\n        i < s.length - 1; i ++) {\n            if (s [i] > s [i + 1]) {\n                int t = s [i];\n                s [i] = s [i + 1];\n                s [i + 1] = t;\n                f = true;\n            }\n        }\n    }\n    return s;\n}\n"}
{"clone_type": "ST3", "method1_id": 80860, "method2_id": 4328782, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "ST3", "method1_id": 2537400, "method2_id": 15730395, "code1": "public static double [] [] mergeColumns (double []...x) {\n    double [] [] array = new double [x [0].length] [x.length];\n    for (int i = 0;\n    i < array.length; i ++) {\n        for (int j = 0;\n        j < array [i].length; j ++) {\n            array [i] [j] = x [j] [i];\n        }\n    }\n    return array;\n}\n", "code2": "public static double [] [] calcTranspose (double [] [] mat) {\n    double [] [] transpose = new double [mat [0].length] [mat.length];\n    for (int a = 0;\n    a < transpose.length; a ++) {\n        for (int b = 0;\n        b < transpose [0].length; b ++) {\n            transpose [a] [b] = mat [b] [a];\n        }\n    }\n    return transpose;\n}\n"}
{"clone_type": "ST3", "method1_id": 6371592, "method2_id": 6371605, "code1": "public void deleteUser (final List < Integer > userIds) {\n    try {\n        connection.setAutoCommit (false);\n        new ProcessEnvelope ().executeNull (new ExecuteProcessAbstractImpl (connection, false, false, true, true) {\n            @Override\n            public void executeProcessReturnNull () throws SQLException {\n                psImpl = connImpl.prepareStatement (sqlCommands.getProperty (\"user.delete\"));\n                Iterator < Integer > iter = userIds.iterator ();\n                int userId;\n                while (iter.hasNext ()) {\n                    userId = iter.next ();\n                    psImpl.setInt (1, userId);\n                    psImpl.executeUpdate ();\n                }\n            }}\n\n        );\n        connection.commit ();\n        cmDB.removeUsers (userIds);\n    } catch (SQLException sqle) {\n        log.error (sqle);\n        if (connection != null) {\n            try {\n                connection.rollback ();\n            } catch (SQLException ex) {\n            }\n        }\n    } finally {\n        if (connection != null) {\n            try {\n                connection.setAutoCommit (true);\n            } catch (SQLException ex) {\n            }\n        }\n    }\n}\n", "code2": "public void insertRealm (final List < NewRealms > newRealms) {\n    try {\n        connection.setAutoCommit (false);\n        new ProcessEnvelope ().executeNull (new ExecuteProcessAbstractImpl (connection, false, false, true, true) {\n            @Override\n            public void executeProcessReturnNull () throws SQLException {\n                psImpl = connImpl.prepareStatement (sqlCommands.getProperty (\"realm.add\"));\n                Iterator < NewRealms > iter = newRealms.iterator ();\n                NewRealms newRealm;\n                String realm;\n                Iterator < String > iter2;\n                while (iter.hasNext ()) {\n                    newRealm = iter.next ();\n                    psImpl.setInt (3, newRealm.domainId);\n                    iter2 = newRealm.realms.iterator ();\n                    while (iter2.hasNext ()) {\n                        realm = iter2.next ();\n                        psImpl.setString (1, realm);\n                        psImpl.setString (2, realm.toLowerCase (locale));\n                        psImpl.executeUpdate ();\n                    }\n                }\n            }}\n\n        );\n        connection.commit ();\n    } catch (SQLException sqle) {\n        log.error (sqle);\n        if (connection != null) {\n            try {\n                connection.rollback ();\n            } catch (SQLException ex) {\n            }\n        }\n    } finally {\n        if (connection != null) {\n            try {\n                connection.setAutoCommit (true);\n            } catch (SQLException ex) {\n            }\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 3239010, "method2_id": 3959503, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File source, File dest) throws IOException {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        in.transferTo (0, in.size (), out);\n    } catch (FileNotFoundException fnfe) {\n        fnfe.printStackTrace ();\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 114901, "method2_id": 405771, "code1": "public static void main (String [] argv) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n", "code2": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 3577507, "method2_id": 20870396, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "private static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 1428985, "method2_id": 7077816, "code1": "public static void copyDirectory (File srcPath, File dstPath) throws IOException {\n    if (srcPath.getName ().contains (\"svn\") || srcPath.getName ().contains (\"backup\")) return;\n\n    if (srcPath.isDirectory ()) {\n        if (! dstPath.exists ()) {\n            dstPath.mkdirs ();\n        }\n        String files [] = srcPath.list ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            copyDirectory (new File (srcPath, files [i]), new File (dstPath, files [i]));\n        }\n    } else {\n        if (! srcPath.exists ()) {\n            System.out.println (\"Arquivo ou diret\ufffdrio n\ufffdo existe.\");\n            System.exit (0);\n        } else {\n            InputStream in = new FileInputStream (srcPath);\n            OutputStream out = new FileOutputStream (dstPath);\n            byte [] buf = new byte [1024];\n            int len;\n            while ((len = in.read (buf)) > 0) {\n                out.write (buf, 0, len);\n            }\n            in.close ();\n            out.close ();\n        }\n    }\n    System.out.println (\"Directory copied.\");\n}\n", "code2": "public static Boolean copyDir (File oSource, File oDestination) {\n    try {\n        if (oSource.exists ()) {\n            if (oSource.isDirectory ()) {\n                if (! oDestination.exists ()) {\n                    oDestination.mkdir ();\n                }\n                String [] children = oSource.list ();\n                for (int i = 0;\n                i < children.length; i ++) {\n                    copyDir (new File (oSource, children [i]), new File (oDestination, children [i]));\n                }\n            } else {\n                InputStream in = new FileInputStream (oSource);\n                OutputStream out = new FileOutputStream (oDestination);\n                byte [] buf = new byte [1024];\n                int len;\n                while ((len = in.read (buf)) > 0) {\n                    out.write (buf, 0, len);\n                }\n                in.close ();\n                out.close ();\n            }\n            return true;\n        }\n    } catch (IOException oException) {\n        throw new FilesystemException (oException.getMessage (), oSource.getName (), oException);\n    }\n    return false;\n}\n"}
{"clone_type": "ST3", "method1_id": 19147275, "method2_id": 19147297, "code1": "public boolean crear () {\n    int result = 0;\n    String sql = \"insert into jugadorxdivxronda\" + \"(jugadorxDivision_idJugadorxDivision, ronda_numeroRonda, resultado, idPareoRival, color, flotante, puntajeRonda, idPareo) \" + \"values (?, ?, ?, ?, ?, ?, ?, ?)\";\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        populatePreparedStatement (unjxdxr);\n        result = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (result > 0);\n}\n", "code2": "public boolean ponerRivalxRonda (int idJugadorDiv, int idRonda, int dato) {\n    int intResult = 0;\n    String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + dato + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        intResult = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (intResult > 0);\n}\n"}
{"clone_type": "ST3", "method1_id": 9552054, "method2_id": 14647876, "code1": "public static void copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) dir.mkdir ();\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n", "code2": "public static void copyFile (IPath fromFileName, IPath toFileName) throws IOException {\n    File fromFile = fromFileName.toFile ();\n    File toFile = toFileName.toFile ();\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    InputStream from = null;\n    OutputStream to = null;\n    try {\n        from = new BufferedInputStream (new FileInputStream (fromFile));\n        to = new BufferedOutputStream (new FileOutputStream (toFile));\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 10781751, "method2_id": 19462844, "code1": "public Matrix transpose () {\n    double [] [] out = new double [cols] [rows];\n    for (int i = 0;\n    i < cols; i ++) {\n        for (int j = 0;\n        j < rows; j ++) {\n            out [i] [j] = value [j] [i];\n        }\n    }\n    return new Matrix (out, cols, rows);\n}\n", "code2": "public Matrix transpose () {\n    Matrix X = new Matrix (n, m);\n    double [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n"}
{"clone_type": "ST3", "method1_id": 11389886, "method2_id": 21803552, "code1": "private static boolean renderStaticResource (final String requestedResource, HttpServletResponse servletResponse) throws IOException {\n    boolean successfull = true;\n    String fileName = PathTool.getFSPathOfResource (requestedResource);\n    File file = new File (fileName);\n    if (! file.exists ()) {\n        logger.error (\"Static resource not found: \" + fileName);\n        return false;\n    }\n    if (fileName.endsWith (\"xml\") || fileName.endsWith (\"asp\")) servletResponse.setContentType (\"text/xml\");\n    else if (fileName.endsWith (\"css\")) servletResponse.setContentType (\"text/css\");\n    else if (fileName.endsWith (\"js\")) servletResponse.setContentType (\"text/javascript\");\n\n    InputStream in = null;\n    try {\n        in = new BufferedInputStream (new FileInputStream (file));\n        IOUtils.copy (in, servletResponse.getOutputStream ());\n        logger.debug (\"Static resource rendered: \".concat (fileName));\n    } catch (FileNotFoundException e) {\n        logger.error (\"Static resource not found: \" + fileName);\n        successfull = false;\n    } finally {\n        IOUtils.closeQuietly (in);\n    }\n    return successfull;\n}\n", "code2": "public void doRender () throws IOException {\n    File file = new File (fileName);\n    if (! file.exists ()) {\n        logger.error (\"Static resource not found: \" + fileName);\n        isNotFound = true;\n        return;\n    }\n    if (fileName.endsWith (\"xml\") || fileName.endsWith (\"asp\")) servletResponse.setContentType (\"text/xml\");\n    else if (fileName.endsWith (\"css\")) servletResponse.setContentType (\"text/css\");\n    else if (fileName.endsWith (\"js\")) servletResponse.setContentType (\"text/javascript\");\n\n    InputStream in = null;\n    try {\n        in = new FileInputStream (file);\n        IOUtils.copy (in, servletResponse.getOutputStream ());\n        logger.debug (\"Static resource rendered: \".concat (fileName));\n    } catch (FileNotFoundException e) {\n        logger.error (\"Static resource not found: \" + fileName);\n        isNotFound = true;\n    } finally {\n        IOUtils.closeQuietly (in);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 8766039, "method2_id": 15910370, "code1": "public static int fibonacci (int broj) {\n    if (broj <= 1) return broj;\n    else return fibonacci (broj - 1) + fibonacci (broj - 2);\n\n}\n", "code2": "int seqFib (int n) {\n    if (n <= 1) return n;\n    else return seqFib (n - 1) + seqFib (n - 2);\n\n}\n"}
{"clone_type": "ST3", "method1_id": 832234, "method2_id": 885948, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 3501324, "method2_id": 19389536, "code1": "public Matrix transpose () {\n    Matrix X = new Matrix (n, m);\n    double [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n", "code2": "public Matrix transpose () {\n    double [] [] out = new double [cols] [rows];\n    for (int i = 0;\n    i < cols; i ++) {\n        for (int j = 0;\n        j < rows; j ++) {\n            out [i] [j] = value [j] [i];\n        }\n    }\n    return new Matrix (out, cols, rows);\n}\n"}
{"clone_type": "ST3", "method1_id": 6579996, "method2_id": 10629557, "code1": "public static Boolean compress (String sSourceDir, ArrayList < String > aFiles, String sDestinationFilename) {\n    log.info (\"PentahoReport() sourceDir: \" + sSourceDir + \" destination:\" + sDestinationFilename);\n    BufferedInputStream oOrigin = null;\n    FileOutputStream oDestination;\n    ZipOutputStream oOutput;\n    Iterator < String > oIterator;\n    byte [] aData;\n    try {\n        oDestination = new FileOutputStream (sDestinationFilename);\n        oOutput = new ZipOutputStream (new BufferedOutputStream (oDestination));\n        aData = new byte [BUFFER_SIZE];\n        oIterator = aFiles.iterator ();\n        while (oIterator.hasNext ()) {\n            String sFilename = (String) oIterator.next ();\n            FileInputStream fisInput = new FileInputStream (sSourceDir + File.separator + sFilename);\n            oOrigin = new BufferedInputStream (fisInput, BUFFER_SIZE);\n            ZipEntry oEntry = new ZipEntry (sFilename.replace ('\\\\', '/'));\n            oOutput.putNextEntry (oEntry);\n            int iCount;\n            while ((iCount = oOrigin.read (aData, 0, BUFFER_SIZE)) != - 1) {\n                oOutput.write (aData, 0, iCount);\n            }\n            oOrigin.close ();\n        }\n        oOutput.close ();\n    } catch (Exception oException) {\n        log.error (oException.getMessage ());\n        oException.printStackTrace ();\n        return false;\n    }\n    return true;\n}\n", "code2": "public static Boolean compress (ArrayList < String > aFiles, String sDestinationFilename) {\n    BufferedInputStream oOrigin = null;\n    FileOutputStream oDestination;\n    ZipOutputStream oOutput;\n    Iterator < String > oIterator;\n    byte [] aData;\n    try {\n        oDestination = new FileOutputStream (sDestinationFilename);\n        oOutput = new ZipOutputStream (new BufferedOutputStream (oDestination));\n        aData = new byte [BUFFER_SIZE];\n        oIterator = aFiles.iterator ();\n        while (oIterator.hasNext ()) {\n            String sFilename = (String) oIterator.next ();\n            FileInputStream fisInput = new FileInputStream (sFilename);\n            oOrigin = new BufferedInputStream (fisInput, BUFFER_SIZE);\n            ZipEntry oEntry = new ZipEntry (sFilename);\n            oOutput.putNextEntry (oEntry);\n            int iCount;\n            while ((iCount = oOrigin.read (aData, 0, BUFFER_SIZE)) != - 1) {\n                oOutput.write (aData, 0, iCount);\n            }\n            oOrigin.close ();\n        }\n        oOutput.close ();\n    } catch (Exception e) {\n        AgentLogger.getInstance ().error (e);\n        return false;\n    }\n    return true;\n}\n"}
{"clone_type": "ST3", "method1_id": 7680527, "method2_id": 19934218, "code1": "static String MD5 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"MD5\");\n    byte [] md5hash = new byte [32];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    md5hash = md.digest ();\n    return convertToHex (md5hash);\n}\n", "code2": "public static String doCrypt (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"UTF-8\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 16242336, "method2_id": 19362432, "code1": "public static void zipFilesInDirectory (File directory, String outname) {\n    byte [] buf = new byte [1024];\n    try {\n        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outname));\n        File [] files = directory.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            FileInputStream in = new FileInputStream (files [i]);\n            out.putNextEntry (new ZipEntry (files [i].getName ()));\n            int len;\n            while ((len = in.read (buf)) > 0) {\n                out.write (buf, 0, len);\n            }\n            out.closeEntry ();\n            in.close ();\n        }\n        out.close ();\n    } catch (IOException ex) {\n        System.out.println (\"Exception: \" + ex);\n    }\n}\n", "code2": "public static void zipFiles (String zipFilePath, String [] filenames) {\n    byte [] buf = new byte [1024];\n    try {\n        String outFilename = zipFilePath;\n        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outFilename));\n        for (int i = 0;\n        i < filenames.length; i ++) {\n            File file = new File (filenames [i]);\n            if (file.exists ()) {\n                FileInputStream in = new FileInputStream (filenames [i]);\n                out.putNextEntry (new ZipEntry (filenames [i]));\n                int len;\n                while ((len = in.read (buf)) > 0) {\n                    out.write (buf, 0, len);\n                }\n                out.closeEntry ();\n                in.close ();\n            }\n        }\n        out.close ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 17543732, "method2_id": 22705280, "code1": "private String getCoded (String pass) {\n    String passSecret = \"\";\n    try {\n        MessageDigest m = MessageDigest.getInstance (\"MD5\");\n        m.update (pass.getBytes (\"UTF8\"));\n        byte s [] = m.digest ();\n        for (int i = 0;\n        i < s.length; i ++) {\n            passSecret += Integer.toHexString ((0x000000ff & s [i]) | 0xffffff00).substring (6);\n        }\n    } catch (NoSuchAlgorithmException e1) {\n        e1.printStackTrace ();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace ();\n    }\n    return passSecret;\n}\n", "code2": "public static String encode (String str) {\n    String md5Str = null;\n    try {\n        MessageDigest digest = java.security.MessageDigest.getInstance (\"MD5\");\n        digest.update (str.getBytes (\"UTF8\"));\n        byte [] hash = digest.digest ();\n        md5Str = \"\";\n        for (int i = 0;\n        i < hash.length; i ++) {\n            md5Str += Integer.toHexString ((0x000000ff & hash [i]) | 0xffffff00).substring (6);\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n    return md5Str;\n}\n"}
{"clone_type": "ST3", "method1_id": 12561704, "method2_id": 23677133, "code1": "private void bubbleSort (int [] mas) {\n    boolean t = true;\n    while (t) {\n        t = false;\n        for (int i = 0;\n        i < mas.length - 1; i ++) {\n            if (mas [i] > mas [i + 1]) {\n                int temp = mas [i];\n                mas [i] = mas [i + 1];\n                mas [i + 1] = temp;\n                t = true;\n            }\n        }\n    }\n}\n", "code2": "public static void BubbleSortInt1 (int [] num) {\n    boolean flag = true;\n    int temp;\n    while (flag) {\n        flag = false;\n        for (int j = 0;\n        j < num.length - 1; j ++) {\n            if (num [j] > num [j + 1]) {\n                temp = num [j];\n                num [j] = num [j + 1];\n                num [j + 1] = temp;\n                flag = true;\n            }\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 80963, "method2_id": 859991, "code1": "public static boolean delete (File resource) throws IOException {\n    if (resource.isDirectory ()) {\n        File [] childFiles = resource.listFiles ();\n        for (File child : childFiles) {\n            delete (child);\n        }\n    }\n    return resource.delete ();\n}\n", "code2": "private static boolean delete (File resource) throws IOException {\n    if (resource.isDirectory ()) {\n        File [] childFiles = resource.listFiles ();\n        for (File child : childFiles) {\n            delete (child);\n        }\n    }\n    return resource.delete ();\n}\n"}
{"clone_type": "ST3", "method1_id": 262940, "method2_id": 434724, "code1": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n", "code2": "public static void main (String [] argv) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 52265, "method2_id": 153021, "code1": "public static void main (String [] argv) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n", "code2": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 10781751, "method2_id": 14313423, "code1": "public Matrix transpose () {\n    double [] [] out = new double [cols] [rows];\n    for (int i = 0;\n    i < cols; i ++) {\n        for (int j = 0;\n        j < rows; j ++) {\n            out [i] [j] = value [j] [i];\n        }\n    }\n    return new Matrix (out, cols, rows);\n}\n", "code2": "public void transpose () {\n    for (int i = 0;\n    i < rows; i ++) {\n        for (int j = 0;\n        j < i; j ++) {\n            double t = flmat [i] [j];\n            flmat [i] [j] = flmat [j] [i];\n            flmat [j] [i] = t;\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 853457, "method2_id": 6494291, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private Integer slowFib (int i) {\n    if (i <= 0) return 0;\n\n    if (i == 1) return 1;\n\n    return slowFib (i - 1) + slowFib (i - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 7052766, "method2_id": 21858888, "code1": "public static void zipDir (String dirPath, ZipOutputStream zos, int truncLen, String prefix) {\n    try {\n        File zipDir = new File (dirPath);\n        String [] dirList = zipDir.list ();\n        byte [] readBuffer = new byte [1024];\n        int bytesIn = 0;\n        for (int i = 0;\n        i < dirList.length; i ++) {\n            File f = new File (zipDir, dirList [i]);\n            if (f.isDirectory ()) {\n                String filePath = f.getPath ();\n                zipDir (filePath, zos, truncLen, prefix);\n                continue;\n            }\n            FileInputStream fis = new FileInputStream (f);\n            ZipEntry anEntry = new ZipEntry (prefix + f.getPath ().substring (truncLen));\n            zos.putNextEntry (anEntry);\n            while ((bytesIn = fis.read (readBuffer)) != - 1) {\n                zos.write (readBuffer, 0, bytesIn);\n            }\n            fis.close ();\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace ();\n    }\n}\n", "code2": "private static void zipDirectory (String dir2zip, ZipOutputStream zos, String zipPath) throws IOException, IllegalArgumentException {\n    File zipDir = new File (dir2zip);\n    String [] dirList = zipDir.list ();\n    byte [] readBuffer = new byte [2156];\n    int bytesIn = 0;\n    for (int i = 0;\n    i < dirList.length; i ++) {\n        File f = new File (zipDir, dirList [i]);\n        if (f.isDirectory ()) {\n            String filePath = f.getPath ();\n            zipDirectory (filePath, zos, zipPath);\n            continue;\n        }\n        FileInputStream fis = new FileInputStream (f);\n        String path = f.getPath ().substring (zipPath.length ());\n        ZipEntry anEntry = new ZipEntry (path);\n        zos.putNextEntry (anEntry);\n        while ((bytesIn = fis.read (readBuffer)) != - 1) {\n            zos.write (readBuffer, 0, bytesIn);\n        }\n        fis.close ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 217484, "method2_id": 254725, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 7464991, "method2_id": 20955452, "code1": "public void criarQuestaoDiscursiva (QuestaoDiscursiva q) throws SQLException {\n    PreparedStatement stmt = null;\n    String sql = \"INSERT INTO discursiva (id_questao,gabarito) VALUES (?,?)\";\n    try {\n        stmt = conexao.prepareStatement (sql);\n        stmt.setInt (1, q.getIdQuestao ());\n        stmt.setString (2, q.getGabarito ());\n        stmt.executeUpdate ();\n        conexao.commit ();\n    } catch (SQLException e) {\n        conexao.rollback ();\n        throw e;\n    }\n}\n", "code2": "private void criarQuestaoMultiplaEscolha (QuestaoMultiplaEscolha q) throws SQLException {\n    PreparedStatement stmt = null;\n    String sql = \"INSERT INTO multipla_escolha (id_questao, texto, gabarito) VALUES (?,?,?)\";\n    try {\n        for (Alternativa alternativa : q.getAlternativa ()) {\n            stmt = conexao.prepareStatement (sql);\n            stmt.setInt (1, q.getIdQuestao ());\n            stmt.setString (2, alternativa.getTexto ());\n            stmt.setBoolean (3, alternativa.getGabarito ());\n            stmt.executeUpdate ();\n            conexao.commit ();\n        }\n    } catch (SQLException e) {\n        conexao.rollback ();\n        throw e;\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 6856298, "method2_id": 14988339, "code1": "public static void copyFile (File from, File to) throws IOException {\n    ensureFile (to);\n    FileChannel srcChannel = new FileInputStream (from).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (to).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n", "code2": "public void copyTo (String newname) throws IOException {\n    FileChannel srcChannel = new FileInputStream (dosname).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (newname).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 7034031, "method2_id": 19849797, "code1": "private void copyFile (File sourceFile, File destFile) throws IOException {\n    if (log.isDebugEnabled ()) {\n        log.debug (\"CopyFile : Source[\" + sourceFile.getAbsolutePath () + \"] Dest[\" + destFile.getAbsolutePath () + \"]\");\n    }\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 7761195, "method2_id": 15088608, "code1": "public synchronized String encrypt (String plaintext) throws Exception {\n    StringBuffer sb = new StringBuffer ();\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"SHA-512\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new Exception (e.getMessage ());\n    }\n    try {\n        md.update (plaintext.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        throw new Exception (e.getMessage ());\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n", "code2": "public synchronized String encrypt (String plaintext) {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"SHA1\");\n    } catch (NoSuchAlgorithmException noSuchAlgorithmException) {\n        noSuchAlgorithmException.printStackTrace ();\n    }\n    try {\n        md.update (plaintext.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException unsupportedEncodingException) {\n        unsupportedEncodingException.printStackTrace ();\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n"}
{"clone_type": "ST3", "method1_id": 11604443, "method2_id": 14887616, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer (128);\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        logger.error (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer (32);\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & TWO_BYTES;\n            if (b < PAD_BELOW) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        logger.error (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 20507335, "method2_id": 21343235, "code1": "private static void doZip (ZipOutputStream out, File f, String base, FilenameFilter filter) throws Exception {\n    if (f.isDirectory ()) {\n        File [] fl = f.listFiles (filter);\n        out.putNextEntry (new ZipEntry (base + \"/\"));\n        base = base.length () == 0 ? \"\" : base + \"/\";\n        for (int i = 0;\n        i < fl.length; i ++) {\n            doZip (out, fl [i], base + fl [i].getName (), filter);\n        }\n    } else {\n        out.putNextEntry (new ZipEntry (base));\n        FileInputStream in = new FileInputStream (f);\n        int b;\n        System.out.println (base);\n        while ((b = in.read ()) != - 1) {\n            out.write (b);\n        }\n        in.close ();\n    }\n}\n", "code2": "private static void zip (ZipOutputStream out, File file, String base) throws Exception {\n    if (file.isDirectory ()) {\n        File [] fl = file.listFiles ();\n        base = base.length () == 0 ? \"\" : base + File.separator;\n        for (int i = 0;\n        i < fl.length; i ++) {\n            zip (out, fl [i], base + fl [i].getName ());\n        }\n    } else {\n        out.putNextEntry (new ZipEntry (base));\n        log.debug (\"\u6dfb\u52a0\u538b\u7f29\u6587\u4ef6\uff1a\" + base);\n        FileInputStream in = new FileInputStream (file);\n        int b;\n        while ((b = in.read ()) != - 1) {\n            out.write (b);\n        }\n        in.close ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 3318214, "method2_id": 19883483, "code1": "void copyFile (String sInput, String sOutput) throws IOException {\n    File inputFile = new File (sInput);\n    File outputFile = new File (sOutput);\n    FileReader in = new FileReader (inputFile);\n    FileWriter out = new FileWriter (outputFile);\n    int c;\n    while ((c = in.read ()) != - 1) out.write (c);\n\n    in.close ();\n    out.close ();\n}\n", "code2": "public static void copy (String file1, String file2) throws IOException {\n    File inputFile = new File (file1);\n    File outputFile = new File (file2);\n    FileReader in = new FileReader (inputFile);\n    FileWriter out = new FileWriter (outputFile);\n    System.out.println (\"Copy file from: \" + file1 + \" to: \" + file2);\n    int c;\n    while ((c = in.read ()) != - 1) out.write (c);\n\n    in.close ();\n    out.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 4716110, "method2_id": 19685311, "code1": "public static void copyFile (File in, File out) throws Exception {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n", "code2": "public static void copyFile (File inputFile, File outputFile) throws IOException {\n    FileChannel srcChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (outputFile).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 614099, "method2_id": 810342, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 5132884, "method2_id": 6633988, "code1": "public byte [] encryptMsg (String encryptString) {\n    byte [] encryptByte = null;\n    try {\n        MessageDigest messageDigest = MessageDigest.getInstance (\"MD5\");\n        messageDigest.update (encryptString.getBytes ());\n        encryptByte = messageDigest.digest ();\n    } catch (NoSuchAlgorithmException ex) {\n        ex.printStackTrace ();\n    }\n    return encryptByte;\n}\n", "code2": "public byte [] generatePassword (String clave) {\n    byte [] password = {00};\n    try {\n        MessageDigest md5 = MessageDigest.getInstance (\"MD5\");\n        md5.update (clave.getBytes ());\n        password = md5.digest ();\n        return password;\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace ();\n    }\n    return password;\n}\n"}
{"clone_type": "ST3", "method1_id": 16324741, "method2_id": 17727663, "code1": "public static void copyFiles (File source, File dest) throws IOException {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n", "code2": "private static void copy (String sourceName, String destName) throws IOException {\n    File source = new File (sourceName);\n    File dest = new File (destName);\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 537782, "method2_id": 845967, "code1": "public sendhtml (String [] argv) {\n    String to, subject = null, from = null, cc = null, bcc = null, url = null;\n    String mailhost = null;\n    String mailer = \"sendhtml\";\n    String protocol = null, host = null, user = null, password = null;\n    String record = null;\n    boolean debug = false;\n    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n    int optind;\n    for (optind = 0; optind < argv.length; optind ++) {\n        if (argv [optind].equals (\"-T\")) {\n            protocol = argv [++ optind];\n        } else if (argv [optind].equals (\"-H\")) {\n            host = argv [++ optind];\n        } else if (argv [optind].equals (\"-U\")) {\n            user = argv [++ optind];\n        } else if (argv [optind].equals (\"-P\")) {\n            password = argv [++ optind];\n        } else if (argv [optind].equals (\"-M\")) {\n            mailhost = argv [++ optind];\n        } else if (argv [optind].equals (\"-f\")) {\n            record = argv [++ optind];\n        } else if (argv [optind].equals (\"-s\")) {\n            subject = argv [++ optind];\n        } else if (argv [optind].equals (\"-o\")) {\n            from = argv [++ optind];\n        } else if (argv [optind].equals (\"-c\")) {\n            cc = argv [++ optind];\n        } else if (argv [optind].equals (\"-b\")) {\n            bcc = argv [++ optind];\n        } else if (argv [optind].equals (\"-L\")) {\n            url = argv [++ optind];\n        } else if (argv [optind].equals (\"-d\")) {\n            debug = true;\n        } else if (argv [optind].equals (\"--\")) {\n            optind ++;\n            break;\n        } else if (argv [optind].startsWith (\"-\")) {\n            System.out.println (\"Usage: sendhtml [[-L store-url] | [-T prot] [-H host] [-U user] [-P passwd]]\");\n            System.out.println (\"\\t[-s subject] [-o from-address] [-c cc-addresses] [-b bcc-addresses]\");\n            System.out.println (\"\\t[-f record-mailbox] [-M transport-host] [-d] [address]\");\n            System.exit (1);\n        } else {\n            break;\n        }\n\n    }\n    try {\n        if (optind < argv.length) {\n            to = argv [optind];\n            System.out.println (\"To: \" + to);\n        } else {\n            System.out.print (\"To: \");\n            System.out.flush ();\n            to = in.readLine ();\n        }\n        if (subject == null) {\n            System.out.print (\"Subject: \");\n            System.out.flush ();\n            subject = in.readLine ();\n        } else {\n            System.out.println (\"Subject: \" + subject);\n        }\n        Properties props = System.getProperties ();\n        if (mailhost != null) props.put (\"mail.smtp.host\", mailhost);\n\n        Session session = Session.getInstance (props, null);\n        if (debug) session.setDebug (true);\n\n        Message msg = new MimeMessage (session);\n        if (from != null) msg.setFrom (new InternetAddress (from));\n        else msg.setFrom ();\n\n        msg.setRecipients (Message.RecipientType.TO, InternetAddress.parse (to, false));\n        if (cc != null) msg.setRecipients (Message.RecipientType.CC, InternetAddress.parse (cc, false));\n\n        if (bcc != null) msg.setRecipients (Message.RecipientType.BCC, InternetAddress.parse (bcc, false));\n\n        msg.setSubject (subject);\n        collect (in, msg);\n        msg.setHeader (\"X-Mailer\", mailer);\n        msg.setSentDate (new Date ());\n        Transport.send (msg);\n        System.out.println (\"\\nMail was sent successfully.\");\n        if (record != null) {\n            Store store = null;\n            if (url != null) {\n                URLName urln = new URLName (url);\n                store = session.getStore (urln);\n                store.connect ();\n            } else {\n                if (protocol != null) store = session.getStore (protocol);\n                else store = session.getStore ();\n\n                if (host != null || user != null || password != null) store.connect (host, user, password);\n                else store.connect ();\n\n            }\n            Folder folder = store.getFolder (record);\n            if (folder == null) {\n                System.err.println (\"Can't get record folder.\");\n                System.exit (1);\n            }\n            if (! folder.exists ()) folder.create (Folder.HOLDS_MESSAGES);\n\n            Message [] msgs = new Message [1];\n            msgs [0] = msg;\n            folder.appendMessages (msgs);\n            System.out.println (\"Mail was recorded successfully.\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static void main (String [] argv) {\n    String to, subject = null, from = null, cc = null, bcc = null, url = null;\n    String mailhost = null;\n    String mailer = \"msgsend\";\n    String file = null;\n    String protocol = null, host = null, user = null, password = null;\n    String record = null;\n    boolean debug = false;\n    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n    int optind;\n    for (optind = 0; optind < argv.length; optind ++) {\n        if (argv [optind].equals (\"-T\")) {\n            protocol = argv [++ optind];\n        } else if (argv [optind].equals (\"-H\")) {\n            host = argv [++ optind];\n        } else if (argv [optind].equals (\"-U\")) {\n            user = argv [++ optind];\n        } else if (argv [optind].equals (\"-P\")) {\n            password = argv [++ optind];\n        } else if (argv [optind].equals (\"-M\")) {\n            mailhost = argv [++ optind];\n        } else if (argv [optind].equals (\"-f\")) {\n            record = argv [++ optind];\n        } else if (argv [optind].equals (\"-a\")) {\n            file = argv [++ optind];\n        } else if (argv [optind].equals (\"-s\")) {\n            subject = argv [++ optind];\n        } else if (argv [optind].equals (\"-o\")) {\n            from = argv [++ optind];\n        } else if (argv [optind].equals (\"-c\")) {\n            cc = argv [++ optind];\n        } else if (argv [optind].equals (\"-b\")) {\n            bcc = argv [++ optind];\n        } else if (argv [optind].equals (\"-L\")) {\n            url = argv [++ optind];\n        } else if (argv [optind].equals (\"-d\")) {\n            debug = true;\n        } else if (argv [optind].equals (\"--\")) {\n            optind ++;\n            break;\n        } else if (argv [optind].startsWith (\"-\")) {\n            System.out.println (\"Usage: msgsend [[-L store-url] | [-T prot] [-H host] [-U user] [-P passwd]]\");\n            System.out.println (\"\\t[-s subject] [-o from-address] [-c cc-addresses] [-b bcc-addresses]\");\n            System.out.println (\"\\t[-f record-mailbox] [-M transport-host] [-a attach-file] [-d] [address]\");\n            System.exit (1);\n        } else {\n            break;\n        }\n\n    }\n    try {\n        if (optind < argv.length) {\n            to = argv [optind];\n            System.out.println (\"To: \" + to);\n        } else {\n            System.out.print (\"To: \");\n            System.out.flush ();\n            to = in.readLine ();\n        }\n        if (subject == null) {\n            System.out.print (\"Subject: \");\n            System.out.flush ();\n            subject = in.readLine ();\n        } else {\n            System.out.println (\"Subject: \" + subject);\n        }\n        Properties props = System.getProperties ();\n        if (mailhost != null) props.put (\"mail.smtp.host\", mailhost);\n\n        Session session = Session.getInstance (props, null);\n        if (debug) session.setDebug (true);\n\n        Message msg = new MimeMessage (session);\n        if (from != null) msg.setFrom (new InternetAddress (from));\n        else msg.setFrom ();\n\n        msg.setRecipients (Message.RecipientType.TO, InternetAddress.parse (to, false));\n        if (cc != null) msg.setRecipients (Message.RecipientType.CC, InternetAddress.parse (cc, false));\n\n        if (bcc != null) msg.setRecipients (Message.RecipientType.BCC, InternetAddress.parse (bcc, false));\n\n        msg.setSubject (subject);\n        String text = collect (in);\n        if (file != null) {\n            MimeBodyPart mbp1 = new MimeBodyPart ();\n            mbp1.setText (text);\n            MimeBodyPart mbp2 = new MimeBodyPart ();\n            mbp2.attachFile (file);\n            MimeMultipart mp = new MimeMultipart ();\n            mp.addBodyPart (mbp1);\n            mp.addBodyPart (mbp2);\n            msg.setContent (mp);\n        } else {\n            msg.setText (text);\n        }\n        msg.setHeader (\"X-Mailer\", mailer);\n        msg.setSentDate (new Date ());\n        Transport.send (msg);\n        System.out.println (\"\\nMail was sent successfully.\");\n        if (record != null) {\n            Store store = null;\n            if (url != null) {\n                URLName urln = new URLName (url);\n                store = session.getStore (urln);\n                store.connect ();\n            } else {\n                if (protocol != null) store = session.getStore (protocol);\n                else store = session.getStore ();\n\n                if (host != null || user != null || password != null) store.connect (host, user, password);\n                else store.connect ();\n\n            }\n            Folder folder = store.getFolder (record);\n            if (folder == null) {\n                System.err.println (\"Can't get record folder.\");\n                System.exit (1);\n            }\n            if (! folder.exists ()) folder.create (Folder.HOLDS_MESSAGES);\n\n            Message [] msgs = new Message [1];\n            msgs [0] = msg;\n            folder.appendMessages (msgs);\n            System.out.println (\"Mail was recorded successfully.\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 8921716, "method2_id": 16367499, "code1": "public static String MD5 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"MD5\");\n    byte [] md5hash = new byte [32];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    md5hash = md.digest ();\n    return convertToHex (md5hash);\n}\n", "code2": "public static String md5 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"MD5\");\n    byte [] md5hash;\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    md5hash = md.digest ();\n    return convertToHex (md5hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 670011, "method2_id": 7976872, "code1": "public static void copy (String from_name, String to_name) throws IOException {\n    File from_file = new File (from_name);\n    File to_file = new File (to_name);\n    if (! from_file.exists ()) abort (\"FileCopy: no such source file: \" + from_name);\n\n    if (! from_file.isFile ()) abort (\"FileCopy: can't copy directory: \" + from_name);\n\n    if (! from_file.canRead ()) abort (\"FileCopy: source file is unreadable: \" + from_name);\n\n    if (to_file.isDirectory ()) to_file = new File (to_file, from_file.getName ());\n\n    if (to_file.exists ()) {\n        if (! to_file.canWrite ()) abort (\"FileCopy: destination file is unwriteable: \" + to_name);\n\n        System.out.print (\"Overwrite existing file \" + to_name + \"? (Y/N): \");\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) abort (\"FileCopy: existing file was not overwritten.\");\n\n    } else {\n        String parent = to_file.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) abort (\"FileCopy: destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) abort (\"FileCopy: destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) abort (\"FileCopy: destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (from_file);\n        to = new FileOutputStream (to_file);\n        byte [] buffer = new byte [4096];\n        int bytes_read;\n        while ((bytes_read = from.read (buffer)) != - 1) to.write (buffer, 0, bytes_read);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n", "code2": "public static void copy_file (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n        System.out.print (\"Overwrite existing file \" + toFile.getName () + \"? (Y/N): \");\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) throw new IOException (\"FileCopy: \" + \"existing file was not overwritten.\");\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 4921631, "method2_id": 16085716, "code1": "public int create (BusinessObject o) throws DAOException {\n    int insert = 0;\n    int id = 0;\n    Item item = (Item) o;\n    try {\n        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery (\"INSERT_ITEM\"));\n        pst.setString (1, item.getDescription ());\n        pst.setDouble (2, item.getUnit_price ());\n        pst.setInt (3, item.getQuantity ());\n        pst.setDouble (4, item.getVat ());\n        pst.setInt (5, item.getIdProject ());\n        pst.setInt (6, item.getIdCurrency ());\n        insert = pst.executeUpdate ();\n        if (insert <= 0) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows <= 0\");\n        } else if (insert > 1) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows > 1\");\n        }\n\n        Statement st = connection.createStatement ();\n        ResultSet rs = st.executeQuery (\"select max(id_item) from item\");\n        rs.next ();\n        id = rs.getInt (1);\n        connection.commit ();\n    } catch (SQLException e) {\n        Log.write (e.getMessage ());\n        throw new DAOException (\"A SQLException has occured\");\n    } catch (NullPointerException npe) {\n        Log.write (npe.getMessage ());\n        throw new DAOException (\"Connection null\");\n    }\n    return id;\n}\n", "code2": "public int update (BusinessObject o) throws DAOException {\n    int update = 0;\n    Currency curr = (Currency) o;\n    try {\n        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery (\"UPDATE_CURRENCY\"));\n        pst.setString (1, curr.getName ());\n        pst.setInt (2, curr.getIdBase ());\n        pst.setDouble (3, curr.getValue ());\n        pst.setInt (4, curr.getId ());\n        update = pst.executeUpdate ();\n        if (update <= 0) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows <= 0\");\n        } else if (update > 1) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows > 1\");\n        }\n\n        connection.commit ();\n    } catch (SQLException e) {\n        Log.write (e.getMessage ());\n        throw new DAOException (\"A SQLException has occured\");\n    } catch (NullPointerException npe) {\n        Log.write (npe.getMessage ());\n        throw new DAOException (\"Connection null\");\n    }\n    return update;\n}\n"}
{"clone_type": "ST3", "method1_id": 2396214, "method2_id": 17037028, "code1": "public static String toMD5Sum (String arg0) {\n    String ret;\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (arg0.getBytes ());\n        ret = toHexString (md.digest ());\n    } catch (Exception e) {\n        ret = arg0;\n    }\n    return ret;\n}\n", "code2": "private String md5 (String value) {\n    String md5Value = \"1\";\n    try {\n        MessageDigest digest = MessageDigest.getInstance (\"MD5\");\n        digest.update (value.getBytes ());\n        md5Value = getHex (digest.digest ());\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n    return md5Value;\n}\n"}
{"clone_type": "ST3", "method1_id": 1239587, "method2_id": 2233543, "code1": "private void cleanDir (File dir) {\n    File [] files = dir.listFiles ();\n    for (int i = 0;\n    i < files.length; i ++) {\n        if (files [i].isDirectory ()) {\n            cleanDir (files [i]);\n        } else {\n            files [i].delete ();\n        }\n    }\n    dir.delete ();\n}\n", "code2": "private boolean destroyWorkDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                destroyWorkDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n"}
{"clone_type": "ST3", "method1_id": 87685, "method2_id": 574279, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 10689659, "method2_id": 13891080, "code1": "public static void copyFile (File fromFile, File toFile) throws OWFileCopyException {\n    try {\n        FileChannel src = new FileInputStream (fromFile).getChannel ();\n        FileChannel dest = new FileOutputStream (toFile).getChannel ();\n        dest.transferFrom (src, 0, src.size ());\n        src.close ();\n        dest.close ();\n    } catch (IOException e) {\n        throw (new OWFileCopyException (\"An error occurred while copying a file\", e));\n    }\n}\n", "code2": "public static void copyFile (File srcFile, File destFile) throws IOException {\n    logger.debug (\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n    FileChannel srcChannel = new FileInputStream (srcFile).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (destFile).getChannel ();\n    try {\n        dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    } finally {\n        srcChannel.close ();\n        dstChannel.close ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 14489368, "method2_id": 14772409, "code1": "private void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    } else {\n    }\n}\n", "code2": "public static void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n        }\n    } else {\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 910689, "method2_id": 6494291, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private Integer slowFib (int i) {\n    if (i <= 0) return 0;\n\n    if (i == 1) return 1;\n\n    return slowFib (i - 1) + slowFib (i - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 52265, "method2_id": 89955, "code1": "public static void main (String [] argv) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n", "code2": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 6188784, "method2_id": 13783549, "code1": "public static void copy (File source, File dest) throws IOException {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n", "code2": "private static void copy (String sourceName, String destName) throws IOException {\n    File source = new File (sourceName);\n    File dest = new File (destName);\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 18314468, "method2_id": 19523689, "code1": "public static String hash (String str) {\n    MessageDigest summer;\n    try {\n        summer = MessageDigest.getInstance (\"md5\");\n        summer.update (str.getBytes ());\n    } catch (NoSuchAlgorithmException ex) {\n        return null;\n    }\n    BigInteger hash = new BigInteger (1, summer.digest ());\n    String hashword = hash.toString (16);\n    return hashword;\n}\n", "code2": "public static String encodePassword (String password) {\n    MessageDigest md;\n    try {\n        md = MessageDigest.getInstance (\"SHA\");\n        md.update (password.getBytes ());\n        String encodedPassword = new String (md.digest (), new Base64Provider ().charsetForName (\"x-base64\"));\n        return encodedPassword;\n    } catch (NoSuchAlgorithmException e) {\n        return null;\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 11044947, "method2_id": 15831694, "code1": "public static void copyFile (File in, File out, boolean append) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out, append).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 345908, "method2_id": 6494291, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private Integer slowFib (int i) {\n    if (i <= 0) return 0;\n\n    if (i == 1) return 1;\n\n    return slowFib (i - 1) + slowFib (i - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 251963, "method2_id": 319419, "code1": "File createJar (File jar, String...entries) throws IOException {\n    OutputStream out = new FileOutputStream (jar);\n    try {\n        JarOutputStream jos = new JarOutputStream (out);\n        for (String e : entries) {\n            jos.putNextEntry (new JarEntry (getPathForZipEntry (e)));\n            jos.write (getBodyForEntry (e).getBytes ());\n        }\n        jos.close ();\n    } finally {\n        out.close ();\n    }\n    return jar;\n}\n", "code2": "File createJar (String name, String...entries) throws IOException {\n    File jar = new File (name);\n    OutputStream out = new FileOutputStream (jar);\n    try {\n        JarOutputStream jos = new JarOutputStream (out);\n        for (String e : entries) {\n            jos.putNextEntry (new ZipEntry (e));\n            jos.write (e.getBytes ());\n        }\n        jos.close ();\n    } finally {\n        out.close ();\n    }\n    return jar;\n}\n"}
{"clone_type": "ST3", "method1_id": 17663965, "method2_id": 20603726, "code1": "private double [] [] getTransponColumns (double [] [] data) {\n    double [] [] columns = new double [data [0].length] [data.length];\n    for (int i = 0;\n    i < columns.length; i ++) {\n        for (int j = 0;\n        j < columns [0].length; j ++) {\n            columns [i] [j] = data [j] [i];\n        }\n    }\n    return columns;\n}\n", "code2": "public static String [] [] transpose (String [] [] object) {\n    String [] [] transpose = new String [object [0].length] [object.length];\n    for (int i = 0;\n    i < object.length; i ++) {\n        for (int x = 0;\n        x < transpose.length; x ++) {\n            transpose [x] [i] = object [i] [x];\n        }\n    }\n    return transpose;\n}\n"}
{"clone_type": "ST3", "method1_id": 541801, "method2_id": 22324341, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private long fib (long n) {\n    if (n == 0) return 0L;\n\n    if (n == 1) return 1L;\n\n    return fib (n - 1) + fib (n - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 2890392, "method2_id": 22810500, "code1": "public String SHA1 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n", "code2": "public static String MD5 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"MD5\");\n    byte [] md5hash = new byte [32];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    md5hash = md.digest ();\n    return convertToHex (md5hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 12728035, "method2_id": 15768167, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws Exception {\n    FileChannel sourceChannel = null;\n    FileChannel destinationChannel = null;\n    try {\n        sourceChannel = new FileInputStream (in).getChannel ();\n        destinationChannel = new FileOutputStream (out).getChannel ();\n        sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    } finally {\n        if (sourceChannel != null) sourceChannel.close ();\n\n        if (destinationChannel != null) destinationChannel.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 19362432, "method2_id": 19604736, "code1": "public static void zipFiles (String zipFilePath, String [] filenames) {\n    byte [] buf = new byte [1024];\n    try {\n        String outFilename = zipFilePath;\n        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outFilename));\n        for (int i = 0;\n        i < filenames.length; i ++) {\n            File file = new File (filenames [i]);\n            if (file.exists ()) {\n                FileInputStream in = new FileInputStream (filenames [i]);\n                out.putNextEntry (new ZipEntry (filenames [i]));\n                int len;\n                while ((len = in.read (buf)) > 0) {\n                    out.write (buf, 0, len);\n                }\n                out.closeEntry ();\n                in.close ();\n            }\n        }\n        out.close ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public void createZip (String _filesToZip [], String _targetZip) {\n    byte [] buffer = new byte [18024];\n    try {\n        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (_targetZip));\n        out.setLevel (Deflater.DEFAULT_COMPRESSION);\n        for (int i = 0;\n        i < _filesToZip.length; i ++) {\n            FileInputStream in = new FileInputStream (_filesToZip [i]);\n            out.putNextEntry (new ZipEntry (_filesToZip [i]));\n            int len;\n            while ((len = in.read (buffer)) > 0) {\n                out.write (buffer, 0, len);\n            }\n            out.closeEntry ();\n            in.close ();\n        }\n        out.close ();\n    } catch (IllegalArgumentException iae) {\n        iae.printStackTrace ();\n    } catch (FileNotFoundException fnfe) {\n        fnfe.printStackTrace ();\n    } catch (IOException ioe) {\n        ioe.printStackTrace ();\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 843888, "method2_id": 952021, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 7911686, "method2_id": 12728035, "code1": "public static void copyFile (File source, File destination) throws IOException {\n    FileChannel in = null;\n    FileChannel out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (destination).getChannel ();\n        in.transferTo (0, in.size (), out);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 1552000, "method2_id": 2904376, "code1": "private boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n", "code2": "public static void deleteFilesInDirectory (File directory) {\n    if (directory.isDirectory ()) {\n        File [] subfiles = directory.listFiles ();\n        for (int i = 0;\n        i < subfiles.length; i ++) {\n            if (subfiles [i].isFile ()) {\n                subfiles [i].delete ();\n                Assert.assertFalse (subfiles [i].getAbsolutePath (), subfiles [i].exists ());\n            }\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 53204, "method2_id": 842876, "code1": "static long seqFib (int n) {\n    if (n <= 1) return n;\n    else return seqFib (n - 1) + seqFib (n - 2);\n\n}\n", "code2": "public long fib (long n) {\n    if (n <= 1) return n;\n    else return fib (n - 1) + fib (n - 2);\n\n}\n"}
{"clone_type": "ST3", "method1_id": 14284540, "method2_id": 17573230, "code1": "public static void copyAFile (final String entree, final String sortie) {\n    FileChannel in = null;\n    FileChannel out = null;\n    try {\n        in = new FileInputStream (entree).getChannel ();\n        out = new FileOutputStream (sortie).getChannel ();\n        in.transferTo (0, in.size (), out);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    } finally {\n        if (in != null) {\n            try {\n                in.close ();\n            } catch (IOException e) {\n                e.printStackTrace ();\n            }\n        }\n        if (out != null) {\n            try {\n                out.close ();\n            } catch (IOException e) {\n                e.printStackTrace ();\n            }\n        }\n    }\n}\n", "code2": "public static boolean copyFile (String sourceFileName, String destFileName) {\n    FileChannel ic = null;\n    FileChannel oc = null;\n    try {\n        ic = new FileInputStream (sourceFileName).getChannel ();\n        oc = new FileOutputStream (destFileName).getChannel ();\n        ic.transferTo (0, ic.size (), oc);\n        return true;\n    } catch (FileNotFoundException e) {\n        e.printStackTrace ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    } finally {\n        try {\n            ic.close ();\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n        try {\n            oc.close ();\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    }\n    return false;\n}\n"}
{"clone_type": "ST3", "method1_id": 206397, "method2_id": 338138, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 2168610, "method2_id": 20306677, "code1": "public int update (BusinessObject o) throws DAOException {\n    int update = 0;\n    Contact contact = (Contact) o;\n    try {\n        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery (\"UPDATE_CONTACT\"));\n        pst.setString (1, contact.getName ());\n        pst.setString (2, contact.getFirstname ());\n        pst.setString (3, contact.getPhone ());\n        pst.setString (4, contact.getEmail ());\n        if (contact.getAccount () == 0) {\n            pst.setNull (5, java.sql.Types.INTEGER);\n        } else {\n            pst.setInt (5, contact.getAccount ());\n        }\n        pst.setBoolean (6, contact.isArchived ());\n        pst.setInt (7, contact.getId ());\n        update = pst.executeUpdate ();\n        if (update <= 0) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows <= 0\");\n        } else if (update > 1) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows > 1\");\n        }\n\n        connection.commit ();\n    } catch (SQLException e) {\n        Log.write (e.getMessage ());\n        throw new DAOException (\"A SQLException has occured\");\n    } catch (NullPointerException npe) {\n        Log.write (npe.getMessage ());\n        throw new DAOException (\"Connection null\");\n    }\n    return update;\n}\n", "code2": "public int update (BusinessObject o) throws DAOException {\n    int update = 0;\n    Bill bill = (Bill) o;\n    try {\n        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery (\"UPDATE_BILL\"));\n        pst.setInt (1, bill.getId ());\n        update = pst.executeUpdate ();\n        if (update <= 0) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows <= 0\");\n        } else if (update > 1) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows > 1\");\n        }\n\n        connection.commit ();\n    } catch (SQLException e) {\n        Log.write (e.getMessage ());\n        throw new DAOException (\"A SQLException has occured\");\n    } catch (NullPointerException npe) {\n        Log.write (npe.getMessage ());\n        throw new DAOException (\"Connection null\");\n    }\n    return update;\n}\n"}
{"clone_type": "ST3", "method1_id": 1789230, "method2_id": 1789234, "code1": "public static final int binarySearch (Object [] a, Object key, int length) {\n    int x1 = 0;\n    int x2 = length;\n    int i = x2 / 2, c;\n    while (x1 < x2) {\n        c = ((Comparable) a [i]).compareTo (key);\n        if (c == 0) {\n            return i;\n        } else if (c < 0) {\n            x1 = i + 1;\n        } else {\n            x2 = i;\n        }\n\n        i = x1 + (x2 - x1) / 2;\n    }\n    return - 1 * (i + 1);\n}\n", "code2": "public static final int binarySearch (Object [] a, Object key, Comparator cp, int begin, int end) {\n    int x1 = begin;\n    int x2 = end;\n    int i = x1 + (x2 - x1) / 2, c;\n    while (x1 < x2) {\n        c = cp.compare (a [i], key);\n        if (c == 0) {\n            return i;\n        } else if (c < 0) {\n            x1 = i + 1;\n        } else {\n            x2 = i;\n        }\n\n        i = x1 + (x2 - x1) / 2;\n    }\n    return - 1 * (i + 1);\n}\n"}
{"clone_type": "ST3", "method1_id": 6823, "method2_id": 47558, "code1": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://prologdev1:5432/wdb\";\n    final String dbuser = \"guest2\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT value, dataProviderName, placeName, placeGeometry,\" + \"        referencetime, \" + \"        validFrom, validTo, \" + \"        valueParameterName, valueParameterUnit, \" + \"        levelParameterName, levelUnitName, levelFrom, levelTo, \" + \"        dataVersion, confidenceCode, storetime, valueid, valuetype \" + \" FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', \" + \"                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), \" + \"                NULL, \" + \"                array['instant temperature of air'], \" + \"                ( 2, 2, 'distance above ground', 'exact' ), \" + \"                array[-1], \" + \"                NULL::wci.returnOid )\";\n    final String colNames [] = {\"value\", \"dataProviderName\", \"placeName\", \"referencetime\", \"validFrom\", \"validTo\", \"valueParameterName\", \"valueParameterUnit\", \"levelParameterName\", \"levelUnitName\", \"levelFrom\", \"levelTo\"};\n    ResultSet rs = null;\n    try {\n        con.setAutoCommit (false);\n        statement.execute (wdbInit);\n        LargeObjectManager lobj = ((org.postgresql.PGConnection) con).getLargeObjectAPI ();\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            long oid = rs.getLong (\"value\");\n            LargeObject obj = lobj.open (oid, LargeObjectManager.READ);\n            byte buf [] = new byte [obj.size ()];\n            obj.read (buf, 0, obj.size ());\n            obj.close ();\n            System.out.print (\"  BLOB size: \" + buf.length);\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        try {\n            con.commit ();\n            if (rs != null) rs.close ();\n\n        } catch (SQLException ex) {\n            System.out.println (\"EXCEPTION: rs.close: \" + ex);\n        }\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://localhost:5432/wdb\";\n    final String dbuser = \"wcitest\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT * \" + \" FROM wci.read( array['test wci 5'], 'POINT( 10.0 59.0 )', \" + \"                '2009-11-13 00:00:00+00', \" + \"                NULL, \" + \"                array['air temperature', \" + \"                      'air pressure'], \" + \"                NULL, \" + \"                array[-1], \" + \"                NULL::wci.returnFloat )\";\n    final String colNames [] = {\"value\", \"valueParameterName\", \"validTimeFrom\"};\n    ResultSet rs = null;\n    try {\n        statement.execute (wdbInit);\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        if (rs != null) {\n            try {\n                rs.close ();\n            } catch (SQLException ex) {\n                System.out.println (\"EXCEPTION: rs.close: \" + ex);\n            }\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 7143272, "method2_id": 9840907, "code1": "private void copyFile (File in, File out) throws IOException {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n", "code2": "public static final void copyFile (File source, File destination) throws IOException {\n    FileChannel sourceChannel = new FileInputStream (source).getChannel ();\n    FileChannel targetChannel = new FileOutputStream (destination).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), targetChannel);\n    sourceChannel.close ();\n    targetChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 401685, "method2_id": 430406, "code1": "public void elimina (Pedido pe) throws errorSQL, errorConexionBD {\n    System.out.println (\"GestorPedido.elimina()\");\n    int id = pe.getId ();\n    String sql;\n    Statement stmt = null;\n    try {\n        gd.begin ();\n        sql = \"DELETE FROM pedido WHERE id=\" + id;\n        System.out.println (\"Ejecutando: \" + sql);\n        stmt = gd.getConexion ().createStatement ();\n        stmt.executeUpdate (sql);\n        System.out.println (\"executeUpdate\");\n        gd.commit ();\n        System.out.println (\"commit\");\n        stmt.close ();\n    } catch (SQLException e) {\n        gd.rollback ();\n        throw new errorSQL (e.toString ());\n    } catch (errorConexionBD e) {\n        System.err.println (\"Error en GestorPedido.elimina(): \" + e);\n    } catch (errorSQL e) {\n        System.err.println (\"Error en GestorPedido.elimina(): \" + e);\n    }\n}\n", "code2": "public void elimina (Cliente cli) throws errorSQL, errorConexionBD {\n    System.out.println (\"GestorCliente.elimina()\");\n    int id = cli.getId ();\n    String sql;\n    Statement stmt = null;\n    try {\n        gd.begin ();\n        sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n        System.out.println (\"Ejecutando: \" + sql);\n        stmt = gd.getConexion ().createStatement ();\n        stmt.executeUpdate (sql);\n        System.out.println (\"executeUpdate\");\n        sql = \"DELETE FROM persona WHERE id =\" + id;\n        System.out.println (\"Ejecutando: \" + sql);\n        stmt.executeUpdate (sql);\n        gd.commit ();\n        System.out.println (\"commit\");\n        stmt.close ();\n    } catch (SQLException e) {\n        gd.rollback ();\n        throw new errorSQL (e.toString ());\n    } catch (errorConexionBD e) {\n        System.err.println (\"Error en GestorCliente.elimina(): \" + e);\n    } catch (errorSQL e) {\n        System.err.println (\"Error en GestorCliente.elimina(): \" + e);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 91501, "method2_id": 150662, "code1": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    cache = null;\n    znames = new Hashtable ();\n    TSIGs = new Hashtable ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.equals (\"primary\")) addZone (st.nextToken ());\n        else if (keyword.equals (\"cache\")) cache = new Cache (st.nextToken ());\n        else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n\n    }\n    if (cache == null) {\n        System.out.println (\"no cache specified\");\n        System.exit (- 1);\n    }\n    addUDP ((short) 12345);\n    addTCP ((short) 12345);\n}\n", "code2": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    boolean started = false;\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    cache = null;\n    znames = new Hashtable ();\n    TSIGs = new Hashtable ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken ());\n\n        if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) cache = new Cache (st.nextToken ());\n        else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) {\n            short port = Short.parseShort (st.nextToken ());\n            addUDP (port);\n            addTCP (port);\n            started = true;\n        }\n\n    }\n    if (cache == null) {\n        System.out.println (\"no cache specified\");\n        System.exit (- 1);\n    }\n    if (! started) {\n        addUDP ((short) 53);\n        addTCP ((short) 53);\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 607094, "method2_id": 19869683, "code1": "public static String MD5 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"MD5\");\n    byte [] md5hash = new byte [32];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    md5hash = md.digest ();\n    return convertToHex (md5hash);\n}\n", "code2": "public static String MD5 (byte [] data) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    String text = convertToHex (data);\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"MD5\");\n    byte [] md5hash = new byte [32];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    md5hash = md.digest ();\n    return convertToHex (md5hash);\n}\n"}
{"clone_type": "ST3", "method1_id": 7436917, "method2_id": 12962394, "code1": "public IntChoiceFromSet randomize () {\n    for (int i = values.length - 1;\n    i > 0; i --) {\n        int j = random.nextInt (i + 1);\n        String tmp = values [i];\n        values [i] = values [j];\n        values [j] = tmp;\n    }\n    return this;\n}\n", "code2": "public final void randomize (int [] index, Random random) {\n    for (int j = index.length - 1;\n    j > 0; j --) {\n        int k = random.nextInt (j + 1);\n        int temp = index [j];\n        index [j] = index [k];\n        index [k] = temp;\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 881839, "method2_id": 22324341, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private long fib (long n) {\n    if (n == 0) return 0L;\n\n    if (n == 1) return 1L;\n\n    return fib (n - 1) + fib (n - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 6987642, "method2_id": 18314468, "code1": "public static String encodePassword (String password) {\n    MessageDigest md;\n    try {\n        md = MessageDigest.getInstance (\"SHA\");\n        md.update (password.getBytes ());\n        String encodedPassword = new String (md.digest (), new Base64Provider ().charsetForName (\"x-base64\"));\n        return encodedPassword;\n    } catch (NoSuchAlgorithmException e) {\n        return null;\n    }\n}\n", "code2": "public static String hash (String str) {\n    MessageDigest summer;\n    try {\n        summer = MessageDigest.getInstance (\"md5\");\n        summer.update (str.getBytes ());\n    } catch (NoSuchAlgorithmException ex) {\n        return null;\n    }\n    BigInteger hash = new BigInteger (1, summer.digest ());\n    String hashword = hash.toString (16);\n    return hashword;\n}\n"}
{"clone_type": "ST3", "method1_id": 53204, "method2_id": 155209, "code1": "static long seqFib (int n) {\n    if (n <= 1) return n;\n    else return seqFib (n - 1) + seqFib (n - 2);\n\n}\n", "code2": "public long fib (long n) {\n    if (n <= 1) return n;\n    else return fib (n - 1) + fib (n - 2);\n\n}\n"}
{"clone_type": "ST3", "method1_id": 13783549, "method2_id": 22919520, "code1": "private static void copy (String sourceName, String destName) throws IOException {\n    File source = new File (sourceName);\n    File dest = new File (destName);\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n", "code2": "public static void copyFile (String sourceFilePath, String destFilePath) throws IOException {\n    FileChannel in = null;\n    FileChannel out = null;\n    try {\n        in = new FileInputStream (sourceFilePath).getChannel ();\n        out = new FileOutputStream (destFilePath).getChannel ();\n        long inputSize = in.size ();\n        in.transferTo (0, inputSize, out);\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, inputSize);\n        out.write (buf);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 821503, "method2_id": 6234218, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private long fib (long n) {\n    if (n == 0) return 0L;\n\n    if (n == 1) return 1L;\n\n    return fib (n - 1) + fib (n - 2);\n}\n"}
{"clone_type": "ST3", "method1_id": 2418918, "method2_id": 13783549, "code1": "public static void copyFile (File source, File dest) throws IOException {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n", "code2": "private static void copy (String sourceName, String destName) throws IOException {\n    File source = new File (sourceName);\n    File dest = new File (destName);\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 108845, "method2_id": 562437, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "ST3", "method1_id": 1490117, "method2_id": 4716110, "code1": "private static void copy (File source, File target) throws IOException {\n    FileChannel sourceChannel = new FileInputStream (source).getChannel ();\n    FileChannel targetChannel = new FileOutputStream (target).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), targetChannel);\n    sourceChannel.close ();\n    targetChannel.close ();\n}\n", "code2": "public static void copyFile (File in, File out) throws Exception {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 986079, "method2_id": 5236784, "code1": "public static int [] [] mergeColumns (int []...x) {\n    int [] [] array = new int [x [0].length] [x.length];\n    for (int i = 0;\n    i < array.length; i ++) {\n        for (int j = 0;\n        j < array [i].length; j ++) {\n            array [i] [j] = x [j] [i];\n        }\n    }\n    return array;\n}\n", "code2": "public static double [] [] calcTranspose (double [] [] mat) {\n    double [] [] transpose = new double [mat [0].length] [mat.length];\n    for (int a = 0;\n    a < transpose.length; a ++) {\n        for (int b = 0;\n        b < transpose [0].length; b ++) {\n            transpose [a] [b] = mat [b] [a];\n        }\n    }\n    return transpose;\n}\n"}
{"clone_type": "ST3", "method1_id": 6171420, "method2_id": 22271237, "code1": "public static void copyFile (File sourceFile, File destFile) throws IOException {\n    log.info (\"Copying file '\" + sourceFile + \"' to '\" + destFile + \"'\");\n    if (! sourceFile.isFile ()) {\n        throw new IllegalArgumentException (\"The sourceFile '\" + sourceFile + \"' does not exist or is not a normal file.\");\n    }\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        long numberOfBytes = destination.transferFrom (source, 0, source.size ());\n        log.debug (\"Transferred \" + numberOfBytes + \" bytes from '\" + sourceFile + \"' to '\" + destFile + \"'.\");\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public static void copy (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "ST3", "method1_id": 2537400, "method2_id": 7707971, "code1": "public static double [] [] mergeColumns (double []...x) {\n    double [] [] array = new double [x [0].length] [x.length];\n    for (int i = 0;\n    i < array.length; i ++) {\n        for (int j = 0;\n        j < array [i].length; j ++) {\n            array [i] [j] = x [j] [i];\n        }\n    }\n    return array;\n}\n", "code2": "public static double [] [] transpose (double [] [] matrix) {\n    double [] [] result = new double [matrix.length] [matrix [0].length];\n    for (int i = 0;\n    i < matrix.length; i ++) {\n        for (int j = 0;\n        j < matrix [i].length; j ++) {\n            result [i] [j] = matrix [j] [i];\n        }\n    }\n    return result;\n}\n"}
{"clone_type": "ST3", "method1_id": 16098010, "method2_id": 19582152, "code1": "public static void copyFile (String src, String target) throws IOException {\n    FileChannel ic = new FileInputStream (src).getChannel ();\n    FileChannel oc = new FileOutputStream (target).getChannel ();\n    ic.transferTo (0, ic.size (), oc);\n    ic.close ();\n    oc.close ();\n}\n", "code2": "private void copyFile (File source, File target) throws IOException {\n    FileChannel srcChannel = new FileInputStream (source).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (target).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n"}
{"clone_type": "ST3", "method1_id": 266990, "method2_id": 12524506, "code1": "public static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public static void copyFile (File in, File outDir) throws IOException {\n    FileChannel sourceChannel = null;\n    FileChannel destinationChannel = null;\n    try {\n        sourceChannel = new FileInputStream (in).getChannel ();\n        File out = new File (outDir, in.getName ());\n        destinationChannel = new FileOutputStream (out).getChannel ();\n        sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    } finally {\n        try {\n            if (sourceChannel != null) {\n                sourceChannel.close ();\n            }\n        } finally {\n            if (destinationChannel != null) {\n                destinationChannel.close ();\n            }\n        }\n    }\n}\n"}
