{"clone_type": "VST3", "method1_id": 539275, "method2_id": 880167, "code1": "void run () throws Exception {\n    File javaHome = new File (System.getProperty (\"java.home\"));\n    if (javaHome.getName ().equals (\"jre\")) javaHome = javaHome.getParentFile ();\n\n    File javadoc = new File (new File (javaHome, \"bin\"), \"javadoc\");\n    File testSrc = new File (System.getProperty (\"test.src\"));\n    String thisClassName = TestStdDoclet.class.getName ();\n    Process p = new ProcessBuilder ().command (javadoc.getPath (), \"-J-Xbootclasspath:\" + System.getProperty (\"sun.boot.class.path\"), \"-package\", new File (testSrc, thisClassName + \".java\").getPath ()).redirectErrorStream (true).start ();\n    int actualDocletWarnCount = 0;\n    int reportedDocletWarnCount = 0;\n    BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));\n    try {\n        String line;\n        while ((line = in.readLine ()) != null) {\n            System.err.println (line);\n            if (line.contains (\"DoesNotExist\")) actualDocletWarnCount ++;\n\n            if (line.matches (\"[0-9]+ warning(s)?\")) reportedDocletWarnCount = Integer.valueOf (line.substring (0, line.indexOf (\" \")));\n\n        }\n    } finally {\n        in.close ();\n    }\n    int rc = p.waitFor ();\n    if (rc != 0) System.err.println (\"javadoc failed, rc:\" + rc);\n\n    int expectedDocletWarnCount = 2;\n    checkEqual (\"actual\", actualDocletWarnCount, \"expected\", expectedDocletWarnCount);\n    checkEqual (\"actual\", actualDocletWarnCount, \"reported\", reportedDocletWarnCount);\n}\n", "code2": "void run () throws Exception {\n    File javaHome = new File (System.getProperty (\"java.home\"));\n    if (javaHome.getName ().equals (\"jre\")) javaHome = javaHome.getParentFile ();\n\n    File javadoc = new File (new File (javaHome, \"bin\"), \"javadoc\");\n    File testSrc = new File (System.getProperty (\"test.src\"));\n    File testClasses = new File (System.getProperty (\"test.classes\"));\n    String thisClassName = TestUserDoclet.class.getName ();\n    Process p = new ProcessBuilder ().command (javadoc.getPath (), \"-J-Xbootclasspath:\" + System.getProperty (\"sun.boot.class.path\"), \"-doclet\", thisClassName, \"-docletpath\", testClasses.getPath (), new File (testSrc, thisClassName + \".java\").getPath ()).redirectErrorStream (true).start ();\n    int actualDocletWarnCount = 0;\n    int reportedDocletWarnCount = 0;\n    BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));\n    try {\n        String line;\n        while ((line = in.readLine ()) != null) {\n            System.err.println (line);\n            if (line.contains (docletWarning)) actualDocletWarnCount ++;\n\n            if (line.matches (\"[0-9]+ warning(s)?\")) reportedDocletWarnCount = Integer.valueOf (line.substring (0, line.indexOf (\" \")));\n\n        }\n    } finally {\n        in.close ();\n    }\n    int rc = p.waitFor ();\n    if (rc != 0) System.err.println (\"javadoc failed, rc:\" + rc);\n\n    int expectedDocletWarnCount = 1;\n    checkEqual (\"actual\", actualDocletWarnCount, \"expected\", expectedDocletWarnCount);\n    checkEqual (\"actual\", actualDocletWarnCount, \"reported\", reportedDocletWarnCount);\n}\n"}
{"clone_type": "VST3", "method1_id": 12039034, "method2_id": 12039036, "code1": "public static ArrayList < RoleName > importRoles (String urlString) {\n    ArrayList < RoleName > results = new ArrayList < RoleName > ();\n    try {\n        URL url = new URL (urlString);\n        BufferedReader in = new BufferedReader (new InputStreamReader (url.openStream ()));\n        StringBuffer buff = new StringBuffer ();\n        String line;\n        while ((line = in.readLine ()) != null) {\n            buff.append (line);\n            if (line.equals (\"</RoleName>\")) {\n                RoleName name = ProfileParser.parseRoleName (buff.toString ());\n                results.add (name);\n                buff = new StringBuffer ();\n            } else {\n                buff.append (NL);\n            }\n        }\n    } catch (MalformedURLException e) {\n    } catch (IOException e) {\n    } catch (ParsingException e) {\n    }\n    return results;\n}\n", "code2": "public static ArrayList < Credential > importCredentials (String urlString) {\n    ArrayList < Credential > results = new ArrayList < Credential > ();\n    try {\n        URL url = new URL (urlString);\n        BufferedReader in = new BufferedReader (new InputStreamReader (url.openStream ()));\n        StringBuffer buff = new StringBuffer ();\n        String line;\n        while ((line = in.readLine ()) != null) {\n            buff.append (line);\n            if (line.equals (\"-----END PGP SIGNATURE-----\")) {\n                Credential credential = ProfileParser.parseCredential (buff.toString (), true);\n                results.add (credential);\n                buff = new StringBuffer ();\n            } else {\n                buff.append (NL);\n            }\n        }\n    } catch (MalformedURLException e) {\n    } catch (IOException e) {\n    } catch (ParsingException e) {\n        System.err.println (e);\n    }\n    return results;\n}\n"}
{"clone_type": "VST3", "method1_id": 4542075, "method2_id": 12194043, "code1": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n", "code2": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class < ? > compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n"}
{"clone_type": "VST3", "method1_id": 7460370, "method2_id": 21488868, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 423437, "method2_id": 492571, "code1": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setCstrvar (\"Goodbye\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n", "code2": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n"}
{"clone_type": "VST3", "method1_id": 326712, "method2_id": 365522, "code1": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Short (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Short.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Short ((short) 53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            short port = ((Short) iport.next ()).shortValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Integer (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Integer (53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            int port = ((Integer) iport.next ()).intValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n"}
{"clone_type": "VST3", "method1_id": 12744653, "method2_id": 23243320, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) {\n                sb.append ('0');\n            }\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 18070589, "method2_id": 22303544, "code1": "@Test\npublic void testWriteAndReadSecondLevel () throws Exception {\n    JCFSFileServer server = new JCFSFileServer (defaultTcpPort, defaultTcpAddress, defaultUdpPort, defaultUdpAddress, dir, 0, 0);\n    JCFS.configureDiscovery (defaultUdpAddress, defaultUdpPort);\n    try {\n        server.start ();\n        RFile directory1 = new RFile (\"directory1\");\n        RFile directory2 = new RFile (directory1, \"directory2\");\n        RFile file = new RFile (directory2, \"testreadwrite2nd.txt\");\n        RFileOutputStream out = new RFileOutputStream (file);\n        out.write (\"test\".getBytes (\"utf-8\"));\n        out.close ();\n        RFileInputStream in = new RFileInputStream (file);\n        byte [] buffer = new byte [4];\n        int readCount = in.read (buffer);\n        in.close ();\n        assertEquals (4, readCount);\n        String resultRead = new String (buffer, \"utf-8\");\n        assertEquals (\"test\", resultRead);\n    } finally {\n        server.stop ();\n    }\n}\n", "code2": "@Test\npublic void testWriteAndRead () throws Exception {\n    JCFSFileServer server = new JCFSFileServer (defaultTcpPort, defaultTcpAddress, defaultUdpPort, defaultUdpAddress, dir, 0, 0);\n    JCFS.configureDiscovery (defaultUdpAddress, defaultUdpPort);\n    try {\n        server.start ();\n        RFile file = new RFile (\"testreadwrite.txt\");\n        RFileOutputStream out = new RFileOutputStream (file);\n        out.write (\"test\".getBytes (\"utf-8\"));\n        out.close ();\n        RFileInputStream in = new RFileInputStream (file);\n        byte [] buffer = new byte [4];\n        int readCount = in.read (buffer);\n        in.close ();\n        assertEquals (4, readCount);\n        String resultRead = new String (buffer, \"utf-8\");\n        assertEquals (\"test\", resultRead);\n    } finally {\n        server.stop ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 548504, "method2_id": 873958, "code1": "private void scanAll (HTTPurl urlData, OutputStream outStream) throws Exception {\n    int country = 0;\n    int region = 0;\n    try {\n        country = Integer.parseInt (urlData.getParameter (\"country\"));\n        region = Integer.parseInt (urlData.getParameter (\"region\"));\n    } catch (Exception e) {\n        throw new Exception (\"country or region code not valid: \" + e.toString ());\n    }\n    PageTemplate template = new PageTemplate (store.getProperty (\"path.template\") + File.separator + \"channelscan.html\");\n    outStream.write (template.getPageBytes ());\n    CaptureDeviceList devList = CaptureDeviceList.getInstance ();\n    if (devList.getActiveDeviceCount () > 0) {\n        outStream.write (\"Can not scan channels, Captures Running!\".getBytes ());\n        return;\n    }\n    if (devList.getDeviceCount () == 0) {\n        outStream.write (\"No Devices Available!\".getBytes ());\n        return;\n    }\n    String out = \"<form action=\\\"/servlet/\" + urlData.getServletClass () + \"\\\" method=\\\"POST\\\" accept-charset=\\\"UTF-8\\\">\\n\" + \"<input type=\\\"hidden\\\" name=\\\"action\\\" value='05'>\\n\";\n    outStream.write (out.getBytes ());\n    outStream.flush ();\n    ChannelList list = new ChannelList (store.getProperty (\"path.data\") + File.separator + \"stationdata.list\");\n    Channel [] channelList = list.getStations (country, region);\n    list.close ();\n    try {\n        int channelCount = 0;\n        Channel ch = null;\n        for (int x = 0;\n        x < channelList.length; x ++) {\n            int channelsFound = 0;\n            ch = channelList [x];\n            if (ch != null) {\n                StringBuffer buff = new StringBuffer (2048);\n                buff.append (\"<table class='channelScanResult'>\\n\");\n                buff.append (\"<tr class=\\\"scanChannelHeading\\\">\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingDataName\\\">\" + ch.getName () + \"</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Program</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Video</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Audio</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Add</td>\\n\");\n                buff.append (\"</tr>\\n\");\n                if (x > 0) Thread.sleep (5000);\n\n                CaptureDevice cap = (CaptureDevice) devList.getDevice (0);\n                String scanCommand = \"scan.exe \" + ch.getFrequency () + \" \" + ch.getBandWidth () + \" \\\"\" + cap.getID () + \"\\\"\";\n                System.out.println (\"Running channel scan command: \" + scanCommand);\n                Runtime runner = Runtime.getRuntime ();\n                String [] com = new String [4];\n                com [0] = \"scan.exe\";\n                com [1] = new Integer (ch.getFrequency ()).toString ();\n                com [2] = new Integer (ch.getBandWidth ()).toString ();\n                com [3] = \"\\\"\" + cap.getID () + \"\\\"\";\n                Process scan = runner.exec (com);\n                ScanResult result = new ScanResult (ch.getFrequency (), ch.getBandWidth ());\n                result.readInput (scan.getInputStream ());\n                result.parseXML ();\n                Vector scanResult = result.getResult ();\n                Channel chData = null;\n                for (int y = 0;\n                y < scanResult.size (); y ++) {\n                    chData = (Channel) scanResult.get (y);\n                    if (chData != null) {\n                        buff.append (\"<tr class='scanChannelResult'>\");\n                        buff.append (\"<td>\\n<input type='text' name='name\" + channelCount + \"' value='\" + checkName (chData.getName ()) + \"'>\\n\");\n                        buff.append (\"<input type='hidden' name='freq\" + channelCount + \"' value='\" + chData.getFrequency () + \"'>\\n\");\n                        buff.append (\"<input type='hidden' name='band\" + channelCount + \"' value='\" + chData.getBandWidth () + \"'>\\n\");\n                        buff.append (\"</td>\\n\\n\");\n                        buff.append (\"<td align='center'>\" + chData.getProgramID ());\n                        buff.append (\"<input type='hidden' name='programid\" + channelCount + \"' value='\" + chData.getProgramID () + \"'>\\n\");\n                        buff.append (\"</td>\\n\");\n                        buff.append (\"<td align='center'>\");\n                        int count = getStreamTypeCount (chData, Channel.TYPE_VIDEO);\n                        if (count == 0) {\n                            buff.append (\"-1\");\n                            buff.append (\"<input type='hidden' name='videoid\" + channelCount + \"' value='-1'>\\n\");\n                        }\n                        if (count == 1) {\n                            int [] data = getFirstOfType (chData, Channel.TYPE_VIDEO);\n                            buff.append (data [0]);\n                            buff.append (\"<input type='hidden' name='videoid\" + channelCount + \"' value='\" + data [0] + \"'>\\n\");\n                        } else if (count > 1) {\n                            buff.append (\"<SELECT NAME='videoid\" + channelCount + \"'>\\n\");\n                            for (int st = 0;\n                            st < chData.getStreams ().size (); st ++) {\n                                int [] streamData = (int []) chData.getStreams ().get (st);\n                                if (streamData [1] == Channel.TYPE_VIDEO) {\n                                    buff.append (\"<OPTION value=\\\"\" + streamData [0] + \"\\\">\");\n                                    buff.append (streamData [0]);\n                                    buff.append (\"</OPTION>\\n\");\n                                }\n                            }\n                            buff.append (\"</SELECT>\");\n                        }\n\n                        buff.append (\"</td>\\n\");\n                        buff.append (\"<td align='center'>\");\n                        count = getStreamTypeCount (chData, Channel.TYPE_AUDIO_AC3);\n                        count += getStreamTypeCount (chData, Channel.TYPE_AUDIO_MPG);\n                        if (count == 0) {\n                            buff.append (\"-1\");\n                            buff.append (\"<input type='hidden' name='audioid\" + channelCount + \"' value='-1'>\\n\");\n                        }\n                        if (count == 1) {\n                            int [] data = getFirstOfType (chData, Channel.TYPE_AUDIO_AC3);\n                            if (data == null) data = getFirstOfType (chData, Channel.TYPE_AUDIO_MPG);\n\n                            buff.append (data [0]);\n                            if (data [1] == Channel.TYPE_AUDIO_AC3) buff.append (\" AC3\");\n                            else buff.append (\" MPG\");\n\n                            buff.append (\"<input type='hidden' name='audioid\" + channelCount + \"' value='\" + data [0] + \":\" + data [1] + \"'>\\n\");\n                        } else if (count > 1) {\n                            buff.append (\"<SELECT NAME='audioid\" + channelCount + \"'>\\n\");\n                            for (int st = 0;\n                            st < chData.getStreams ().size (); st ++) {\n                                int [] streamData = (int []) chData.getStreams ().get (st);\n                                if (streamData [1] == Channel.TYPE_AUDIO_MPG || streamData [1] == Channel.TYPE_AUDIO_AC3) {\n                                    buff.append (\"<OPTION value=\\\"\" + streamData [0] + \":\" + streamData [1] + \"\\\">\");\n                                    buff.append (streamData [0]);\n                                    if (streamData [1] == Channel.TYPE_AUDIO_AC3) buff.append (\" AC3\");\n                                    else buff.append (\" MPG\");\n\n                                    buff.append (\"</OPTION>\\n\");\n                                }\n                            }\n                            buff.append (\"</SELECT>\");\n                        }\n\n                        buff.append (\"</td>\\n\");\n                        buff.append (\"<td align='center'><input type='checkbox' name='add\" + channelCount + \"' value='add'></td>\\n\");\n                        buff.append (\"</tr>\\n\\n\");\n                        channelCount ++;\n                        channelsFound ++;\n                    } else {\n                        break;\n                    }\n                }\n                if (channelsFound == 0) {\n                    buff.append (\"<tr class='scanChannelResult'>\");\n                    buff.append (\"<td>No Programs Found</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"</tr>\\n\\n\");\n                }\n                buff.append (\"</table><br>\\n\");\n                outStream.write (buff.toString ().getBytes ());\n                outStream.flush ();\n                outStream.write (\"\\n\\n\\n\\n\\n           \\n\\n\\n\\n\\n\\n\".getBytes ());\n                outStream.flush ();\n            }\n        }\n        if (channelCount > 0) out = \"<input type=\\\"submit\\\" value=\\\"Add Selected\\\"></form></body></html><br><br>\\n\";\n\n        outStream.write (out.getBytes ());\n        outStream.flush ();\n    } catch (Exception e) {\n        throw e;\n    }\n}\n", "code2": "private void scanAll (HTTPurl urlData, OutputStream outStream) throws Exception {\n    int country = 0;\n    int region = 0;\n    try {\n        country = Integer.parseInt (urlData.getParameter (\"country\"));\n        region = Integer.parseInt (urlData.getParameter (\"region\"));\n    } catch (Exception e) {\n        throw new Exception (\"country or region code not valid: \" + e.toString ());\n    }\n    PageTemplate template = new PageTemplate (store.getProperty (\"path.template\").replace ('\\\\', File.separatorChar) + File.separator + \"channelscan.html\");\n    outStream.write (template.getPageBytes ());\n    CaptureDeviceList devList = CaptureDeviceList.getInstance ();\n    if (devList.getActiveDeviceCount () > 0) {\n        outStream.write (\"Can not scan channels, Captures Running!\".getBytes ());\n        return;\n    }\n    if (devList.getDeviceCount () == 0) {\n        outStream.write (\"No Devices Available!\".getBytes ());\n        return;\n    }\n    String out = \"<form action=\\\"/servlet/\" + urlData.getServletClass () + \"\\\" method=\\\"POST\\\" accept-charset=\\\"UTF-8\\\">\\n\" + \"<input type=\\\"hidden\\\" name=\\\"action\\\" value='05'>\\n\";\n    outStream.write (out.getBytes ());\n    outStream.flush ();\n    ChannelList list = new ChannelList (store.getProperty (\"path.data\") + File.separator + \"stationdata.list\");\n    Channel [] channelList = list.getStations (country, region);\n    list.close ();\n    try {\n        int channelCount = 0;\n        Channel ch = null;\n        for (int x = 0;\n        x < channelList.length; x ++) {\n            int channelsFound = 0;\n            ch = channelList [x];\n            if (ch != null) {\n                StringBuffer buff = new StringBuffer (2048);\n                buff.append (\"<table class='channelScanResult'>\\n\");\n                buff.append (\"<tr class=\\\"scanChannelHeading\\\">\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingDataName\\\">\" + ch.getName () + \"</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Program</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Video</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Audio</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Add</td>\\n\");\n                buff.append (\"</tr>\\n\");\n                if (x > 0) Thread.sleep (5000);\n\n                CaptureDevice cap = (CaptureDevice) devList.getDevice (0);\n                String scanCommand = \"scan.exe \" + ch.getFrequency () + \" \" + ch.getBandWidth () + \" \\\"\" + cap.getID () + \"\\\"\";\n                System.out.println (\"Running channel scan command: \" + scanCommand);\n                Runtime runner = Runtime.getRuntime ();\n                String [] com = new String [4];\n                com [0] = \"scan.exe\";\n                com [1] = new Integer (ch.getFrequency ()).toString ();\n                com [2] = new Integer (ch.getBandWidth ()).toString ();\n                com [3] = \"\\\"\" + cap.getID () + \"\\\"\";\n                Process scan = runner.exec (com);\n                ScanResult result = new ScanResult (ch.getFrequency (), ch.getBandWidth ());\n                result.readInput (scan.getInputStream ());\n                result.parseXML ();\n                Vector scanResult = result.getResult ();\n                Channel chData = null;\n                for (int y = 0;\n                y < scanResult.size (); y ++) {\n                    chData = (Channel) scanResult.get (y);\n                    if (chData != null) {\n                        buff.append (\"<tr class='scanChannelResult'>\");\n                        buff.append (\"<td>\\n<input type='text' name='name\" + channelCount + \"' value='\" + checkName (chData.getName ()) + \"'>\\n\");\n                        buff.append (\"<input type='hidden' name='freq\" + channelCount + \"' value='\" + chData.getFrequency () + \"'>\\n\");\n                        buff.append (\"<input type='hidden' name='band\" + channelCount + \"' value='\" + chData.getBandWidth () + \"'>\\n\");\n                        buff.append (\"</td>\\n\\n\");\n                        buff.append (\"<td align='center'>\" + chData.getProgramID ());\n                        buff.append (\"<input type='hidden' name='programid\" + channelCount + \"' value='\" + chData.getProgramID () + \"'>\\n\");\n                        buff.append (\"</td>\\n\");\n                        buff.append (\"<td align='center'>\");\n                        int count = getStreamTypeCount (chData, Channel.TYPE_VIDEO);\n                        if (count == 0) {\n                            buff.append (\"-1\");\n                            buff.append (\"<input type='hidden' name='videoid\" + channelCount + \"' value='-1'>\\n\");\n                        }\n                        if (count == 1) {\n                            int [] data = getFirstOfType (chData, Channel.TYPE_VIDEO);\n                            buff.append (data [0]);\n                            buff.append (\"<input type='hidden' name='videoid\" + channelCount + \"' value='\" + data [0] + \"'>\\n\");\n                        } else if (count > 1) {\n                            buff.append (\"<SELECT NAME='videoid\" + channelCount + \"'>\\n\");\n                            for (int st = 0;\n                            st < chData.getStreams ().size (); st ++) {\n                                int [] streamData = (int []) chData.getStreams ().get (st);\n                                if (streamData [1] == Channel.TYPE_VIDEO) {\n                                    buff.append (\"<OPTION value=\\\"\" + streamData [0] + \"\\\">\");\n                                    buff.append (streamData [0]);\n                                    buff.append (\"</OPTION>\\n\");\n                                }\n                            }\n                            buff.append (\"</SELECT>\");\n                        }\n\n                        buff.append (\"</td>\\n\");\n                        buff.append (\"<td align='center'>\");\n                        count = getStreamTypeCount (chData, Channel.TYPE_AUDIO_AC3);\n                        count += getStreamTypeCount (chData, Channel.TYPE_AUDIO_MPG);\n                        if (count == 0) {\n                            buff.append (\"-1\");\n                            buff.append (\"<input type='hidden' name='audioid\" + channelCount + \"' value='-1'>\\n\");\n                        }\n                        if (count == 1) {\n                            int [] data = getFirstOfType (chData, Channel.TYPE_AUDIO_AC3);\n                            if (data == null) data = getFirstOfType (chData, Channel.TYPE_AUDIO_MPG);\n\n                            buff.append (data [0]);\n                            if (data [1] == Channel.TYPE_AUDIO_AC3) buff.append (\" AC3\");\n                            else buff.append (\" MPG\");\n\n                            buff.append (\"<input type='hidden' name='audioid\" + channelCount + \"' value='\" + data [0] + \":\" + data [1] + \"'>\\n\");\n                        } else if (count > 1) {\n                            buff.append (\"<SELECT NAME='audioid\" + channelCount + \"'>\\n\");\n                            for (int st = 0;\n                            st < chData.getStreams ().size (); st ++) {\n                                int [] streamData = (int []) chData.getStreams ().get (st);\n                                if (streamData [1] == Channel.TYPE_AUDIO_MPG || streamData [1] == Channel.TYPE_AUDIO_AC3) {\n                                    buff.append (\"<OPTION value=\\\"\" + streamData [0] + \":\" + streamData [1] + \"\\\">\");\n                                    buff.append (streamData [0]);\n                                    if (streamData [1] == Channel.TYPE_AUDIO_AC3) buff.append (\" AC3\");\n                                    else buff.append (\" MPG\");\n\n                                    buff.append (\"</OPTION>\\n\");\n                                }\n                            }\n                            buff.append (\"</SELECT>\");\n                        }\n\n                        buff.append (\"</td>\\n\");\n                        buff.append (\"<td align='center'><input type='checkbox' name='add\" + channelCount + \"' value='add'></td>\\n\");\n                        buff.append (\"</tr>\\n\\n\");\n                        channelCount ++;\n                        channelsFound ++;\n                    } else {\n                        break;\n                    }\n                }\n                if (channelsFound == 0) {\n                    buff.append (\"<tr class='scanChannelResult'>\");\n                    buff.append (\"<td>No Programs Found</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"</tr>\\n\\n\");\n                }\n                buff.append (\"</table><br>\\n\");\n                outStream.write (buff.toString ().getBytes ());\n                outStream.flush ();\n                outStream.write (\"\\n\\n\\n\\n\\n           \\n\\n\\n\\n\\n\\n\".getBytes ());\n                outStream.flush ();\n            }\n        }\n        if (channelCount > 0) out = \"<input type=\\\"submit\\\" value=\\\"Add Selected\\\"></form></body></html><br><br>\\n\";\n\n        outStream.write (out.getBytes ());\n        outStream.flush ();\n    } catch (Exception e) {\n        throw e;\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 7169017, "method2_id": 7169018, "code1": "private void download (String fileName, HttpServletResponse response) throws IOException {\n    TelnetInputStream ftpIn = ftpClient_sun.get (fileName);\n    response.setHeader (\"Content-disposition\", \"attachment;filename=\" + URLEncoder.encode (fileName, \"UTF-8\"));\n    OutputStream out = null;\n    try {\n        out = response.getOutputStream ();\n        IOUtils.copy (ftpIn, out);\n    } finally {\n        if (ftpIn != null) {\n            ftpIn.close ();\n        }\n    }\n}\n", "code2": "private void show (String fileName, HttpServletResponse response) throws IOException {\n    TelnetInputStream ftpIn = ftpClient_sun.get (fileName);\n    OutputStream out = null;\n    try {\n        out = response.getOutputStream ();\n        IOUtils.copy (ftpIn, out);\n    } finally {\n        if (ftpIn != null) {\n            ftpIn.close ();\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 279123, "method2_id": 379677, "code1": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n", "code2": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 420464, "method2_id": 627810, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 56285, "method2_id": 173394, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (InetAddress.getByName (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (null);\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                String addrString;\n                addUDP (addr, port);\n                addTCP (addr, port);\n                if (addr == null) addrString = \"0.0.0.0\";\n                else addrString = addr.getHostAddress ();\n\n                System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Integer (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Integer (53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            int port = ((Integer) iport.next ()).intValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n"}
{"clone_type": "VST3", "method1_id": 20806023, "method2_id": 22137915, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 1176194, "method2_id": 2012608, "code1": "private boolean deleteLocalDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteLocalDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n", "code2": "private static boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n"}
{"clone_type": "VST3", "method1_id": 35511, "method2_id": 335919, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 68708, "method2_id": 83588, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Integer (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Integer (53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            int port = ((Integer) iport.next ()).intValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (InetAddress.getByName (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (null);\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                String addrString;\n                addUDP (addr, port);\n                addTCP (addr, port);\n                if (addr == null) addrString = \"0.0.0.0\";\n                else addrString = addr.getHostAddress ();\n\n                System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 11986970, "method2_id": 16540473, "code1": "public void Copy () throws IOException {\n    if (! FileDestination.exists ()) {\n        FileDestination.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (FileSource).getChannel ();\n        destination = new FileOutputStream (FileDestination).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 223122, "method2_id": 761427, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 329965, "method2_id": 385126, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 173394, "method2_id": 201328, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Integer (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Integer (53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            int port = ((Integer) iport.next ()).intValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n", "code2": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Short (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Short.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Short ((short) 53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            short port = ((Short) iport.next ()).shortValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n"}
{"clone_type": "VST3", "method1_id": 2315719, "method2_id": 6138230, "code1": "public TypedObjectChoice randomize () {\n    for (int i = values.length - 1;\n    i > 0; i --) {\n        int j = random.nextInt (i + 1);\n        int tmp = values [i];\n        values [i] = values [j];\n        values [j] = tmp;\n    }\n    return this;\n}\n", "code2": "public DoubleChoiceFromSet randomize () {\n    for (int i = values.length - 1;\n    i > 0; i --) {\n        int j = random.nextInt (i + 1);\n        String tmp = values [i];\n        values [i] = values [j];\n        values [j] = tmp;\n    }\n    return this;\n}\n"}
{"clone_type": "VST3", "method1_id": 17787699, "method2_id": 19474501, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        logger.debug (\"Random GUID error: \" + e.getMessage ());\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 3495460, "method2_id": 8561726, "code1": "public boolean actEstadoEnBD (int idRonda) {\n    int intResult = 0;\n    String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        intResult = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (intResult > 0);\n}\n", "code2": "public boolean actualizarDivisionActual (division div) {\n    int intResult = 0;\n    String sql = \"UPDATE divisionxTorneo \" + \" SET tipoTorneo_idTipoTorneo = \" + div.getidTipoTorneo () + \" , nombreDivision = '\" + div.getnombreDivision () + \"', \" + \" descripcion = '\" + div.getDescripcion () + \"', tipoDesempate = \" + div.getDesempate () + \", \" + \" numFechas = \" + div.getnumFechas () + \" , ptosxbye = \" + div.getPtosxBye () + \" WHERE idDivisionxTorneo = \" + div.getidDivision ();\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        intResult = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (intResult > 0);\n}\n"}
{"clone_type": "VST3", "method1_id": 385126, "method2_id": 891614, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 37335, "method2_id": 331718, "code1": "public static void main (String [] args) {\n    final String version = System.getProperty (\"java.version\");\n    if (version.startsWith (\"1.0\") || version.startsWith (\"1.1\") || version.startsWith (\"1.2\")) {\n        System.err.println (\"\");\n        System.err.print (\"J requires Java 1.3 or later.\");\n        System.err.println (\" (Java 1.4.1 is recommended.)\");\n        System.err.println (\"\");\n        System.exit (1);\n    }\n    try {\n        Class c = Class.forName (\"org.armedbear.j.Editor\");\n        Class [] parameterTypes = new Class [1];\n        parameterTypes [0] = String [].class;\n        Method method = c.getMethod (\"main\", parameterTypes);\n        Object [] parameters = new Object [1];\n        parameters [0] = args;\n        method.invoke (null, parameters);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String version = System.getProperty (\"java.version\");\n    if (version.startsWith (\"1.0\") || version.startsWith (\"1.1\") || version.startsWith (\"1.2\") || version.startsWith (\"1.3\")) {\n        System.err.println (\"\");\n        System.err.print (\"J requires Java 1.4 or later.\");\n        System.err.println (\" (Java 1.4.2 is recommended.)\");\n        System.err.println (\"\");\n        System.exit (1);\n    }\n    try {\n        Class c = Class.forName (\"org.armedbear.j.Editor\");\n        Class [] parameterTypes = new Class [1];\n        parameterTypes [0] = String [].class;\n        Method method = c.getMethod (\"main\", parameterTypes);\n        Object [] parameters = new Object [1];\n        parameters [0] = args;\n        method.invoke (null, parameters);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 321738, "method2_id": 656124, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 10293577, "method2_id": 15166511, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = random.nextLong ();\n        }\n        sbValueBeforeMD5.append (sid);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 151248, "method2_id": 794567, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 6788258, "method2_id": 12744653, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) {\n                sb.append ('0');\n            }\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 80830, "method2_id": 616054, "code1": "private void showReportPage (HTTPurl urlData, OutputStream outStream) throws Exception {\n    String download = urlData.getParameter (\"download\");\n    String id = urlData.getParameter (\"id\");\n    if (download == null || download.length () == 0) {\n        PageTemplate template = new PageTemplate (store.getProperty (\"path.template\").replace ('\\\\', File.separatorChar) + File.separator + \"submit.html\");\n        template.replaceAll (\"$schedule_id\", id);\n        outStream.write (template.getPageBytes ());\n        return;\n    }\n    ScheduleItem si = store.getScheduleItem (id);\n    if (si == null) {\n        String redirect = \"HTTP/1.0 302 Moved Temporarily\\n\";\n        redirect += \"Location: /servlet/ScheduleDataRes\\n\\n\";\n        outStream.write (redirect.getBytes ());\n        return;\n    }\n    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ();\n    ZipOutputStream out = new ZipOutputStream (bytesOut);\n    Vector < String > logFiles = si.getLogFileNames ();\n    for (int x = 0;\n    x < logFiles.size (); x ++) {\n        File log = new File (logFiles.get (x));\n        if (log.exists ()) {\n            out.putNextEntry (new ZipEntry (log.getName ()));\n            byte [] data = new byte [1024];\n            FileInputStream is = new FileInputStream (log);\n            int read = is.read (data);\n            while (read > - 1) {\n                out.write (data, 0, read);\n                read = is.read (data);\n            }\n            out.closeEntry ();\n        }\n    }\n    out.putNextEntry (new ZipEntry (\"ItemLog.txt\"));\n    out.write (si.getLog ().getBytes (\"UTF-8\"));\n    out.closeEntry ();\n    StringBuffer buff = new StringBuffer ();\n    buff.append (\"Name         : \" + si.getName () + \"\\r\\n\");\n    buff.append (\"Start        : \" + si.getStart ().toString () + \"\\r\\n\");\n    buff.append (\"Stop         : \" + si.getStop ().toString () + \"\\r\\n\");\n    buff.append (\"Duration     : \" + si.getDuration () + \"\\r\\n\");\n    buff.append (\"Channel      : \" + si.getChannel () + \"\\r\\n\");\n    buff.append (\"Path Index   : \" + si.getCapturePathIndex () + \"\\r\\n\");\n    buff.append (\"Capture Type : \" + si.getCapType () + \"\\r\\n\");\n    buff.append (\"Filename     : \" + si.getFileName () + \"\\r\\n\");\n    buff.append (\"File Pattern : \" + si.getFilePattern () + \"\\r\\n\");\n    buff.append (\"Keep For     : \" + si.getKeepFor () + \"\\r\\n\");\n    buff.append (\"Post Task    : \" + si.getPostTask () + \"\\r\\n\");\n    buff.append (\"State        : \" + si.getState () + \"\\r\\n\");\n    buff.append (\"Status       : \" + si.getStatus () + \"\\r\\n\");\n    buff.append (\"Type         : \" + si.getType () + \"\\r\\n\");\n    buff.append (\"\\r\\nWarnings:\\r\\n\");\n    Vector < String > warns = si.getWarnings ();\n    for (int x = 0;\n    x < warns.size (); x ++) {\n        buff.append (warns.get (x) + \"\\r\\n\");\n    }\n    buff.append (\"\\r\\n\");\n    buff.append (\"Log Files:\\r\\n\");\n    Vector < String > logs = si.getLogFileNames ();\n    for (int x = 0;\n    x < logs.size (); x ++) {\n        buff.append (logs.get (x) + \"\\r\\n\");\n    }\n    buff.append (\"\\r\\n\");\n    GuideItem item = si.getCreatedFrom ();\n    if (item != null) {\n        buff.append (\"Created From:\\r\\n\");\n        buff.append (\"Name     : \" + item.getName () + \"\\r\\n\");\n        buff.append (\"Start    : \" + item.getStart ().toString () + \"\\r\\n\");\n        buff.append (\"Stop     : \" + item.getStop ().toString () + \"\\r\\n\");\n        buff.append (\"Duration : \" + item.getDuration () + \"\\r\\n\");\n        buff.append (\"\\r\\n\");\n    }\n    HashMap < Date, SignalStatistic > signal = si.getSignalStatistics ();\n    if (signal.size () > 0) {\n        buff.append (\"Signal Statistics: (Locked, Strength, Quality)\\r\\n\");\n        Date [] keys = signal.keySet ().toArray (new Date [0]);\n        for (int x = 0;\n        x < signal.size (); x ++) {\n            SignalStatistic stat = signal.get (keys [x]);\n            buff.append (keys [x].toString () + \" - \" + stat.getLocked () + \", \" + stat.getStrength () + \", \" + stat.getQuality () + \"\\r\\n\");\n        }\n        buff.append (\"\\r\\n\");\n    }\n    out.putNextEntry (new ZipEntry (\"ItemDetails.txt\"));\n    out.write (buff.toString ().getBytes (\"UTF-8\"));\n    out.closeEntry ();\n    out.flush ();\n    out.close ();\n    StringBuffer header = new StringBuffer ();\n    header.append (\"HTTP/1.1 200 OK\\n\");\n    header.append (\"Content-Type: application/zip\\n\");\n    header.append (\"Content-Length: \" + bytesOut.size () + \"\\n\");\n    header.append (\"Content-Disposition: attachment; filename=\\\"ScheduleErrorReport.zip\\\"\\n\");\n    DateFormat df = new SimpleDateFormat (\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\", new Locale (\"En\", \"Us\", \"Unix\"));\n    header.append (\"Last-Modified: \" + df.format (new Date ()) + \"\\n\");\n    header.append (\"\\n\");\n    outStream.write (header.toString ().getBytes ());\n    ByteArrayInputStream zipStream = new ByteArrayInputStream (bytesOut.toByteArray ());\n    byte [] bytes = new byte [4096];\n    int read = zipStream.read (bytes);\n    while (read > - 1) {\n        outStream.write (bytes, 0, read);\n        outStream.flush ();\n        read = zipStream.read (bytes);\n    }\n    return;\n}\n", "code2": "private void showReportPage (HTTPurl urlData, OutputStream outStream) throws Exception {\n    String download = urlData.getParameter (\"download\");\n    String id = urlData.getParameter (\"id\");\n    if (download == null || download.length () == 0) {\n        PageTemplate template = new PageTemplate (store.getProperty (\"path.template\") + File.separator + \"submit.html\");\n        template.replaceAll (\"$schedule_id\", id);\n        outStream.write (template.getPageBytes ());\n        return;\n    }\n    ScheduleItem si = store.getScheduleItem (id);\n    if (si == null) {\n        String redirect = \"HTTP/1.0 302 Moved Temporarily\\n\";\n        redirect += \"Location: /servlet/ScheduleDataRes\\n\\n\";\n        outStream.write (redirect.getBytes ());\n        return;\n    }\n    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ();\n    ZipOutputStream out = new ZipOutputStream (bytesOut);\n    Vector < String > logFiles = si.getLogFileNames ();\n    for (int x = 0;\n    x < logFiles.size (); x ++) {\n        File log = new File (logFiles.get (x));\n        if (log.exists ()) {\n            out.putNextEntry (new ZipEntry (log.getName ()));\n            byte [] data = new byte [1024];\n            FileInputStream is = new FileInputStream (log);\n            int read = is.read (data);\n            while (read > - 1) {\n                out.write (data, 0, read);\n                read = is.read (data);\n            }\n            out.closeEntry ();\n        }\n    }\n    out.putNextEntry (new ZipEntry (\"ItemLog.txt\"));\n    out.write (si.getLog ().getBytes (\"UTF-8\"));\n    out.closeEntry ();\n    StringBuffer buff = new StringBuffer ();\n    buff.append (\"Name         : \" + si.getName () + \"\\r\\n\");\n    buff.append (\"Start        : \" + si.getStart ().toString () + \"\\r\\n\");\n    buff.append (\"Stop         : \" + si.getStop ().toString () + \"\\r\\n\");\n    buff.append (\"Duration     : \" + si.getDuration () + \"\\r\\n\");\n    buff.append (\"Channel      : \" + si.getChannel () + \"\\r\\n\");\n    buff.append (\"Path Index   : \" + si.getCapturePathIndex () + \"\\r\\n\");\n    buff.append (\"Capture Type : \" + si.getCapType () + \"\\r\\n\");\n    buff.append (\"Filename     : \" + si.getFileName () + \"\\r\\n\");\n    buff.append (\"File Pattern : \" + si.getFilePattern () + \"\\r\\n\");\n    buff.append (\"Keep For     : \" + si.getKeepFor () + \"\\r\\n\");\n    buff.append (\"Post Task    : \" + si.getPostTask () + \"\\r\\n\");\n    buff.append (\"State        : \" + si.getState () + \"\\r\\n\");\n    buff.append (\"Status       : \" + si.getStatus () + \"\\r\\n\");\n    buff.append (\"Type         : \" + si.getType () + \"\\r\\n\");\n    buff.append (\"\\r\\nWarnings:\\r\\n\");\n    Vector < String > warns = si.getWarnings ();\n    for (int x = 0;\n    x < warns.size (); x ++) {\n        buff.append (warns.get (x) + \"\\r\\n\");\n    }\n    buff.append (\"\\r\\n\");\n    buff.append (\"Log Files:\\r\\n\");\n    Vector < String > logs = si.getLogFileNames ();\n    for (int x = 0;\n    x < logs.size (); x ++) {\n        buff.append (logs.get (x) + \"\\r\\n\");\n    }\n    buff.append (\"\\r\\n\");\n    GuideItem item = si.getCreatedFrom ();\n    if (item != null) {\n        buff.append (\"Created From:\\r\\n\");\n        buff.append (\"Name     : \" + item.getName () + \"\\r\\n\");\n        buff.append (\"Start    : \" + item.getStart ().toString () + \"\\r\\n\");\n        buff.append (\"Stop     : \" + item.getStop ().toString () + \"\\r\\n\");\n        buff.append (\"Duration : \" + item.getDuration () + \"\\r\\n\");\n        buff.append (\"\\r\\n\");\n    }\n    HashMap < Date, SignalStatistic > signal = si.getSignalStatistics ();\n    if (signal.size () > 0) {\n        buff.append (\"Signal Statistics: (Locked, Strength, Quality)\\r\\n\");\n        Date [] keys = signal.keySet ().toArray (new Date [0]);\n        for (int x = 0;\n        x < signal.size (); x ++) {\n            SignalStatistic stat = signal.get (keys [x]);\n            buff.append (keys [x].toString () + \" - \" + stat.getLocked () + \", \" + stat.getStrength () + \", \" + stat.getQuality () + \"\\r\\n\");\n        }\n        buff.append (\"\\r\\n\");\n    }\n    out.putNextEntry (new ZipEntry (\"ItemDetails.txt\"));\n    out.write (buff.toString ().getBytes (\"UTF-8\"));\n    out.closeEntry ();\n    out.flush ();\n    out.close ();\n    StringBuffer header = new StringBuffer ();\n    header.append (\"HTTP/1.1 200 OK\\n\");\n    header.append (\"Content-Type: application/zip\\n\");\n    header.append (\"Content-Length: \" + bytesOut.size () + \"\\n\");\n    header.append (\"Content-Disposition: attachment; filename=\\\"ScheduleErrorReport.zip\\\"\\n\");\n    DateFormat df = new SimpleDateFormat (\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\", new Locale (\"En\", \"Us\", \"Unix\"));\n    header.append (\"Last-Modified: \" + df.format (new Date ()) + \"\\n\");\n    header.append (\"\\n\");\n    outStream.write (header.toString ().getBytes ());\n    ByteArrayInputStream zipStream = new ByteArrayInputStream (bytesOut.toByteArray ());\n    byte [] bytes = new byte [4096];\n    int read = zipStream.read (bytes);\n    while (read > - 1) {\n        outStream.write (bytes, 0, read);\n        outStream.flush ();\n        read = zipStream.read (bytes);\n    }\n    return;\n}\n"}
{"clone_type": "VST3", "method1_id": 223122, "method2_id": 679416, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 282653, "method2_id": 570699, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 232916, "method2_id": 399007, "code1": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n", "code2": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setCstrvar (\"Goodbye\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n"}
{"clone_type": "VST3", "method1_id": 7460370, "method2_id": 18623183, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 4471001, "method2_id": 7460370, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 4764618, "method2_id": 19388622, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) {\n                sb.append ('0');\n            }\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 666031, "method2_id": 808353, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 760909, "method2_id": 792276, "code1": "public double probeProcessEnergy (int processId) throws RemoteException {\n    float idle_energy = 19;\n    double utiltopower_factor = 0.2394;\n    double cpu_util = 10;\n    String energy = \"\";\n    double total_energy = 0;\n    try {\n        Process P = Runtime.getRuntime ().exec (linuxPath + \"/PidCPU.sh \" + processId);\n        StringBuffer strBuf = new StringBuffer ();\n        String strLine = \"\";\n        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));\n        while ((strLine = outCommand.readLine ()) != null) {\n            energy = strLine;\n        }\n        P.waitFor ();\n        cpu_util = Double.parseDouble (energy);\n        total_energy = utiltopower_factor * cpu_util;\n    } catch (Exception e) {\n        total_energy = - 1;\n        System.out.println (e.getMessage ());\n        e.printStackTrace ();\n    }\n    return total_energy;\n}\n", "code2": "public double probeProcessEnergy (int processId) throws RemoteException {\n    float idle_energy1 = Float.parseFloat (idle_energy);\n    double utiltopower_factor1 = Double.parseDouble (utiltopower_factor);\n    double cpu_util = 10;\n    String energy = \"\";\n    double total_energy = 0;\n    try {\n        Process P = Runtime.getRuntime ().exec (linuxPath + \"/PidCPU.sh \" + processId);\n        StringBuffer strBuf = new StringBuffer ();\n        String strLine = \"\";\n        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));\n        while ((strLine = outCommand.readLine ()) != null) {\n            energy = strLine;\n        }\n        P.waitFor ();\n        cpu_util = Double.parseDouble (energy);\n        total_energy = utiltopower_factor1 * cpu_util;\n    } catch (Exception e) {\n        total_energy = - 1;\n        System.out.println (e.getMessage ());\n        e.printStackTrace ();\n    }\n    return total_energy;\n}\n"}
{"clone_type": "VST3", "method1_id": 6061402, "method2_id": 19643372, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem encoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 83588, "method2_id": 173394, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (InetAddress.getByName (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (null);\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                String addrString;\n                addUDP (addr, port);\n                addTCP (addr, port);\n                if (addr == null) addrString = \"0.0.0.0\";\n                else addrString = addr.getHostAddress ();\n\n                System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Integer (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Integer (53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            int port = ((Integer) iport.next ()).intValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n"}
{"clone_type": "VST3", "method1_id": 282653, "method2_id": 488477, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 162674, "method2_id": 6991541, "code1": "private void buildInfoZip (ScheduleItem si, OutputStream outStream) throws Exception {\n    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ();\n    ZipOutputStream out = new ZipOutputStream (bytesOut);\n    Vector < String > logFiles = si.getLogFileNames ();\n    for (int x = 0;\n    x < logFiles.size (); x ++) {\n        File log = new File (logFiles.get (x));\n        if (log.exists ()) {\n            out.putNextEntry (new ZipEntry (log.getName ()));\n            byte [] data = new byte [1024];\n            FileInputStream is = new FileInputStream (log);\n            int read = is.read (data);\n            while (read > - 1) {\n                out.write (data, 0, read);\n                read = is.read (data);\n            }\n            out.closeEntry ();\n        }\n    }\n    out.putNextEntry (new ZipEntry (\"ItemLog.txt\"));\n    out.write (si.getLog ().getBytes (\"UTF-8\"));\n    out.closeEntry ();\n    StringBuffer buff = new StringBuffer ();\n    buff.append (\"Name              : \" + si.getName () + \"\\r\\n\");\n    buff.append (\"Start             : \" + si.getStart ().toString () + \"\\r\\n\");\n    buff.append (\"Stop              : \" + si.getStop ().toString () + \"\\r\\n\");\n    buff.append (\"Duration          : \" + si.getDuration () + \"\\r\\n\");\n    buff.append (\"Channel           : \" + si.getChannel () + \"\\r\\n\");\n    buff.append (\"Path Index        : \" + si.getCapturePathIndex () + \"\\r\\n\");\n    buff.append (\"Capture Type      : \" + si.getCapType () + \"\\r\\n\");\n    buff.append (\"Filename          : \" + si.getFileName () + \"\\r\\n\");\n    buff.append (\"File Pattern      : \" + si.getFilePattern () + \"\\r\\n\");\n    buff.append (\"Keep For          : \" + si.getKeepFor () + \"\\r\\n\");\n    buff.append (\"Post Task         : \" + si.getPostTask () + \"\\r\\n\");\n    buff.append (\"Post Task Enabled : \" + si.getPostTaskEnabled () + \"\\r\\n\");\n    buff.append (\"State             : \" + si.getState () + \"\\r\\n\");\n    buff.append (\"Status            : \" + si.getStatus () + \"\\r\\n\");\n    buff.append (\"Type              : \" + si.getType () + \"\\r\\n\");\n    buff.append (\"\\r\\nWarnings:\\r\\n\");\n    Vector < String > warns = si.getWarnings ();\n    for (int x = 0;\n    x < warns.size (); x ++) {\n        buff.append (warns.get (x) + \"\\r\\n\");\n    }\n    buff.append (\"\\r\\n\");\n    buff.append (\"Log Files:\\r\\n\");\n    Vector < String > logs = si.getLogFileNames ();\n    for (int x = 0;\n    x < logs.size (); x ++) {\n        buff.append (logs.get (x) + \"\\r\\n\");\n    }\n    buff.append (\"\\r\\n\");\n    GuideItem item = si.getCreatedFrom ();\n    if (item != null) {\n        buff.append (\"Created From:\\r\\n\");\n        buff.append (\"Name     : \" + item.getName () + \"\\r\\n\");\n        buff.append (\"Start    : \" + item.getStart ().toString () + \"\\r\\n\");\n        buff.append (\"Stop     : \" + item.getStop ().toString () + \"\\r\\n\");\n        buff.append (\"Duration : \" + item.getDuration () + \"\\r\\n\");\n        buff.append (\"\\r\\n\");\n    }\n    HashMap < Date, SignalStatistic > signal = si.getSignalStatistics ();\n    if (signal.size () > 0) {\n        buff.append (\"Signal Statistics: (Locked, Strength, Quality)\\r\\n\");\n        Date [] keys = signal.keySet ().toArray (new Date [0]);\n        for (int x = 0;\n        x < signal.size (); x ++) {\n            SignalStatistic stat = signal.get (keys [x]);\n            buff.append (keys [x].toString () + \" - \" + stat.getLocked () + \", \" + stat.getStrength () + \", \" + stat.getQuality () + \"\\r\\n\");\n        }\n        buff.append (\"\\r\\n\");\n    }\n    out.putNextEntry (new ZipEntry (\"ItemDetails.txt\"));\n    out.write (buff.toString ().getBytes (\"UTF-8\"));\n    out.closeEntry ();\n    out.flush ();\n    out.close ();\n    StringBuffer header = new StringBuffer ();\n    header.append (\"HTTP/1.1 200 OK\\n\");\n    header.append (\"Content-Type: application/zip\\n\");\n    header.append (\"Content-Length: \" + bytesOut.size () + \"\\n\");\n    header.append (\"Content-Disposition: attachment; filename=\\\"ScheduleErrorReport.zip\\\"\\n\");\n    DateFormat df = new SimpleDateFormat (\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\", new Locale (\"En\", \"Us\", \"Unix\"));\n    header.append (\"Last-Modified: \" + df.format (new Date ()) + \"\\n\");\n    header.append (\"\\n\");\n    outStream.write (header.toString ().getBytes ());\n    ByteArrayInputStream zipStream = new ByteArrayInputStream (bytesOut.toByteArray ());\n    byte [] bytes = new byte [4096];\n    int read = zipStream.read (bytes);\n    while (read > - 1) {\n        outStream.write (bytes, 0, read);\n        outStream.flush ();\n        read = zipStream.read (bytes);\n    }\n    return;\n}\n", "code2": "private void exportInternal (HTTPurl urlData, HashMap < String, String > headers, OutputStream outStream) throws Exception {\n    String id = urlData.getParameter (\"id\");\n    ScheduleItem item = store.getScheduleItem (id);\n    if (item == null) {\n        outStream.write (\"ID not found\".getBytes ());\n        return;\n    }\n    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ();\n    ZipOutputStream out = new ZipOutputStream (bytesOut);\n    Vector < String > logFiles = item.getLogFileNames ();\n    for (int x = 0;\n    x < logFiles.size (); x ++) {\n        File log = new File (logFiles.get (x));\n        if (log.exists ()) {\n            out.putNextEntry (new ZipEntry (log.getName ()));\n            byte [] data = new byte [1024];\n            FileInputStream is = new FileInputStream (log);\n            int read = is.read (data);\n            while (read > - 1) {\n                out.write (data, 0, read);\n                read = is.read (data);\n            }\n            out.closeEntry ();\n        }\n    }\n    out.putNextEntry (new ZipEntry (\"ItemLog.txt\"));\n    out.write (item.getLog ().getBytes (\"UTF-8\"));\n    out.closeEntry ();\n    StringBuffer buff = new StringBuffer ();\n    buff.append (\"Name              : \" + item.getName () + \"\\r\\n\");\n    buff.append (\"Start             : \" + item.getStart ().toString () + \"\\r\\n\");\n    buff.append (\"Stop              : \" + item.getStop ().toString () + \"\\r\\n\");\n    buff.append (\"Duration          : \" + item.getDuration () + \"\\r\\n\");\n    buff.append (\"Channel           : \" + item.getChannel () + \"\\r\\n\");\n    buff.append (\"Path Index        : \" + item.getCapturePathIndex () + \"\\r\\n\");\n    buff.append (\"Capture Type      : \" + item.getCapType () + \"\\r\\n\");\n    buff.append (\"Filename          : \" + item.getFileName () + \"\\r\\n\");\n    buff.append (\"File Pattern      : \" + item.getFilePattern () + \"\\r\\n\");\n    buff.append (\"Keep For          : \" + item.getKeepFor () + \"\\r\\n\");\n    buff.append (\"Post Task         : \" + item.getPostTask () + \"\\r\\n\");\n    buff.append (\"Post Task Enabled : \" + item.getPostTaskEnabled () + \"\\r\\n\");\n    buff.append (\"State             : \" + item.getState () + \"\\r\\n\");\n    buff.append (\"Status            : \" + item.getStatus () + \"\\r\\n\");\n    buff.append (\"Type              : \" + item.getType () + \"\\r\\n\");\n    buff.append (\"\\r\\nWarnings:\\r\\n\");\n    Vector < String > warns = item.getWarnings ();\n    for (int x = 0;\n    x < warns.size (); x ++) {\n        buff.append (warns.get (x) + \"\\r\\n\");\n    }\n    buff.append (\"\\r\\n\");\n    buff.append (\"Log Files:\\r\\n\");\n    Vector < String > logs = item.getLogFileNames ();\n    for (int x = 0;\n    x < logs.size (); x ++) {\n        buff.append (logs.get (x) + \"\\r\\n\");\n    }\n    buff.append (\"\\r\\n\");\n    GuideItem guide_item = item.getCreatedFrom ();\n    if (guide_item != null) {\n        buff.append (\"Created From:\\r\\n\");\n        buff.append (\"Name     : \" + guide_item.getName () + \"\\r\\n\");\n        buff.append (\"Start    : \" + guide_item.getStart ().toString () + \"\\r\\n\");\n        buff.append (\"Stop     : \" + guide_item.getStop ().toString () + \"\\r\\n\");\n        buff.append (\"Duration : \" + guide_item.getDuration () + \"\\r\\n\");\n        buff.append (\"\\r\\n\");\n    }\n    HashMap < Date, SignalStatistic > signal = item.getSignalStatistics ();\n    if (signal.size () > 0) {\n        buff.append (\"Signal Statistics: (Locked, Strength, Quality)\\r\\n\");\n        Date [] keys = signal.keySet ().toArray (new Date [0]);\n        for (int x = 0;\n        x < signal.size (); x ++) {\n            SignalStatistic stat = signal.get (keys [x]);\n            buff.append (keys [x].toString () + \" - \" + stat.getLocked () + \", \" + stat.getStrength () + \", \" + stat.getQuality () + \"\\r\\n\");\n        }\n        buff.append (\"\\r\\n\");\n    }\n    out.putNextEntry (new ZipEntry (\"ItemDetails.txt\"));\n    out.write (buff.toString ().getBytes (\"UTF-8\"));\n    out.closeEntry ();\n    out.flush ();\n    out.close ();\n    StringBuffer header = new StringBuffer ();\n    header.append (\"HTTP/1.1 200 OK\\n\");\n    header.append (\"Content-Type: application/zip\\n\");\n    header.append (\"Content-Length: \" + bytesOut.size () + \"\\n\");\n    header.append (\"Content-Disposition: attachment; filename=\\\"ScheduleErrorReport.zip\\\"\\n\");\n    DateFormat df = new SimpleDateFormat (\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\", new Locale (\"En\", \"Us\", \"Unix\"));\n    header.append (\"Last-Modified: \" + df.format (new Date ()) + \"\\n\");\n    header.append (\"\\n\");\n    outStream.write (header.toString ().getBytes ());\n    ByteArrayInputStream zipStream = new ByteArrayInputStream (bytesOut.toByteArray ());\n    byte [] bytes = new byte [4096];\n    int read = zipStream.read (bytes);\n    while (read > - 1) {\n        outStream.write (bytes, 0, read);\n        outStream.flush ();\n        read = zipStream.read (bytes);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 268305, "method2_id": 322775, "code1": "public void doMain (String [] args) throws Exception {\n    filename = args [0];\n    xpath = args [1];\n    if ((filename != null) && (filename.length () > 0) && (xpath != null) && (xpath.length () > 0)) {\n        System.out.println (\"Loading classes, parsing \" + filename + \", and setting up serializer\");\n        InputSource in = new InputSource (new FileInputStream (filename));\n        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n        dfactory.setNamespaceAware (true);\n        Document doc = dfactory.newDocumentBuilder ().parse (in);\n        Transformer serializer = TransformerFactory.newInstance ().newTransformer ();\n        serializer.setOutputProperty (OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n        System.out.println (\"Querying DOM using \" + xpath);\n        NodeIterator nl = XPathAPI.selectNodeIterator (doc, xpath);\n        System.out.println (\"<output>\");\n        Node n;\n        while ((n = nl.nextNode ()) != null) {\n            if (isTextNode (n)) {\n                StringBuffer sb = new StringBuffer (n.getNodeValue ());\n                for (Node nn = n.getNextSibling ();\n                isTextNode (nn); nn = nn.getNextSibling ()) {\n                    sb.append (nn.getNodeValue ());\n                }\n                System.out.print (sb);\n            } else {\n                serializer.transform (new DOMSource (n), new StreamResult (new OutputStreamWriter (System.out)));\n            }\n            System.out.println ();\n        }\n        System.out.println (\"</output>\");\n    } else {\n        System.out.println (\"Bad input args: \" + filename + \", \" + xpath);\n    }\n}\n", "code2": "public void doMain (String [] args) throws Exception {\n    filename = args [0];\n    xpath = args [1];\n    if ((filename != null) && (filename.length () > 0) && (xpath != null) && (xpath.length () > 0)) {\n        System.out.println (\"Loading classes, parsing \" + filename + \", and setting up serializer\");\n        InputSource in = new InputSource (new FileInputStream (filename));\n        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n        dfactory.setNamespaceAware (true);\n        Document doc = dfactory.newDocumentBuilder ().parse (in);\n        Transformer serializer = TransformerFactory.newInstance ().newTransformer ();\n        serializer.setOutputProperty (OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n        System.out.println (\"Querying DOM using \" + xpath);\n        XPathEvaluator evaluator = new XPathEvaluatorImpl (doc);\n        XPathNSResolver resolver = evaluator.createNSResolver (doc);\n        XPathResult result = (XPathResult) evaluator.evaluate (xpath, doc, resolver, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);\n        System.out.println (\"<output>\");\n        Node n;\n        while ((n = result.iterateNext ()) != null) {\n            if (isTextNode (n)) {\n                StringBuffer sb = new StringBuffer (n.getNodeValue ());\n                for (Node nn = n.getNextSibling ();\n                isTextNode (nn); nn = nn.getNextSibling ()) {\n                    sb.append (nn.getNodeValue ());\n                }\n                System.out.print (sb);\n            } else {\n                serializer.transform (new DOMSource (n), new StreamResult (new OutputStreamWriter (System.out)));\n            }\n            System.out.println ();\n        }\n        System.out.println (\"</output>\");\n    } else {\n        System.out.println (\"Bad input args: \" + filename + \", \" + xpath);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 7235121, "method2_id": 17805384, "code1": "public static final String getUniqueId () {\n    String digest = \"\";\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        String timeVal = \"\" + (System.currentTimeMillis () + 1);\n        String localHost = \"\";\n        try {\n            localHost = InetAddress.getLocalHost ().toString ();\n        } catch (UnknownHostException e) {\n            throw new RuntimeException (\"Error trying to get localhost\" + e.getMessage ());\n        }\n        String randVal = \"\" + new Random ().nextInt ();\n        String val = timeVal + localHost + randVal;\n        md.reset ();\n        md.update (val.getBytes ());\n        digest = toHexString (md.digest ());\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException (\"NoSuchAlgorithmException : \" + e.getMessage ());\n    }\n    return digest;\n}\n", "code2": "public static final String getUniqueId () {\n    String digest = \"\";\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        String timeVal = \"\" + (System.currentTimeMillis () + 1);\n        String localHost = \"\";\n        try {\n            localHost = InetAddress.getLocalHost ().toString ();\n        } catch (UnknownHostException e) {\n            log.error (\"Error trying to get localhost\" + e.getMessage ());\n        }\n        String randVal = \"\" + new Random ().nextInt ();\n        String val = timeVal + localHost + randVal;\n        md.reset ();\n        md.update (val.getBytes ());\n        digest = toHexString (md.digest ());\n    } catch (NoSuchAlgorithmException e) {\n        log.error (\"Error trying to generate unique Id\" + e.getMessage ());\n    }\n    return digest;\n}\n"}
{"clone_type": "VST3", "method1_id": 738785, "method2_id": 794567, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 6729311, "method2_id": 10425169, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure, Object o) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (o.getClass ().getName ());\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 223122, "method2_id": 794567, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 13783899, "method2_id": 19643372, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem encoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 399007, "method2_id": 492976, "code1": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setCstrvar (\"Goodbye\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n", "code2": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n"}
{"clone_type": "VST3", "method1_id": 14887616, "method2_id": 17787699, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        logger.debug (\"Random GUID error: \" + e.getMessage ());\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 539004, "method2_id": 2413963, "code1": "public static double [] [] transpose (double [] [] values) {\n    double [] [] swapValues = new double [values [0].length] [values.length];\n    for (int x = 0;\n    x < values.length; x ++) {\n        for (int y = 0;\n        y < values [x].length; y ++) {\n            swapValues [y] [x] = values [x] [y];\n        }\n    }\n    return swapValues;\n}\n", "code2": "public static double [] [] transpose (double [] [] doubleBox) {\n    YeriDebug.ASSERT (CollectionsToolkit.isRectangular (doubleBox));\n    double [] [] returnBox = new double [doubleBox [0].length] [doubleBox.length];\n    for (int i = 0;\n    i < doubleBox.length; i ++) {\n        for (int j = 0;\n        j < doubleBox [i].length; j ++) {\n            returnBox [j] [i] = doubleBox [i] [j];\n        }\n    }\n    return returnBox;\n}\n"}
{"clone_type": "VST3", "method1_id": 569226, "method2_id": 767236, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 10589735, "method2_id": 13020691, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = random.nextLong ();\n        }\n        sbValueBeforeMD5.append (sid);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 3386501, "method2_id": 16540468, "code1": "private static void addFileToZip (String path, String srcFile, ZipOutputStream zip) throws Exception {\n    File folder = new File (srcFile);\n    if (folder.isDirectory ()) {\n        addFolderToZip (path, srcFile, zip);\n    } else {\n        byte [] buf = new byte [1024];\n        int len;\n        FileInputStream in = new FileInputStream (srcFile);\n        zip.putNextEntry (new ZipEntry (path + \"/\" + folder.getName ()));\n        while ((len = in.read (buf)) > 0) {\n            zip.write (buf, 0, len);\n        }\n    }\n}\n", "code2": "private static void addFileToZip (String path, String srcFile, ZipOutputStream zip) throws Exception {\n    File folder = new File (srcFile);\n    if (folder.isDirectory ()) {\n        addFolderToZip (path, srcFile, zip);\n    } else {\n        byte [] buf = new byte [1024];\n        int len;\n        FileInputStream in = new FileInputStream (srcFile);\n        zip.putNextEntry (new ZipEntry (path + \"/\" + folder.getName ()));\n        while ((len = in.read (buf)) > 0) {\n            zip.write (buf, 0, len);\n        }\n        in.close ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 12678589, "method2_id": 19643373, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem decoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 653681, "method2_id": 3538574, "code1": "public static boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n", "code2": "private boolean deleteDirectory (File file) {\n    if (file.exists ()) {\n        File [] files = file.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (file.delete ());\n}\n"}
{"clone_type": "VST3", "method1_id": 581819, "method2_id": 862524, "code1": "private void exportAllSettings (HTTPurl urlData, OutputStream outStream) throws Exception {\n    CaptureDeviceList devList = CaptureDeviceList.getInstance ();\n    if (devList.getActiveDeviceCount () > 0) {\n        PageTemplate template = new PageTemplate (store.getProperty (\"path.template\") + File.separator + \"SettingsLoad.html\");\n        StringBuffer buff = new StringBuffer ();\n        buff.append (\"<tr><td><img border=0 src='/images/stop.png' align='absmiddle' width='24' height='24'></td><td>Can not save settings while a capture is in progress.</td></tr>\");\n        template.replaceAll (\"$result\", buff.toString ());\n        outStream.write (template.getPageBytes ());\n        return;\n    }\n    boolean matchList = \"true\".equalsIgnoreCase (urlData.getParameter (\"MatchList\"));\n    boolean autoAdd = \"true\".equalsIgnoreCase (urlData.getParameter (\"AutoAdd\"));\n    boolean channelMapping = \"true\".equalsIgnoreCase (urlData.getParameter (\"ChannelMapping\"));\n    boolean deviceSelection = \"true\".equalsIgnoreCase (urlData.getParameter (\"DeviceSelection\"));\n    boolean agentMapping = \"true\".equalsIgnoreCase (urlData.getParameter (\"AgentMapping\"));\n    boolean channels = \"true\".equalsIgnoreCase (urlData.getParameter (\"Channels\"));\n    boolean tasks = \"true\".equalsIgnoreCase (urlData.getParameter (\"Tasks\"));\n    boolean systemProp = \"true\".equalsIgnoreCase (urlData.getParameter (\"SystemProp\"));\n    boolean schedules = \"true\".equalsIgnoreCase (urlData.getParameter (\"Schedules\"));\n    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ();\n    ZipOutputStream out = new ZipOutputStream (bytesOut);\n    out.setComment (\"TV Scheduler Pro Settings file (Version: 1.0)\");\n    if (channels) {\n        out.putNextEntry (new ZipEntry (\"Channels.xml\"));\n        StringBuffer channelData = new StringBuffer ();\n        store.saveChannels (channelData);\n        byte [] channelBytes = channelData.toString ().getBytes (\"UTF-8\");\n        out.write (channelBytes);\n        out.closeEntry ();\n    }\n    if (matchList) {\n        out.putNextEntry (new ZipEntry (\"MatchList.xml\"));\n        StringBuffer matchData = new StringBuffer ();\n        store.saveMatchList (matchData);\n        byte [] matchBytes = matchData.toString ().getBytes (\"UTF-8\");\n        out.write (matchBytes);\n        out.closeEntry ();\n    }\n    if (autoAdd) {\n        out.putNextEntry (new ZipEntry (\"EpgAutoAdd.xml\"));\n        StringBuffer addData = new StringBuffer ();\n        store.saveEpgAutoList (addData);\n        byte [] addBytes = addData.toString ().getBytes (\"UTF-8\");\n        out.write (addBytes);\n        out.closeEntry ();\n    }\n    if (tasks) {\n        out.putNextEntry (new ZipEntry (\"Tasks.xml\"));\n        StringBuffer taskData = new StringBuffer ();\n        store.saveTaskList (taskData);\n        byte [] taskBytes = taskData.toString ().getBytes (\"UTF-8\");\n        out.write (taskBytes);\n        out.closeEntry ();\n    }\n    if (channelMapping) {\n        GuideStore guideStore = GuideStore.getInstance ();\n        out.putNextEntry (new ZipEntry (\"ChannelMap.sof\"));\n        ByteArrayOutputStream chanMapBytes = new ByteArrayOutputStream ();\n        guideStore.saveChannelMap (chanMapBytes);\n        out.write (chanMapBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (deviceSelection) {\n        out.putNextEntry (new ZipEntry (\"CaptureDevices.sof\"));\n        ByteArrayOutputStream deviceBytes = new ByteArrayOutputStream ();\n        devList.saveDeviceList (deviceBytes);\n        out.write (deviceBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (agentMapping) {\n        out.putNextEntry (new ZipEntry (\"AgentMap.sof\"));\n        ByteArrayOutputStream agentMapBytes = new ByteArrayOutputStream ();\n        store.saveAgentToThemeMap (agentMapBytes);\n        out.write (agentMapBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (schedules) {\n        out.putNextEntry (new ZipEntry (\"Times.sof\"));\n        ByteArrayOutputStream timesBytes = new ByteArrayOutputStream ();\n        store.saveSchedule (timesBytes);\n        out.write (timesBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (systemProp) {\n        HashMap < String, String > serverProp = new HashMap < String, String > ();\n        serverProp.put (\"Capture.path\", store.getProperty (\"Capture.path\"));\n        serverProp.put (\"Capture.AverageDataRate\", store.getProperty (\"Capture.AverageDataRate\"));\n        serverProp.put (\"Capture.AutoSelectMethod\", store.getProperty (\"Capture.AutoSelectMethod\"));\n        serverProp.put (\"Capture.minSpace\", store.getProperty (\"Capture.minSpace\"));\n        serverProp.put (\"Capture.IncludeCalculatedUsage\", store.getProperty (\"Capture.IncludeCalculatedUsage\"));\n        serverProp.put (\"Capture.deftype\", store.getProperty (\"Capture.deftype\"));\n        serverProp.put (\"Capture.filename.patterns\", store.getProperty (\"Capture.filename.patterns\"));\n        serverProp.put (\"Capture.path.details\", store.getProperty (\"Capture.path.details\"));\n        serverProp.put (\"Capture.CaptureFailedTimeout\", store.getProperty (\"Capture.CaptureFailedTimeout\"));\n        serverProp.put (\"Schedule.buffer.start\", store.getProperty (\"Schedule.buffer.start\"));\n        serverProp.put (\"Schedule.buffer.end\", store.getProperty (\"Schedule.buffer.end\"));\n        serverProp.put (\"Schedule.buffer.end.epg\", store.getProperty (\"Schedule.buffer.end.epg\"));\n        serverProp.put (\"Schedule.wake.system\", store.getProperty (\"Schedule.wake.system\"));\n        serverProp.put (\"sch.autodel.action\", store.getProperty (\"sch.autodel.action\"));\n        serverProp.put (\"sch.autodel.time\", store.getProperty (\"sch.autodel.time\"));\n        serverProp.put (\"guide.source.http.pwd\", store.getProperty (\"guide.source.http.pwd\"));\n        serverProp.put (\"guide.source.xml.channelList\", store.getProperty (\"guide.source.xml.channelList\"));\n        serverProp.put (\"guide.source.type\", store.getProperty (\"guide.source.type\"));\n        serverProp.put (\"guide.source.http\", store.getProperty (\"guide.source.http\"));\n        serverProp.put (\"guide.source.file\", store.getProperty (\"guide.source.file\"));\n        serverProp.put (\"guide.action.name\", store.getProperty (\"guide.action.name\"));\n        serverProp.put (\"guide.source.http.usr\", store.getProperty (\"guide.source.http.usr\"));\n        serverProp.put (\"guide.source.schedule\", store.getProperty (\"guide.source.schedule\"));\n        serverProp.put (\"guide.warn.overlap\", store.getProperty (\"guide.warn.overlap\"));\n        serverProp.put (\"proxy.server\", store.getProperty (\"proxy.server\"));\n        serverProp.put (\"proxy.port\", store.getProperty (\"proxy.port\"));\n        serverProp.put (\"proxy.server.usr\", store.getProperty (\"proxy.server.usr\"));\n        serverProp.put (\"proxy.server.pwd\", store.getProperty (\"proxy.server.pwd\"));\n        serverProp.put (\"email.server\", store.getProperty (\"email.server\"));\n        serverProp.put (\"email.from.name\", store.getProperty (\"email.from.name\"));\n        serverProp.put (\"email.to\", store.getProperty (\"email.to\"));\n        serverProp.put (\"email.from\", store.getProperty (\"email.from\"));\n        serverProp.put (\"Tasks.DefTask\", store.getProperty (\"Tasks.DefTask\"));\n        serverProp.put (\"Tasks.PreTask\", store.getProperty (\"Tasks.PreTask\"));\n        serverProp.put (\"Tasks.NoDataErrorTask\", store.getProperty (\"Tasks.NoDataErrorTask\"));\n        serverProp.put (\"Tasks.StartErrorTask\", store.getProperty (\"Tasks.StartErrorTask\"));\n        serverProp.put (\"filebrowser.DirsAtTop\", store.getProperty (\"filebrowser.DirsAtTop\"));\n        serverProp.put (\"filebrowser.masks\", store.getProperty (\"filebrowser.masks\"));\n        serverProp.put (\"server.kbLED\", store.getProperty (\"server.kbLED\"));\n        ByteArrayOutputStream serverpropBytes = new ByteArrayOutputStream ();\n        ObjectOutputStream oos = new ObjectOutputStream (serverpropBytes);\n        oos.writeObject (serverProp);\n        oos.close ();\n        out.putNextEntry (new ZipEntry (\"ServerProperties.sof\"));\n        out.write (serverpropBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    out.flush ();\n    out.close ();\n    StringBuffer header = new StringBuffer ();\n    header.append (\"HTTP/1.1 200 OK\\n\");\n    header.append (\"Content-Type: application/zip\\n\");\n    header.append (\"Content-Length: \" + bytesOut.size () + \"\\n\");\n    header.append (\"Content-Disposition: attachment; filename=\\\"TV Scheduler Pro Settings.zip\\\"\\n\");\n    DateFormat df = new SimpleDateFormat (\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\", new Locale (\"En\", \"Us\", \"Unix\"));\n    header.append (\"Last-Modified: \" + df.format (new Date ()) + \"\\n\");\n    header.append (\"\\n\");\n    outStream.write (header.toString ().getBytes ());\n    ByteArrayInputStream zipStream = new ByteArrayInputStream (bytesOut.toByteArray ());\n    byte [] bytes = new byte [4096];\n    int read = zipStream.read (bytes);\n    while (read > - 1) {\n        outStream.write (bytes, 0, read);\n        outStream.flush ();\n        read = zipStream.read (bytes);\n    }\n}\n", "code2": "private void exportAllSettings (HTTPurl urlData, OutputStream outStream) throws Exception {\n    CaptureDeviceList devList = CaptureDeviceList.getInstance ();\n    if (devList.getActiveDeviceCount () > 0) {\n        PageTemplate template = new PageTemplate (store.getProperty (\"path.template\").replace ('\\\\', File.separatorChar) + File.separator + \"SettingsLoad.html\");\n        StringBuffer buff = new StringBuffer ();\n        buff.append (\"<tr><td><img border=0 src='/images/stop.png' align='absmiddle' width='24' height='24'></td><td>Can not save settings while a capture is in progress.</td></tr>\");\n        template.replaceAll (\"$result\", buff.toString ());\n        outStream.write (template.getPageBytes ());\n        return;\n    }\n    boolean matchList = \"true\".equalsIgnoreCase (urlData.getParameter (\"MatchList\"));\n    boolean autoAdd = \"true\".equalsIgnoreCase (urlData.getParameter (\"AutoAdd\"));\n    boolean channelMapping = \"true\".equalsIgnoreCase (urlData.getParameter (\"ChannelMapping\"));\n    boolean deviceSelection = \"true\".equalsIgnoreCase (urlData.getParameter (\"DeviceSelection\"));\n    boolean agentMapping = \"true\".equalsIgnoreCase (urlData.getParameter (\"AgentMapping\"));\n    boolean channels = \"true\".equalsIgnoreCase (urlData.getParameter (\"Channels\"));\n    boolean tasks = \"true\".equalsIgnoreCase (urlData.getParameter (\"Tasks\"));\n    boolean systemProp = \"true\".equalsIgnoreCase (urlData.getParameter (\"SystemProp\"));\n    boolean schedules = \"true\".equalsIgnoreCase (urlData.getParameter (\"Schedules\"));\n    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ();\n    ZipOutputStream out = new ZipOutputStream (bytesOut);\n    out.setComment (\"TV Scheduler Pro Settings file (Version: 1.0)\");\n    if (channels) {\n        out.putNextEntry (new ZipEntry (\"Channels.xml\"));\n        StringBuffer channelData = new StringBuffer ();\n        store.saveChannels (channelData);\n        byte [] channelBytes = channelData.toString ().getBytes (\"UTF-8\");\n        out.write (channelBytes);\n        out.closeEntry ();\n    }\n    if (matchList) {\n        out.putNextEntry (new ZipEntry (\"MatchList.xml\"));\n        StringBuffer matchData = new StringBuffer ();\n        store.saveMatchList (matchData);\n        byte [] matchBytes = matchData.toString ().getBytes (\"UTF-8\");\n        out.write (matchBytes);\n        out.closeEntry ();\n    }\n    if (autoAdd) {\n        out.putNextEntry (new ZipEntry (\"EpgAutoAdd.xml\"));\n        StringBuffer addData = new StringBuffer ();\n        store.saveEpgAutoList (addData);\n        byte [] addBytes = addData.toString ().getBytes (\"UTF-8\");\n        out.write (addBytes);\n        out.closeEntry ();\n    }\n    if (tasks) {\n        out.putNextEntry (new ZipEntry (\"Tasks.xml\"));\n        StringBuffer taskData = new StringBuffer ();\n        store.saveTaskList (taskData);\n        byte [] taskBytes = taskData.toString ().getBytes (\"UTF-8\");\n        out.write (taskBytes);\n        out.closeEntry ();\n    }\n    if (channelMapping) {\n        GuideStore guideStore = GuideStore.getInstance ();\n        out.putNextEntry (new ZipEntry (\"ChannelMap.sof\"));\n        ByteArrayOutputStream chanMapBytes = new ByteArrayOutputStream ();\n        guideStore.saveChannelMap (chanMapBytes);\n        out.write (chanMapBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (deviceSelection) {\n        out.putNextEntry (new ZipEntry (\"CaptureDevices.sof\"));\n        ByteArrayOutputStream deviceBytes = new ByteArrayOutputStream ();\n        devList.saveDeviceList (deviceBytes);\n        out.write (deviceBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (agentMapping) {\n        out.putNextEntry (new ZipEntry (\"AgentMap.sof\"));\n        ByteArrayOutputStream agentMapBytes = new ByteArrayOutputStream ();\n        store.saveAgentToThemeMap (agentMapBytes);\n        out.write (agentMapBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (schedules) {\n        out.putNextEntry (new ZipEntry (\"Times.sof\"));\n        ByteArrayOutputStream timesBytes = new ByteArrayOutputStream ();\n        store.saveSchedule (timesBytes);\n        out.write (timesBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (systemProp) {\n        HashMap < String, String > serverProp = new HashMap < String, String > ();\n        serverProp.put (\"Capture.path\", store.getProperty (\"Capture.path\"));\n        serverProp.put (\"Capture.AverageDataRate\", store.getProperty (\"Capture.AverageDataRate\"));\n        serverProp.put (\"Capture.AutoSelectMethod\", store.getProperty (\"Capture.AutoSelectMethod\"));\n        serverProp.put (\"Capture.minSpace\", store.getProperty (\"Capture.minSpace\"));\n        serverProp.put (\"Capture.IncludeCalculatedUsage\", store.getProperty (\"Capture.IncludeCalculatedUsage\"));\n        serverProp.put (\"Capture.deftype\", store.getProperty (\"Capture.deftype\"));\n        serverProp.put (\"Capture.filename.patterns\", store.getProperty (\"Capture.filename.patterns\"));\n        serverProp.put (\"Capture.path.details\", store.getProperty (\"Capture.path.details\"));\n        serverProp.put (\"Capture.CaptureFailedTimeout\", store.getProperty (\"Capture.CaptureFailedTimeout\"));\n        serverProp.put (\"Schedule.buffer.start\", store.getProperty (\"Schedule.buffer.start\"));\n        serverProp.put (\"Schedule.buffer.end\", store.getProperty (\"Schedule.buffer.end\"));\n        serverProp.put (\"Schedule.buffer.end.epg\", store.getProperty (\"Schedule.buffer.end.epg\"));\n        serverProp.put (\"Schedule.wake.system\", store.getProperty (\"Schedule.wake.system\"));\n        serverProp.put (\"sch.autodel.action\", store.getProperty (\"sch.autodel.action\"));\n        serverProp.put (\"sch.autodel.time\", store.getProperty (\"sch.autodel.time\"));\n        serverProp.put (\"guide.source.http.pwd\", store.getProperty (\"guide.source.http.pwd\"));\n        serverProp.put (\"guide.source.xml.channelList\", store.getProperty (\"guide.source.xml.channelList\"));\n        serverProp.put (\"guide.source.type\", store.getProperty (\"guide.source.type\"));\n        serverProp.put (\"guide.source.http\", store.getProperty (\"guide.source.http\"));\n        serverProp.put (\"guide.source.file\", store.getProperty (\"guide.source.file\"));\n        serverProp.put (\"guide.action.name\", store.getProperty (\"guide.action.name\"));\n        serverProp.put (\"guide.source.http.usr\", store.getProperty (\"guide.source.http.usr\"));\n        serverProp.put (\"guide.source.schedule\", store.getProperty (\"guide.source.schedule\"));\n        serverProp.put (\"guide.warn.overlap\", store.getProperty (\"guide.warn.overlap\"));\n        serverProp.put (\"proxy.server\", store.getProperty (\"proxy.server\"));\n        serverProp.put (\"proxy.port\", store.getProperty (\"proxy.port\"));\n        serverProp.put (\"proxy.server.usr\", store.getProperty (\"proxy.server.usr\"));\n        serverProp.put (\"proxy.server.pwd\", store.getProperty (\"proxy.server.pwd\"));\n        serverProp.put (\"email.server\", store.getProperty (\"email.server\"));\n        serverProp.put (\"email.from.name\", store.getProperty (\"email.from.name\"));\n        serverProp.put (\"email.to\", store.getProperty (\"email.to\"));\n        serverProp.put (\"email.from\", store.getProperty (\"email.from\"));\n        serverProp.put (\"Tasks.DefTask\", store.getProperty (\"Tasks.DefTask\"));\n        serverProp.put (\"Tasks.PreTask\", store.getProperty (\"Tasks.PreTask\"));\n        serverProp.put (\"Tasks.NoDataErrorTask\", store.getProperty (\"Tasks.NoDataErrorTask\"));\n        serverProp.put (\"Tasks.StartErrorTask\", store.getProperty (\"Tasks.StartErrorTask\"));\n        serverProp.put (\"filebrowser.DirsAtTop\", store.getProperty (\"filebrowser.DirsAtTop\"));\n        serverProp.put (\"filebrowser.masks\", store.getProperty (\"filebrowser.masks\"));\n        serverProp.put (\"server.kbLED\", store.getProperty (\"server.kbLED\"));\n        ByteArrayOutputStream serverpropBytes = new ByteArrayOutputStream ();\n        ObjectOutputStream oos = new ObjectOutputStream (serverpropBytes);\n        oos.writeObject (serverProp);\n        oos.close ();\n        out.putNextEntry (new ZipEntry (\"ServerProperties.sof\"));\n        out.write (serverpropBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    out.flush ();\n    out.close ();\n    StringBuffer header = new StringBuffer ();\n    header.append (\"HTTP/1.1 200 OK\\n\");\n    header.append (\"Content-Type: application/zip\\n\");\n    header.append (\"Content-Length: \" + bytesOut.size () + \"\\n\");\n    header.append (\"Content-Disposition: attachment; filename=\\\"TV Scheduler Pro Settings.zip\\\"\\n\");\n    DateFormat df = new SimpleDateFormat (\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\", new Locale (\"En\", \"Us\", \"Unix\"));\n    header.append (\"Last-Modified: \" + df.format (new Date ()) + \"\\n\");\n    header.append (\"\\n\");\n    outStream.write (header.toString ().getBytes ());\n    ByteArrayInputStream zipStream = new ByteArrayInputStream (bytesOut.toByteArray ());\n    byte [] bytes = new byte [4096];\n    int read = zipStream.read (bytes);\n    while (read > - 1) {\n        outStream.write (bytes, 0, read);\n        outStream.flush ();\n        read = zipStream.read (bytes);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 7460369, "method2_id": 10287987, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 311978, "method2_id": 719027, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 15461843, "method2_id": 21374275, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "private static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 5090669, "method2_id": 22403259, "code1": "private static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 17630907, "method2_id": 17630910, "code1": "public static int [] sortDescending (int input []) {\n    int [] order = new int [input.length];\n    for (int i = 0;\n    i < order.length; i ++) order [i] = i;\n\n    for (int i = input.length;\n    -- i >= 0;) {\n        for (int j = 0;\n        j < i; j ++) {\n            if (input [j] < input [j + 1]) {\n                int mem = input [j];\n                input [j] = input [j + 1];\n                input [j + 1] = mem;\n                int id = order [j];\n                order [j] = order [j + 1];\n                order [j + 1] = id;\n            }\n        }\n    }\n    return order;\n}\n", "code2": "public static int [] sortDescending (double input []) {\n    int [] order = new int [input.length];\n    for (int i = 0;\n    i < order.length; i ++) order [i] = i;\n\n    for (int i = input.length;\n    -- i >= 0;) {\n        for (int j = 0;\n        j < i; j ++) {\n            if (input [j] < input [j + 1]) {\n                double mem = input [j];\n                input [j] = input [j + 1];\n                input [j + 1] = mem;\n                int id = order [j];\n                order [j] = order [j + 1];\n                order [j + 1] = id;\n            }\n        }\n    }\n    return order;\n}\n"}
{"clone_type": "VST3", "method1_id": 92759, "method2_id": 138582, "code1": "public void start (Gedcom gedcom) {\n    List args = new ArrayList ();\n    for (int i = 0;\n    i < OPTIONS.length; i ++) args.add (OPTIONS [i]);\n\n    File reports = ReportLoader.getReportDirectory ();\n    args.add (\"-d\");\n    args.add (reports.getAbsolutePath ());\n    int sources = findSources (reports, args);\n    if (sources == 0) {\n        println (translate (\"nosources\", reports));\n        return;\n    }\n    Object rc = null;\n    try {\n        Object javac = Class.forName (\"com.sun.tools.javac.Main\").newInstance ();\n        rc = javac.getClass ().getMethod (\"compile\", new Class [] {new String [0].getClass (), PrintWriter.class}).invoke (javac, new Object [] {args.toArray (new String [args.size ()]), getOut ()});\n    } catch (Throwable t) {\n        println (translate (\"javac.jre\", System.getProperty (\"java.home\")));\n        return;\n    }\n    if (Integer.valueOf (0).equals (rc)) println (translate (\"javac.success\", new Object [] {\"\" + sources, reports}));\n    else {\n        println (\"---\");\n        println (translate (\"javac.error\"));\n    }\n}\n", "code2": "public void start (Gedcom gedcom) {\n    List args = new ArrayList ();\n    for (int i = 0;\n    i < OPTIONS.length; i ++) args.add (OPTIONS [i]);\n\n    File reports = ReportLoader.getReportDirectory ();\n    args.add (\"-d\");\n    args.add (reports.getAbsolutePath ());\n    int sources = findSources (reports, args);\n    if (sources == 0) {\n        println (translate (\"nosources\", reports));\n        return;\n    }\n    Object rc = null;\n    try {\n        Object javac = Class.forName (\"com.sun.tools.javac.Main\").newInstance ();\n        rc = javac.getClass ().getMethod (\"compile\", new Class [] {new String [0].getClass (), PrintWriter.class}).invoke (javac, new Object [] {args.toArray (new String [args.size ()]), out});\n    } catch (Exception e) {\n        println (translate (\"javac.jre\", System.getProperty (\"java.home\")));\n        return;\n    }\n    if (new Integer (0).equals (rc)) println (translate (\"javac.success\", new Object [] {\"\" + sources, reports}));\n    else {\n        println (\"---\");\n        println (translate (\"javac.error\"));\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 669615, "method2_id": 957614, "code1": "private static boolean loadClasses () {\n    switch (jvm) {\n        case MRJ_2_0 :\n            try {\n                Class aeTargetClass = Class.forName (\"com.apple.MacOS.AETarget\");\n                Class osUtilsClass = Class.forName (\"com.apple.MacOS.OSUtils\");\n                Class appleEventClass = Class.forName (\"com.apple.MacOS.AppleEvent\");\n                Class aeClass = Class.forName (\"com.apple.MacOS.ae\");\n                aeDescClass = Class.forName (\"com.apple.MacOS.AEDesc\");\n                aeTargetConstructor = aeTargetClass.getDeclaredConstructor (new Class [] {int.class});\n                appleEventConstructor = appleEventClass.getDeclaredConstructor (new Class [] {int.class, int.class, aeTargetClass, int.class, int.class});\n                aeDescConstructor = aeDescClass.getDeclaredConstructor (new Class [] {String.class});\n                makeOSType = osUtilsClass.getDeclaredMethod (\"makeOSType\", new Class [] {String.class});\n                putParameter = appleEventClass.getDeclaredMethod (\"putParameter\", new Class [] {int.class, aeDescClass});\n                sendNoReply = appleEventClass.getDeclaredMethod (\"sendNoReply\", new Class [] {});\n                Field keyDirectObjectField = aeClass.getDeclaredField (\"keyDirectObject\");\n                keyDirectObject = (Integer) keyDirectObjectField.get (null);\n                Field autoGenerateReturnIDField = appleEventClass.getDeclaredField (\"kAutoGenerateReturnID\");\n                kAutoGenerateReturnID = (Integer) autoGenerateReturnIDField.get (null);\n                Field anyTransactionIDField = appleEventClass.getDeclaredField (\"kAnyTransactionID\");\n                kAnyTransactionID = (Integer) anyTransactionIDField.get (null);\n            } catch (ClassNotFoundException cnfe) {\n                errorMessage = cnfe.getMessage ();\n                return false;\n            } catch (NoSuchMethodException nsme) {\n                errorMessage = nsme.getMessage ();\n                return false;\n            } catch (NoSuchFieldException nsfe) {\n                errorMessage = nsfe.getMessage ();\n                return false;\n            } catch (IllegalAccessException iae) {\n                errorMessage = iae.getMessage ();\n                return false;\n            }\n            break;\n        case MRJ_2_1 :\n            try {\n                mrjFileUtilsClass = Class.forName (\"com.apple.mrj.MRJFileUtils\");\n                mrjOSTypeClass = Class.forName (\"com.apple.mrj.MRJOSType\");\n                Field systemFolderField = mrjFileUtilsClass.getDeclaredField (\"kSystemFolderType\");\n                kSystemFolderType = systemFolderField.get (null);\n                findFolder = mrjFileUtilsClass.getDeclaredMethod (\"findFolder\", new Class [] {mrjOSTypeClass});\n                getFileCreator = mrjFileUtilsClass.getDeclaredMethod (\"getFileCreator\", new Class [] {File.class});\n                getFileType = mrjFileUtilsClass.getDeclaredMethod (\"getFileType\", new Class [] {File.class});\n            } catch (ClassNotFoundException cnfe) {\n                errorMessage = cnfe.getMessage ();\n                return false;\n            } catch (NoSuchFieldException nsfe) {\n                errorMessage = nsfe.getMessage ();\n                return false;\n            } catch (NoSuchMethodException nsme) {\n                errorMessage = nsme.getMessage ();\n                return false;\n            } catch (SecurityException se) {\n                errorMessage = se.getMessage ();\n                return false;\n            } catch (IllegalAccessException iae) {\n                errorMessage = iae.getMessage ();\n                return false;\n            }\n            break;\n        case MRJ_3_0 :\n            try {\n                Class linker = Class.forName (\"com.apple.mrj.jdirect.Linker\");\n                Constructor constructor = linker.getConstructor (new Class [] {Class.class});\n                constructor.newInstance (new Object [] {BrowserLauncher.class});\n            } catch (ClassNotFoundException cnfe) {\n                errorMessage = cnfe.getMessage ();\n                return false;\n            } catch (NoSuchMethodException nsme) {\n                errorMessage = nsme.getMessage ();\n                return false;\n            } catch (InvocationTargetException ite) {\n                errorMessage = ite.getMessage ();\n                return false;\n            } catch (InstantiationException ie) {\n                errorMessage = ie.getMessage ();\n                return false;\n            } catch (IllegalAccessException iae) {\n                errorMessage = iae.getMessage ();\n                return false;\n            }\n            break;\n        case MRJ_3_1 :\n            try {\n                mrjFileUtilsClass = Class.forName (\"com.apple.mrj.MRJFileUtils\");\n                openURL = mrjFileUtilsClass.getDeclaredMethod (\"openURL\", new Class [] {String.class});\n            } catch (ClassNotFoundException cnfe) {\n                errorMessage = cnfe.getMessage ();\n                return false;\n            } catch (NoSuchMethodException nsme) {\n                errorMessage = nsme.getMessage ();\n                return false;\n            }\n            break;\n        default :\n            break;\n    }\n    return true;\n}\n", "code2": "private static boolean loadClasses () {\n    switch (jvm) {\n        case MRJ_2_0 :\n            try {\n                Class < ? > aeTargetClass = Class.forName (\"com.apple.MacOS.AETarget\");\n                Class < ? > osUtilsClass = Class.forName (\"com.apple.MacOS.OSUtils\");\n                Class < ? > appleEventClass = Class.forName (\"com.apple.MacOS.AppleEvent\");\n                Class < ? > aeClass = Class.forName (\"com.apple.MacOS.ae\");\n                aeDescClass = Class.forName (\"com.apple.MacOS.AEDesc\");\n                aeTargetConstructor = aeTargetClass.getDeclaredConstructor (new Class [] {int.class});\n                appleEventConstructor = appleEventClass.getDeclaredConstructor (new Class [] {int.class, int.class, aeTargetClass, int.class, int.class});\n                aeDescConstructor = aeDescClass.getDeclaredConstructor (new Class [] {String.class});\n                makeOSType = osUtilsClass.getDeclaredMethod (\"makeOSType\", new Class [] {String.class});\n                putParameter = appleEventClass.getDeclaredMethod (\"putParameter\", new Class [] {int.class, aeDescClass});\n                sendNoReply = appleEventClass.getDeclaredMethod (\"sendNoReply\", ArrayUtils.EMPTY_CLASS_ARRAY);\n                Field keyDirectObjectField = aeClass.getDeclaredField (\"keyDirectObject\");\n                keyDirectObject = (Integer) keyDirectObjectField.get (null);\n                Field autoGenerateReturnIDField = appleEventClass.getDeclaredField (\"kAutoGenerateReturnID\");\n                kAutoGenerateReturnID = (Integer) autoGenerateReturnIDField.get (null);\n                Field anyTransactionIDField = appleEventClass.getDeclaredField (\"kAnyTransactionID\");\n                kAnyTransactionID = (Integer) anyTransactionIDField.get (null);\n            } catch (ClassNotFoundException cnfe) {\n                errorMessage = cnfe.getMessage ();\n                return false;\n            } catch (NoSuchMethodException nsme) {\n                errorMessage = nsme.getMessage ();\n                return false;\n            } catch (NoSuchFieldException nsfe) {\n                errorMessage = nsfe.getMessage ();\n                return false;\n            } catch (IllegalAccessException iae) {\n                errorMessage = iae.getMessage ();\n                return false;\n            }\n            break;\n        case MRJ_2_1 :\n            try {\n                mrjFileUtilsClass = Class.forName (\"com.apple.mrj.MRJFileUtils\");\n                mrjOSTypeClass = Class.forName (\"com.apple.mrj.MRJOSType\");\n                Field systemFolderField = mrjFileUtilsClass.getDeclaredField (\"kSystemFolderType\");\n                kSystemFolderType = systemFolderField.get (null);\n                findFolder = mrjFileUtilsClass.getDeclaredMethod (\"findFolder\", new Class [] {mrjOSTypeClass});\n                getFileCreator = mrjFileUtilsClass.getDeclaredMethod (\"getFileCreator\", new Class [] {File.class});\n                getFileType = mrjFileUtilsClass.getDeclaredMethod (\"getFileType\", new Class [] {File.class});\n            } catch (ClassNotFoundException cnfe) {\n                errorMessage = cnfe.getMessage ();\n                return false;\n            } catch (NoSuchFieldException nsfe) {\n                errorMessage = nsfe.getMessage ();\n                return false;\n            } catch (NoSuchMethodException nsme) {\n                errorMessage = nsme.getMessage ();\n                return false;\n            } catch (SecurityException se) {\n                errorMessage = se.getMessage ();\n                return false;\n            } catch (IllegalAccessException iae) {\n                errorMessage = iae.getMessage ();\n                return false;\n            }\n            break;\n        case MRJ_3_0 :\n            try {\n                Class < ? > linker = Class.forName (\"com.apple.mrj.jdirect.Linker\");\n                Constructor < ? > constructor = linker.getConstructor (new Class [] {Class.class});\n                constructor.newInstance (new Object [] {BrowserLauncher.class});\n            } catch (ClassNotFoundException cnfe) {\n                errorMessage = cnfe.getMessage ();\n                return false;\n            } catch (NoSuchMethodException nsme) {\n                errorMessage = nsme.getMessage ();\n                return false;\n            } catch (InvocationTargetException ite) {\n                errorMessage = ite.getMessage ();\n                return false;\n            } catch (InstantiationException ie) {\n                errorMessage = ie.getMessage ();\n                return false;\n            } catch (IllegalAccessException iae) {\n                errorMessage = iae.getMessage ();\n                return false;\n            }\n            break;\n        case MRJ_3_1 :\n            try {\n                mrjFileUtilsClass = Class.forName (\"com.apple.mrj.MRJFileUtils\");\n                openURL = mrjFileUtilsClass.getDeclaredMethod (\"openURL\", new Class [] {String.class});\n            } catch (ClassNotFoundException cnfe) {\n                errorMessage = cnfe.getMessage ();\n                return false;\n            } catch (NoSuchMethodException nsme) {\n                errorMessage = nsme.getMessage ();\n                return false;\n            }\n            break;\n        default :\n            break;\n    }\n    return true;\n}\n"}
{"clone_type": "VST3", "method1_id": 16797551, "method2_id": 16797552, "code1": "public boolean backup () {\n    try {\n        File sd = Environment.getExternalStorageDirectory ();\n        File data = Environment.getDataDirectory ();\n        if (sd.canWrite ()) {\n            String currentDBPath = \"/data/android.bluebox/databases/bluebox.db\";\n            String backupDBPath = \"/Android/bluebox.bak\";\n            File currentDB = new File (data, currentDBPath);\n            File backupDB = new File (sd, backupDBPath);\n            if (currentDB.exists ()) {\n                FileChannel src = new FileInputStream (currentDB).getChannel ();\n                FileChannel dst = new FileOutputStream (backupDB).getChannel ();\n                dst.transferFrom (src, 0, src.size ());\n                src.close ();\n                dst.close ();\n                return true;\n            }\n        }\n    } catch (FileNotFoundException e) {\n        e.printStackTrace ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n    return false;\n}\n", "code2": "public boolean restore () {\n    try {\n        File sd = Environment.getExternalStorageDirectory ();\n        File data = Environment.getDataDirectory ();\n        if (sd.canWrite ()) {\n            String currentDBPath = \"/Android/bluebox.bak\";\n            String backupDBPath = \"/data/android.bluebox/databases/bluebox.db\";\n            File currentDB = new File (sd, currentDBPath);\n            File backupDB = new File (data, backupDBPath);\n            if (currentDB.exists ()) {\n                FileChannel src = new FileInputStream (currentDB).getChannel ();\n                FileChannel dst = new FileOutputStream (backupDB).getChannel ();\n                dst.transferFrom (src, 0, src.size ());\n                src.close ();\n                dst.close ();\n                return true;\n            }\n        }\n    } catch (FileNotFoundException e) {\n        e.printStackTrace ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n    return false;\n}\n"}
{"clone_type": "VST3", "method1_id": 547325, "method2_id": 871396, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 14357939, "method2_id": 17082610, "code1": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n", "code2": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class < ? > compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n"}
{"clone_type": "VST3", "method1_id": 1037968, "method2_id": 2252378, "code1": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n", "code2": "private static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 10496861, "method2_id": 22713046, "code1": "private static void multiclass_probability (int k, double [] [] r, double [] p) {\n    int t, j;\n    int iter = 0, max_iter = Math.max (100, k);\n    double [] [] Q = new double [k] [k];\n    double [] Qp = new double [k];\n    double pQp, eps = 0.005 / k;\n    for (t = 0; t < k; t ++) {\n        p [t] = 1.0 / k;\n        Q [t] [t] = 0;\n        for (j = 0; j < t; j ++) {\n            Q [t] [t] += r [j] [t] * r [j] [t];\n            Q [t] [j] = Q [j] [t];\n        }\n        for (j = t + 1; j < k; j ++) {\n            Q [t] [t] += r [j] [t] * r [j] [t];\n            Q [t] [j] = - r [j] [t] * r [t] [j];\n        }\n    }\n    for (iter = 0; iter < max_iter; iter ++) {\n        pQp = 0;\n        for (t = 0; t < k; t ++) {\n            Qp [t] = 0;\n            for (j = 0; j < k; j ++) Qp [t] += Q [t] [j] * p [j];\n\n            pQp += p [t] * Qp [t];\n        }\n        double max_error = 0;\n        for (t = 0; t < k; t ++) {\n            double error = Math.abs (Qp [t] - pQp);\n            if (error > max_error) max_error = error;\n\n        }\n        if (max_error < eps) break;\n\n        for (t = 0; t < k; t ++) {\n            double diff = (- Qp [t] + pQp) / Q [t] [t];\n            p [t] += diff;\n            pQp = (pQp + diff * (diff * Q [t] [t] + 2 * Qp [t])) / (1 + diff) / (1 + diff);\n            for (j = 0; j < k; j ++) {\n                Qp [j] = (Qp [j] + diff * Q [t] [j]) / (1 + diff);\n                p [j] /= (1 + diff);\n            }\n        }\n    }\n    if (iter >= max_iter) svm.info (\"Exceeds max_iter in multiclass_prob\\n\");\n\n}\n", "code2": "private static void multiclass_probability (int k, double [] [] r, double [] p) {\n    int t, j;\n    int iter = 0, max_iter = Math.max (100, k);\n    double [] [] Q = new double [k] [k];\n    double [] Qp = new double [k];\n    double pQp, eps = 0.005 / k;\n    for (t = 0; t < k; t ++) {\n        p [t] = 1.0 / k;\n        Q [t] [t] = 0;\n        for (j = 0; j < t; j ++) {\n            Q [t] [t] += r [j] [t] * r [j] [t];\n            Q [t] [j] = Q [j] [t];\n        }\n        for (j = t + 1; j < k; j ++) {\n            Q [t] [t] += r [j] [t] * r [j] [t];\n            Q [t] [j] = - r [j] [t] * r [t] [j];\n        }\n    }\n    for (iter = 0; iter < max_iter; iter ++) {\n        pQp = 0;\n        for (t = 0; t < k; t ++) {\n            Qp [t] = 0;\n            for (j = 0; j < k; j ++) Qp [t] += Q [t] [j] * p [j];\n\n            pQp += p [t] * Qp [t];\n        }\n        double max_error = 0;\n        for (t = 0; t < k; t ++) {\n            double error = Math.abs (Qp [t] - pQp);\n            if (error > max_error) max_error = error;\n\n        }\n        if (max_error < eps) break;\n\n        for (t = 0; t < k; t ++) {\n            double diff = (- Qp [t] + pQp) / Q [t] [t];\n            p [t] += diff;\n            pQp = (pQp + diff * (diff * Q [t] [t] + 2 * Qp [t])) / (1 + diff) / (1 + diff);\n            for (j = 0; j < k; j ++) {\n                Qp [j] = (Qp [j] + diff * Q [t] [j]) / (1 + diff);\n                p [j] /= (1 + diff);\n            }\n        }\n    }\n    if (iter >= max_iter) System.err.print (\"Exceeds max_iter in multiclass_prob\\n\");\n\n}\n"}
{"clone_type": "VST3", "method1_id": 166887, "method2_id": 738785, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 6792396, "method2_id": 6792397, "code1": "private void findByMail (List < String > emailList) {\n    log.info (\"Find by mail start ...\");\n    Pattern pattern = Pattern.compile (this.regex, PATTERN_FLAGS);\n    Matcher matcher = pattern.matcher (text);\n    while (matcher.find ()) {\n        int start = matcher.start ();\n        int end = matcher.end ();\n        String mail = text.substring (start, end + 1);\n        if (log.isDebugEnabled ()) {\n            log.debug (\"Find [\" + mail + \"]\");\n        }\n        emailList.add (mail);\n    }\n}\n", "code2": "private void findByMailTo (List < String > emailList) {\n    log.info (\"Find by mailTo start ...\");\n    Pattern pattern = Pattern.compile (this.regex, PATTERN_FLAGS);\n    Matcher matcher = pattern.matcher (text);\n    while (matcher.find ()) {\n        int start = matcher.start ();\n        int end = matcher.end ();\n        String mail = text.substring (start + 7, end + 1);\n        if (log.isDebugEnabled ()) {\n            log.debug (\"Find [\" + mail + \"]\");\n        }\n        emailList.add (mail);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 86778, "method2_id": 492976, "code1": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setCstrvar (\"Goodbye\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n", "code2": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n"}
{"clone_type": "VST3", "method1_id": 2467221, "method2_id": 5523389, "code1": "void copyFile (File src, File dst) throws IOException {\n    InputStream in = new FileInputStream (src);\n    OutputStream out = new FileOutputStream (dst);\n    byte [] buf = new byte [1024];\n    int len;\n    while ((len = in.read (buf)) > 0) out.write (buf, 0, len);\n\n    in.close ();\n    out.close ();\n}\n", "code2": "public static void copy (File src, File dst) throws IOException {\n    InputStream in = new FileInputStream (src);\n    OutputStream out = new FileOutputStream (dst);\n    byte [] buf = new byte [1024];\n    int len;\n    while ((len = in.read (buf)) > 0) out.write (buf, 0, len);\n\n    in.close ();\n    out.close ();\n}\n"}
{"clone_type": "VST3", "method1_id": 13210305, "method2_id": 22991277, "code1": "public static final String encryptMD5 (String decrypted) {\n    try {\n        MessageDigest md5 = MessageDigest.getInstance (\"MD5\");\n        md5.update (decrypted.getBytes ());\n        byte hash [] = md5.digest ();\n        md5.reset ();\n        return hashToHex (hash);\n    } catch (NoSuchAlgorithmException _ex) {\n        return null;\n    }\n}\n", "code2": "public static final String encryptSHA (String decrypted) {\n    try {\n        MessageDigest sha = MessageDigest.getInstance (\"SHA-1\");\n        sha.reset ();\n        sha.update (decrypted.getBytes ());\n        byte hash [] = sha.digest ();\n        sha.reset ();\n        return hashToHex (hash);\n    } catch (NoSuchAlgorithmException _ex) {\n        return null;\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 7460369, "method2_id": 18731110, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 1666041, "method2_id": 10637999, "code1": "public static double [] [] transpose (double [] [] a) {\n    int rows = a.length;\n    int cols = a [0].length;\n    double [] [] res = new double [cols] [rows];\n    for (int i = 0;\n    i < rows; i ++) {\n        for (int j = 0;\n        j < cols; j ++) {\n            res [j] [i] = a [i] [j];\n        }\n    }\n    return res;\n}\n", "code2": "public static final double [] [] transpose (double [] [] a) {\n    int am = a.length;\n    int an = a [0].length;\n    double [] [] result = new double [an] [am];\n    for (int i = 0;\n    i < am; i ++) {\n        for (int j = 0;\n        j < an; j ++) {\n            result [j] [i] = a [i] [j];\n        }\n    }\n    return result;\n}\n"}
{"clone_type": "VST3", "method1_id": 2593325, "method2_id": 7133024, "code1": "public static String getMD5Str (String str) {\n    MessageDigest messageDigest = null;\n    try {\n        messageDigest = MessageDigest.getInstance (\"MD5\");\n        messageDigest.reset ();\n        messageDigest.update (str.getBytes (\"UTF-8\"));\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"NoSuchAlgorithmException caught!\");\n        System.exit (- 1);\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace ();\n    }\n    byte [] byteArray = messageDigest.digest ();\n    StringBuffer md5StrBuff = new StringBuffer ();\n    for (int i = 0;\n    i < byteArray.length; i ++) {\n        if (Integer.toHexString (0xFF & byteArray [i]).length () == 1) md5StrBuff.append (\"0\").append (Integer.toHexString (0xFF & byteArray [i]));\n        else md5StrBuff.append (Integer.toHexString (0xFF & byteArray [i]));\n\n    }\n    return md5StrBuff.substring (8, 24).toString ().toUpperCase ();\n}\n", "code2": "public static String getMD5Str (String str) {\n    MessageDigest messageDigest = null;\n    try {\n        messageDigest = MessageDigest.getInstance (\"MD5\");\n        messageDigest.reset ();\n        messageDigest.update (str.getBytes (\"UTF-8\"));\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"NoSuchAlgorithmException caught!\");\n        System.exit (- 1);\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace ();\n    }\n    byte [] byteArray = messageDigest.digest ();\n    StringBuffer md5StrBuff = new StringBuffer ();\n    for (int i = 0;\n    i < byteArray.length; i ++) {\n        if (Integer.toHexString (0xFF & byteArray [i]).length () == 1) md5StrBuff.append (\"0\").append (Integer.toHexString (0xFF & byteArray [i]));\n        else md5StrBuff.append (Integer.toHexString (0xFF & byteArray [i]));\n\n    }\n    return md5StrBuff.toString ();\n}\n"}
{"clone_type": "VST3", "method1_id": 738785, "method2_id": 808353, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 49611, "method2_id": 120115, "code1": "public void actionPerformed (ActionEvent e) {\n    String sql = \"delete from jadwalUjian where MP='\" + FieldNim.getText ().trim () + \"'\";\n    if (FieldNim.getText ().trim ().equals (\"\")) {\n        JOptionPane.showMessageDialog (frame, \"Nama Mata_Pelajaran Wajib di Isi\", \"Simpan Data\", JOptionPane.WARNING_MESSAGE);\n        FieldNim.requestFocus ();\n    } else {\n        try {\n            Connection connection = DriverManager.getConnection (\"jdbc:odbc:db_Sekolah\");\n            Statement statement = connection.createStatement ();\n            statement.executeUpdate (sql);\n            statement.close ();\n            connection.close ();\n            FieldNim.setText (\"\");\n            FieldNama.setText (\"\");\n            FieldTtl.setText (\"\");\n            FieldJk.setText (\"\");\n            FieldNim.requestFocus ();\n        } catch (Exception exc) {\n            System.err.println (sql);\n            System.err.println (\"Error: \" + exc);\n        }\n    }\n}\n", "code2": "public void actionPerformed (ActionEvent e) {\n    String sql = \"update jadwalKBM set Tahun='\" + FieldNama.getText () + \"',Pertemuan='\" + FieldTtl.getText () + \"'where Bulan='\" + FieldNim.getText ().trim () + \"'\";\n    if (FieldNim.getText ().trim ().equals (\"\")) {\n        JOptionPane.showMessageDialog (frame, \"Nama Bulan Wajib diIsi\", \"Simpan Data\", JOptionPane.WARNING_MESSAGE);\n        FieldNim.requestFocus ();\n    } else {\n        try {\n            Connection connection = DriverManager.getConnection (\"jdbc:odbc:db_Sekolah\");\n            Statement statement = connection.createStatement ();\n            statement.executeUpdate (sql);\n            statement.close ();\n            connection.close ();\n            FieldNim.setText (\"\");\n            FieldNama.setText (\"\");\n            FieldTtl.setText (\"\");\n            FieldNim.requestFocus ();\n        } catch (Exception exc) {\n            System.err.println (sql);\n            System.err.println (\"Error :\" + exc);\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 7948308, "method2_id": 15972030, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        logger.error (\"At RandomGUID !!!\", e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        logger.error (\"At RandomGUID !!!\", e);\n    }\n}\n", "code2": "private void getGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 19643373, "method2_id": 22993368, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem decoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 271634, "method2_id": 380998, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 10287986, "method2_id": 19643372, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem encoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 19947818, "method2_id": 23402237, "code1": "public boolean update (int idPartida, partida partidaModificada) {\n    int intResult = 0;\n    String sql = \"UPDATE partida \" + \"SET torneo_idTorneo = ?, \" + \" jugador_idJugadorNegras = ?, jugador_idJugadorBlancas = ?, \" + \" fecha = ?, \" + \" resultado = ?, \" + \" nombreBlancas = ?, nombreNegras = ?, eloBlancas = ?, eloNegras = ?, idApertura = ? \" + \" WHERE idPartida = \" + idPartida;\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        populatePreparedStatement2 (partidaModificada);\n        intResult = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (intResult > 0);\n}\n", "code2": "public boolean crear () {\n    int result = 0;\n    String sql = \"insert into torneo\" + \"(nombreTorneo, ciudad, fechaInicio, fechaFinal, organizador, numeroDivisiones, terminado)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        populatePreparedStatement (eltorneo);\n        result = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (result > 0);\n}\n"}
{"clone_type": "VST3", "method1_id": 258653, "method2_id": 322916, "code1": "public void doMain (String [] args) throws Exception {\n    filename = args [0];\n    xpath = args [1];\n    if ((filename != null) && (filename.length () > 0) && (xpath != null) && (xpath.length () > 0)) {\n        System.out.println (\"Loading classes, parsing \" + filename + \", and setting up serializer\");\n        InputSource in = new InputSource (new FileInputStream (filename));\n        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n        dfactory.setNamespaceAware (true);\n        Document doc = dfactory.newDocumentBuilder ().parse (in);\n        Transformer serializer = TransformerFactory.newInstance ().newTransformer ();\n        serializer.setOutputProperty (OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n        System.out.println (\"Querying DOM using \" + xpath);\n        XPathEvaluator evaluator = new XPathEvaluatorImpl (doc);\n        XPathNSResolver resolver = evaluator.createNSResolver (doc);\n        XPathResult result = (XPathResult) evaluator.evaluate (xpath, doc, resolver, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);\n        System.out.println (\"<output>\");\n        Node n;\n        while ((n = result.iterateNext ()) != null) {\n            if (isTextNode (n)) {\n                StringBuffer sb = new StringBuffer (n.getNodeValue ());\n                for (Node nn = n.getNextSibling ();\n                isTextNode (nn); nn = nn.getNextSibling ()) {\n                    sb.append (nn.getNodeValue ());\n                }\n                System.out.print (sb);\n            } else {\n                serializer.transform (new DOMSource (n), new StreamResult (new OutputStreamWriter (System.out)));\n            }\n            System.out.println ();\n        }\n        System.out.println (\"</output>\");\n    } else {\n        System.out.println (\"Bad input args: \" + filename + \", \" + xpath);\n    }\n}\n", "code2": "public void doMain (String [] args) throws Exception {\n    filename = args [0];\n    xpath = args [1];\n    if ((filename != null) && (filename.length () > 0) && (xpath != null) && (xpath.length () > 0)) {\n        System.out.println (\"Loading classes, parsing \" + filename + \", and setting up serializer\");\n        InputSource in = new InputSource (new FileInputStream (filename));\n        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n        dfactory.setNamespaceAware (true);\n        Document doc = dfactory.newDocumentBuilder ().parse (in);\n        Transformer serializer = TransformerFactory.newInstance ().newTransformer ();\n        serializer.setOutputProperty (OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n        System.out.println (\"Querying DOM using \" + xpath);\n        NodeIterator nl = XPathAPI.selectNodeIterator (doc, xpath);\n        System.out.println (\"<output>\");\n        Node n;\n        while ((n = nl.nextNode ()) != null) {\n            if (isTextNode (n)) {\n                StringBuffer sb = new StringBuffer (n.getNodeValue ());\n                for (Node nn = n.getNextSibling ();\n                isTextNode (nn); nn = nn.getNextSibling ()) {\n                    sb.append (nn.getNodeValue ());\n                }\n                System.out.print (sb);\n            } else {\n                serializer.transform (new DOMSource (n), new StreamResult (new OutputStreamWriter (System.out)));\n            }\n            System.out.println ();\n        }\n        System.out.println (\"</output>\");\n    } else {\n        System.out.println (\"Bad input args: \" + filename + \", \" + xpath);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 7542627, "method2_id": 7615037, "code1": "public Matrix transpose () {\n    final int array [] [] = new int [numCols] [numRows];\n    for (int j, i = 0;\n    i < numRows; i ++) {\n        array [0] [i] = matrix [i] [0];\n        for (j = 1; j < numCols; j ++) array [j] [i] = matrix [i] [j];\n\n    }\n    return new IntegerMatrix (array);\n}\n", "code2": "public Matrix transpose () {\n    final double array [] [] = new double [numCols] [numRows];\n    for (int j, i = 0;\n    i < numRows; i ++) {\n        array [0] [i] = matrix [i] [0];\n        for (j = 1; j < numCols; j ++) array [j] [i] = matrix [i] [j];\n\n    }\n    return new DoubleMatrix (array);\n}\n"}
{"clone_type": "VST3", "method1_id": 92772, "method2_id": 338353, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 12764800, "method2_id": 18288470, "code1": "public static void extractZipFile (String filename) {\n    try {\n        byte [] buf = new byte [1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream (new FileInputStream (filename));\n        zipentry = zipinputstream.getNextEntry ();\n        while (zipentry != null) {\n            String entryName = zipentry.getName ();\n            int n;\n            FileOutputStream fileoutputstream;\n            File newFile = new File (entryName);\n            String directory = newFile.getParent ();\n            if (directory == null) {\n                if (newFile.isDirectory ()) break;\n\n            }\n            fileoutputstream = new FileOutputStream (entryName);\n            while ((n = zipinputstream.read (buf, 0, 1024)) > - 1) fileoutputstream.write (buf, 0, n);\n\n            fileoutputstream.close ();\n            zipinputstream.closeEntry ();\n            zipentry = zipinputstream.getNextEntry ();\n        }\n        zipinputstream.close ();\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static void unzip (String zipfile, String outputDirectory) {\n    try {\n        byte [] buf = new byte [1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream (new FileInputStream (zipfile));\n        zipentry = zipinputstream.getNextEntry ();\n        while (zipentry != null) {\n            String entryName = zipentry.getName ();\n            System.out.println (\"entryname \" + entryName);\n            int n;\n            FileOutputStream fileoutputstream;\n            File newFile = new File (entryName);\n            String directory = newFile.getParent ();\n            if (directory == null) {\n                if (newFile.isDirectory ()) break;\n\n            }\n            fileoutputstream = new FileOutputStream (outputDirectory + entryName);\n            while ((n = zipinputstream.read (buf, 0, 1024)) > - 1) fileoutputstream.write (buf, 0, n);\n\n            fileoutputstream.close ();\n            zipinputstream.closeEntry ();\n            zipentry = zipinputstream.getNextEntry ();\n        }\n        zipinputstream.close ();\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 22300980, "method2_id": 22303544, "code1": "@Test\npublic void testTransactWriteAndRead () throws Exception {\n    JCFSFileServer server = new JCFSFileServer (defaultTcpPort, defaultTcpAddress, defaultUdpPort, defaultUdpAddress, dir, 0, 0);\n    JCFS.configureDiscovery (defaultUdpAddress, defaultUdpPort);\n    try {\n        server.start ();\n        RFile file = new RFile (\"testreadwritetrans.txt\");\n        RFileOutputStream out = new RFileOutputStream (file, WriteMode.TRANSACTED, false, 1);\n        out.write (\"test\".getBytes (\"utf-8\"));\n        out.close ();\n        RFileInputStream in = new RFileInputStream (file);\n        byte [] buffer = new byte [4];\n        int readCount = in.read (buffer);\n        in.close ();\n        assertEquals (4, readCount);\n        String resultRead = new String (buffer, \"utf-8\");\n        assertEquals (\"test\", resultRead);\n    } finally {\n        server.stop ();\n    }\n}\n", "code2": "@Test\npublic void testWriteAndRead () throws Exception {\n    JCFSFileServer server = new JCFSFileServer (defaultTcpPort, defaultTcpAddress, defaultUdpPort, defaultUdpAddress, dir, 0, 0);\n    JCFS.configureDiscovery (defaultUdpAddress, defaultUdpPort);\n    try {\n        server.start ();\n        RFile file = new RFile (\"testreadwrite.txt\");\n        RFileOutputStream out = new RFileOutputStream (file);\n        out.write (\"test\".getBytes (\"utf-8\"));\n        out.close ();\n        RFileInputStream in = new RFileInputStream (file);\n        byte [] buffer = new byte [4];\n        int readCount = in.read (buffer);\n        in.close ();\n        assertEquals (4, readCount);\n        String resultRead = new String (buffer, \"utf-8\");\n        assertEquals (\"test\", resultRead);\n    } finally {\n        server.stop ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 5086587, "method2_id": 10415388, "code1": "public static void copyFromTo (String src, String des) {\n    staticprintln (\"Copying:\\\"\" + src + \"\\\"\\nto:\\\"\" + des + \"\\\"\");\n    try {\n        FileChannel srcChannel = new FileInputStream (src).getChannel ();\n        FileChannel dstChannel = new FileOutputStream (des).getChannel ();\n        dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n        srcChannel.close ();\n        dstChannel.close ();\n    } catch (IOException e) {\n    }\n}\n", "code2": "public static void copyFileNIO (String src, String dst) {\n    try {\n        FileChannel srcChannel = new FileInputStream (src).getChannel ();\n        FileChannel dstChannel = new FileOutputStream (dst).getChannel ();\n        dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n        srcChannel.close ();\n        dstChannel.close ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 17630905, "method2_id": 17630906, "code1": "public static int [] sortAscending (int input []) {\n    int [] order = new int [input.length];\n    for (int i = 0;\n    i < order.length; i ++) order [i] = i;\n\n    for (int i = input.length;\n    -- i >= 0;) {\n        for (int j = 0;\n        j < i; j ++) {\n            if (input [j] > input [j + 1]) {\n                int mem = input [j];\n                input [j] = input [j + 1];\n                input [j + 1] = mem;\n                int id = order [j];\n                order [j] = order [j + 1];\n                order [j + 1] = id;\n            }\n        }\n    }\n    return order;\n}\n", "code2": "public static int [] sortAscending (float input []) {\n    int [] order = new int [input.length];\n    for (int i = 0;\n    i < order.length; i ++) order [i] = i;\n\n    for (int i = input.length;\n    -- i >= 0;) {\n        for (int j = 0;\n        j < i; j ++) {\n            if (input [j] > input [j + 1]) {\n                float mem = input [j];\n                input [j] = input [j + 1];\n                input [j + 1] = mem;\n                int id = order [j];\n                order [j] = order [j + 1];\n                order [j + 1] = id;\n            }\n        }\n    }\n    return order;\n}\n"}
{"clone_type": "VST3", "method1_id": 2279291, "method2_id": 3362080, "code1": "public static String encrypt (String plainText) throws Exception {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new Exception (e.getMessage ());\n    }\n    try {\n        md.update (plainText.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        throw new Exception (e.getMessage ());\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n", "code2": "public synchronized String encrypt (String plaintext) throws ServiceRuntimeException {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"SHA\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new ServiceRuntimeException (e.getMessage ());\n    }\n    try {\n        md.update (plaintext.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        throw new ServiceRuntimeException (e.getMessage ());\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n"}
{"clone_type": "VST3", "method1_id": 557546, "method2_id": 719027, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 753882, "method2_id": 889475, "code1": "public double probeProcessEnergy (int processId) throws RemoteException {\n    float idle_energy1 = Float.parseFloat (idle_energy);\n    double utiltopower_factor1 = Double.parseDouble (utiltopower_factor);\n    double cpu_util = 10;\n    String energy = \"\";\n    double total_energy = 0;\n    try {\n        Process P = Runtime.getRuntime ().exec (linuxPath + \"/PidCPU.sh \" + processId);\n        StringBuffer strBuf = new StringBuffer ();\n        String strLine = \"\";\n        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));\n        while ((strLine = outCommand.readLine ()) != null) {\n            energy = strLine;\n        }\n        P.waitFor ();\n        cpu_util = Double.parseDouble (energy);\n        total_energy = utiltopower_factor1 * cpu_util;\n    } catch (Exception e) {\n        total_energy = - 1;\n        System.out.println (e.getMessage ());\n        e.printStackTrace ();\n    }\n    return total_energy;\n}\n", "code2": "public double probeProcessEnergy (int processId) throws RemoteException {\n    float idle_energy = 19;\n    double utiltopower_factor = 0.2394;\n    double cpu_util = 10;\n    String energy = \"\";\n    double total_energy = 0;\n    try {\n        Process P = Runtime.getRuntime ().exec (linuxPath + \"/PidCPU.sh \" + processId);\n        StringBuffer strBuf = new StringBuffer ();\n        String strLine = \"\";\n        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));\n        while ((strLine = outCommand.readLine ()) != null) {\n            energy = strLine;\n        }\n        P.waitFor ();\n        cpu_util = Double.parseDouble (energy);\n        total_energy = utiltopower_factor * cpu_util;\n    } catch (Exception e) {\n        total_energy = - 1;\n        System.out.println (e.getMessage ());\n        e.printStackTrace ();\n    }\n    return total_energy;\n}\n"}
{"clone_type": "VST3", "method1_id": 329965, "method2_id": 794567, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 4471000, "method2_id": 19643373, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem decoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 13020691, "method2_id": 20378673, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 6944319, "method2_id": 21238881, "code1": "public void spellCheck () {\n    Highlighter hi = textComp.getHighlighter ();\n    hi.removeAllHighlights ();\n    List < String > words = parseText (textComp.getText ());\n    List < String > misspelledWords = spellCheck (words);\n    if (misspelledWords.isEmpty ()) {\n        return;\n    }\n    StringBuilder sb = new StringBuilder ();\n    for (String word : misspelledWords) {\n        sb.append (word).append (\"|\");\n    }\n    sb.setLength (sb.length () - 1);\n    String patternStr = \"\\\\b(\" + sb.toString () + \")\\\\b\";\n    Pattern pattern = Pattern.compile (patternStr, Pattern.CASE_INSENSITIVE);\n    Matcher matcher = pattern.matcher (textComp.getText ());\n    while (matcher.find ()) {\n        try {\n            hi.addHighlight (matcher.start (), matcher.end (), myPainter);\n        } catch (BadLocationException ex) {\n        }\n    }\n}\n", "code2": "void spellCheck () {\n    Highlighter hi = textComp.getHighlighter ();\n    hi.removeAllHighlights ();\n    List < String > words = parseText (textComp.getText ());\n    List < String > misspelledWords = spellCheck (words);\n    if (misspelledWords.isEmpty ()) {\n        return;\n    }\n    StringBuilder sb = new StringBuilder ();\n    for (String word : misspelledWords) {\n        sb.append (word).append (\"|\");\n    }\n    sb.setLength (sb.length () - 1);\n    String patternStr = \"\\\\b(\" + sb.toString () + \")\\\\b\";\n    Pattern pattern = Pattern.compile (patternStr, Pattern.CASE_INSENSITIVE);\n    Matcher matcher = pattern.matcher (textComp.getText ());\n    while (matcher.find ()) {\n        try {\n            hi.addHighlight (matcher.start (), matcher.end (), myPainter);\n        } catch (BadLocationException ex) {\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 92425, "method2_id": 891614, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 8024375, "method2_id": 20815980, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) throws NoSuchAlgorithmException {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n        throw e;\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 338353, "method2_id": 679416, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 322116, "method2_id": 1552000, "code1": "public static boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n", "code2": "private boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n"}
{"clone_type": "VST3", "method1_id": 106543, "method2_id": 117262, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) {\n                String s1 = st.nextToken ();\n                String s2 = st.nextToken ();\n                if (st.hasMoreTokens ()) addTSIG (s1, s2, st.nextToken ());\n                else addTSIG (\"hmac-md5\", s1, s2);\n\n            } else if (keyword.equals (\"port\")) {\n                ports.add (Integer.valueOf (st.nextToken ()));\n            } else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (Address.getByAddress (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (Address.getByAddress (\"0.0.0.0\"));\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                addUDP (addr, port);\n                addTCP (addr, port);\n                System.out.println (\"jnamed: listening on \" + addrport (addr, port));\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    InputStreamReader isr;\n    BufferedReader br;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n        isr = new InputStreamReader (fs);\n        br = new BufferedReader (isr);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) {\n                String s1 = st.nextToken ();\n                String s2 = st.nextToken ();\n                if (st.hasMoreTokens ()) addTSIG (s1, s2, st.nextToken ());\n                else addTSIG (\"hmac-md5\", s1, s2);\n\n            } else if (keyword.equals (\"port\")) {\n                ports.add (Integer.valueOf (st.nextToken ()));\n            } else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (Address.getByAddress (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (Address.getByAddress (\"0.0.0.0\"));\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                addUDP (addr, port);\n                addTCP (addr, port);\n                System.out.println (\"jnamed: listening on \" + addrport (addr, port));\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 42892, "method2_id": 192715, "code1": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://localhost:5432/wdb\";\n    final String dbuser = \"wcitest\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT * \" + \" FROM wci.read( array['test wci 5'], 'POINT( 10.0 59.0 )', \" + \"                '2009-11-13 00:00:00+00', \" + \"                NULL, \" + \"                array['air temperature', \" + \"                      'air pressure'], \" + \"                NULL, \" + \"                array[-1], \" + \"                NULL::wci.returnFloat )\";\n    final String colNames [] = {\"value\", \"valueParameterName\", \"validTimeFrom\"};\n    ResultSet rs = null;\n    try {\n        statement.execute (wdbInit);\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        if (rs != null) {\n            try {\n                rs.close ();\n            } catch (SQLException ex) {\n                System.out.println (\"EXCEPTION: rs.close: \" + ex);\n            }\n        }\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String dbdriver = \"org.postgresql.Driver\";\n    final String dbconnect = \"jdbc:postgresql://prologdev1:5432/wdb\";\n    final String dbuser = \"guest2\";\n    final String dbpasswd = \"\";\n    Connection con = null;\n    Statement statement = null;\n    try {\n        Class.forName (dbdriver);\n        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);\n        statement = con.createStatement ();\n    } catch (Exception e) {\n        System.out.println (\"FATAL: cant load the database driver <\" + dbdriver + \">!\");\n        System.exit (1);\n    }\n    String wdbInit = \"SELECT wci.begin('\" + dbuser + \"')\";\n    String sql = \" SELECT value, dataProviderName, placeName, placeGeometry,\" + \"        referencetime, \" + \"        validFrom, validTo, \" + \"        valueParameterName, valueParameterUnit, \" + \"        levelParameterName, levelUnitName, levelFrom, levelTo, \" + \"        dataVersion, confidenceCode, storetime, valueid, valuetype \" + \" FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', \" + \"                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), \" + \"                NULL, \" + \"                array['instant pressure of air', \" + \"                      'instant temperature of air', \" + \"                      'instant velocity of air (u-component)', \" + \"                      'instant velocity of air (v-component)'], \" + \"                ( 2, 2, 'distance above ground', 'exact' ), \" + \"                array[-1], \" + \"                NULL::wci.returnFloat )\";\n    final String colNames [] = {\"value\", \"dataProviderName\", \"placeName\", \"referencetime\", \"validFrom\", \"validTo\", \"valueParameterName\", \"valueParameterUnit\", \"levelParameterName\", \"levelUnitName\", \"levelFrom\", \"levelTo\", \"dataVersion\"};\n    ResultSet rs = null;\n    try {\n        statement.execute (wdbInit);\n        rs = statement.executeQuery (sql);\n        ResultSetMetaData rsMetaData = rs.getMetaData ();\n        String data;\n        boolean first;\n        while (rs.next ()) {\n            first = true;\n            for (String name : colNames) {\n                data = rs.getString (name);\n                if (first) {\n                    first = false;\n                } else {\n                    System.out.print (\", \");\n                }\n                if (data != null) System.out.print (data);\n                else System.out.print (\"\\\\N\");\n\n            }\n            System.out.println ();\n        }\n    } catch (Exception ex) {\n        System.out.println (\"SELECT error: \" + ex);\n    } finally {\n        if (rs != null) {\n            try {\n                rs.close ();\n            } catch (SQLException ex) {\n                System.out.println (\"EXCEPTION: rs.close: \" + ex);\n            }\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 12232011, "method2_id": 14763206, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 2545752, "method2_id": 6361638, "code1": "public void copyDirectory (File srcDir, File dstDir) throws IOException {\n    if (srcDir.isDirectory ()) {\n        if (! dstDir.exists ()) {\n            dstDir.mkdir ();\n        }\n        String [] children = srcDir.list ();\n        for (int i = 0;\n        i < children.length; i ++) {\n            copyDirectory (new File (srcDir, children [i]), new File (dstDir, children [i]));\n        }\n    } else {\n        copyInOut (srcDir, dstDir);\n    }\n}\n", "code2": "public static synchronized void copyDirectory (File source, File destination) throws BlogunityException {\n    if (source.isDirectory ()) {\n        if (! destination.exists ()) {\n            destination.mkdir ();\n        }\n        String [] children = source.list ();\n        for (int i = 0;\n        i < children.length; i ++) {\n            copyDirectory (new File (source, children [i]), new File (destination, children [i]));\n        }\n    } else {\n        copyFile (source, destination);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 1799462, "method2_id": 1982368, "code1": "public static boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n", "code2": "private boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n"}
{"clone_type": "VST3", "method1_id": 95203, "method2_id": 341478, "code1": "public void doMain (String [] args) throws Exception {\n    filename = args [0];\n    xpath = args [1];\n    if ((filename != null) && (filename.length () > 0) && (xpath != null) && (xpath.length () > 0)) {\n        System.out.println (\"Loading classes, parsing \" + filename + \", and setting up serializer\");\n        InputSource in = new InputSource (new FileInputStream (filename));\n        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n        dfactory.setNamespaceAware (true);\n        Document doc = dfactory.newDocumentBuilder ().parse (in);\n        Transformer serializer = TransformerFactory.newInstance ().newTransformer ();\n        serializer.setOutputProperty (OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n        System.out.println (\"Querying DOM using \" + xpath);\n        NodeIterator nl = XPathAPI.selectNodeIterator (doc, xpath);\n        System.out.println (\"<output>\");\n        Node n;\n        while ((n = nl.nextNode ()) != null) {\n            if (isTextNode (n)) {\n                StringBuffer sb = new StringBuffer (n.getNodeValue ());\n                for (Node nn = n.getNextSibling ();\n                isTextNode (nn); nn = nn.getNextSibling ()) {\n                    sb.append (nn.getNodeValue ());\n                }\n                System.out.print (sb);\n            } else {\n                serializer.transform (new DOMSource (n), new StreamResult (new OutputStreamWriter (System.out)));\n            }\n            System.out.println ();\n        }\n        System.out.println (\"</output>\");\n    } else {\n        System.out.println (\"Bad input args: \" + filename + \", \" + xpath);\n    }\n}\n", "code2": "public void doMain (String [] args) throws Exception {\n    filename = args [0];\n    xpath = args [1];\n    if ((filename != null) && (filename.length () > 0) && (xpath != null) && (xpath.length () > 0)) {\n        System.out.println (\"Loading classes, parsing \" + filename + \", and setting up serializer\");\n        InputSource in = new InputSource (new FileInputStream (filename));\n        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n        dfactory.setNamespaceAware (true);\n        Document doc = dfactory.newDocumentBuilder ().parse (in);\n        Transformer serializer = TransformerFactory.newInstance ().newTransformer ();\n        serializer.setOutputProperty (OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n        System.out.println (\"Querying DOM using \" + xpath);\n        XPathEvaluator evaluator = new XPathEvaluatorImpl (doc);\n        XPathNSResolver resolver = evaluator.createNSResolver (doc);\n        XPathResult result = (XPathResult) evaluator.evaluate (xpath, doc, resolver, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);\n        System.out.println (\"<output>\");\n        Node n;\n        while ((n = result.iterateNext ()) != null) {\n            if (isTextNode (n)) {\n                StringBuffer sb = new StringBuffer (n.getNodeValue ());\n                for (Node nn = n.getNextSibling ();\n                isTextNode (nn); nn = nn.getNextSibling ()) {\n                    sb.append (nn.getNodeValue ());\n                }\n                System.out.print (sb);\n            } else {\n                serializer.transform (new DOMSource (n), new StreamResult (new OutputStreamWriter (System.out)));\n            }\n            System.out.println ();\n        }\n        System.out.println (\"</output>\");\n    } else {\n        System.out.println (\"Bad input args: \" + filename + \", \" + xpath);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 644662, "method2_id": 738785, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 644662, "method2_id": 891614, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 683983, "method2_id": 891614, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 17630905, "method2_id": 17630909, "code1": "public static int [] sortAscending (int input []) {\n    int [] order = new int [input.length];\n    for (int i = 0;\n    i < order.length; i ++) order [i] = i;\n\n    for (int i = input.length;\n    -- i >= 0;) {\n        for (int j = 0;\n        j < i; j ++) {\n            if (input [j] > input [j + 1]) {\n                int mem = input [j];\n                input [j] = input [j + 1];\n                input [j + 1] = mem;\n                int id = order [j];\n                order [j] = order [j + 1];\n                order [j + 1] = id;\n            }\n        }\n    }\n    return order;\n}\n", "code2": "public static int [] sortAscending (double input []) {\n    int [] order = new int [input.length];\n    for (int i = 0;\n    i < order.length; i ++) order [i] = i;\n\n    for (int i = input.length;\n    -- i >= 0;) {\n        for (int j = 0;\n        j < i; j ++) {\n            if (input [j] > input [j + 1]) {\n                double mem = input [j];\n                input [j] = input [j + 1];\n                input [j + 1] = mem;\n                int id = order [j];\n                order [j] = order [j + 1];\n                order [j + 1] = id;\n            }\n        }\n    }\n    return order;\n}\n"}
{"clone_type": "VST3", "method1_id": 420464, "method2_id": 831471, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 7132185, "method2_id": 7460369, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 3026764, "method2_id": 21186038, "code1": "public MoteDeploymentConfiguration addMoteDeploymentConfiguration (int projectDepConfID, int moteID, int programID, int radioPowerLevel) throws AdaptationException {\n    MoteDeploymentConfiguration mdc = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        String query = \"INSERT INTO MoteDeploymentConfigurations(\" + \"projectDeploymentConfigurationID, \" + \"moteID, programID, radioPowerLevel) VALUES (\" + projectDepConfID + \", \" + moteID + \", \" + programID + \", \" + radioPowerLevel + \")\";\n        connection = DriverManager.getConnection (CONN_STR);\n        statement = connection.createStatement ();\n        statement.executeUpdate (query);\n        query = \"SELECT * from MoteDeploymentConfigurations WHERE \" + \"projectDeploymentConfigurationID = \" + projectDepConfID + \" AND moteID = \" + moteID;\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Unable to select newly added config.\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        mdc = getMoteDeploymentConfiguration (resultSet);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in addMoteDeploymentConfiguration\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return mdc;\n}\n", "code2": "public Project deleteProject (int projectID) throws AdaptationException {\n    Project project = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        String query = \"SELECT * FROM Projects WHERE id = \" + projectID;\n        connection = DriverManager.getConnection (CONN_STR);\n        statement = connection.createStatement ();\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Attempt to delete project failed.\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        project = getProject (resultSet);\n        query = \"DELETE FROM Projects WHERE id = \" + projectID;\n        statement.executeUpdate (query);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in deleteProject\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return project;\n}\n"}
{"clone_type": "VST3", "method1_id": 15924093, "method2_id": 16378626, "code1": "public static void copy (File src, File dest) {\n    try {\n        FileChannel srcChannel = new FileInputStream (src).getChannel ();\n        FileChannel dstChannel = new FileOutputStream (dest).getChannel ();\n        dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n        srcChannel.close ();\n        dstChannel.close ();\n    } catch (IOException e) {\n    }\n}\n", "code2": "public static void copy (String pstrFileFrom, String pstrFileTo) {\n    try {\n        FileChannel srcChannel = new FileInputStream (pstrFileFrom).getChannel ();\n        FileChannel dstChannel = new FileOutputStream (pstrFileTo).getChannel ();\n        dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n        srcChannel.close ();\n        dstChannel.close ();\n    } catch (Exception e) {\n        throw new RuntimeException (e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 278811, "method2_id": 278812, "code1": "private void findGTK (java.awt.event.ActionEvent evt) {\n    final javax.swing.JFileChooser fc = new javax.swing.JFileChooser ();\n    int returnVal = fc.showOpenDialog (this);\n    if (returnVal == javax.swing.JFileChooser.APPROVE_OPTION) {\n        File theme = fc.getSelectedFile ();\n        gtkTheme = theme.toString ();\n        gtkField.setText (themePack);\n    }\n}\n", "code2": "private void findTheme (java.awt.event.ActionEvent evt) {\n    final javax.swing.JFileChooser fc = new javax.swing.JFileChooser ();\n    int returnVal = fc.showOpenDialog (this);\n    if (returnVal == javax.swing.JFileChooser.APPROVE_OPTION) {\n        File theme = fc.getSelectedFile ();\n        themePack = theme.toString ();\n        themeField.setText (themePack);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 666046, "method2_id": 773285, "code1": "private static boolean deleteFile (File resource) throws IOException {\n    if (resource.isDirectory ()) {\n        File [] childFiles = resource.listFiles ();\n        for (File child : childFiles) {\n            deleteFile (child);\n        }\n    }\n    return resource.delete ();\n}\n", "code2": "private static boolean delete (File resource) throws IOException {\n    if (resource.isDirectory ()) {\n        File [] childFiles = resource.listFiles ();\n        for (File child : childFiles) {\n            delete (child);\n        }\n    }\n    return resource.delete ();\n}\n"}
{"clone_type": "VST3", "method1_id": 117262, "method2_id": 475617, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    InputStreamReader isr;\n    BufferedReader br;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n        isr = new InputStreamReader (fs);\n        br = new BufferedReader (isr);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) {\n                String s1 = st.nextToken ();\n                String s2 = st.nextToken ();\n                if (st.hasMoreTokens ()) addTSIG (s1, s2, st.nextToken ());\n                else addTSIG (\"hmac-md5\", s1, s2);\n\n            } else if (keyword.equals (\"port\")) {\n                ports.add (Integer.valueOf (st.nextToken ()));\n            } else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (Address.getByAddress (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (Address.getByAddress (\"0.0.0.0\"));\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                addUDP (addr, port);\n                addTCP (addr, port);\n                System.out.println (\"jnamed: listening on \" + addrport (addr, port));\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) {\n                String s1 = st.nextToken ();\n                String s2 = st.nextToken ();\n                if (st.hasMoreTokens ()) addTSIG (s1, s2, st.nextToken ());\n                else addTSIG (\"hmac-md5\", s1, s2);\n\n            } else if (keyword.equals (\"port\")) {\n                ports.add (Integer.valueOf (st.nextToken ()));\n            } else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (Address.getByAddress (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (Address.getByAddress (\"0.0.0.0\"));\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                addUDP (addr, port);\n                addTCP (addr, port);\n                System.out.println (\"jnamed: listening on \" + addrport (addr, port));\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 11066056, "method2_id": 20870396, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "private static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 98022, "method2_id": 738785, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 21877022, "method2_id": 23539531, "code1": "private void buildAttributeConstructor (Instances data) throws Exception {\n    m_eigenvalues = null;\n    m_outputNumAtts = - 1;\n    m_attributeFilter = null;\n    m_nominalToBinFilter = null;\n    m_sumOfEigenValues = 0.0;\n    m_trainInstances = new Instances (data);\n    m_trainHeader = new Instances (m_trainInstances, 0);\n    m_replaceMissingFilter = new ReplaceMissingValues ();\n    m_replaceMissingFilter.setInputFormat (m_trainInstances);\n    m_trainInstances = Filter.useFilter (m_trainInstances, m_replaceMissingFilter);\n    if (m_normalize) {\n        m_normalizeFilter = new Normalize ();\n        m_normalizeFilter.setInputFormat (m_trainInstances);\n        m_trainInstances = Filter.useFilter (m_trainInstances, m_normalizeFilter);\n    }\n    m_nominalToBinFilter = new NominalToBinary ();\n    m_nominalToBinFilter.setInputFormat (m_trainInstances);\n    m_trainInstances = Filter.useFilter (m_trainInstances, m_nominalToBinFilter);\n    Vector deleteCols = new Vector ();\n    for (int i = 0;\n    i < m_trainInstances.numAttributes (); i ++) {\n        if (m_trainInstances.numDistinctValues (i) <= 1) {\n            deleteCols.addElement (new Integer (i));\n        }\n    }\n    if (m_trainInstances.classIndex () >= 0) {\n        m_hasClass = true;\n        m_classIndex = m_trainInstances.classIndex ();\n        deleteCols.addElement (new Integer (m_classIndex));\n    }\n    if (deleteCols.size () > 0) {\n        m_attributeFilter = new Remove ();\n        int [] todelete = new int [deleteCols.size ()];\n        for (int i = 0;\n        i < deleteCols.size (); i ++) {\n            todelete [i] = ((Integer) (deleteCols.elementAt (i))).intValue ();\n        }\n        m_attributeFilter.setAttributeIndicesArray (todelete);\n        m_attributeFilter.setInvertSelection (false);\n        m_attributeFilter.setInputFormat (m_trainInstances);\n        m_trainInstances = Filter.useFilter (m_trainInstances, m_attributeFilter);\n    }\n    getCapabilities ().testWithFail (m_trainInstances);\n    m_numInstances = m_trainInstances.numInstances ();\n    m_numAttribs = m_trainInstances.numAttributes ();\n    fillCorrelation ();\n    double [] d = new double [m_numAttribs];\n    double [] [] v = new double [m_numAttribs] [m_numAttribs];\n    Matrix corr = new Matrix (m_correlation);\n    corr.eigenvalueDecomposition (v, d);\n    m_eigenvectors = (double [] []) v.clone ();\n    m_eigenvalues = (double []) d.clone ();\n    for (int i = 0;\n    i < m_eigenvalues.length; i ++) {\n        if (m_eigenvalues [i] < 0) {\n            m_eigenvalues [i] = 0.0;\n        }\n    }\n    m_sortedEigens = Utils.sort (m_eigenvalues);\n    m_sumOfEigenValues = Utils.sum (m_eigenvalues);\n    m_transformedFormat = setOutputFormat ();\n    if (m_transBackToOriginal) {\n        m_originalSpaceFormat = setOutputFormatOriginal ();\n        int numVectors = (m_transformedFormat.classIndex () < 0) ? m_transformedFormat.numAttributes () : m_transformedFormat.numAttributes () - 1;\n        double [] [] orderedVectors = new double [m_eigenvectors.length] [numVectors + 1];\n        for (int i = m_numAttribs - 1;\n        i > (m_numAttribs - numVectors - 1); i --) {\n            for (int j = 0;\n            j < m_numAttribs; j ++) {\n                orderedVectors [j] [m_numAttribs - i] = m_eigenvectors [j] [m_sortedEigens [i]];\n            }\n        }\n        int nr = orderedVectors.length;\n        int nc = orderedVectors [0].length;\n        m_eTranspose = new double [nc] [nr];\n        for (int i = 0;\n        i < nc; i ++) {\n            for (int j = 0;\n            j < nr; j ++) {\n                m_eTranspose [i] [j] = orderedVectors [j] [i];\n            }\n        }\n    }\n}\n", "code2": "private void buildAttributeConstructor (Instances data) throws Exception {\n    m_eigenvalues = null;\n    m_outputNumAtts = - 1;\n    m_attributeFilter = null;\n    m_nominalToBinFilter = null;\n    m_sumOfEigenValues = 0.0;\n    m_trainInstances = new Instances (data);\n    m_trainHeader = new Instances (m_trainInstances, 0);\n    m_replaceMissingFilter = new ReplaceMissingValues ();\n    m_replaceMissingFilter.setInputFormat (m_trainInstances);\n    m_trainInstances = Filter.useFilter (m_trainInstances, m_replaceMissingFilter);\n    m_nominalToBinFilter = new NominalToBinary ();\n    m_nominalToBinFilter.setInputFormat (m_trainInstances);\n    m_trainInstances = Filter.useFilter (m_trainInstances, m_nominalToBinFilter);\n    Vector deleteCols = new Vector ();\n    for (int i = 0;\n    i < m_trainInstances.numAttributes (); i ++) {\n        if (m_trainInstances.numDistinctValues (i) <= 1) {\n            deleteCols.addElement (new Integer (i));\n        }\n    }\n    if (m_trainInstances.classIndex () >= 0) {\n        m_hasClass = true;\n        m_classIndex = m_trainInstances.classIndex ();\n        deleteCols.addElement (new Integer (m_classIndex));\n    }\n    if (deleteCols.size () > 0) {\n        m_attributeFilter = new Remove ();\n        int [] todelete = new int [deleteCols.size ()];\n        for (int i = 0;\n        i < deleteCols.size (); i ++) {\n            todelete [i] = ((Integer) (deleteCols.elementAt (i))).intValue ();\n        }\n        m_attributeFilter.setAttributeIndicesArray (todelete);\n        m_attributeFilter.setInvertSelection (false);\n        m_attributeFilter.setInputFormat (m_trainInstances);\n        m_trainInstances = Filter.useFilter (m_trainInstances, m_attributeFilter);\n    }\n    getCapabilities ().testWithFail (m_trainInstances);\n    m_numInstances = m_trainInstances.numInstances ();\n    m_numAttribs = m_trainInstances.numAttributes ();\n    fillCovariance ();\n    double [] d = new double [m_numAttribs];\n    double [] [] v = new double [m_numAttribs] [m_numAttribs];\n    Matrix corr = new Matrix (m_correlation);\n    corr.eigenvalueDecomposition (v, d);\n    m_eigenvectors = (double [] []) v.clone ();\n    m_eigenvalues = (double []) d.clone ();\n    for (int i = 0;\n    i < m_eigenvalues.length; i ++) {\n        if (m_eigenvalues [i] < 0) {\n            m_eigenvalues [i] = 0.0;\n        }\n    }\n    m_sortedEigens = Utils.sort (m_eigenvalues);\n    m_sumOfEigenValues = Utils.sum (m_eigenvalues);\n    m_transformedFormat = setOutputFormat ();\n    if (m_transBackToOriginal) {\n        m_originalSpaceFormat = setOutputFormatOriginal ();\n        int numVectors = (m_transformedFormat.classIndex () < 0) ? m_transformedFormat.numAttributes () : m_transformedFormat.numAttributes () - 1;\n        double [] [] orderedVectors = new double [m_eigenvectors.length] [numVectors + 1];\n        for (int i = m_numAttribs - 1;\n        i > (m_numAttribs - numVectors - 1); i --) {\n            for (int j = 0;\n            j < m_numAttribs; j ++) {\n                orderedVectors [j] [m_numAttribs - i] = m_eigenvectors [j] [m_sortedEigens [i]];\n            }\n        }\n        int nr = orderedVectors.length;\n        int nc = orderedVectors [0].length;\n        m_eTranspose = new double [nc] [nr];\n        for (int i = 0;\n        i < nc; i ++) {\n            for (int j = 0;\n            j < nr; j ++) {\n                m_eTranspose [i] [j] = orderedVectors [j] [i];\n            }\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 362411, "method2_id": 716975, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 13218990, "method2_id": 22953885, "code1": "private int indexOf (char c) {\n    int start = 0;\n    int end = intervalls.size () - 1;\n    while (start <= end) {\n        int check = (start + end) / 2;\n        Interval i = (Interval) intervalls.get (check);\n        if (start == end) return i.contains (c) ? start : - 1;\n\n        if (c < i.start) {\n            end = check - 1;\n            continue;\n        }\n        if (c > i.end) {\n            start = check + 1;\n            continue;\n        }\n        return check;\n    }\n    return - 1;\n}\n", "code2": "private int indexOf (char c) {\n    int start = 0;\n    int end = intervals.size () - 1;\n    while (start <= end) {\n        int check = (start + end) / 2;\n        Interval i = intervals.get (check);\n        if (start == end) return i.contains (c) ? start : - 1;\n\n        if (c < i.start) {\n            end = check - 1;\n            continue;\n        }\n        if (c > i.end) {\n            start = check + 1;\n            continue;\n        }\n        return check;\n    }\n    return - 1;\n}\n"}
{"clone_type": "VST3", "method1_id": 3108499, "method2_id": 15461843, "code1": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 13396233, "method2_id": 19868933, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 2353890, "method2_id": 10496861, "code1": "private static void multiclass_probability (int k, double [] [] r, double [] p) {\n    int t, j;\n    int iter = 0, max_iter = Math.max (100, k);\n    double [] [] Q = new double [k] [k];\n    double [] Qp = new double [k];\n    double pQp, eps = 0.005 / k;\n    for (t = 0; t < k; t ++) {\n        p [t] = 1.0 / k;\n        Q [t] [t] = 0;\n        for (j = 0; j < t; j ++) {\n            Q [t] [t] += r [j] [t] * r [j] [t];\n            Q [t] [j] = Q [j] [t];\n        }\n        for (j = t + 1; j < k; j ++) {\n            Q [t] [t] += r [j] [t] * r [j] [t];\n            Q [t] [j] = - r [j] [t] * r [t] [j];\n        }\n    }\n    for (iter = 0; iter < max_iter; iter ++) {\n        pQp = 0;\n        for (t = 0; t < k; t ++) {\n            Qp [t] = 0;\n            for (j = 0; j < k; j ++) Qp [t] += Q [t] [j] * p [j];\n\n            pQp += p [t] * Qp [t];\n        }\n        double max_error = 0;\n        for (t = 0; t < k; t ++) {\n            double error = Math.abs (Qp [t] - pQp);\n            if (error > max_error) max_error = error;\n\n        }\n        if (max_error < eps) break;\n\n        for (t = 0; t < k; t ++) {\n            double diff = (- Qp [t] + pQp) / Q [t] [t];\n            p [t] += diff;\n            pQp = (pQp + diff * (diff * Q [t] [t] + 2 * Qp [t])) / (1 + diff) / (1 + diff);\n            for (j = 0; j < k; j ++) {\n                Qp [j] = (Qp [j] + diff * Q [t] [j]) / (1 + diff);\n                p [j] /= (1 + diff);\n            }\n        }\n    }\n    if (iter >= max_iter) System.err.print (\"Exceeds max_iter in multiclass_prob\\n\");\n\n}\n", "code2": "private static void multiclass_probability (int k, double [] [] r, double [] p) {\n    int t, j;\n    int iter = 0, max_iter = Math.max (100, k);\n    double [] [] Q = new double [k] [k];\n    double [] Qp = new double [k];\n    double pQp, eps = 0.005 / k;\n    for (t = 0; t < k; t ++) {\n        p [t] = 1.0 / k;\n        Q [t] [t] = 0;\n        for (j = 0; j < t; j ++) {\n            Q [t] [t] += r [j] [t] * r [j] [t];\n            Q [t] [j] = Q [j] [t];\n        }\n        for (j = t + 1; j < k; j ++) {\n            Q [t] [t] += r [j] [t] * r [j] [t];\n            Q [t] [j] = - r [j] [t] * r [t] [j];\n        }\n    }\n    for (iter = 0; iter < max_iter; iter ++) {\n        pQp = 0;\n        for (t = 0; t < k; t ++) {\n            Qp [t] = 0;\n            for (j = 0; j < k; j ++) Qp [t] += Q [t] [j] * p [j];\n\n            pQp += p [t] * Qp [t];\n        }\n        double max_error = 0;\n        for (t = 0; t < k; t ++) {\n            double error = Math.abs (Qp [t] - pQp);\n            if (error > max_error) max_error = error;\n\n        }\n        if (max_error < eps) break;\n\n        for (t = 0; t < k; t ++) {\n            double diff = (- Qp [t] + pQp) / Q [t] [t];\n            p [t] += diff;\n            pQp = (pQp + diff * (diff * Q [t] [t] + 2 * Qp [t])) / (1 + diff) / (1 + diff);\n            for (j = 0; j < k; j ++) {\n                Qp [j] = (Qp [j] + diff * Q [t] [j]) / (1 + diff);\n                p [j] /= (1 + diff);\n            }\n        }\n    }\n    if (iter >= max_iter) svm.info (\"Exceeds max_iter in multiclass_prob\\n\");\n\n}\n"}
{"clone_type": "VST3", "method1_id": 112054, "method2_id": 236030, "code1": "private void exportAllSettings (HTTPurl urlData, OutputStream outStream) throws Exception {\n    CaptureDeviceList devList = CaptureDeviceList.getInstance ();\n    if (devList.getActiveDeviceCount () > 0) {\n        PageTemplate template = new PageTemplate (store.getProperty (\"path.template\") + File.separator + \"SettingsLoad.html\");\n        StringBuffer buff = new StringBuffer ();\n        buff.append (\"<tr><td><img border=0 src='/images/stop.png' align='absmiddle' width='24' height='24'></td><td>Can not save settings while a capture is in progress.</td></tr>\");\n        template.replaceAll (\"$result\", buff.toString ());\n        outStream.write (template.getPageBytes ());\n        return;\n    }\n    boolean matchList = \"true\".equalsIgnoreCase (urlData.getParameter (\"MatchList\"));\n    boolean autoAdd = \"true\".equalsIgnoreCase (urlData.getParameter (\"AutoAdd\"));\n    boolean channelMapping = \"true\".equalsIgnoreCase (urlData.getParameter (\"ChannelMapping\"));\n    boolean deviceSelection = \"true\".equalsIgnoreCase (urlData.getParameter (\"DeviceSelection\"));\n    boolean agentMapping = \"true\".equalsIgnoreCase (urlData.getParameter (\"AgentMapping\"));\n    boolean channels = \"true\".equalsIgnoreCase (urlData.getParameter (\"Channels\"));\n    boolean tasks = \"true\".equalsIgnoreCase (urlData.getParameter (\"Tasks\"));\n    boolean systemProp = \"true\".equalsIgnoreCase (urlData.getParameter (\"SystemProp\"));\n    boolean schedules = \"true\".equalsIgnoreCase (urlData.getParameter (\"Schedules\"));\n    boolean authSettings = \"true\".equalsIgnoreCase (urlData.getParameter (\"AuthSettings\"));\n    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ();\n    ZipOutputStream out = new ZipOutputStream (bytesOut);\n    out.setComment (\"TV Scheduler Pro Settings file (Version: 1.0)\");\n    if (channels) {\n        out.putNextEntry (new ZipEntry (\"Channels.xml\"));\n        StringBuffer channelData = new StringBuffer ();\n        store.saveChannels (channelData);\n        byte [] channelBytes = channelData.toString ().getBytes (\"UTF-8\");\n        out.write (channelBytes);\n        out.closeEntry ();\n    }\n    if (matchList) {\n        out.putNextEntry (new ZipEntry (\"MatchList.xml\"));\n        StringBuffer matchData = new StringBuffer ();\n        store.saveMatchList (matchData);\n        byte [] matchBytes = matchData.toString ().getBytes (\"UTF-8\");\n        out.write (matchBytes);\n        out.closeEntry ();\n    }\n    if (autoAdd) {\n        out.putNextEntry (new ZipEntry (\"EpgAutoAdd.xml\"));\n        StringBuffer addData = new StringBuffer ();\n        store.saveEpgAutoList (addData);\n        byte [] addBytes = addData.toString ().getBytes (\"UTF-8\");\n        out.write (addBytes);\n        out.closeEntry ();\n    }\n    if (tasks) {\n        out.putNextEntry (new ZipEntry (\"Tasks.xml\"));\n        StringBuffer taskData = new StringBuffer ();\n        store.saveTaskList (taskData);\n        byte [] taskBytes = taskData.toString ().getBytes (\"UTF-8\");\n        out.write (taskBytes);\n        out.closeEntry ();\n    }\n    if (channelMapping) {\n        GuideStore guideStore = GuideStore.getInstance ();\n        out.putNextEntry (new ZipEntry (\"ChannelMap.sof\"));\n        ByteArrayOutputStream chanMapBytes = new ByteArrayOutputStream ();\n        guideStore.saveChannelMap (chanMapBytes);\n        out.write (chanMapBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (deviceSelection) {\n        out.putNextEntry (new ZipEntry (\"CaptureDevices.sof\"));\n        ByteArrayOutputStream deviceBytes = new ByteArrayOutputStream ();\n        devList.saveDeviceList (deviceBytes);\n        out.write (deviceBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (agentMapping) {\n        out.putNextEntry (new ZipEntry (\"AgentMap.sof\"));\n        ByteArrayOutputStream agentMapBytes = new ByteArrayOutputStream ();\n        store.saveAgentToThemeMap (agentMapBytes);\n        out.write (agentMapBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (schedules) {\n        out.putNextEntry (new ZipEntry (\"Times.sof\"));\n        ByteArrayOutputStream timesBytes = new ByteArrayOutputStream ();\n        store.saveSchedule (timesBytes);\n        out.write (timesBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (systemProp) {\n        HashMap < String, String > serverProp = new HashMap < String, String > ();\n        serverProp.put (\"epg.showunlinked\", store.getProperty (\"epg.showunlinked\"));\n        serverProp.put (\"path.theme\", store.getProperty (\"path.theme\"));\n        serverProp.put (\"path.theme.epg\", store.getProperty (\"path.theme.epg\"));\n        serverProp.put (\"capture.path\", store.getProperty (\"capture.path\"));\n        serverProp.put (\"capture.averagedatarate\", store.getProperty (\"capture.averagedatarate\"));\n        serverProp.put (\"capture.autoselectmethod\", store.getProperty (\"capture.autoselectmethod\"));\n        serverProp.put (\"capture.minspacesoft\", store.getProperty (\"capture.minspacesoft\"));\n        serverProp.put (\"capture.includecalculatedusage\", store.getProperty (\"capture.includecalculatedusage\"));\n        serverProp.put (\"capture.deftype\", store.getProperty (\"capture.deftype\"));\n        serverProp.put (\"capture.filename.patterns\", store.getProperty (\"capture.filename.patterns\"));\n        serverProp.put (\"capture.path.details\", store.getProperty (\"capture.path.details\"));\n        serverProp.put (\"capture.capturefailedtimeout\", store.getProperty (\"capture.capturefailedtimeout\"));\n        serverProp.put (\"schedule.buffer.start\", store.getProperty (\"schedule.buffer.start\"));\n        serverProp.put (\"schedule.buffer.end\", store.getProperty (\"schedule.buffer.end\"));\n        serverProp.put (\"schedule.buffer.end.epg\", store.getProperty (\"schedule.buffer.end.epg\"));\n        serverProp.put (\"schedule.wake.system\", store.getProperty (\"schedule.wake.system\"));\n        serverProp.put (\"schedule.overlap\", store.getProperty (\"schedule.overlap\"));\n        serverProp.put (\"sch.autodel.action\", store.getProperty (\"sch.autodel.action\"));\n        serverProp.put (\"sch.autodel.time\", store.getProperty (\"sch.autodel.time\"));\n        serverProp.put (\"guide.source.http.pwd\", store.getProperty (\"guide.source.http.pwd\"));\n        serverProp.put (\"guide.source.xml.channelList\", store.getProperty (\"guide.source.xml.channelList\"));\n        serverProp.put (\"guide.source.type\", store.getProperty (\"guide.source.type\"));\n        serverProp.put (\"guide.source.http\", store.getProperty (\"guide.source.http\"));\n        serverProp.put (\"guide.source.file\", store.getProperty (\"guide.source.file\"));\n        serverProp.put (\"guide.action.name\", store.getProperty (\"guide.action.name\"));\n        serverProp.put (\"guide.source.http.usr\", store.getProperty (\"guide.source.http.usr\"));\n        serverProp.put (\"guide.source.schedule\", store.getProperty (\"guide.source.schedule\"));\n        serverProp.put (\"guide.warn.overlap\", store.getProperty (\"guide.warn.overlap\"));\n        serverProp.put (\"proxy.server\", store.getProperty (\"proxy.server\"));\n        serverProp.put (\"proxy.port\", store.getProperty (\"proxy.port\"));\n        serverProp.put (\"proxy.server.usr\", store.getProperty (\"proxy.server.usr\"));\n        serverProp.put (\"proxy.server.pwd\", store.getProperty (\"proxy.server.pwd\"));\n        serverProp.put (\"email.server\", store.getProperty (\"email.server\"));\n        serverProp.put (\"email.from.name\", store.getProperty (\"email.from.name\"));\n        serverProp.put (\"email.to\", store.getProperty (\"email.to\"));\n        serverProp.put (\"email.from\", store.getProperty (\"email.from\"));\n        serverProp.put (\"email.send.weeklyreport\", store.getProperty (\"email.send.weeklyreport\"));\n        serverProp.put (\"email.send.capfinished\", store.getProperty (\"email.send.capfinished\"));\n        serverProp.put (\"email.send.epgloaded\", store.getProperty (\"email.send.epgloaded\"));\n        serverProp.put (\"email.send.onwarning\", store.getProperty (\"email.send.onwarning\"));\n        serverProp.put (\"email.send.freespacelow\", store.getProperty (\"email.send.freespacelow\"));\n        serverProp.put (\"email.send.serverstarted\", store.getProperty (\"email.send.serverstarted\"));\n        serverProp.put (\"tasks.deftask\", store.getProperty (\"tasks.deftask\"));\n        serverProp.put (\"tasks.pretask\", store.getProperty (\"tasks.pretask\"));\n        serverProp.put (\"tasks.nodataerrortask\", store.getProperty (\"tasks.nodataerrortask\"));\n        serverProp.put (\"tasks.starterrortask\", store.getProperty (\"tasks.starterrortask\"));\n        serverProp.put (\"filebrowser.dirsattop\", store.getProperty (\"filebrowser.dirsattop\"));\n        serverProp.put (\"filebrowser.masks\", store.getProperty (\"filebrowser.masks\"));\n        serverProp.put (\"server.kbled\", store.getProperty (\"server.kbled\"));\n        ByteArrayOutputStream serverpropBytes = new ByteArrayOutputStream ();\n        ObjectOutputStream oos = new ObjectOutputStream (serverpropBytes);\n        oos.writeObject (serverProp);\n        oos.close ();\n        out.putNextEntry (new ZipEntry (\"ServerProperties.sof\"));\n        out.write (serverpropBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (authSettings) {\n        File authFile = new File (store.getProperty (\"path.data\") + File.separator + \"authentication.prop\");\n        if (authFile.exists ()) {\n            out.putNextEntry (new ZipEntry (\"authentication.prop\"));\n            FileInputStream is = new FileInputStream (authFile);\n            byte [] buff = new byte [1024];\n            int read = is.read (buff);\n            while (read != - 1) {\n                out.write (buff, 0, read);\n                read = is.read (buff);\n            }\n            out.closeEntry ();\n            is.close ();\n        }\n    }\n    out.flush ();\n    out.close ();\n    StringBuffer header = new StringBuffer ();\n    header.append (\"HTTP/1.1 200 OK\\n\");\n    header.append (\"Content-Type: application/zip\\n\");\n    header.append (\"Content-Length: \" + bytesOut.size () + \"\\n\");\n    header.append (\"Content-Disposition: attachment; filename=\\\"TV Scheduler Pro Settings.zip\\\"\\n\");\n    DateFormat df = new SimpleDateFormat (\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\", new Locale (\"En\", \"Us\", \"Unix\"));\n    header.append (\"Last-Modified: \" + df.format (new Date ()) + \"\\n\");\n    header.append (\"\\n\");\n    outStream.write (header.toString ().getBytes ());\n    ByteArrayInputStream zipStream = new ByteArrayInputStream (bytesOut.toByteArray ());\n    byte [] bytes = new byte [4096];\n    int read = zipStream.read (bytes);\n    while (read > - 1) {\n        outStream.write (bytes, 0, read);\n        outStream.flush ();\n        read = zipStream.read (bytes);\n    }\n}\n", "code2": "private void exportAllSettings (HTTPurl urlData, OutputStream outStream) throws Exception {\n    CaptureDeviceList devList = CaptureDeviceList.getInstance ();\n    if (devList.getActiveDeviceCount () > 0) {\n        PageTemplate template = new PageTemplate (store.getProperty (\"path.template\") + File.separator + \"SettingsLoad.html\");\n        StringBuffer buff = new StringBuffer ();\n        buff.append (\"<tr><td><img border=0 src='/images/stop.png' align='absmiddle' width='24' height='24'></td><td>Can not save settings while a capture is in progress.</td></tr>\");\n        template.replaceAll (\"$result\", buff.toString ());\n        outStream.write (template.getPageBytes ());\n        return;\n    }\n    boolean matchList = \"true\".equalsIgnoreCase (urlData.getParameter (\"MatchList\"));\n    boolean autoAdd = \"true\".equalsIgnoreCase (urlData.getParameter (\"AutoAdd\"));\n    boolean channelMapping = \"true\".equalsIgnoreCase (urlData.getParameter (\"ChannelMapping\"));\n    boolean deviceSelection = \"true\".equalsIgnoreCase (urlData.getParameter (\"DeviceSelection\"));\n    boolean agentMapping = \"true\".equalsIgnoreCase (urlData.getParameter (\"AgentMapping\"));\n    boolean channels = \"true\".equalsIgnoreCase (urlData.getParameter (\"Channels\"));\n    boolean tasks = \"true\".equalsIgnoreCase (urlData.getParameter (\"Tasks\"));\n    boolean systemProp = \"true\".equalsIgnoreCase (urlData.getParameter (\"SystemProp\"));\n    boolean schedules = \"true\".equalsIgnoreCase (urlData.getParameter (\"Schedules\"));\n    boolean authSettings = \"true\".equalsIgnoreCase (urlData.getParameter (\"AuthSettings\"));\n    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ();\n    ZipOutputStream out = new ZipOutputStream (bytesOut);\n    out.setComment (\"TV Scheduler Pro Settings file (Version: 1.0)\");\n    if (channels) {\n        out.putNextEntry (new ZipEntry (\"Channels.xml\"));\n        StringBuffer channelData = new StringBuffer ();\n        store.saveChannels (channelData);\n        byte [] channelBytes = channelData.toString ().getBytes (\"UTF-8\");\n        out.write (channelBytes);\n        out.closeEntry ();\n    }\n    if (matchList) {\n        out.putNextEntry (new ZipEntry (\"MatchList.xml\"));\n        StringBuffer matchData = new StringBuffer ();\n        store.saveMatchList (matchData);\n        byte [] matchBytes = matchData.toString ().getBytes (\"UTF-8\");\n        out.write (matchBytes);\n        out.closeEntry ();\n    }\n    if (autoAdd) {\n        out.putNextEntry (new ZipEntry (\"EpgAutoAdd.xml\"));\n        StringBuffer addData = new StringBuffer ();\n        store.saveEpgAutoList (addData);\n        byte [] addBytes = addData.toString ().getBytes (\"UTF-8\");\n        out.write (addBytes);\n        out.closeEntry ();\n    }\n    if (tasks) {\n        out.putNextEntry (new ZipEntry (\"Tasks.xml\"));\n        StringBuffer taskData = new StringBuffer ();\n        store.saveTaskList (taskData);\n        byte [] taskBytes = taskData.toString ().getBytes (\"UTF-8\");\n        out.write (taskBytes);\n        out.closeEntry ();\n    }\n    if (channelMapping) {\n        GuideStore guideStore = GuideStore.getInstance ();\n        out.putNextEntry (new ZipEntry (\"ChannelMap.sof\"));\n        ByteArrayOutputStream chanMapBytes = new ByteArrayOutputStream ();\n        guideStore.saveChannelMap (chanMapBytes);\n        out.write (chanMapBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (deviceSelection) {\n        out.putNextEntry (new ZipEntry (\"CaptureDevices.sof\"));\n        ByteArrayOutputStream deviceBytes = new ByteArrayOutputStream ();\n        devList.saveDeviceList (deviceBytes);\n        out.write (deviceBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (agentMapping) {\n        out.putNextEntry (new ZipEntry (\"AgentMap.sof\"));\n        ByteArrayOutputStream agentMapBytes = new ByteArrayOutputStream ();\n        store.saveAgentToThemeMap (agentMapBytes);\n        out.write (agentMapBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (schedules) {\n        out.putNextEntry (new ZipEntry (\"Times.sof\"));\n        ByteArrayOutputStream timesBytes = new ByteArrayOutputStream ();\n        store.saveSchedule (timesBytes);\n        out.write (timesBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (systemProp) {\n        HashMap < String, String > serverProp = new HashMap < String, String > ();\n        serverProp.put (\"epg.showunlinked\", store.getProperty (\"epg.showunlinked\"));\n        serverProp.put (\"path.theme\", store.getProperty (\"path.theme\"));\n        serverProp.put (\"path.theme.epg\", store.getProperty (\"path.theme.epg\"));\n        serverProp.put (\"capture.path\", store.getProperty (\"capture.path\"));\n        serverProp.put (\"capture.averagedatarate\", store.getProperty (\"capture.averagedatarate\"));\n        serverProp.put (\"capture.autoselectmethod\", store.getProperty (\"capture.autoselectmethod\"));\n        serverProp.put (\"capture.minspacesoft\", store.getProperty (\"capture.minspacesoft\"));\n        serverProp.put (\"capture.includecalculatedusage\", store.getProperty (\"capture.includecalculatedusage\"));\n        serverProp.put (\"capture.deftype\", store.getProperty (\"capture.deftype\"));\n        serverProp.put (\"capture.filename.patterns\", store.getProperty (\"capture.filename.patterns\"));\n        serverProp.put (\"capture.path.details\", store.getProperty (\"capture.path.details\"));\n        serverProp.put (\"capture.capturefailedtimeout\", store.getProperty (\"capture.capturefailedtimeout\"));\n        serverProp.put (\"schedule.buffer.start\", store.getProperty (\"schedule.buffer.start\"));\n        serverProp.put (\"schedule.buffer.end\", store.getProperty (\"schedule.buffer.end\"));\n        serverProp.put (\"schedule.buffer.end.epg\", store.getProperty (\"schedule.buffer.end.epg\"));\n        serverProp.put (\"schedule.wake.system\", store.getProperty (\"schedule.wake.system\"));\n        serverProp.put (\"schedule.overlap\", store.getProperty (\"schedule.overlap\"));\n        serverProp.put (\"schedule.noaachan\", store.getProperty (\"schedule.noaachan\"));\n        serverProp.put (\"sch.autodel.action\", store.getProperty (\"sch.autodel.action\"));\n        serverProp.put (\"sch.autodel.time\", store.getProperty (\"sch.autodel.time\"));\n        serverProp.put (\"guide.source.http.pwd\", store.getProperty (\"guide.source.http.pwd\"));\n        serverProp.put (\"guide.source.xml.channelList\", store.getProperty (\"guide.source.xml.channelList\"));\n        serverProp.put (\"guide.source.type\", store.getProperty (\"guide.source.type\"));\n        serverProp.put (\"guide.source.http\", store.getProperty (\"guide.source.http\"));\n        serverProp.put (\"guide.source.file\", store.getProperty (\"guide.source.file\"));\n        serverProp.put (\"guide.action.name\", store.getProperty (\"guide.action.name\"));\n        serverProp.put (\"guide.source.http.usr\", store.getProperty (\"guide.source.http.usr\"));\n        serverProp.put (\"guide.source.schedule\", store.getProperty (\"guide.source.schedule\"));\n        serverProp.put (\"guide.warn.overlap\", store.getProperty (\"guide.warn.overlap\"));\n        serverProp.put (\"proxy.server\", store.getProperty (\"proxy.server\"));\n        serverProp.put (\"proxy.port\", store.getProperty (\"proxy.port\"));\n        serverProp.put (\"proxy.server.usr\", store.getProperty (\"proxy.server.usr\"));\n        serverProp.put (\"proxy.server.pwd\", store.getProperty (\"proxy.server.pwd\"));\n        serverProp.put (\"email.server\", store.getProperty (\"email.server\"));\n        serverProp.put (\"email.from.name\", store.getProperty (\"email.from.name\"));\n        serverProp.put (\"email.to\", store.getProperty (\"email.to\"));\n        serverProp.put (\"email.from\", store.getProperty (\"email.from\"));\n        serverProp.put (\"email.send.weeklyreport\", store.getProperty (\"email.send.weeklyreport\"));\n        serverProp.put (\"email.send.capfinished\", store.getProperty (\"email.send.capfinished\"));\n        serverProp.put (\"email.send.epgloaded\", store.getProperty (\"email.send.epgloaded\"));\n        serverProp.put (\"email.send.onwarning\", store.getProperty (\"email.send.onwarning\"));\n        serverProp.put (\"email.send.freespacelow\", store.getProperty (\"email.send.freespacelow\"));\n        serverProp.put (\"email.send.serverstarted\", store.getProperty (\"email.send.serverstarted\"));\n        serverProp.put (\"tasks.deftask\", store.getProperty (\"tasks.deftask\"));\n        serverProp.put (\"tasks.pretask\", store.getProperty (\"tasks.pretask\"));\n        serverProp.put (\"tasks.nodataerrortask\", store.getProperty (\"tasks.nodataerrortask\"));\n        serverProp.put (\"tasks.starterrortask\", store.getProperty (\"tasks.starterrortask\"));\n        serverProp.put (\"filebrowser.dirsattop\", store.getProperty (\"filebrowser.dirsattop\"));\n        serverProp.put (\"filebrowser.masks\", store.getProperty (\"filebrowser.masks\"));\n        serverProp.put (\"server.kbled\", store.getProperty (\"server.kbled\"));\n        ByteArrayOutputStream serverpropBytes = new ByteArrayOutputStream ();\n        ObjectOutputStream oos = new ObjectOutputStream (serverpropBytes);\n        oos.writeObject (serverProp);\n        oos.close ();\n        out.putNextEntry (new ZipEntry (\"ServerProperties.sof\"));\n        out.write (serverpropBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (authSettings) {\n        File authFile = new File (store.getProperty (\"path.data\") + File.separator + \"authentication.prop\");\n        if (authFile.exists ()) {\n            out.putNextEntry (new ZipEntry (\"authentication.prop\"));\n            FileInputStream is = new FileInputStream (authFile);\n            byte [] buff = new byte [1024];\n            int read = is.read (buff);\n            while (read != - 1) {\n                out.write (buff, 0, read);\n                read = is.read (buff);\n            }\n            out.closeEntry ();\n            is.close ();\n        }\n    }\n    out.flush ();\n    out.close ();\n    StringBuffer header = new StringBuffer ();\n    header.append (\"HTTP/1.1 200 OK\\n\");\n    header.append (\"Content-Type: application/zip\\n\");\n    header.append (\"Content-Length: \" + bytesOut.size () + \"\\n\");\n    header.append (\"Content-Disposition: attachment; filename=\\\"TV Scheduler Pro Settings.zip\\\"\\n\");\n    DateFormat df = new SimpleDateFormat (\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\", new Locale (\"En\", \"Us\", \"Unix\"));\n    header.append (\"Last-Modified: \" + df.format (new Date ()) + \"\\n\");\n    header.append (\"\\n\");\n    outStream.write (header.toString ().getBytes ());\n    ByteArrayInputStream zipStream = new ByteArrayInputStream (bytesOut.toByteArray ());\n    byte [] bytes = new byte [4096];\n    int read = zipStream.read (bytes);\n    while (read > - 1) {\n        outStream.write (bytes, 0, read);\n        outStream.flush ();\n        read = zipStream.read (bytes);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 68708, "method2_id": 273486, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Integer (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Integer (53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            int port = ((Integer) iport.next ()).intValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (InetAddress.getByName (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (null);\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                String addrString;\n                addUDP (addr, port);\n                addTCP (addr, port);\n                if (addr == null) addrString = \"0.0.0.0\";\n                else addrString = addr.getHostAddress ();\n\n                System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 280465, "method2_id": 548504, "code1": "private void scanAll (HTTPurl urlData, OutputStream outStream) throws Exception {\n    int country = 0;\n    int region = 0;\n    try {\n        country = Integer.parseInt (urlData.getParameter (\"country\"));\n        region = Integer.parseInt (urlData.getParameter (\"region\"));\n    } catch (Exception e) {\n        throw new Exception (\"country or region code not valid: \" + e.toString ());\n    }\n    PageTemplate template = new PageTemplate (store.getProperty (\"path.template\") + File.separator + \"channelscan.html\");\n    outStream.write (template.getPageBytes ());\n    CaptureDeviceList devList = CaptureDeviceList.getInstance ();\n    if (devList.getActiveDeviceCount () > 0) {\n        outStream.write (\"Can not scan channels, Captures Running!\".getBytes ());\n        return;\n    }\n    if (devList.getDeviceCount () == 0) {\n        outStream.write (\"No Devices Available!\".getBytes ());\n        return;\n    }\n    String out = \"<form action=\\\"/servlet/\" + urlData.getServletClass () + \"\\\" method=\\\"POST\\\" accept-charset=\\\"UTF-8\\\">\\n\" + \"<input type=\\\"hidden\\\" name=\\\"action\\\" value='05'>\\n\";\n    outStream.write (out.getBytes ());\n    outStream.flush ();\n    ChannelList list = new ChannelList (store.getProperty (\"path.data\") + File.separator + \"stationdata.list\");\n    Channel [] channelList = list.getStations (country, region);\n    list.close ();\n    try {\n        boolean testMode = \"1\".equals (store.getProperty (\"tools.testmode\"));\n        int channelCount = 0;\n        Channel ch = null;\n        for (int x = 0;\n        x < channelList.length; x ++) {\n            int channelsFound = 0;\n            ch = channelList [x];\n            if (ch != null) {\n                StringBuffer buff = new StringBuffer (2048);\n                buff.append (\"<table class='channelScanResult'>\\n\");\n                buff.append (\"<tr class=\\\"scanChannelHeading\\\">\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingDataName\\\">\" + ch.getName () + \"</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Program</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Video</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Audio</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Add</td>\\n\");\n                buff.append (\"</tr>\\n\");\n                if (x > 0) Thread.sleep (5000);\n\n                CaptureDevice cap = (CaptureDevice) devList.getDevice (0);\n                Runtime runner = Runtime.getRuntime ();\n                String [] com = null;\n                if (testMode == true) {\n                    String scanCommand = \"win32/scan.exe -test\";\n                    System.out.println (\"Running channel scan command: \" + scanCommand);\n                    com = new String [2];\n                    com [0] = \"win32/scan.exe\";\n                    com [1] = \"-test\";\n                } else {\n                    String scanCommand = \"win32/scan.exe \" + ch.getFrequency () + \" \" + ch.getBandWidth () + \" \\\"\" + cap.getID () + \"\\\"\";\n                    System.out.println (\"Running channel scan command: \" + scanCommand);\n                    com = new String [4];\n                    com [0] = \"win32/scan.exe\";\n                    com [1] = new Integer (ch.getFrequency ()).toString ();\n                    com [2] = new Integer (ch.getBandWidth ()).toString ();\n                    com [3] = \"\\\"\" + cap.getID () + \"\\\"\";\n                }\n                Process scan = runner.exec (com);\n                ScanResult result = new ScanResult (ch.getFrequency (), ch.getBandWidth ());\n                result.readInput (scan.getInputStream ());\n                result.parseXML ();\n                Vector < Channel > scanResult = result.getResult ();\n                Channel chData = null;\n                for (int y = 0;\n                y < scanResult.size (); y ++) {\n                    chData = (Channel) scanResult.get (y);\n                    if (chData != null) {\n                        buff.append (\"<tr class='scanChannelResult'>\");\n                        buff.append (\"<td>\\n<input type='text' name='name\" + channelCount + \"' value='\" + checkName (chData.getName ()) + \"'>\\n\");\n                        buff.append (\"<input type='hidden' name='freq\" + channelCount + \"' value='\" + chData.getFrequency () + \"'>\\n\");\n                        buff.append (\"<input type='hidden' name='band\" + channelCount + \"' value='\" + chData.getBandWidth () + \"'>\\n\");\n                        buff.append (\"</td>\\n\\n\");\n                        buff.append (\"<td align='center'>\" + chData.getProgramID ());\n                        buff.append (\"<input type='hidden' name='programid\" + channelCount + \"' value='\" + chData.getProgramID () + \"'>\\n\");\n                        buff.append (\"</td>\\n\");\n                        buff.append (\"<td align='center'>\");\n                        int count = getStreamTypeCount (chData, Channel.TYPE_VIDEO);\n                        if (count == 0) {\n                            buff.append (\"-1\");\n                            buff.append (\"<input type='hidden' name='videoid\" + channelCount + \"' value='-1'>\\n\");\n                        }\n                        if (count == 1) {\n                            int [] data = getFirstOfType (chData, Channel.TYPE_VIDEO);\n                            buff.append (data [0]);\n                            buff.append (\"<input type='hidden' name='videoid\" + channelCount + \"' value='\" + data [0] + \"'>\\n\");\n                        } else if (count > 1) {\n                            buff.append (\"<SELECT NAME='videoid\" + channelCount + \"'>\\n\");\n                            for (int st = 0;\n                            st < chData.getStreams ().size (); st ++) {\n                                int [] streamData = (int []) chData.getStreams ().get (st);\n                                if (streamData [1] == Channel.TYPE_VIDEO) {\n                                    buff.append (\"<OPTION value=\\\"\" + streamData [0] + \"\\\">\");\n                                    buff.append (streamData [0]);\n                                    buff.append (\"</OPTION>\\n\");\n                                }\n                            }\n                            buff.append (\"</SELECT>\");\n                        }\n\n                        buff.append (\"</td>\\n\");\n                        buff.append (\"<td align='center'>\");\n                        count = getStreamTypeCount (chData, Channel.TYPE_AUDIO_AC3);\n                        count += getStreamTypeCount (chData, Channel.TYPE_AUDIO_MPG);\n                        if (count == 0) {\n                            buff.append (\"-1\");\n                            buff.append (\"<input type='hidden' name='audioid\" + channelCount + \"' value='-1'>\\n\");\n                        }\n                        if (count == 1) {\n                            int [] data = getFirstOfType (chData, Channel.TYPE_AUDIO_AC3);\n                            if (data == null) data = getFirstOfType (chData, Channel.TYPE_AUDIO_MPG);\n\n                            buff.append (data [0]);\n                            if (data [1] == Channel.TYPE_AUDIO_AC3) buff.append (\" AC3\");\n                            else buff.append (\" MPG\");\n\n                            buff.append (\"<input type='hidden' name='audioid\" + channelCount + \"' value='\" + data [0] + \":\" + data [1] + \"'>\\n\");\n                        } else if (count > 1) {\n                            buff.append (\"<SELECT NAME='audioid\" + channelCount + \"'>\\n\");\n                            for (int st = 0;\n                            st < chData.getStreams ().size (); st ++) {\n                                int [] streamData = (int []) chData.getStreams ().get (st);\n                                if (streamData [1] == Channel.TYPE_AUDIO_MPG || streamData [1] == Channel.TYPE_AUDIO_AC3) {\n                                    buff.append (\"<OPTION value=\\\"\" + streamData [0] + \":\" + streamData [1] + \"\\\">\");\n                                    buff.append (streamData [0]);\n                                    if (streamData [1] == Channel.TYPE_AUDIO_AC3) buff.append (\" AC3\");\n                                    else buff.append (\" MPG\");\n\n                                    buff.append (\"</OPTION>\\n\");\n                                }\n                            }\n                            buff.append (\"</SELECT>\");\n                        }\n\n                        buff.append (\"</td>\\n\");\n                        buff.append (\"<td align='center'><input type='checkbox' name='add\" + channelCount + \"' value='add'></td>\\n\");\n                        buff.append (\"</tr>\\n\\n\");\n                        channelCount ++;\n                        channelsFound ++;\n                    } else {\n                        break;\n                    }\n                }\n                if (channelsFound == 0) {\n                    buff.append (\"<tr class='scanChannelResult'>\");\n                    buff.append (\"<td>No Programs Found</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"</tr>\\n\\n\");\n                }\n                buff.append (\"</table><br>\\n\");\n                outStream.write (buff.toString ().getBytes ());\n                outStream.flush ();\n                outStream.write (\"\\n\\n\\n\\n\\n           \\n\\n\\n\\n\\n\\n\".getBytes ());\n                outStream.flush ();\n            }\n        }\n        if (channelCount > 0) out = \"<input type=\\\"submit\\\" value=\\\"Add Selected\\\"></form></body></html><br><br>\\n\";\n\n        outStream.write (out.getBytes ());\n        outStream.flush ();\n    } catch (Exception e) {\n        throw e;\n    }\n}\n", "code2": "private void scanAll (HTTPurl urlData, OutputStream outStream) throws Exception {\n    int country = 0;\n    int region = 0;\n    try {\n        country = Integer.parseInt (urlData.getParameter (\"country\"));\n        region = Integer.parseInt (urlData.getParameter (\"region\"));\n    } catch (Exception e) {\n        throw new Exception (\"country or region code not valid: \" + e.toString ());\n    }\n    PageTemplate template = new PageTemplate (store.getProperty (\"path.template\") + File.separator + \"channelscan.html\");\n    outStream.write (template.getPageBytes ());\n    CaptureDeviceList devList = CaptureDeviceList.getInstance ();\n    if (devList.getActiveDeviceCount () > 0) {\n        outStream.write (\"Can not scan channels, Captures Running!\".getBytes ());\n        return;\n    }\n    if (devList.getDeviceCount () == 0) {\n        outStream.write (\"No Devices Available!\".getBytes ());\n        return;\n    }\n    String out = \"<form action=\\\"/servlet/\" + urlData.getServletClass () + \"\\\" method=\\\"POST\\\" accept-charset=\\\"UTF-8\\\">\\n\" + \"<input type=\\\"hidden\\\" name=\\\"action\\\" value='05'>\\n\";\n    outStream.write (out.getBytes ());\n    outStream.flush ();\n    ChannelList list = new ChannelList (store.getProperty (\"path.data\") + File.separator + \"stationdata.list\");\n    Channel [] channelList = list.getStations (country, region);\n    list.close ();\n    try {\n        int channelCount = 0;\n        Channel ch = null;\n        for (int x = 0;\n        x < channelList.length; x ++) {\n            int channelsFound = 0;\n            ch = channelList [x];\n            if (ch != null) {\n                StringBuffer buff = new StringBuffer (2048);\n                buff.append (\"<table class='channelScanResult'>\\n\");\n                buff.append (\"<tr class=\\\"scanChannelHeading\\\">\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingDataName\\\">\" + ch.getName () + \"</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Program</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Video</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Audio</td>\\n\");\n                buff.append (\"<td class=\\\"scanChannelHeadingData\\\">Add</td>\\n\");\n                buff.append (\"</tr>\\n\");\n                if (x > 0) Thread.sleep (5000);\n\n                CaptureDevice cap = (CaptureDevice) devList.getDevice (0);\n                String scanCommand = \"scan.exe \" + ch.getFrequency () + \" \" + ch.getBandWidth () + \" \\\"\" + cap.getID () + \"\\\"\";\n                System.out.println (\"Running channel scan command: \" + scanCommand);\n                Runtime runner = Runtime.getRuntime ();\n                String [] com = new String [4];\n                com [0] = \"scan.exe\";\n                com [1] = new Integer (ch.getFrequency ()).toString ();\n                com [2] = new Integer (ch.getBandWidth ()).toString ();\n                com [3] = \"\\\"\" + cap.getID () + \"\\\"\";\n                Process scan = runner.exec (com);\n                ScanResult result = new ScanResult (ch.getFrequency (), ch.getBandWidth ());\n                result.readInput (scan.getInputStream ());\n                result.parseXML ();\n                Vector scanResult = result.getResult ();\n                Channel chData = null;\n                for (int y = 0;\n                y < scanResult.size (); y ++) {\n                    chData = (Channel) scanResult.get (y);\n                    if (chData != null) {\n                        buff.append (\"<tr class='scanChannelResult'>\");\n                        buff.append (\"<td>\\n<input type='text' name='name\" + channelCount + \"' value='\" + checkName (chData.getName ()) + \"'>\\n\");\n                        buff.append (\"<input type='hidden' name='freq\" + channelCount + \"' value='\" + chData.getFrequency () + \"'>\\n\");\n                        buff.append (\"<input type='hidden' name='band\" + channelCount + \"' value='\" + chData.getBandWidth () + \"'>\\n\");\n                        buff.append (\"</td>\\n\\n\");\n                        buff.append (\"<td align='center'>\" + chData.getProgramID ());\n                        buff.append (\"<input type='hidden' name='programid\" + channelCount + \"' value='\" + chData.getProgramID () + \"'>\\n\");\n                        buff.append (\"</td>\\n\");\n                        buff.append (\"<td align='center'>\");\n                        int count = getStreamTypeCount (chData, Channel.TYPE_VIDEO);\n                        if (count == 0) {\n                            buff.append (\"-1\");\n                            buff.append (\"<input type='hidden' name='videoid\" + channelCount + \"' value='-1'>\\n\");\n                        }\n                        if (count == 1) {\n                            int [] data = getFirstOfType (chData, Channel.TYPE_VIDEO);\n                            buff.append (data [0]);\n                            buff.append (\"<input type='hidden' name='videoid\" + channelCount + \"' value='\" + data [0] + \"'>\\n\");\n                        } else if (count > 1) {\n                            buff.append (\"<SELECT NAME='videoid\" + channelCount + \"'>\\n\");\n                            for (int st = 0;\n                            st < chData.getStreams ().size (); st ++) {\n                                int [] streamData = (int []) chData.getStreams ().get (st);\n                                if (streamData [1] == Channel.TYPE_VIDEO) {\n                                    buff.append (\"<OPTION value=\\\"\" + streamData [0] + \"\\\">\");\n                                    buff.append (streamData [0]);\n                                    buff.append (\"</OPTION>\\n\");\n                                }\n                            }\n                            buff.append (\"</SELECT>\");\n                        }\n\n                        buff.append (\"</td>\\n\");\n                        buff.append (\"<td align='center'>\");\n                        count = getStreamTypeCount (chData, Channel.TYPE_AUDIO_AC3);\n                        count += getStreamTypeCount (chData, Channel.TYPE_AUDIO_MPG);\n                        if (count == 0) {\n                            buff.append (\"-1\");\n                            buff.append (\"<input type='hidden' name='audioid\" + channelCount + \"' value='-1'>\\n\");\n                        }\n                        if (count == 1) {\n                            int [] data = getFirstOfType (chData, Channel.TYPE_AUDIO_AC3);\n                            if (data == null) data = getFirstOfType (chData, Channel.TYPE_AUDIO_MPG);\n\n                            buff.append (data [0]);\n                            if (data [1] == Channel.TYPE_AUDIO_AC3) buff.append (\" AC3\");\n                            else buff.append (\" MPG\");\n\n                            buff.append (\"<input type='hidden' name='audioid\" + channelCount + \"' value='\" + data [0] + \":\" + data [1] + \"'>\\n\");\n                        } else if (count > 1) {\n                            buff.append (\"<SELECT NAME='audioid\" + channelCount + \"'>\\n\");\n                            for (int st = 0;\n                            st < chData.getStreams ().size (); st ++) {\n                                int [] streamData = (int []) chData.getStreams ().get (st);\n                                if (streamData [1] == Channel.TYPE_AUDIO_MPG || streamData [1] == Channel.TYPE_AUDIO_AC3) {\n                                    buff.append (\"<OPTION value=\\\"\" + streamData [0] + \":\" + streamData [1] + \"\\\">\");\n                                    buff.append (streamData [0]);\n                                    if (streamData [1] == Channel.TYPE_AUDIO_AC3) buff.append (\" AC3\");\n                                    else buff.append (\" MPG\");\n\n                                    buff.append (\"</OPTION>\\n\");\n                                }\n                            }\n                            buff.append (\"</SELECT>\");\n                        }\n\n                        buff.append (\"</td>\\n\");\n                        buff.append (\"<td align='center'><input type='checkbox' name='add\" + channelCount + \"' value='add'></td>\\n\");\n                        buff.append (\"</tr>\\n\\n\");\n                        channelCount ++;\n                        channelsFound ++;\n                    } else {\n                        break;\n                    }\n                }\n                if (channelsFound == 0) {\n                    buff.append (\"<tr class='scanChannelResult'>\");\n                    buff.append (\"<td>No Programs Found</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"<td align='center'>N/A</td>\\n\");\n                    buff.append (\"</tr>\\n\\n\");\n                }\n                buff.append (\"</table><br>\\n\");\n                outStream.write (buff.toString ().getBytes ());\n                outStream.flush ();\n                outStream.write (\"\\n\\n\\n\\n\\n           \\n\\n\\n\\n\\n\\n\".getBytes ());\n                outStream.flush ();\n            }\n        }\n        if (channelCount > 0) out = \"<input type=\\\"submit\\\" value=\\\"Add Selected\\\"></form></body></html><br><br>\\n\";\n\n        outStream.write (out.getBytes ());\n        outStream.flush ();\n    } catch (Exception e) {\n        throw e;\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 38445, "method2_id": 362411, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 18799599, "method2_id": 18799600, "code1": "private double searchMin (double left, double delta, int depth) {\n    double right = left + delta;\n    mmVar.setVal (left);\n    double leftVal = mmExpr.getVal ();\n    boolean incrLeft = mmDeriv.getVal () > 0;\n    mmVar.setVal (right);\n    double rightVal = mmExpr.getVal ();\n    boolean incrRight = mmDeriv.getVal () > 0;\n    if (! incrLeft && incrRight) {\n        double mid = (left + right) / 2;\n        if (depth >= 13) {\n            mmVar.setVal (mid);\n            return mmExpr.getVal ();\n        }\n        double slope = mmDeriv.getVal ();\n        if (slope < 0) return searchMin (mid, right, depth + 1);\n        else return searchMin (left, mid, depth + 1);\n\n    }\n    return Math.min (leftVal, rightVal);\n}\n", "code2": "private double searchMax (double left, double delta, int depth) {\n    double right = left + delta;\n    mmVar.setVal (left);\n    double leftVal = mmExpr.getVal ();\n    boolean incrLeft = mmDeriv.getVal () > 0;\n    mmVar.setVal (right);\n    double rightVal = mmExpr.getVal ();\n    boolean incrRight = mmDeriv.getVal () > 0;\n    if (incrLeft && ! incrRight) {\n        double mid = (left + right) / 2;\n        if (depth >= 13) {\n            mmVar.setVal (mid);\n            return mmExpr.getVal ();\n        }\n        double slope = mmDeriv.getVal ();\n        if (slope > 0) return searchMax (mid, right, depth + 1);\n        else return searchMax (left, mid, depth + 1);\n\n    }\n    return Math.max (leftVal, rightVal);\n}\n"}
{"clone_type": "VST3", "method1_id": 831650, "method2_id": 7460369, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 25839, "method2_id": 331443, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (InetAddress.getByName (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (null);\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                String addrString;\n                addUDP (addr, port);\n                addTCP (addr, port);\n                if (addr == null) addrString = \"0.0.0.0\";\n                else addrString = addr.getHostAddress ();\n\n                System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (Address.getByAddress (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (Address.getByAddress (\"0.0.0.0\"));\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                addUDP (addr, port);\n                addTCP (addr, port);\n                System.out.println (\"jnamed: listening on \" + addrport (addr, port));\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 3613198, "method2_id": 9756057, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public void writeToFile (File out) throws IOException, DocumentException {\n    FileChannel inChannel = new FileInputStream (pdf_file).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 11440870, "method2_id": 13728120, "code1": "public Matrix transpose () {\n    Matrix X = new Matrix (n, m);\n    int [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n", "code2": "public Matrix transpose () {\n    Matrix X = new Matrix (n, m);\n    double [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n"}
{"clone_type": "VST3", "method1_id": 7237618, "method2_id": 14763206, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 569226, "method2_id": 893803, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 1543361, "method2_id": 12469139, "code1": "public ProgramSymbol createNewProgramSymbol (int programID, String module, String symbol, int address, int size) throws AdaptationException {\n    ProgramSymbol programSymbol = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        String query = \"INSERT INTO ProgramSymbols \" + \"(programID, module, symbol, address, size)\" + \" VALUES (\" + programID + \", '\" + module + \"',  '\" + symbol + \"', \" + address + \", \" + size + \")\";\n        connection = DriverManager.getConnection (CONN_STR);\n        statement = connection.createStatement ();\n        statement.executeUpdate (query);\n        query = \"SELECT * FROM ProgramSymbols WHERE  \" + \"programID =  \" + programID + \"  AND \" + \"module    = '\" + module + \"' AND \" + \"symbol    = '\" + symbol + \"'\";\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Attempt to create program symbol failed.\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        programSymbol = getProgramSymbol (resultSet);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in createNewProgramSymbol\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return programSymbol;\n}\n", "code2": "public Program createNewProgram (int projectID, String name, String description) throws AdaptationException {\n    Program program = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        connection = DriverManager.getConnection (CONN_STR);\n        connection.setAutoCommit (false);\n        statement = connection.createStatement ();\n        String query = \"INSERT INTO Programs(projectID, name, \" + \"description, sourcePath) VALUES ( \" + projectID + \", \" + \"'\" + name + \"', \" + \"'\" + description + \"', \" + \"'\" + \"[unknown]\" + \"')\";\n        log.debug (\"SQL Query:\\n\" + query);\n        statement.executeUpdate (query);\n        query = \"SELECT * FROM Programs WHERE \" + \" projectID   =  \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Attempt to create program failed\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        program = getProgram (resultSet);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in createNewProgram\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return program;\n}\n"}
{"clone_type": "VST3", "method1_id": 1663419, "method2_id": 15831694, "code1": "private static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 36317, "method2_id": 259742, "code1": "public static void main (String [] args) {\n    final String version = System.getProperty (\"java.version\");\n    if (version.startsWith (\"1.0\") || version.startsWith (\"1.1\") || version.startsWith (\"1.2\") || version.startsWith (\"1.3\")) {\n        System.err.println (\"\");\n        System.err.print (\"J requires Java 1.4 or later.\");\n        System.err.println (\" (Java 1.4.2 is recommended.)\");\n        System.err.println (\"\");\n        System.exit (1);\n    }\n    try {\n        Class c = Class.forName (\"org.armedbear.j.Editor\");\n        Class [] parameterTypes = new Class [1];\n        parameterTypes [0] = String [].class;\n        Method method = c.getMethod (\"main\", parameterTypes);\n        Object [] parameters = new Object [1];\n        parameters [0] = args;\n        method.invoke (null, parameters);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String version = System.getProperty (\"java.version\");\n    if (version.startsWith (\"1.0\") || version.startsWith (\"1.1\") || version.startsWith (\"1.2\")) {\n        System.err.println (\"\");\n        System.err.print (\"J requires Java 1.3 or later.\");\n        System.err.println (\" (Java 1.4.1 is recommended.)\");\n        System.err.println (\"\");\n        System.exit (1);\n    }\n    try {\n        Class c = Class.forName (\"org.armedbear.j.Editor\");\n        Class [] parameterTypes = new Class [1];\n        parameterTypes [0] = String [].class;\n        Method method = c.getMethod (\"main\", parameterTypes);\n        Object [] parameters = new Object [1];\n        parameters [0] = args;\n        method.invoke (null, parameters);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 10425169, "method2_id": 23161545, "code1": "private void getRandomGUID (boolean secure, Object o) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (o.getClass ().getName ());\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 18623183, "method2_id": 19643372, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem encoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 1624010, "method2_id": 14263421, "code1": "public static void copy (String a, String b) throws IOException {\n    File inputFile = new File (a);\n    File outputFile = new File (b);\n    FileReader in = new FileReader (inputFile);\n    FileWriter out = new FileWriter (outputFile);\n    int c;\n    while ((c = in.read ()) != - 1) out.write (c);\n\n    in.close ();\n    out.close ();\n}\n", "code2": "void copyFile (String sInput, String sOutput) throws IOException {\n    File inputFile = new File (sInput);\n    File outputFile = new File (sOutput);\n    FileReader in = new FileReader (inputFile);\n    FileWriter out = new FileWriter (outputFile);\n    int c;\n    while ((c = in.read ()) != - 1) out.write (c);\n\n    in.close ();\n    out.close ();\n}\n"}
{"clone_type": "VST3", "method1_id": 8537851, "method2_id": 11453370, "code1": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n", "code2": "public static Object [] addObjectToArray (Object [] array, Object object) {\n    Class < ? > compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (object != null) {\n        compType = object.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = object;\n    return newArr;\n}\n"}
{"clone_type": "VST3", "method1_id": 361635, "method2_id": 362411, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 4471001, "method2_id": 7460369, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 801150, "method2_id": 914605, "code1": "void run () throws Exception {\n    File javaHome = new File (System.getProperty (\"java.home\"));\n    if (javaHome.getName ().equals (\"jre\")) javaHome = javaHome.getParentFile ();\n\n    File javadoc = new File (new File (javaHome, \"bin\"), \"javadoc\");\n    File testSrc = new File (System.getProperty (\"test.src\"));\n    String thisClassName = TestStdDoclet.class.getName ();\n    Process p = new ProcessBuilder ().command (javadoc.getPath (), \"-J-Xbootclasspath:\" + System.getProperty (\"sun.boot.class.path\"), \"-package\", new File (testSrc, thisClassName + \".java\").getPath ()).redirectErrorStream (true).start ();\n    int actualDocletWarnCount = 0;\n    int reportedDocletWarnCount = 0;\n    BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));\n    try {\n        String line;\n        while ((line = in.readLine ()) != null) {\n            System.err.println (line);\n            if (line.contains (\"DoesNotExist\")) actualDocletWarnCount ++;\n\n            if (line.matches (\"[0-9]+ warning(s)?\")) reportedDocletWarnCount = Integer.valueOf (line.substring (0, line.indexOf (\" \")));\n\n        }\n    } finally {\n        in.close ();\n    }\n    int rc = p.waitFor ();\n    if (rc != 0) System.err.println (\"javadoc failed, rc:\" + rc);\n\n    int expectedDocletWarnCount = 2;\n    checkEqual (\"actual\", actualDocletWarnCount, \"expected\", expectedDocletWarnCount);\n    checkEqual (\"actual\", actualDocletWarnCount, \"reported\", reportedDocletWarnCount);\n}\n", "code2": "void run () throws Exception {\n    File javaHome = new File (System.getProperty (\"java.home\"));\n    if (javaHome.getName ().equals (\"jre\")) javaHome = javaHome.getParentFile ();\n\n    File javadoc = new File (new File (javaHome, \"bin\"), \"javadoc\");\n    File testSrc = new File (System.getProperty (\"test.src\"));\n    File testClasses = new File (System.getProperty (\"test.classes\"));\n    String thisClassName = TestUserDoclet.class.getName ();\n    Process p = new ProcessBuilder ().command (javadoc.getPath (), \"-J-Xbootclasspath:\" + System.getProperty (\"sun.boot.class.path\"), \"-doclet\", thisClassName, \"-docletpath\", testClasses.getPath (), new File (testSrc, thisClassName + \".java\").getPath ()).redirectErrorStream (true).start ();\n    int actualDocletWarnCount = 0;\n    int reportedDocletWarnCount = 0;\n    BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));\n    try {\n        String line;\n        while ((line = in.readLine ()) != null) {\n            System.err.println (line);\n            if (line.contains (docletWarning)) actualDocletWarnCount ++;\n\n            if (line.matches (\"[0-9]+ warning(s)?\")) reportedDocletWarnCount = Integer.valueOf (line.substring (0, line.indexOf (\" \")));\n\n        }\n    } finally {\n        in.close ();\n    }\n    int rc = p.waitFor ();\n    if (rc != 0) System.err.println (\"javadoc failed, rc:\" + rc);\n\n    int expectedDocletWarnCount = 1;\n    checkEqual (\"actual\", actualDocletWarnCount, \"expected\", expectedDocletWarnCount);\n    checkEqual (\"actual\", actualDocletWarnCount, \"reported\", reportedDocletWarnCount);\n}\n"}
{"clone_type": "VST3", "method1_id": 3959503, "method2_id": 8980221, "code1": "public static void copyFile (File source, File dest) throws IOException {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        in.transferTo (0, in.size (), out);\n    } catch (FileNotFoundException fnfe) {\n        fnfe.printStackTrace ();\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File source, File dest) throws IOException {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        in.transferTo (0, in.size (), out);\n    } catch (Exception e) {\n        log.error (e, e);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 279123, "method2_id": 480187, "code1": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n", "code2": "public static void main (String [] argv) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 320201, "method2_id": 331443, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (InetAddress.getByName (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (null);\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                String addrString;\n                addUDP (addr, port);\n                addTCP (addr, port);\n                if (addr == null) addrString = \"0.0.0.0\";\n                else addrString = addr.getHostAddress ();\n\n                System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (Address.getByAddress (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (Address.getByAddress (\"0.0.0.0\"));\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                addUDP (addr, port);\n                addTCP (addr, port);\n                System.out.println (\"jnamed: listening on \" + addrport (addr, port));\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 7460369, "method2_id": 7760801, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 2532322, "method2_id": 7460369, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 1037968, "method2_id": 21374275, "code1": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n", "code2": "private static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 684308, "method2_id": 948930, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 6109628, "method2_id": 20361756, "code1": "public ITreeProcessor [] getProcessors (String text) {\n    ArrayList < ITreeProcessor > list = new ArrayList < ITreeProcessor > ();\n    Pattern pattern = Pattern.compile (regex);\n    Matcher matcher = pattern.matcher (text);\n    while (matcher.find ()) {\n        String found = text.substring (matcher.start (), matcher.end ());\n        StringTokenizer st = new StringTokenizer (found, \"=; \");\n        st.nextToken ();\n        list.add (new SeedHandler (Integer.parseInt (st.nextToken ())));\n    }\n    return list.toArray (new ITreeProcessor [list.size ()]);\n}\n", "code2": "public ITreeProcessor [] getProcessors (String text) {\n    ArrayList < ITreeProcessor > list = new ArrayList < ITreeProcessor > ();\n    Pattern pattern = Pattern.compile (regex);\n    Matcher matcher = pattern.matcher (text);\n    while (matcher.find ()) {\n        String found = text.substring (matcher.start (), matcher.end ());\n        StringTokenizer st = new StringTokenizer (found, \" ;\");\n        st.nextToken ();\n        list.add (new ImportHandler (st.nextToken ()));\n    }\n    return list.toArray (new ITreeProcessor [list.size ()]);\n}\n"}
{"clone_type": "VST3", "method1_id": 569226, "method2_id": 683983, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 7542627, "method2_id": 10513108, "code1": "public Matrix transpose () {\n    final int array [] [] = new int [numCols] [numRows];\n    for (int j, i = 0;\n    i < numRows; i ++) {\n        array [0] [i] = matrix [i] [0];\n        for (j = 1; j < numCols; j ++) array [j] [i] = matrix [i] [j];\n\n    }\n    return new IntegerMatrix (array);\n}\n", "code2": "public Matrix transpose () {\n    final double array [] [] = new double [numCols] [numRows];\n    for (int j, i = 0;\n    i < numRows; i ++) {\n        array [0] [i] = matrix [i] [0];\n        for (j = 1; j < numCols; j ++) array [j] [i] = matrix [i] [j];\n\n    }\n    return new DoubleSquareMatrix (array);\n}\n"}
{"clone_type": "VST3", "method1_id": 6414571, "method2_id": 7423625, "code1": "private void downloadlblMouseClicked (java.awt.event.MouseEvent evt) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        if (desktop.isSupported (Desktop.Action.BROWSE)) {\n            try {\n                desktop.browse (new URI (Way2SMSCore.downloadlink));\n            } catch (Exception e) {\n                System.out.println (e);\n            }\n        }\n    }\n}\n", "code2": "private void projlblMouseClicked (java.awt.event.MouseEvent evt) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        if (desktop.isSupported (Desktop.Action.BROWSE)) {\n            try {\n                desktop.browse (new URI (\"http://sourceforge.net/projects/w2sc/\"));\n            } catch (Exception e) {\n                System.out.println (e);\n            }\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 93570, "method2_id": 412224, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Integer (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Integer (53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            int port = ((Integer) iport.next ()).intValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n", "code2": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Short (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Short.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Short ((short) 53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            short port = ((Short) iport.next ()).shortValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n"}
{"clone_type": "VST3", "method1_id": 14926036, "method2_id": 15187702, "code1": "@Override\npublic void mouseClicked (MouseEvent e) {\n    String link = fixedLink;\n    if (link == null) {\n        link = JHyperlinkLabel.this.getText ();\n    }\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (URI.create (link));\n        } catch (IOException ex) {\n            LOG.log (Level.SEVERE, null, ex);\n        }\n    } else {\n    }\n}\n", "code2": "@Override\npublic void mouseClicked (MouseEvent e) {\n    String link = fixedLink;\n    if (link == null) {\n        link = JHyperlinkLabel.this.getText ();\n    }\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (URI.create (link));\n        } catch (IOException ex) {\n            LOG.log (Level.SEVERE, null, ex);\n        }\n    } else {\n        BrowserStarter.displayURL (link);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 11719425, "method2_id": 14321943, "code1": "public RealSquareMatrix copyLowerToUpper () {\n    for (int i = 0;\n    i < cols - 1; i ++) {\n        for (int j = i + 1;\n        j < cols; j ++) {\n            flmat [i] [j] = flmat [j] [i];\n        }\n    }\n    return this;\n}\n", "code2": "public IntSquareMatrix copyUpperToLower () {\n    for (int i = 0;\n    i < cols - 1; i ++) {\n        for (int j = i + 1;\n        j < cols; j ++) {\n            flmat [j] [i] = flmat [i] [j];\n        }\n    }\n    return this;\n}\n"}
{"clone_type": "VST3", "method1_id": 691839, "method2_id": 891614, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 576881, "method2_id": 948930, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 1769771, "method2_id": 15831694, "code1": "private void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 223122, "method2_id": 808353, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 3516106, "method2_id": 19388622, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) {\n                sb.append ('0');\n            }\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 10637999, "method2_id": 13295660, "code1": "public static final double [] [] transpose (double [] [] a) {\n    int am = a.length;\n    int an = a [0].length;\n    double [] [] result = new double [an] [am];\n    for (int i = 0;\n    i < am; i ++) {\n        for (int j = 0;\n        j < an; j ++) {\n            result [j] [i] = a [i] [j];\n        }\n    }\n    return result;\n}\n", "code2": "public static double [] [] transpose (double [] [] M) {\n    int lines = M.length;\n    int columns = M [0].length;\n    double [] [] Mtrans = new double [columns] [lines];\n    for (int i = 0;\n    i < lines; i ++) {\n        for (int j = 0;\n        j < columns; j ++) {\n            Mtrans [j] [i] = M [i] [j];\n        }\n    }\n    return Mtrans;\n}\n"}
{"clone_type": "VST3", "method1_id": 12822637, "method2_id": 23179136, "code1": "private void doLogin (String password) throws LoginFailedException, IncorrectPasswordException {\n    long mgr = Constants.MANAGER;\n    Data data, response;\n    try {\n        response = sendAndWait (new Request (mgr)).get (0);\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance (\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException (\"MD5 hash not supported.\");\n        }\n        byte [] challenge = response.getBytes ();\n        md.update (challenge);\n        md.update (password.getBytes (Data.STRING_ENCODING));\n        try {\n            data = Data.valueOf (md.digest ());\n            response = sendAndWait (new Request (mgr).add (0, data)).get (0);\n        } catch (ExecutionException ex) {\n            throw new IncorrectPasswordException ();\n        }\n        loginMessage = response.getString ();\n        response = sendAndWait (new Request (mgr).add (0, getLoginData ())).get (0);\n        ID = response.getWord ();\n    } catch (InterruptedException ex) {\n        throw new LoginFailedException (ex);\n    } catch (ExecutionException ex) {\n        throw new LoginFailedException (ex);\n    } catch (IOException ex) {\n        throw new LoginFailedException (ex);\n    }\n}\n", "code2": "private void doLogin (String password) throws LoginFailedException, IncorrectPasswordException {\n    final long mgr = Constants.MANAGER;\n    Data data, response;\n    try {\n        response = sendAndWait (new Request (mgr)).get (0);\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance (\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException (\"MD5 hash not supported.\");\n        }\n        byte [] challenge = response.getBytes ();\n        md.update (challenge);\n        md.update (password.getBytes (Data.STRING_ENCODING));\n        try {\n            data = Data.valueOf (md.digest ());\n            response = sendAndWait (new Request (mgr).add (0, data)).get (0);\n        } catch (ExecutionException ex) {\n            throw new IncorrectPasswordException ();\n        }\n        setLoginMessage (response.getString ());\n        response = sendAndWait (new Request (mgr).add (0, getLoginData ())).get (0);\n        ID = response.getWord ();\n        registerSettings ();\n    } catch (InterruptedException ex) {\n        throw new LoginFailedException (ex);\n    } catch (ExecutionException ex) {\n        throw new LoginFailedException (ex);\n    } catch (IOException ex) {\n        throw new LoginFailedException (ex);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 12499284, "method2_id": 16929855, "code1": "public void runTask (HashMap pjobParms) throws Exception {\n    FTPClient lftpClient = null;\n    FileOutputStream lfosTargetFile = null;\n    JBJFPluginDefinition lpluginCipher = null;\n    IJBJFPluginCipher theCipher = null;\n    try {\n        JBJFFTPDefinition lxmlFTP = null;\n        if (getFTPDefinition () != null) {\n            lxmlFTP = getFTPDefinition ();\n            this.mstrSourceDirectory = lxmlFTP.getSourceDirectory ();\n            this.mstrTargetDirectory = lxmlFTP.getTargetDirectory ();\n            this.mstrFilename = lxmlFTP.getFilename ();\n            this.mstrRemoteServer = lxmlFTP.getServer ();\n            if (getResources ().containsKey (\"plugin-cipher\")) {\n                lpluginCipher = (JBJFPluginDefinition) getResources ().get (\"plugin-cipher\");\n            }\n            if (lpluginCipher != null) {\n                theCipher = getTaskPlugins ().getCipherPlugin (lpluginCipher.getPluginId ());\n            }\n            if (theCipher != null) {\n                this.mstrServerUsr = theCipher.decryptString (lxmlFTP.getUser ());\n                this.mstrServerPwd = theCipher.decryptString (lxmlFTP.getPass ());\n            } else {\n                this.mstrServerUsr = lxmlFTP.getUser ();\n                this.mstrServerPwd = lxmlFTP.getPass ();\n            }\n        } else {\n            throw new Exception (\"Work unit [ \" + SHORT_NAME + \" ] is missing an FTP Definition.  Please check\" + \" your JBJF Batch Definition file an make sure\" + \" this work unit has a <resource> element added\" + \" within the <task> element.\");\n        }\n        lfosTargetFile = new FileOutputStream (mstrTargetDirectory + File.separator + mstrFilename);\n        lftpClient = new FTPClient ();\n        lftpClient.connect (mstrRemoteServer);\n        lftpClient.setFileType (lxmlFTP.getFileTransferType ());\n        if (! FTPReply.isPositiveCompletion (lftpClient.getReplyCode ())) {\n            throw new Exception (\"FTP server [ \" + mstrRemoteServer + \" ] refused connection.\");\n        }\n        if (! lftpClient.login (mstrServerUsr, mstrServerPwd)) {\n            throw new Exception (\"Unable to login to server [ \" + mstrTargetDirectory + \" ].\");\n        }\n        if (! lftpClient.changeWorkingDirectory (mstrSourceDirectory)) {\n            throw new Exception (\"Unable to change to remote directory [ \" + mstrSourceDirectory + \"]\");\n        }\n        lftpClient.enterLocalPassiveMode ();\n        if (! lftpClient.retrieveFile (mstrFilename, lfosTargetFile)) {\n            throw new Exception (\"Unable to download [ \" + mstrSourceDirectory + \"/\" + mstrFilename + \" to \" + mstrTargetDirectory + File.separator + mstrFilename + \" ] from server [ \" + mstrRemoteServer + \" ]\");\n        }\n        lfosTargetFile.close ();\n        lftpClient.logout ();\n    } catch (Exception e) {\n        throw e;\n    } finally {\n        if (lftpClient != null && lftpClient.isConnected ()) {\n            try {\n                lftpClient.disconnect ();\n            } catch (IOException ioe) {\n            }\n        }\n        if (lfosTargetFile != null) {\n            try {\n                lfosTargetFile.close ();\n            } catch (Exception e) {\n            }\n        }\n    }\n}\n", "code2": "public void runTask (HashMap pjobParms) throws Exception {\n    FTPClient lftpClient = null;\n    FileInputStream lfisSourceFile = null;\n    JBJFPluginDefinition lpluginCipher = null;\n    IJBJFPluginCipher theCipher = null;\n    try {\n        JBJFFTPDefinition lxmlFTP = null;\n        if (getFTPDefinition () != null) {\n            lxmlFTP = getFTPDefinition ();\n            this.mstrSourceDirectory = lxmlFTP.getSourceDirectory ();\n            this.mstrTargetDirectory = lxmlFTP.getTargetDirectory ();\n            this.mstrFilename = lxmlFTP.getFilename ();\n            this.mstrRemoteServer = lxmlFTP.getServer ();\n            if (getResources ().containsKey (\"plugin-cipher\")) {\n                lpluginCipher = (JBJFPluginDefinition) getResources ().get (\"plugin-cipher\");\n            }\n            if (lpluginCipher != null) {\n                theCipher = getTaskPlugins ().getCipherPlugin (lpluginCipher.getPluginId ());\n            }\n            if (theCipher != null) {\n                this.mstrServerUsr = theCipher.decryptString (lxmlFTP.getUser ());\n                this.mstrServerPwd = theCipher.decryptString (lxmlFTP.getPass ());\n            } else {\n                this.mstrServerUsr = lxmlFTP.getUser ();\n                this.mstrServerPwd = lxmlFTP.getPass ();\n            }\n        } else {\n            throw new Exception (\"Work unit [ \" + SHORT_NAME + \" ] is missing an FTP Definition.  Please check\" + \" your JBJF Batch Definition file an make sure\" + \" this work unit has a <resource> element added\" + \" within the <task> element.\");\n        }\n        lfisSourceFile = new FileInputStream (mstrSourceDirectory + File.separator + mstrFilename);\n        lftpClient = new FTPClient ();\n        lftpClient.connect (mstrRemoteServer);\n        lftpClient.setFileType (lxmlFTP.getFileTransferType ());\n        if (! FTPReply.isPositiveCompletion (lftpClient.getReplyCode ())) {\n            throw new Exception (\"FTP server [ \" + mstrRemoteServer + \" ] refused connection.\");\n        }\n        if (! lftpClient.login (mstrServerUsr, mstrServerPwd)) {\n            throw new Exception (\"Unable to login to server [ \" + mstrTargetDirectory + \" ].\");\n        }\n        if (! lftpClient.changeWorkingDirectory (mstrTargetDirectory)) {\n            throw new Exception (\"Unable to change to remote directory [ \" + mstrTargetDirectory + \"]\");\n        }\n        lftpClient.enterLocalPassiveMode ();\n        if (! lftpClient.storeFile (mstrFilename, lfisSourceFile)) {\n            throw new Exception (\"Unable to upload [ \" + mstrSourceDirectory + \"/\" + mstrFilename + \" ]\" + \" to \" + mstrTargetDirectory + File.separator + mstrFilename + \" to \" + mstrRemoteServer);\n        }\n        lfisSourceFile.close ();\n        lftpClient.logout ();\n    } catch (Exception e) {\n        throw e;\n    } finally {\n        if (lftpClient != null && lftpClient.isConnected ()) {\n            try {\n                lftpClient.disconnect ();\n            } catch (IOException ioe) {\n            }\n        }\n        if (lfisSourceFile != null) {\n            try {\n                lfisSourceFile.close ();\n            } catch (Exception e) {\n            }\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 321738, "method2_id": 539536, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 8024375, "method2_id": 10293577, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = random.nextLong ();\n        }\n        sbValueBeforeMD5.append (sid);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 151248, "method2_id": 615133, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 7976872, "method2_id": 9499457, "code1": "public static void copy_file (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n        System.out.print (\"Overwrite existing file \" + toFile.getName () + \"? (Y/N): \");\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) throw new IOException (\"FileCopy: \" + \"existing file was not overwritten.\");\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n", "code2": "private static void copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n        System.out.print (\"Overwrite existing file \" + toFile.getName () + \"? (Y/N): \");\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) throw new IOException (\"FileCopy: \" + \"existing file was not overwritten.\");\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 1934652, "method2_id": 3108904, "code1": "public static boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n", "code2": "private boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n"}
{"clone_type": "VST3", "method1_id": 446496, "method2_id": 654194, "code1": "int binarySearch (int [] a, int x) {\n    int result = - 1;\n    int mid = 0;\n    int left = 0;\n    int right = a.length - 1;\n    while (result == - 1 && left <= right) {\n        mid = (left + right) / 2;\n        if (a [mid] == x) {\n            result = mid;\n        } else {\n            if (a [mid] > x) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n    }\n    return result;\n}\n", "code2": "int binarySearch (int [] a, int x) {\n    int result = - 1;\n    int mid = 0;\n    int left = 0;\n    int right = a.length - 1;\n    while (result == - 1 && left <= right) {\n        mid = (left + right) / 2;\n        if (a [mid] == x) {\n            result = mid;\n        } else {\n            if (a [mid] > x) {\n                right = mid - 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return result;\n}\n"}
{"clone_type": "VST3", "method1_id": 15911781, "method2_id": 21433001, "code1": "public FloatMatrix transpose () {\n    FloatMatrix X = new FloatMatrix (n, m);\n    float [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n", "code2": "public Matrix transpose () {\n    Matrix X = new Matrix (n, m);\n    double [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n"}
{"clone_type": "VST3", "method1_id": 1831679, "method2_id": 16085716, "code1": "public int update (BusinessObject o) throws DAOException {\n    int update = 0;\n    Account acc = (Account) o;\n    try {\n        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery (\"UPDATE_ACCOUNT\"));\n        pst.setString (1, acc.getName ());\n        pst.setString (2, acc.getAddress ());\n        pst.setInt (3, acc.getCurrency ());\n        pst.setInt (4, acc.getMainContact ());\n        pst.setBoolean (5, acc.isArchived ());\n        pst.setInt (6, acc.getId ());\n        update = pst.executeUpdate ();\n        if (update <= 0) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows <= 0\");\n        } else if (update > 1) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows > 1\");\n        }\n\n        connection.commit ();\n    } catch (SQLException e) {\n        Log.write (e.getMessage ());\n        throw new DAOException (\"A SQLException has occured\");\n    } catch (NullPointerException npe) {\n        Log.write (npe.getMessage ());\n        throw new DAOException (\"Connection null\");\n    }\n    return update;\n}\n", "code2": "public int update (BusinessObject o) throws DAOException {\n    int update = 0;\n    Currency curr = (Currency) o;\n    try {\n        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery (\"UPDATE_CURRENCY\"));\n        pst.setString (1, curr.getName ());\n        pst.setInt (2, curr.getIdBase ());\n        pst.setDouble (3, curr.getValue ());\n        pst.setInt (4, curr.getId ());\n        update = pst.executeUpdate ();\n        if (update <= 0) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows <= 0\");\n        } else if (update > 1) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows > 1\");\n        }\n\n        connection.commit ();\n    } catch (SQLException e) {\n        Log.write (e.getMessage ());\n        throw new DAOException (\"A SQLException has occured\");\n    } catch (NullPointerException npe) {\n        Log.write (npe.getMessage ());\n        throw new DAOException (\"Connection null\");\n    }\n    return update;\n}\n"}
{"clone_type": "VST3", "method1_id": 653681, "method2_id": 1982368, "code1": "public static boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n", "code2": "private boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n"}
{"clone_type": "VST3", "method1_id": 453443, "method2_id": 627810, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 96238, "method2_id": 521041, "code1": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n", "code2": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setCstrvar (\"Goodbye\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n"}
{"clone_type": "VST3", "method1_id": 19147279, "method2_id": 21224972, "code1": "public boolean actualizarDatosFinal (int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n    int intResult = 0;\n    String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        populatePreparedStatementActFinal (unjxdxr);\n        intResult = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (intResult > 0);\n}\n", "code2": "public boolean update (int idJugador, jugador jugadorModificado) {\n    int intResult = 0;\n    String sql = \"UPDATE jugador \" + \"SET apellidoPaterno = ?, apellidoMaterno = ?, nombres = ?, fechaNacimiento = ?, \" + \" pais = ?, rating = ?, sexo = ? \" + \" WHERE idJugador = \" + idJugador;\n    try {\n        connection = conexionBD.getConnection ();\n        connection.setAutoCommit (false);\n        ps = connection.prepareStatement (sql);\n        populatePreparedStatement (jugadorModificado);\n        intResult = ps.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException ex) {\n        ex.printStackTrace ();\n        try {\n            connection.rollback ();\n        } catch (SQLException exe) {\n            exe.printStackTrace ();\n        }\n    } finally {\n        conexionBD.close (ps);\n        conexionBD.close (connection);\n    }\n    return (intResult > 0);\n}\n"}
{"clone_type": "VST3", "method1_id": 2711645, "method2_id": 19643372, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem encoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 162106, "method2_id": 173394, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (InetAddress.getByName (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (null);\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                String addrString;\n                addUDP (addr, port);\n                addTCP (addr, port);\n                if (addr == null) addrString = \"0.0.0.0\";\n                else addrString = addr.getHostAddress ();\n\n                System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Integer (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Integer (53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            int port = ((Integer) iport.next ()).intValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n"}
{"clone_type": "VST3", "method1_id": 7460370, "method2_id": 19142736, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 1884023, "method2_id": 7948308, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        logger.error (\"At RandomGUID !!!\", e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        logger.error (\"At RandomGUID !!!\", e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 128983, "method2_id": 547325, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 12728035, "method2_id": 14763206, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 2252378, "method2_id": 20654105, "code1": "private static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 103831, "method2_id": 423437, "code1": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n", "code2": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setCstrvar (\"Goodbye\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n"}
{"clone_type": "VST3", "method1_id": 1202104, "method2_id": 1552000, "code1": "public static boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n", "code2": "private boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n"}
{"clone_type": "VST3", "method1_id": 6319887, "method2_id": 21374275, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "private static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 13020691, "method2_id": 15972030, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 15730395, "method2_id": 20603727, "code1": "public static double [] [] calcTranspose (double [] [] mat) {\n    double [] [] transpose = new double [mat [0].length] [mat.length];\n    for (int a = 0;\n    a < transpose.length; a ++) {\n        for (int b = 0;\n        b < transpose [0].length; b ++) {\n            transpose [a] [b] = mat [b] [a];\n        }\n    }\n    return transpose;\n}\n", "code2": "public static double [] [] transpose (double [] [] object) {\n    double [] [] transpose = new double [object [0].length] [object.length];\n    for (int i = 0;\n    i < object.length; i ++) {\n        for (int x = 0;\n        x < transpose.length; x ++) {\n            transpose [x] [i] = object [i] [x];\n        }\n    }\n    return transpose;\n}\n"}
{"clone_type": "VST3", "method1_id": 20870396, "method2_id": 21285620, "code1": "private static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 13783898, "method2_id": 19643373, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem decoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 808353, "method2_id": 948930, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 171177, "method2_id": 415563, "code1": "public static void main (String [] argv) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n", "code2": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 14168494, "method2_id": 17857284, "code1": "public static void copyFile (File dest, File src) throws IOException {\n    FileChannel srcChannel = new FileInputStream (src).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (dest).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n", "code2": "public static void copyFile (File source, File destination) throws IOException {\n    FileChannel srcChannel = new FileInputStream (source).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (destination).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n"}
{"clone_type": "VST3", "method1_id": 361635, "method2_id": 420464, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 19584878, "method2_id": 19643373, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem decoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 3291256, "method2_id": 6873267, "code1": "public static void copyDirectory (File sourceLocation, File targetLocation) throws IOException {\n    if (sourceLocation.isDirectory ()) {\n        if (! targetLocation.exists ()) {\n            targetLocation.mkdir ();\n        }\n        String [] children = sourceLocation.list ();\n        for (int i = 0;\n        i < children.length; i ++) {\n            copyDirectory (new File (sourceLocation, children [i]), new File (targetLocation, children [i]));\n        }\n    } else {\n        InputStream in = new FileInputStream (sourceLocation);\n        OutputStream out = new FileOutputStream (targetLocation);\n        byte [] buf = new byte [1024];\n        int len;\n        while ((len = in.read (buf)) > 0) {\n            out.write (buf, 0, len);\n        }\n        in.close ();\n        out.close ();\n    }\n}\n", "code2": "public void copyDirectory (File sourceLocation, File targetLocation) throws IOException {\n    if (sourceLocation.isDirectory ()) {\n        if (! targetLocation.exists ()) {\n            targetLocation.mkdir ();\n        }\n        String [] children = sourceLocation.list ();\n        for (int i = 0;\n        i < children.length; i ++) {\n            copyDirectory (new File (sourceLocation, children [i]), new File (targetLocation, children [i]));\n        }\n    } else {\n        InputStream in = new FileInputStream (sourceLocation);\n        OutputStream out = new FileOutputStream (targetLocation);\n        byte [] buf = new byte [1024];\n        int len;\n        while ((len = in.read (buf)) > 0) {\n            out.write (buf, 0, len);\n        }\n        in.close ();\n        out.close ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 337754, "method2_id": 569226, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 662161, "method2_id": 1982368, "code1": "public static boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n", "code2": "private boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n"}
{"clone_type": "VST3", "method1_id": 2252378, "method2_id": 14763206, "code1": "private static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 18245, "method2_id": 341872, "code1": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.setVisible (true);\n    }\n}\n", "code2": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 2545752, "method2_id": 5706851, "code1": "public void copyDirectory (File srcDir, File dstDir) throws IOException {\n    if (srcDir.isDirectory ()) {\n        if (! dstDir.exists ()) {\n            dstDir.mkdir ();\n        }\n        String [] children = srcDir.list ();\n        for (int i = 0;\n        i < children.length; i ++) {\n            copyDirectory (new File (srcDir, children [i]), new File (dstDir, children [i]));\n        }\n    } else {\n        copyInOut (srcDir, dstDir);\n    }\n}\n", "code2": "public static void copyDirectory (File srcDir, File dstDir) throws IOException {\n    if (srcDir.isDirectory ()) {\n        if (! dstDir.exists ()) {\n            dstDir.mkdir ();\n        }\n        String [] children = srcDir.list ();\n        for (int i = 0;\n        i < children.length; i ++) {\n            copyDirectory (new File (srcDir, children [i]), new File (dstDir, children [i]));\n        }\n    } else {\n        copyFile (srcDir, dstDir);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 224200, "method2_id": 442091, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 4385640, "method2_id": 22403259, "code1": "public static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 162106, "method2_id": 302290, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (InetAddress.getByName (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (null);\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                String addrString;\n                addUDP (addr, port);\n                addTCP (addr, port);\n                if (addr == null) addrString = \"0.0.0.0\";\n                else addrString = addr.getHostAddress ();\n\n                System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Integer (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Integer (53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            int port = ((Integer) iport.next ()).intValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n"}
{"clone_type": "VST3", "method1_id": 19247466, "method2_id": 22403259, "code1": "public void copyFile (File sourceFile, File destFile) throws IOException {\n    Log.level3 (\"Copying \" + sourceFile.getPath () + \" to \" + destFile.getPath ());\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n    }\n    if (destination != null) {\n        destination.close ();\n    }\n}\n", "code2": "public void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 302936, "method2_id": 635006, "code1": "public static void copy (String from_name, String to_name, boolean overwriteOk) throws IOException {\n    File from_file = new File (from_name);\n    File to_file = new File (to_name);\n    if (! from_file.exists ()) abort (\"FileCopy: no such source file: \" + from_name);\n\n    if (! from_file.isFile ()) abort (\"FileCopy: can't copy directory: \" + from_name);\n\n    if (! from_file.canRead ()) abort (\"FileCopy: source file is unreadable: \" + from_name);\n\n    if (to_file.isDirectory ()) to_file = new File (to_file, from_file.getName ());\n\n    if (to_file.exists ()) {\n        if (! to_file.canWrite ()) abort (\"FileCopy: destination file is unwriteable: \" + to_name);\n\n        if (! overwriteOk) {\n            System.out.print (\"Overwrite existing file \" + to_name + \"? (Y/N): \");\n            System.out.flush ();\n            BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n            String response = in.readLine ();\n            if (! response.equals (\"Y\") && ! response.equals (\"y\")) abort (\"FileCopy: existing file was not overwritten.\");\n\n        }\n    } else {\n        String parent = to_file.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) abort (\"FileCopy: destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) abort (\"FileCopy: destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) abort (\"FileCopy: destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (from_file);\n        to = new FileOutputStream (to_file);\n        byte [] buffer = new byte [4096];\n        int bytes_read;\n        while ((bytes_read = from.read (buffer)) != - 1) to.write (buffer, 0, bytes_read);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n", "code2": "public static void copy (String from_name, String to_name) throws IOException {\n    File from_file = new File (from_name);\n    File to_file = new File (to_name);\n    if (! from_file.exists ()) abort (\"FileCopy: no such source file: \" + from_name);\n\n    if (! from_file.isFile ()) abort (\"FileCopy: can't copy directory: \" + from_name);\n\n    if (! from_file.canRead ()) abort (\"FileCopy: source file is unreadable: \" + from_name);\n\n    if (to_file.isDirectory ()) to_file = new File (to_file, from_file.getName ());\n\n    if (to_file.exists ()) {\n        if (! to_file.canWrite ()) abort (\"FileCopy: destination file is unwriteable: \" + to_name);\n\n        System.out.print (\"Overwrite existing file \" + to_name + \"? (Y/N): \");\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) abort (\"FileCopy: existing file was not overwritten.\");\n\n    } else {\n        String parent = to_file.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) abort (\"FileCopy: destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) abort (\"FileCopy: destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) abort (\"FileCopy: destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (from_file);\n        to = new FileOutputStream (to_file);\n        byte [] buffer = new byte [4096];\n        int bytes_read;\n        while ((bytes_read = from.read (buffer)) != - 1) to.write (buffer, 0, bytes_read);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 4518934, "method2_id": 7460369, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 1037968, "method2_id": 2362445, "code1": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 9568958, "method2_id": 20815980, "code1": "private void getRandomGuid (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = secureRandom.nextLong ();\n        } else {\n            rand = random.nextLong ();\n        }\n        sbValueBeforeMD5.append (id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) throws NoSuchAlgorithmException {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n        throw e;\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 14321943, "method2_id": 18306141, "code1": "public IntSquareMatrix copyUpperToLower () {\n    for (int i = 0;\n    i < cols - 1; i ++) {\n        for (int j = i + 1;\n        j < cols; j ++) {\n            flmat [j] [i] = flmat [i] [j];\n        }\n    }\n    return this;\n}\n", "code2": "public RealSquareMatrix copyLowerToUpper () {\n    for (int i = 0;\n    i < cols - 1; i ++) {\n        for (int j = i + 1;\n        j < cols; j ++) {\n            flmat [i] [j] = flmat [j] [i];\n        }\n    }\n    return this;\n}\n"}
{"clone_type": "VST3", "method1_id": 7460369, "method2_id": 19643372, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem encoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 3108499, "method2_id": 23390255, "code1": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 8640120, "method2_id": 14779144, "code1": "private static void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    } else {\n    }\n}\n", "code2": "private void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    } else {\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 10942, "method2_id": 455160, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) {\n                String s1 = st.nextToken ();\n                String s2 = st.nextToken ();\n                if (st.hasMoreTokens ()) addTSIG (s1, s2, st.nextToken ());\n                else addTSIG (\"hmac-md5\", s1, s2);\n\n            } else if (keyword.equals (\"port\")) {\n                ports.add (Integer.valueOf (st.nextToken ()));\n            } else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (Address.getByAddress (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (Address.getByAddress (\"0.0.0.0\"));\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                addUDP (addr, port);\n                addTCP (addr, port);\n                System.out.println (\"jnamed: listening on \" + addrport (addr, port));\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    InputStreamReader isr;\n    BufferedReader br;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n        isr = new InputStreamReader (fs);\n        br = new BufferedReader (isr);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) {\n                String s1 = st.nextToken ();\n                String s2 = st.nextToken ();\n                if (st.hasMoreTokens ()) addTSIG (s1, s2, st.nextToken ());\n                else addTSIG (\"hmac-md5\", s1, s2);\n\n            } else if (keyword.equals (\"port\")) {\n                ports.add (Integer.valueOf (st.nextToken ()));\n            } else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (Address.getByAddress (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (Address.getByAddress (\"0.0.0.0\"));\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                addUDP (addr, port);\n                addTCP (addr, port);\n                System.out.println (\"jnamed: listening on \" + addrport (addr, port));\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 13396233, "method2_id": 17551461, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 5155049, "method2_id": 16836014, "code1": "protected int findInSortedSuballocatedIntVector (SuballocatedIntVector vector, int lookfor) {\n    int i = 0;\n    if (vector != null) {\n        int first = 0;\n        int last = vector.size () - 1;\n        while (first <= last) {\n            i = (first + last) / 2;\n            int test = lookfor - vector.elementAt (i);\n            if (test == 0) {\n                return i;\n            } else if (test < 0) {\n                last = i - 1;\n            } else {\n                first = i + 1;\n            }\n\n        }\n        if (first > i) {\n            i = first;\n        }\n    }\n    return - 1 - i;\n}\n", "code2": "protected int findNamePoint (String name, int start) {\n    int i = 0;\n    if (nodes != null) {\n        int first = start;\n        int last = nodes.size () - 1;\n        while (first <= last) {\n            i = (first + last) / 2;\n            int test = name.compareTo (((Node) (nodes.elementAt (i))).getNodeName ());\n            if (test == 0) {\n                return i;\n            } else if (test < 0) {\n                last = i - 1;\n            } else {\n                first = i + 1;\n            }\n\n        }\n        if (first > i) {\n            i = first;\n        }\n    }\n    return - 1 - i;\n}\n"}
{"clone_type": "VST3", "method1_id": 1543361, "method2_id": 16511008, "code1": "public ProgramSymbol createNewProgramSymbol (int programID, String module, String symbol, int address, int size) throws AdaptationException {\n    ProgramSymbol programSymbol = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        String query = \"INSERT INTO ProgramSymbols \" + \"(programID, module, symbol, address, size)\" + \" VALUES (\" + programID + \", '\" + module + \"',  '\" + symbol + \"', \" + address + \", \" + size + \")\";\n        connection = DriverManager.getConnection (CONN_STR);\n        statement = connection.createStatement ();\n        statement.executeUpdate (query);\n        query = \"SELECT * FROM ProgramSymbols WHERE  \" + \"programID =  \" + programID + \"  AND \" + \"module    = '\" + module + \"' AND \" + \"symbol    = '\" + symbol + \"'\";\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Attempt to create program symbol failed.\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        programSymbol = getProgramSymbol (resultSet);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in createNewProgramSymbol\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return programSymbol;\n}\n", "code2": "public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol (int configID, int programMessageSymbolID) throws AdaptationException {\n    ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n        connection = DriverManager.getConnection (CONN_STR);\n        statement = connection.createStatement ();\n        statement.executeUpdate (query);\n        query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        profilingMessageSymbol = getProfilingMessageSymbol (resultSet);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in createNewProfilingMessageSymbol\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return profilingMessageSymbol;\n}\n"}
{"clone_type": "VST3", "method1_id": 11453370, "method2_id": 14357939, "code1": "public static Object [] addObjectToArray (Object [] array, Object object) {\n    Class < ? > compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (object != null) {\n        compType = object.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = object;\n    return newArr;\n}\n", "code2": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n"}
{"clone_type": "VST3", "method1_id": 4471000, "method2_id": 19643372, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem encoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 151248, "method2_id": 871396, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 121740, "method2_id": 309806, "code1": "public GalleryResource (DefaultValuesProvider parentDVP, URL resourceURL, File metadataFile) throws Exception {\n    super (parentDVP, resourceURL, metadataFile);\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();\n    dbf.setValidating (false);\n    DocumentBuilder b = dbf.newDocumentBuilder ();\n    doc = b.parse (resourceURL.openStream ());\n    Element root = doc.getDocumentElement ();\n    NodeList nl = root.getChildNodes ();\n    String stripped = new String ();\n    boolean first = true;\n    for (int i = 0;\n    i < nl.getLength (); i ++) {\n        Node n = nl.item (i);\n        if (n.getNodeType () == Node.ELEMENT_NODE) {\n            Element e = (Element) n;\n            stripped += e.getTagName () + \": \" + e.getAttribute (\"lcref\") + \"\\n\";\n        }\n    }\n    Font baseFont = new Font (null, Font.PLAIN, 10);\n    smallIcon = new TextIcon (baseFont.deriveFont (4), stripped, 64, 64);\n    bigIcon = new TextIcon (baseFont.deriveFont (8), stripped, 256, 256);\n}\n", "code2": "public GalleryResource (DefaultValuesProvider parentDVP, File resourceFile, File metadataFile) throws Exception {\n    super (parentDVP, resourceFile, metadataFile);\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();\n    dbf.setValidating (false);\n    DocumentBuilder b = dbf.newDocumentBuilder ();\n    doc = b.parse (resourceFile);\n    Element root = doc.getDocumentElement ();\n    NodeList nl = root.getChildNodes ();\n    String stripped = new String ();\n    boolean first = true;\n    for (int i = 0;\n    i < nl.getLength (); i ++) {\n        Node n = nl.item (i);\n        if (n.getNodeType () == Node.ELEMENT_NODE) {\n            Element e = (Element) n;\n            stripped += e.getTagName () + \": \" + e.getAttribute (\"lcref\") + \"\\n\";\n        }\n    }\n    Font baseFont = new Font (null, Font.PLAIN, 10);\n    smallIcon = new TextIcon (baseFont.deriveFont (4), stripped, 64, 64);\n    bigIcon = new TextIcon (baseFont.deriveFont (8), stripped, 256, 256);\n}\n"}
{"clone_type": "VST3", "method1_id": 7460370, "method2_id": 16466519, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 389826, "method2_id": 615133, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 11440870, "method2_id": 13614426, "code1": "public Matrix transpose () {\n    Matrix X = new Matrix (n, m);\n    int [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n", "code2": "public Matrix transpose () {\n    Matrix X = new Matrix (n, m);\n    double [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n"}
{"clone_type": "VST3", "method1_id": 389826, "method2_id": 606037, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 4272110, "method2_id": 12194043, "code1": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n", "code2": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class < ? > compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n"}
{"clone_type": "VST3", "method1_id": 282653, "method2_id": 362411, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 1176194, "method2_id": 1977983, "code1": "private boolean deleteLocalDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteLocalDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n", "code2": "public static boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n"}
{"clone_type": "VST3", "method1_id": 6959224, "method2_id": 16324741, "code1": "public static void copy (File source, File dest) throws java.io.IOException {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n", "code2": "public static void copyFiles (File source, File dest) throws IOException {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 11319480, "method2_id": 19643373, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem decoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 4284518, "method2_id": 8539991, "code1": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n", "code2": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class < ? > compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n"}
{"clone_type": "VST3", "method1_id": 3709102, "method2_id": 19423749, "code1": "public void removerTopicos (Topicos topicos) throws ClassNotFoundException, SQLException {\n    this.criaConexao (false);\n    String sql = \"DELETE FROM \\\"Topicos\\\"    \" + \"      WHERE \\\"id_Topicos\\\" =  ?\";\n    PreparedStatement stmt = null;\n    try {\n        stmt = connection.prepareStatement (sql);\n        stmt.setString (1, topicos.getIdTopicos ());\n        stmt.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException e) {\n        connection.rollback ();\n        throw e;\n    } finally {\n        try {\n            stmt.close ();\n            this.fechaConexao ();\n        } catch (SQLException e) {\n            throw e;\n        }\n    }\n}\n", "code2": "public void removerQuestaoMultiplaEscolha (QuestaoMultiplaEscolha multiplaEscolha) throws ClassNotFoundException, SQLException {\n    this.criaConexao (false);\n    String sql = \"DELETE FROM \\\"Disciplina\\\"    \" + \"      WHERE ID_Disciplina =  ? )\";\n    PreparedStatement stmt = null;\n    try {\n        stmt = connection.prepareStatement (sql);\n        stmt.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException e) {\n        connection.rollback ();\n        throw e;\n    } finally {\n        try {\n            stmt.close ();\n            this.fechaConexao ();\n        } catch (SQLException e) {\n            throw e;\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 442091, "method2_id": 454472, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 2533570, "method2_id": 20815980, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) throws NoSuchAlgorithmException {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n        throw e;\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 1704751, "method2_id": 6419481, "code1": "public static void copy (File fromFile, File toFile) throws IOException {\n    String fromFilename = fromFile.getPath ();\n    String toFileName = toFile.getPath ();\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFilename);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFilename);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFilename);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n        if (AppState.isVerbose ()) System.out.print (\"Overwrite existing file \" + toFile.getName () + \"? (Y/N): \");\n\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) throw new IOException (\"FileCopy: \" + \"existing file was not overwritten.\");\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n", "code2": "public static void copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n        System.out.print (\"Overwrite existing file \" + toFile.getName () + \"? (Y/N): \");\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) throw new IOException (\"FileCopy: \" + \"existing file was not overwritten.\");\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 3597316, "method2_id": 11986970, "code1": "public static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public void Copy () throws IOException {\n    if (! FileDestination.exists ()) {\n        FileDestination.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (FileSource).getChannel ();\n        destination = new FileOutputStream (FileDestination).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 3974031, "method2_id": 16900370, "code1": "private void addAllImages (ZipOutputStream zipout, int progressStart, int progressLength) throws IOException {\n    String [] files = new File (imageDir).list ();\n    int bytesRead = 0;\n    byte byteArray [] = new byte [4096];\n    FileInputStream in = null;\n    for (int i = 0;\n    i < files.length; i ++) {\n        progress = Math.min (progressStart + (int) ((double) i * (double) progressLength / (double) files.length), 99);\n        File fileToHandle = new File (imageDir, files [i]);\n        if (fileToHandle.isFile () && fileToHandle.canRead ()) {\n            try {\n                logger.debug (\"Adding image file \" + files [i]);\n                ZipEntry entry = new ZipEntry (\"images/\" + files [i]);\n                zipout.putNextEntry (entry);\n                in = new FileInputStream (fileToHandle);\n                while (in.available () > 0) {\n                    bytesRead = in.read (byteArray, 0, Math.min (4096, in.available ()));\n                    zipout.write (byteArray, 0, bytesRead);\n                }\n            } catch (FileNotFoundException e) {\n            } catch (IOException e) {\n            } finally {\n                try {\n                    zipout.closeEntry ();\n                } catch (IOException e1) {\n                }\n                try {\n                    zipout.flush ();\n                } catch (IOException e1) {\n                }\n                try {\n                    if (in != null) {\n                        in.close ();\n                        in = null;\n                    }\n                } catch (IOException e1) {\n                }\n            }\n        }\n    }\n}\n", "code2": "private void addAllImages (Environment en, ZipOutputStream zipout, int progressStart, int progressLength) throws IOException {\n    String [] files = new File (imageDir).list ();\n    int bytesRead = 0;\n    byte byteArray [] = new byte [4096];\n    FileInputStream in = null;\n    for (int i = 0;\n    i < files.length; i ++) {\n        progress = Math.min (progressStart + (int) ((double) i * (double) progressLength / files.length), 99);\n        File fileToHandle = new File (imageDir, files [i]);\n        if (fileToHandle.isFile () && fileToHandle.canRead ()) {\n            try {\n                logger.fine (\"Adding image file \" + files [i]);\n                ZipEntry entry = new ZipEntry (\"images/\" + files [i]);\n                zipout.putNextEntry (entry);\n                in = new FileInputStream (fileToHandle);\n                while (in.available () > 0) {\n                    bytesRead = in.read (byteArray, 0, Math.min (4096, in.available ()));\n                    zipout.write (byteArray, 0, bytesRead);\n                }\n            } catch (FileNotFoundException e) {\n            } catch (IOException e) {\n            } finally {\n                try {\n                    zipout.closeEntry ();\n                } catch (IOException e1) {\n                }\n                try {\n                    zipout.flush ();\n                } catch (IOException e1) {\n                }\n                try {\n                    if (in != null) {\n                        in.close ();\n                        in = null;\n                    }\n                } catch (IOException e1) {\n                }\n            }\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 1638505, "method2_id": 17337238, "code1": "private Vendor createVendor () throws SQLException, IOException {\n    Connection conn = null;\n    Statement st = null;\n    String query = null;\n    ResultSet rs = null;\n    try {\n        conn = dataSource.getConnection ();\n        st = conn.createStatement ();\n        query = \"insert into \" + DB.Tbl.vend + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") values('\" + title + \"',now(),\" + user.getId () + \")\";\n        st.executeUpdate (query, new String [] {col.id});\n        rs = st.getGeneratedKeys ();\n        if (! rs.next ()) {\n            throw new SQLException (\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 vendors.\");\n        }\n        int genId = rs.getInt (1);\n        rs.close ();\n        saveDescr (genId);\n        conn.commit ();\n        Vendor v = new Vendor ();\n        v.setId (genId);\n        v.setTitle (title);\n        v.setDescr (descr);\n        VendorViewer.getInstance ().vendorListChanged ();\n        return v;\n    } catch (SQLException e) {\n        try {\n            conn.rollback ();\n        } catch (Exception e1) {\n        }\n        throw e;\n    } finally {\n        try {\n            rs.close ();\n        } catch (Exception e) {\n        }\n        try {\n            st.close ();\n        } catch (Exception e) {\n        }\n        try {\n            conn.close ();\n        } catch (Exception e) {\n        }\n    }\n}\n", "code2": "private Retailer create () throws SQLException, IOException {\n    Connection conn = null;\n    Statement st = null;\n    String query = null;\n    ResultSet rs = null;\n    try {\n        conn = dataSource.getConnection ();\n        st = conn.createStatement ();\n        query = \"insert into \" + DB.Tbl.ret + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") \" + \"values('\" + title + \"',now(),\" + user.getId () + \")\";\n        st.executeUpdate (query, new String [] {col.id});\n        rs = st.getGeneratedKeys ();\n        if (! rs.next ()) {\n            throw new SQLException (\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 retailers.\");\n        }\n        int genId = rs.getInt (1);\n        rs.close ();\n        saveDescr (genId);\n        conn.commit ();\n        Retailer ret = new Retailer ();\n        ret.setId (genId);\n        ret.setTitle (title);\n        ret.setDescr (descr);\n        RetailerViewer.getInstance ().somethingUpdated ();\n        return ret;\n    } catch (SQLException e) {\n        try {\n            conn.rollback ();\n        } catch (Exception e1) {\n        }\n        throw e;\n    } finally {\n        try {\n            rs.close ();\n        } catch (Exception e) {\n        }\n        try {\n            st.close ();\n        } catch (Exception e) {\n        }\n        try {\n            conn.close ();\n        } catch (Exception e) {\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 18099260, "method2_id": 23273706, "code1": "public String [] [] getProjectTreeData () {\n    String [] [] treeData = null;\n    String filename = dms_home + FS + \"temp\" + FS + username + \"projects.xml\";\n    String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetProjects\";\n    try {\n        String urldata = urlString + \"?username=\" + URLEncoder.encode (username, \"UTF-8\") + \"&key=\" + URLEncoder.encode (key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode (username, \"UTF-8\") + \"projects.xml\";\n        System.out.println (urldata);\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance ();\n        factory.setValidating (false);\n        DocumentBuilder parser = factory.newDocumentBuilder ();\n        URL u = new URL (urldata);\n        DataInputStream is = new DataInputStream (u.openStream ());\n        FileOutputStream os = new FileOutputStream (filename);\n        int iBufSize = is.available ();\n        byte inBuf [] = new byte [20000 * 1024];\n        int iNumRead;\n        while ((iNumRead = is.read (inBuf, 0, iBufSize)) > 0) os.write (inBuf, 0, iNumRead);\n\n        os.close ();\n        is.close ();\n        File f = new File (filename);\n        InputStream inputstream = new FileInputStream (f);\n        Document document = parser.parse (inputstream);\n        NodeList nodelist = document.getElementsByTagName (\"j\");\n        int num = nodelist.getLength ();\n        treeData = new String [num] [5];\n        for (int i = 0;\n        i < num; i ++) {\n            treeData [i] [0] = new String (DOMUtil.getSimpleElementText ((Element) nodelist.item (i), \"i\"));\n            treeData [i] [1] = new String (DOMUtil.getSimpleElementText ((Element) nodelist.item (i), \"pi\"));\n            treeData [i] [2] = new String (DOMUtil.getSimpleElementText ((Element) nodelist.item (i), \"p\"));\n            treeData [i] [3] = \"\";\n            treeData [i] [4] = new String (DOMUtil.getSimpleElementText ((Element) nodelist.item (i), \"f\"));\n        }\n    } catch (MalformedURLException ex) {\n        System.out.println (ex);\n    } catch (ParserConfigurationException ex) {\n        System.out.println (ex);\n    } catch (NullPointerException e) {\n    } catch (Exception ex) {\n        System.out.println (ex);\n    }\n    return treeData;\n}\n", "code2": "public String [] [] getProjectTreeData () {\n    String [] [] treeData = null;\n    String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n    String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n    try {\n        String urldata = urlString + \"?username=\" + URLEncoder.encode (username, \"UTF-8\") + \"&key=\" + URLEncoder.encode (key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode (username, \"UTF-8\") + \"adminprojects.xml\";\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance ();\n        factory.setValidating (false);\n        DocumentBuilder parser = factory.newDocumentBuilder ();\n        URL u = new URL (urldata);\n        DataInputStream is = new DataInputStream (u.openStream ());\n        FileOutputStream os = new FileOutputStream (filename);\n        int iBufSize = is.available ();\n        byte inBuf [] = new byte [20000 * 1024];\n        int iNumRead;\n        while ((iNumRead = is.read (inBuf, 0, iBufSize)) > 0) os.write (inBuf, 0, iNumRead);\n\n        os.close ();\n        is.close ();\n        File f = new File (filename);\n        InputStream inputstream = new FileInputStream (f);\n        Document document = parser.parse (inputstream);\n        NodeList nodelist = document.getElementsByTagName (\"proj\");\n        int num = nodelist.getLength ();\n        treeData = new String [num] [3];\n        for (int i = 0;\n        i < num; i ++) {\n            treeData [i] [0] = new String (DOMUtil.getSimpleElementText ((Element) nodelist.item (i), \"pid\"));\n            treeData [i] [1] = new String (DOMUtil.getSimpleElementText ((Element) nodelist.item (i), \"ppid\"));\n            treeData [i] [2] = new String (DOMUtil.getSimpleElementText ((Element) nodelist.item (i), \"p\"));\n        }\n    } catch (MalformedURLException ex) {\n        System.out.println (ex);\n    } catch (ParserConfigurationException ex) {\n        System.out.println (ex);\n    } catch (NullPointerException e) {\n    } catch (Exception ex) {\n        System.out.println (ex);\n    }\n    return treeData;\n}\n"}
{"clone_type": "VST3", "method1_id": 68708, "method2_id": 441330, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new HashMap ();\n    znames = new HashMap ();\n    TSIGs = new HashMap ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Integer (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.add (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.add (new Integer (53));\n\n    if (addresses.size () == 0) addresses.add (null);\n\n    Iterator iaddr = addresses.iterator ();\n    while (iaddr.hasNext ()) {\n        InetAddress addr = (InetAddress) iaddr.next ();\n        Iterator iport = ports.iterator ();\n        while (iport.hasNext ()) {\n            int port = ((Integer) iport.next ()).intValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n", "code2": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    Vector ports = new Vector ();\n    Vector addresses = new Vector ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    caches = new Hashtable ();\n    znames = new Hashtable ();\n    TSIGs = new Hashtable ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.charAt (0) == '#') continue;\n\n        if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"cache\")) {\n            Cache cache = new Cache (st.nextToken ());\n            caches.put (new Short (DClass.IN), cache);\n        } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n        else if (keyword.equals (\"port\")) ports.addElement (Short.valueOf (st.nextToken ()));\n        else if (keyword.equals (\"address\")) {\n            String addr = st.nextToken ();\n            addresses.addElement (InetAddress.getByName (addr));\n        } else {\n            System.out.println (\"ignoring invalid keyword: \" + keyword);\n        }\n\n    }\n    if (ports.size () == 0) ports.addElement (new Short ((short) 53));\n\n    if (addresses.size () == 0) addresses.addElement (null);\n\n    Enumeration eaddr = addresses.elements ();\n    while (eaddr.hasMoreElements ()) {\n        InetAddress addr = (InetAddress) eaddr.nextElement ();\n        Enumeration eport = ports.elements ();\n        while (eport.hasMoreElements ()) {\n            short port = ((Short) eport.nextElement ()).shortValue ();\n            String addrString;\n            addUDP (addr, port);\n            addTCP (addr, port);\n            if (addr == null) addrString = \"0.0.0.0\";\n            else addrString = addr.getHostAddress ();\n\n            System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n        }\n    }\n    System.out.println (\"jnamed: running\");\n}\n"}
{"clone_type": "VST3", "method1_id": 1543361, "method2_id": 12469141, "code1": "public ProgramSymbol createNewProgramSymbol (int programID, String module, String symbol, int address, int size) throws AdaptationException {\n    ProgramSymbol programSymbol = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        String query = \"INSERT INTO ProgramSymbols \" + \"(programID, module, symbol, address, size)\" + \" VALUES (\" + programID + \", '\" + module + \"',  '\" + symbol + \"', \" + address + \", \" + size + \")\";\n        connection = DriverManager.getConnection (CONN_STR);\n        statement = connection.createStatement ();\n        statement.executeUpdate (query);\n        query = \"SELECT * FROM ProgramSymbols WHERE  \" + \"programID =  \" + programID + \"  AND \" + \"module    = '\" + module + \"' AND \" + \"symbol    = '\" + symbol + \"'\";\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Attempt to create program symbol failed.\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        programSymbol = getProgramSymbol (resultSet);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in createNewProgramSymbol\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return programSymbol;\n}\n", "code2": "public Program deleteProgram (int id) throws AdaptationException {\n    Program program = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        String query = \"SELECT * FROM Programs WHERE id = \" + id;\n        connection = DriverManager.getConnection (CONN_STR);\n        statement = connection.createStatement ();\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Attempt to delete program failed.\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        program = getProgram (resultSet);\n        query = \"DELETE FROM Programs WHERE id = \" + id;\n        statement.executeUpdate (query);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in deleteProgram\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return program;\n}\n"}
{"clone_type": "VST3", "method1_id": 13811176, "method2_id": 21655926, "code1": "public CMatrix transpose () {\n    CMatrix X = new CMatrix (n, m);\n    Complex [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n", "code2": "public PNMatrix transpose () {\n    PNMatrix X = new PNMatrix (n, m);\n    int [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n"}
{"clone_type": "VST3", "method1_id": 10272772, "method2_id": 20378673, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) {\n                sb.append ('0');\n            }\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 4725834, "method2_id": 20984238, "code1": "private void addLink (ONDEXConcept vertex) {\n    Set < ConceptAccession > accs = vertex.getConceptAccessions ();\n    if (accs.size () > 0) {\n        for (ConceptAccession acc : accs) {\n            if (! acc.isAmbiguous () && acc.getElementOf ().equals (vertex.getElementOf ())) {\n                try {\n                    new AccessionPlugin (aggregator.getONDEXJUNGGraph ());\n                } catch (InvalidPluginArgumentException e) {\n                    JOptionPane.showMessageDialog ((Component) aggregator, e.getMessage ());\n                }\n                String url = AccessionPlugin.cvToURL.get (acc.getElementOf ().getId ());\n                if (AccessionPlugin.mapper != null) {\n                    Condition cond = new Condition (acc.getElementOf ().getId (), vertex.getElementOf ().getId ());\n                    String prefix = (String) AccessionPlugin.mapper.validate (cond);\n                    if (prefix != null && prefix.length () > 0) {\n                        url = prefix;\n                    }\n                }\n                if (url != null) {\n                    try {\n                        final URI uri = new URI (url + \"\" + acc.getAccession ());\n                        JMenuItem item = new JMenuItem (acc.getElementOf ().getId () + \": \" + acc.getAccession ());\n                        item.setForeground (Color.BLUE);\n                        item.addActionListener (new ActionListener () {\n                            @Override\n                            public void actionPerformed (ActionEvent e) {\n                                Desktop desktop = null;\n                                if (Desktop.isDesktopSupported ()) {\n                                    desktop = Desktop.getDesktop ();\n                                    try {\n                                        desktop.browse (uri);\n                                    } catch (IOException ioe) {\n                                        JOptionPane.showMessageDialog ((Component) aggregator, ioe.getMessage ());\n                                    }\n                                } else {\n                                    JOptionPane.showMessageDialog ((Component) aggregator, \"Hyperlinks not supported by OS.\");\n                                }\n                            }}\n\n                        );\n                        this.add (item);\n                    } catch (URISyntaxException e1) {\n                        JOptionPane.showMessageDialog ((Component) aggregator, e1.getMessage ());\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n", "code2": "private void addLink (ONDEXConcept vertex) {\n    Set < ConceptAccession > accs = vertex.getConceptAccessions ();\n    if (accs.size () > 0) {\n        for (ConceptAccession acc : accs) {\n            if (! acc.isAmbiguous () && vertex.getElementOf ().getId ().contains (acc.getElementOf ().getId ())) {\n                try {\n                    new AccessionPlugin (viewer.getONDEXJUNGGraph ());\n                } catch (InvalidPluginArgumentException e) {\n                    ErrorDialog.show (e);\n                }\n                String url = AccessionPlugin.cvToURL.get (acc.getElementOf ().getId ());\n                if (AccessionPlugin.mapper != null) {\n                    Condition cond = new Condition (acc.getElementOf ().getId (), vertex.getElementOf ().getId ());\n                    String prefix = (String) AccessionPlugin.mapper.validate (cond);\n                    if (prefix != null && prefix.length () > 0) {\n                        url = prefix;\n                    }\n                }\n                if (url != null) {\n                    try {\n                        final URI uri = new URI (url + \"\" + acc.getAccession ());\n                        JMenuItem item = new JMenuItem (acc.getElementOf ().getId () + \": \" + acc.getAccession ());\n                        item.setForeground (Color.BLUE);\n                        item.addActionListener (new ActionListener () {\n                            @Override\n                            public void actionPerformed (ActionEvent e) {\n                                Desktop desktop = null;\n                                if (Desktop.isDesktopSupported ()) {\n                                    desktop = Desktop.getDesktop ();\n                                    try {\n                                        desktop.browse (uri);\n                                    } catch (IOException ioe) {\n                                        ErrorDialog.show (ioe);\n                                    }\n                                } else {\n                                    JOptionPane.showInputDialog (desktop, \"Hyperlinks not supported by OS.\");\n                                }\n                            }}\n\n                        );\n                        this.add (item);\n                    } catch (URISyntaxException e1) {\n                        ErrorDialog.show (e1);\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 6419481, "method2_id": 11066055, "code1": "public static void copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n        System.out.print (\"Overwrite existing file \" + toFile.getName () + \"? (Y/N): \");\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) throw new IOException (\"FileCopy: \" + \"existing file was not overwritten.\");\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n", "code2": "private static void copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: destination file is unwriteable: \" + toFileName);\n\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) throw new IOException (\"FileCopy: existing file was not overwritten.\");\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 15664293, "method2_id": 18517735, "code1": "public void mouseClicked (MouseEvent e) {\n    long delay = System.currentTimeMillis () - lastClicked;\n    if (e.getButton () == MouseEvent.BUTTON1 && delay > 1000) {\n        e.consume ();\n        lastClicked = System.currentTimeMillis ();\n        if (Desktop.isDesktopSupported ()) {\n            Desktop desktop = Desktop.getDesktop ();\n            if (desktop.isSupported (Desktop.Action.BROWSE)) {\n                try {\n                    desktop.browse (new URI (\"http://everquest2.com/Valor/\" + URLEncoder.encode (label.getText (), \"UTF-8\") + \"/\"));\n                } catch (Exception ex) {\n                    System.err.println (ex.getMessage ());\n                }\n            }\n        }\n    }\n}\n", "code2": "public void mouseClicked (MouseEvent e) {\n    long delay = System.currentTimeMillis () - lastClicked;\n    if (e.getButton () == MouseEvent.BUTTON1 && delay > 1000) {\n        e.consume ();\n        lastClicked = System.currentTimeMillis ();\n        if (Desktop.isDesktopSupported ()) {\n            Desktop desktop = Desktop.getDesktop ();\n            if (desktop.isSupported (Desktop.Action.BROWSE)) {\n                try {\n                    desktop.browse (new URI (label.getText ()));\n                } catch (Exception ex) {\n                    System.err.println (ex.getMessage ());\n                }\n            }\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 4284518, "method2_id": 11453370, "code1": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n", "code2": "public static Object [] addObjectToArray (Object [] array, Object object) {\n    Class < ? > compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (object != null) {\n        compType = object.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = object;\n    return newArr;\n}\n"}
{"clone_type": "VST3", "method1_id": 10589735, "method2_id": 15166511, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = random.nextLong ();\n        }\n        sbValueBeforeMD5.append (sid);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 86512, "method2_id": 270827, "code1": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n", "code2": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.setVisible (true);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 7460369, "method2_id": 16466519, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.B64InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 166887, "method2_id": 338353, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 125344, "method2_id": 346193, "code1": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    cache = null;\n    znames = new Hashtable ();\n    TSIGs = new Hashtable ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.equals (\"primary\")) addZone (st.nextToken (), Zone.PRIMARY);\n        else if (keyword.equals (\"cache\")) cache = new Zone (st.nextToken (), Zone.CACHE, null);\n        else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n\n    }\n    if (cache == null) {\n        System.out.println (\"no cache specified\");\n        System.exit (- 1);\n    }\n    addUDP ((short) 12345);\n    addTCP ((short) 12345);\n}\n", "code2": "public jnamed (String conffile) throws IOException {\n    FileInputStream fs;\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    cache = null;\n    znames = new Hashtable ();\n    TSIGs = new Hashtable ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (fs));\n    String line = null;\n    while ((line = br.readLine ()) != null) {\n        StringTokenizer st = new StringTokenizer (line);\n        if (! st.hasMoreTokens ()) continue;\n\n        String keyword = st.nextToken ();\n        if (! st.hasMoreTokens ()) {\n            System.out.println (\"Invalid line: \" + line);\n            continue;\n        }\n        if (keyword.equals (\"primary\")) addZone (st.nextToken ());\n        else if (keyword.equals (\"cache\")) cache = new Cache (st.nextToken ());\n        else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n\n    }\n    if (cache == null) {\n        System.out.println (\"no cache specified\");\n        System.exit (- 1);\n    }\n    addUDP ((short) 12345);\n    addTCP ((short) 12345);\n}\n"}
{"clone_type": "VST3", "method1_id": 17984312, "method2_id": 19868933, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 1753732, "method2_id": 1753734, "code1": "@SuppressWarnings(\"unchecked\")\nprivate void initializeOMEncoder (Properties sosProps) throws OwsExceptionReport {\n    String className = sosProps.getProperty (OMENCODER);\n    try {\n        if (className == null) {\n            log.fatal (\"No OMEncoder Implementation is set in the configFile!\");\n            OwsExceptionReport se = new OwsExceptionReport ();\n            se.addCodedException (OwsExceptionReport.ExceptionCode.NoApplicableCode, \"SosConfigurator.initializeOMEncoder()\", \"No OMEncoder Implementation is set in the configFile!\");\n            throw se;\n        }\n        Class omEncoderClass = Class.forName (className);\n        Class [] constrArgs = {};\n        Object [] args = {};\n        Constructor < IOMEncoder > constructor = omEncoderClass.getConstructor ();\n        this.omEncoder = constructor.newInstance ();\n        log.info (\"\\n******\\n\" + className + \" loaded successfully!\\n******\\n\");\n    } catch (ClassNotFoundException cnfe) {\n        log.fatal (\"Error while loading OMEncoder, required class could not be loaded: \" + cnfe.toString ());\n        throw new OwsExceptionReport (cnfe.getMessage (), cnfe.getCause ());\n    } catch (SecurityException se) {\n        log.fatal (\"Error while loading OMEncoder: \" + se.toString ());\n        throw new OwsExceptionReport (se.getMessage (), se.getCause ());\n    } catch (NoSuchMethodException nsme) {\n        log.fatal (\"Error while loading OMEncoder, no required constructor available: \" + nsme.toString ());\n        throw new OwsExceptionReport (nsme.getMessage (), nsme.getCause ());\n    } catch (IllegalArgumentException iae) {\n        log.fatal (\"Error while loading OMEncoder, parameters for the constructor are illegal: \" + iae.toString ());\n        throw new OwsExceptionReport (iae.getMessage (), iae.getCause ());\n    } catch (InstantiationException ie) {\n        log.fatal (\"The instatiation of a OMEncoder failed: \" + ie.toString ());\n        throw new OwsExceptionReport (ie.getMessage (), ie.getCause ());\n    } catch (IllegalAccessException iace) {\n        log.fatal (\"The instatiation of an OMEncoder failed: \" + iace.toString ());\n        throw new OwsExceptionReport (iace.getMessage (), iace.getCause ());\n    } catch (InvocationTargetException ite) {\n        log.fatal (\"the instatiation of an OMEncoder failed: \" + ite.toString () + ite.getLocalizedMessage () + ite.getCause ());\n        throw new OwsExceptionReport (ite.getMessage (), ite.getCause ());\n    }\n}\n", "code2": "@SuppressWarnings(\"unchecked\")\nprivate void initializeHttpPostRequestDecoder (Properties sosProps) throws OwsExceptionReport {\n    String className = sosProps.getProperty (POSTREQUESTDECODER);\n    try {\n        if (className == null) {\n            log.fatal (\"No postRequestDecoder Implementation is set in the configFile!\");\n            OwsExceptionReport se = new OwsExceptionReport ();\n            se.addCodedException (OwsExceptionReport.ExceptionCode.NoApplicableCode, \"SosConfigurator.initializeHttpPostRequestDecoder()\", \"No postRequestDecoder Implementation is set in the configFile!\");\n            throw se;\n        }\n        Class httpPostRequestDecoderClass = Class.forName (className);\n        Constructor < IHttpPostRequestDecoder > constructor = httpPostRequestDecoderClass.getConstructor ();\n        this.httpPostDecoder = constructor.newInstance ();\n        log.info (\"\\n******\\n\" + className + \" loaded successfully!\\n******\\n\");\n    } catch (ClassNotFoundException cnfe) {\n        log.fatal (\"Error while loading postRequestDecoder, required class could not be loaded: \" + cnfe.toString ());\n        throw new OwsExceptionReport (cnfe.getMessage (), cnfe.getCause ());\n    } catch (SecurityException se) {\n        log.fatal (\"Error while loading postRequestDecoder: \" + se.toString ());\n        throw new OwsExceptionReport (se.getMessage (), se.getCause ());\n    } catch (NoSuchMethodException nsme) {\n        log.fatal (\"Error while loading postRequestDecoder, no required constructor available: \" + nsme.toString ());\n        throw new OwsExceptionReport (nsme.getMessage (), nsme.getCause ());\n    } catch (IllegalArgumentException iae) {\n        log.fatal (\"Error while loading postRequestDecoder, parameters for the constructor are illegal: \" + iae.toString ());\n        throw new OwsExceptionReport (iae.getMessage (), iae.getCause ());\n    } catch (InstantiationException ie) {\n        log.fatal (\"The instatiation of a postRequestDecoder failed: \" + ie.toString ());\n        throw new OwsExceptionReport (ie.getMessage (), ie.getCause ());\n    } catch (IllegalAccessException iace) {\n        log.fatal (\"The instatiation of an postRequestDecoder failed: \" + iace.toString ());\n        throw new OwsExceptionReport (iace.getMessage (), iace.getCause ());\n    } catch (InvocationTargetException ite) {\n        log.fatal (\"the instatiation of an postRequestDecoder failed: \" + ite.toString () + ite.getLocalizedMessage () + ite.getCause ());\n        throw new OwsExceptionReport (ite.getMessage (), ite.getCause ());\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 271986, "method2_id": 698488, "code1": "void run () throws Exception {\n    File javaHome = new File (System.getProperty (\"java.home\"));\n    if (javaHome.getName ().equals (\"jre\")) javaHome = javaHome.getParentFile ();\n\n    File javaExe = new File (new File (javaHome, \"bin\"), \"java\");\n    String classpath = System.getProperty (\"java.class.path\");\n    String [] cmd = {javaExe.getPath (), \"-verbose:class\", \"-classpath\", classpath, HelloWorldTest.class.getName (), \"Hello\", \"World\"};\n    ProcessBuilder pb = new ProcessBuilder (cmd).redirectErrorStream (true);\n    Process p = pb.start ();\n    BufferedReader r = new BufferedReader (new InputStreamReader (p.getInputStream ()));\n    String line;\n    while ((line = r.readLine ()) != null) {\n        System.err.println (line);\n        if (line.contains (\"javax.tools.ToolProvider\") || line.contains (\"com.sun.tools.javac.\")) error (\">>> \" + line);\n\n    }\n    int rc = p.waitFor ();\n    if (rc != 0) error (\"Unexpected exit code: \" + rc);\n\n    if (errors > 0) throw new Exception (errors + \" errors occurred\");\n\n}\n", "code2": "void run () throws Exception {\n    File javaHome = new File (System.getProperty (\"java.home\"));\n    if (javaHome.getName ().equals (\"jre\")) javaHome = javaHome.getParentFile ();\n\n    File javaExe = new File (new File (javaHome, \"bin\"), \"java\");\n    String classpath = System.getProperty (\"java.class.path\");\n    String [] cmd = {javaExe.getPath (), \"-verbose:class\", \"-classpath\", classpath, ToolProviderTest1.class.getName (), \"javax.tools.ToolProvider\"};\n    ProcessBuilder pb = new ProcessBuilder (cmd).redirectErrorStream (true);\n    Process p = pb.start ();\n    BufferedReader r = new BufferedReader (new InputStreamReader (p.getInputStream ()));\n    String line;\n    while ((line = r.readLine ()) != null) {\n        System.err.println (line);\n        if (line.contains (\"com.sun.tools.javac.\")) error (\">>> \" + line);\n\n    }\n    int rc = p.waitFor ();\n    if (rc != 0) error (\"Unexpected exit code: \" + rc);\n\n    if (errors > 0) throw new Exception (errors + \" errors occurred\");\n\n}\n"}
{"clone_type": "VST3", "method1_id": 17224030, "method2_id": 17787699, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        logger.debug (\"Random GUID error: \" + e.getMessage ());\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 453142, "method2_id": 1552000, "code1": "public static boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n", "code2": "private boolean deleteDirectory (File path) {\n    if (path.exists ()) {\n        File [] files = path.listFiles ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            if (files [i].isDirectory ()) {\n                deleteDirectory (files [i]);\n            } else {\n                files [i].delete ();\n            }\n        }\n    }\n    return (path.delete ());\n}\n"}
{"clone_type": "VST3", "method1_id": 8640120, "method2_id": 12363968, "code1": "private static void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    } else {\n    }\n}\n", "code2": "private static void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n        }\n    } else {\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 12267275, "method2_id": 14489368, "code1": "private void goToWebsite (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n        }\n    } else {\n    }\n}\n", "code2": "private void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    } else {\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 86778, "method2_id": 241801, "code1": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setCstrvar (\"Goodbye\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n", "code2": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n"}
{"clone_type": "VST3", "method1_id": 362411, "method2_id": 420464, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 329965, "method2_id": 691839, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 8640120, "method2_id": 14489368, "code1": "private static void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    } else {\n    }\n}\n", "code2": "private void open (URI uri) {\n    if (Desktop.isDesktopSupported ()) {\n        Desktop desktop = Desktop.getDesktop ();\n        try {\n            desktop.browse (uri);\n        } catch (IOException e) {\n            e.printStackTrace ();\n        }\n    } else {\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 1663419, "method2_id": 2362445, "code1": "private static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 18269745, "method2_id": 19643372, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem encoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 4471001, "method2_id": 19643372, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem encoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 10589735, "method2_id": 23243320, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = random.nextLong ();\n        }\n        sbValueBeforeMD5.append (sid);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 15911781, "method2_id": 21655926, "code1": "public FloatMatrix transpose () {\n    FloatMatrix X = new FloatMatrix (n, m);\n    float [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n", "code2": "public PNMatrix transpose () {\n    PNMatrix X = new PNMatrix (n, m);\n    int [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n"}
{"clone_type": "VST3", "method1_id": 83240, "method2_id": 379677, "code1": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n", "code2": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 329965, "method2_id": 783855, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 547325, "method2_id": 551003, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 745207, "method2_id": 935588, "code1": "public static Object invokeInitializer (Class cls, int methodID, int argAddress, boolean isJvalue, boolean isDotDotStyle) throws Exception {\n    VM_Method mth = VM_MethodDictionary.getValue (methodID);\n    VM_Type [] argTypes = mth.getParameterTypes ();\n    Class [] argClasses = new Class [argTypes.length];\n    for (int i = 0;\n    i < argClasses.length; i ++) {\n        argClasses [i] = argTypes [i].getClassForType ();\n    }\n    Constructor constMethod = cls.getConstructor (argClasses);\n    if (constMethod == null) throw new Exception (\"Constructor not found\");\n\n    int varargAddress;\n    if (isDotDotStyle) varargAddress = pushVarArgToSpillArea (methodID, false);\n    else varargAddress = argAddress;\n\n    Object argObjs [];\n    if (isJvalue) argObjs = packageParameterFromJValue (mth, argAddress);\n    else argObjs = packageParameterFromVarArg (mth, varargAddress);\n\n    Object newobj = constMethod.newInstance (argObjs);\n    return newobj;\n}\n", "code2": "public static Object invokeInitializer (Class cls, int methodID, VM_Address argAddress, boolean isJvalue, boolean isDotDotStyle) throws Exception {\n    VM_Method mth = VM_MethodDictionary.getValue (methodID);\n    VM_Type [] argTypes = mth.getParameterTypes ();\n    Class [] argClasses = new Class [argTypes.length];\n    for (int i = 0;\n    i < argClasses.length; i ++) {\n        argClasses [i] = argTypes [i].getClassForType ();\n    }\n    Constructor constMethod = cls.getConstructor (argClasses);\n    if (constMethod == null) throw new Exception (\"Constructor not found\");\n\n    VM_Address varargAddress;\n    if (isDotDotStyle) varargAddress = pushVarArgToSpillArea (methodID, false);\n    else varargAddress = argAddress;\n\n    Object argObjs [];\n    if (isJvalue) argObjs = packageParameterFromJValue (mth, argAddress);\n    else argObjs = packageParameterFromVarArg (mth, varargAddress);\n\n    Object newobj = constMethod.newInstance (argObjs);\n    return newobj;\n}\n"}
{"clone_type": "VST3", "method1_id": 3239010, "method2_id": 20870396, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "private static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 2711644, "method2_id": 19643373, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem decoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "VST3", "method1_id": 666031, "method2_id": 733072, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 126310, "method2_id": 230700, "code1": "public static void main (String [] args) {\n    final String version = System.getProperty (\"java.version\");\n    if (version.startsWith (\"1.0\") || version.startsWith (\"1.1\") || version.startsWith (\"1.2\")) {\n        System.err.println (\"\");\n        System.err.print (\"J requires Java 1.3 or later.\");\n        System.err.println (\" (Java 1.4.1 is recommended.)\");\n        System.err.println (\"\");\n        System.exit (1);\n    }\n    try {\n        Class c = Class.forName (\"org.armedbear.j.Editor\");\n        Class [] parameterTypes = new Class [1];\n        parameterTypes [0] = String [].class;\n        Method method = c.getMethod (\"main\", parameterTypes);\n        Object [] parameters = new Object [1];\n        parameters [0] = args;\n        method.invoke (null, parameters);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String version = System.getProperty (\"java.version\");\n    if (version.startsWith (\"1.0\") || version.startsWith (\"1.1\") || version.startsWith (\"1.2\") || version.startsWith (\"1.3\")) {\n        System.err.println (\"\");\n        System.err.print (\"J requires Java 1.4 or later.\");\n        System.err.println (\" (Java 1.4.2 is recommended.)\");\n        System.err.println (\"\");\n        System.exit (1);\n    }\n    try {\n        Class c = Class.forName (\"org.armedbear.j.Editor\");\n        Class [] parameterTypes = new Class [1];\n        parameterTypes [0] = String [].class;\n        Method method = c.getMethod (\"main\", parameterTypes);\n        Object [] parameters = new Object [1];\n        parameters [0] = args;\n        method.invoke (null, parameters);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 8024375, "method2_id": 17787699, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        logger.debug (\"Random GUID error: \" + e.getMessage ());\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 7948308, "method2_id": 23243320, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        logger.error (\"At RandomGUID !!!\", e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        logger.error (\"At RandomGUID !!!\", e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 18234202, "method2_id": 22713046, "code1": "public static void multiclass_probability (int k, double [] [] r, double [] p) {\n    int t, j;\n    int iter = 0, max_iter = Math.max (100, k);\n    double [] [] Q = new double [k] [k];\n    double [] Qp = new double [k];\n    double pQp, eps = 0.005 / k;\n    for (t = 0; t < k; t ++) {\n        p [t] = 1.0 / k;\n        Q [t] [t] = 0;\n        for (j = 0; j < t; j ++) {\n            Q [t] [t] += r [j] [t] * r [j] [t];\n            Q [t] [j] = Q [j] [t];\n        }\n        for (j = t + 1; j < k; j ++) {\n            Q [t] [t] += r [j] [t] * r [j] [t];\n            Q [t] [j] = - r [j] [t] * r [t] [j];\n        }\n    }\n    for (iter = 0; iter < max_iter; iter ++) {\n        pQp = 0;\n        for (t = 0; t < k; t ++) {\n            Qp [t] = 0;\n            for (j = 0; j < k; j ++) Qp [t] += Q [t] [j] * p [j];\n\n            pQp += p [t] * Qp [t];\n        }\n        double max_error = 0;\n        for (t = 0; t < k; t ++) {\n            double error = Math.abs (Qp [t] - pQp);\n            if (error > max_error) max_error = error;\n\n        }\n        if (max_error < eps) break;\n\n        for (t = 0; t < k; t ++) {\n            double diff = (- Qp [t] + pQp) / Q [t] [t];\n            p [t] += diff;\n            pQp = (pQp + diff * (diff * Q [t] [t] + 2 * Qp [t])) / (1 + diff) / (1 + diff);\n            for (j = 0; j < k; j ++) {\n                Qp [j] = (Qp [j] + diff * Q [t] [j]) / (1 + diff);\n                p [j] /= (1 + diff);\n            }\n        }\n    }\n}\n", "code2": "private static void multiclass_probability (int k, double [] [] r, double [] p) {\n    int t, j;\n    int iter = 0, max_iter = Math.max (100, k);\n    double [] [] Q = new double [k] [k];\n    double [] Qp = new double [k];\n    double pQp, eps = 0.005 / k;\n    for (t = 0; t < k; t ++) {\n        p [t] = 1.0 / k;\n        Q [t] [t] = 0;\n        for (j = 0; j < t; j ++) {\n            Q [t] [t] += r [j] [t] * r [j] [t];\n            Q [t] [j] = Q [j] [t];\n        }\n        for (j = t + 1; j < k; j ++) {\n            Q [t] [t] += r [j] [t] * r [j] [t];\n            Q [t] [j] = - r [j] [t] * r [t] [j];\n        }\n    }\n    for (iter = 0; iter < max_iter; iter ++) {\n        pQp = 0;\n        for (t = 0; t < k; t ++) {\n            Qp [t] = 0;\n            for (j = 0; j < k; j ++) Qp [t] += Q [t] [j] * p [j];\n\n            pQp += p [t] * Qp [t];\n        }\n        double max_error = 0;\n        for (t = 0; t < k; t ++) {\n            double error = Math.abs (Qp [t] - pQp);\n            if (error > max_error) max_error = error;\n\n        }\n        if (max_error < eps) break;\n\n        for (t = 0; t < k; t ++) {\n            double diff = (- Qp [t] + pQp) / Q [t] [t];\n            p [t] += diff;\n            pQp = (pQp + diff * (diff * Q [t] [t] + 2 * Qp [t])) / (1 + diff) / (1 + diff);\n            for (j = 0; j < k; j ++) {\n                Qp [j] = (Qp [j] + diff * Q [t] [j]) / (1 + diff);\n                p [j] /= (1 + diff);\n            }\n        }\n    }\n    if (iter >= max_iter) System.err.print (\"Exceeds max_iter in multiclass_prob\\n\");\n\n}\n"}
{"clone_type": "VST3", "method1_id": 35511, "method2_id": 232887, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 380998, "method2_id": 774117, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (e);\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (- 1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 12194043, "method2_id": 14357939, "code1": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class < ? > compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n", "code2": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n"}
{"clone_type": "VST3", "method1_id": 8117216, "method2_id": 20725036, "code1": "private void copyLocalFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "private static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 92425, "method2_id": 321738, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 37335, "method2_id": 446098, "code1": "public static void main (String [] args) {\n    final String version = System.getProperty (\"java.version\");\n    if (version.startsWith (\"1.0\") || version.startsWith (\"1.1\") || version.startsWith (\"1.2\")) {\n        System.err.println (\"\");\n        System.err.print (\"J requires Java 1.3 or later.\");\n        System.err.println (\" (Java 1.4.1 is recommended.)\");\n        System.err.println (\"\");\n        System.exit (1);\n    }\n    try {\n        Class c = Class.forName (\"org.armedbear.j.Editor\");\n        Class [] parameterTypes = new Class [1];\n        parameterTypes [0] = String [].class;\n        Method method = c.getMethod (\"main\", parameterTypes);\n        Object [] parameters = new Object [1];\n        parameters [0] = args;\n        method.invoke (null, parameters);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String version = System.getProperty (\"java.version\");\n    if (version.startsWith (\"1.0\") || version.startsWith (\"1.1\") || version.startsWith (\"1.2\") || version.startsWith (\"1.3\")) {\n        System.err.println (\"\");\n        System.err.print (\"J requires Java 1.4 or later.\");\n        System.err.println (\" (Java 1.4.2 is recommended.)\");\n        System.err.println (\"\");\n        System.exit (1);\n    }\n    try {\n        Class c = Class.forName (\"org.armedbear.j.Editor\");\n        Class [] parameterTypes = new Class [1];\n        parameterTypes [0] = String [].class;\n        Method method = c.getMethod (\"main\", parameterTypes);\n        Object [] parameters = new Object [1];\n        parameters [0] = args;\n        method.invoke (null, parameters);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 4031802, "method2_id": 13811176, "code1": "public Matrix transpose () {\n    Matrix X = new Matrix (n, m);\n    double [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n", "code2": "public CMatrix transpose () {\n    CMatrix X = new CMatrix (n, m);\n    Complex [] [] C = X.getArray ();\n    for (int i = 0;\n    i < m; i ++) {\n        for (int j = 0;\n        j < n; j ++) {\n            C [j] [i] = A [i] [j];\n        }\n    }\n    return X;\n}\n"}
{"clone_type": "VST3", "method1_id": 16511008, "method2_id": 21438070, "code1": "public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol (int configID, int programMessageSymbolID) throws AdaptationException {\n    ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n        connection = DriverManager.getConnection (CONN_STR);\n        statement = connection.createStatement ();\n        statement.executeUpdate (query);\n        query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        profilingMessageSymbol = getProfilingMessageSymbol (resultSet);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in createNewProfilingMessageSymbol\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return profilingMessageSymbol;\n}\n", "code2": "public ProjectDeploymentConfiguration deleteProjectDeploymentConfig (int id) throws AdaptationException {\n    ProjectDeploymentConfiguration config = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        String query = \"SELECT * FROM ProjectDeploymentConfigurations \" + \"WHERE id = \" + id;\n        connection = DriverManager.getConnection (CONN_STR);\n        statement = connection.createStatement ();\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Attempt to delete project deployment \" + \"configuration failed.\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        config = getProjectDeploymentConfiguration (resultSet);\n        query = \"DELETE FROM ProjectDeploymentConfigurations \" + \"WHERE id = \" + id;\n        statement.executeUpdate (query);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in deleteProjectDeploymentConfig\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return config;\n}\n"}
{"clone_type": "VST3", "method1_id": 131720, "method2_id": 780954, "code1": "public static void main (String [] args) throws IOException {\n    if (args.length == 3) {\n        System.out.println (\"\\nUsing user pipe names!:\");\n        System.out.println (\"\\t...\" + args [1] + \"\\n\\t...\" + args [2] + \"\\n\");\n        System.out.println (\"\\nExecutable name: \" + args [0]);\n        pipe_in = args [1];\n        pipe_out = args [2];\n        javaName = args [0];\n    } else if (args.length == 1) {\n        System.out.println (\"\\nUsing default pipe names!\");\n        System.out.println (\"\\t.../tmp/RL_pipe_env_in\\n\\t.../tmp/RL_pipe_env_out\");\n        System.out.println (\"\\nExecutable name: \" + args [0]);\n        pipe_in = \"/tmp/RL_pipe_env_in\";\n        pipe_out = \"/tmp/RL_pipe_env_out\";\n        javaName = args [0];\n    } else {\n        System.out.println (\"\\nError: incorrect input arguments.\\n\\nExample of valid invokations:\\n java Java_env_handler mines /tmp/RL_pipe_env_in /tmp/RL_pipe_env_out\\n...or...\\njava Java_env_handler mines\\n\\nExiting...\\n\\n\");\n        System.exit (0);\n    }\n\n    boolean errorr = true;\n    while (errorr) {\n        try {\n            fis = new FileInputStream (pipe_in);\n            fr = new InputStreamReader (fis);\n            br = new BufferedReader (fr);\n            file = new FileWriter (pipe_out);\n            errorr = false;\n        } catch (FileNotFoundException e) {\n            errorr = true;\n        }\n    }\n    try {\n        agent = Class.forName (javaName);\n        Class partypes [] = null;\n        Constructor ct = agent.getConstructor (partypes);\n        Object arglist [] = null;\n        retobj = ct.newInstance (arglist);\n        String buf = br.readLine ();\n        while (true) {\n            if (buf != null) {\n                if (buf.equals (\"init\")) {\n                    pipe_env_init ();\n                } else if (buf.equals (\"start\")) {\n                    pipe_env_start ();\n                } else if (buf.equals (\"step\")) {\n                    pipe_env_step ();\n                } else if (buf.equals (\"getstate\")) {\n                    pipe_env_get_state ();\n                } else if (buf.equals (\"setstate\")) {\n                    pipe_env_set_state ();\n                } else if (buf.equals (\"getrandom\")) {\n                    pipe_env_get_random_seed ();\n                } else if (buf.equals (\"setrandom\")) {\n                    pipe_env_set_random_seed ();\n                } else if (buf.equals (\"cleanup\")) {\n                    partypes = null;\n                    Method meth = agent.getMethod (\"env_cleanup\", partypes);\n                    arglist = null;\n                    meth.invoke (retobj, arglist);\n                    System.exit (0);\n                }\n\n            }\n            buf = br.readLine ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"\\nError: BAD COMMAND!!   OR  Error in env_cleanup method\\n\");\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static void main (String [] args) throws IOException {\n    if (args.length == 3) {\n        System.out.println (\"\\nUsing user pipe names!:\");\n        System.out.println (\"\\t...\" + args [1] + \"\\n\\t...\" + args [2] + \"\\n\");\n        System.out.println (\"\\nExecutable name: \" + args [0]);\n        pipe_in = args [1];\n        pipe_out = args [2];\n        javaName = args [0];\n    } else if (args.length == 1) {\n        System.out.println (\"\\nUsing default pipe names!\");\n        System.out.println (\"\\t.../tmp/RL_pipe_agent_in\\n\\t.../tmp/RL_pipe_agent_out\");\n        System.out.println (\"\\nExecutable name: \" + args [0]);\n        pipe_in = \"/tmp/RL_pipe_agent_in\";\n        pipe_out = \"/tmp/RL_pipe_agent_out\";\n        javaName = args [0];\n    } else {\n        System.out.println (\"\\nError: incorrect input arguments.\\n\\nExample of valid invokations:\\n java Java_agent_handler mineAgent /tmp/RL_pipe_agent_in /tmp/RL_pipe_agent_out\\n...or...\\njava Java_agent_handler mineAgent\\n\\nExiting...\\n\\n\");\n        System.exit (0);\n    }\n\n    boolean errorr = true;\n    while (errorr) {\n        try {\n            fis = new FileInputStream (pipe_in);\n            fr = new InputStreamReader (fis);\n            br = new BufferedReader (fr);\n            file = new FileWriter (pipe_out);\n            errorr = false;\n        } catch (FileNotFoundException e) {\n            errorr = true;\n        }\n    }\n    try {\n        agent = Class.forName (javaName);\n        Class partypes [] = null;\n        Constructor ct = agent.getConstructor (partypes);\n        Object arglist [] = null;\n        retobj = ct.newInstance (arglist);\n        String buf = br.readLine ();\n        while (true) {\n            if (buf != null) {\n                if (buf.equals (\"init\")) {\n                    pipe_agent_init ();\n                } else if (buf.equals (\"start\")) {\n                    pipe_agent_start ();\n                } else if (buf.equals (\"step\")) {\n                    pipe_agent_step ();\n                } else if (buf.equals (\"end\")) {\n                    pipe_agent_end ();\n                } else if (buf.equals (\"cleanup\")) {\n                    partypes = null;\n                    Method meth = agent.getMethod (\"agent_cleanup\", partypes);\n                    arglist = null;\n                    meth.invoke (retobj, arglist);\n                    System.exit (0);\n                }\n\n            }\n            buf = br.readLine ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"\\nERROR: BAD COMMAN!!  OR Error in agent_cleanup method\\n\");\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 2279291, "method2_id": 14386499, "code1": "public static String encrypt (String plainText) throws Exception {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new Exception (e.getMessage ());\n    }\n    try {\n        md.update (plainText.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        throw new Exception (e.getMessage ());\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n", "code2": "public synchronized String encrypt (String plaintext) throws SystemUnavailableException {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"SHA\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new SystemUnavailableException (e.getMessage ());\n    }\n    try {\n        md.update (plaintext.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        throw new SystemUnavailableException (e.getMessage ());\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n"}
{"clone_type": "VST3", "method1_id": 10240263, "method2_id": 10240265, "code1": "public void isohunt_search (String input) throws URISyntaxException {\n    try {\n        Desktop desktop = null;\n        if (Desktop.isDesktopSupported ()) {\n            desktop = Desktop.getDesktop ();\n        }\n        URI uri;\n        uri = new URI (\"http://isohunt.com/torrents/?ihq=\" + input.replace (' ', '+'));\n        desktop.browse (uri);\n    } catch (IOException ioe) {\n        ioe.printStackTrace ();\n    }\n}\n", "code2": "public void imdb_search (String input) throws URISyntaxException {\n    try {\n        Desktop desktop = null;\n        if (Desktop.isDesktopSupported ()) {\n            desktop = Desktop.getDesktop ();\n        }\n        URI uri;\n        uri = new URI (\"http://www.imdb.com/find?s=all&q=\" + input.replace (' ', '+') + \"&x=0&y=0\");\n        desktop.browse (uri);\n    } catch (IOException ioe) {\n        ioe.printStackTrace ();\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 1760350, "method2_id": 1760355, "code1": "public static int deleteOrder (String likePatten) {\n    Connection conn = null;\n    PreparedStatement psmt = null;\n    StringBuffer SQL = new StringBuffer (200);\n    int deleted = 0;\n    SQL.append (\" DELETE FROM JHF_ALIVE_ORDER \").append (\" WHERE   ORDER_ID LIKE  ? \");\n    try {\n        conn = JdbcConnectionPool.mainConnection ();\n        conn.setAutoCommit (false);\n        conn.setReadOnly (false);\n        psmt = conn.prepareStatement (SQL.toString ());\n        psmt.setString (1, \"%\" + likePatten + \"%\");\n        deleted = psmt.executeUpdate ();\n        conn.commit ();\n    } catch (SQLException e) {\n        if (null != conn) {\n            try {\n                conn.rollback ();\n            } catch (SQLException e1) {\n                System.out.println (\" error when roll back !\");\n            }\n        }\n    } finally {\n        try {\n            if (null != psmt) {\n                psmt.close ();\n                psmt = null;\n            }\n            if (null != conn) {\n                conn.close ();\n                conn = null;\n            }\n        } catch (SQLException e) {\n            System.out.println (\" error  when psmt close or conn close .\");\n        }\n    }\n    return deleted;\n}\n", "code2": "public static int deleteHedgeCustTrade () {\n    Connection conn = null;\n    PreparedStatement psmt = null;\n    StringBuffer SQL = new StringBuffer (200);\n    int deleted = 0;\n    SQL.append (\" DELETE FROM JHF_HEDGE_CUSTTRADE \");\n    try {\n        conn = JdbcConnectionPool.mainConnection ();\n        conn.setAutoCommit (false);\n        conn.setReadOnly (false);\n        psmt = conn.prepareStatement (SQL.toString ());\n        deleted = psmt.executeUpdate ();\n        conn.commit ();\n    } catch (SQLException e) {\n        if (null != conn) {\n            try {\n                conn.rollback ();\n            } catch (SQLException e1) {\n                System.out.println (\" error when roll back !\");\n            }\n        }\n    } finally {\n        try {\n            if (null != psmt) {\n                psmt.close ();\n                psmt = null;\n            }\n            if (null != conn) {\n                conn.close ();\n                conn = null;\n            }\n        } catch (SQLException e) {\n            System.out.println (\" error  when psmt close or conn close .\");\n        }\n    }\n    return deleted;\n}\n"}
{"clone_type": "VST3", "method1_id": 83240, "method2_id": 509930, "code1": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n", "code2": "public static void main (String argv []) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "VST3", "method1_id": 12172485, "method2_id": 19643373, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem decoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
