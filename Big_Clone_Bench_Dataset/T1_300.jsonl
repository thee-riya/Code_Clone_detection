{"clone_type": "T1", "method1_id": 124388, "method2_id": 211685, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 689531, "method2_id": 820538, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 13475, "method2_id": 927500, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 281392, "method2_id": 357576, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 112491, "method2_id": 861011, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 210587, "method2_id": 470160, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 670345, "method2_id": 682346, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 76427, "method2_id": 901348, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "T1", "method1_id": 6597127, "method2_id": 15376871, "code1": "public static byte [] getStreamBytes (final InputStream in) throws IOException {\n    final ByteArrayOutputStream out = new ByteArrayOutputStream ();\n    IOUtils.copyStream (in, out);\n    return out.toByteArray ();\n}\n", "code2": "public static byte [] getStreamBytes (final InputStream in) throws IOException {\n    final ByteArrayOutputStream out = new ByteArrayOutputStream ();\n    IOUtils.copyStream (in, out);\n    return out.toByteArray ();\n}\n"}
{"clone_type": "T1", "method1_id": 333109, "method2_id": 834053, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "T1", "method1_id": 469340, "method2_id": 820538, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 689689, "method2_id": 804637, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 120778, "method2_id": 359836, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 337754, "method2_id": 575998, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 13460, "method2_id": 437637, "code1": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n", "code2": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n"}
{"clone_type": "T1", "method1_id": 28334, "method2_id": 912097, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 53722, "method2_id": 670345, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 281236, "method2_id": 682345, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 193053, "method2_id": 241851, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 396827, "method2_id": 775734, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 136563, "method2_id": 341872, "code1": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n", "code2": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 28135, "method2_id": 812840, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 473025, "method2_id": 776779, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 25974, "method2_id": 136563, "code1": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n", "code2": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 108845, "method2_id": 810342, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "T1", "method1_id": 831649, "method2_id": 12614305, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "T1", "method1_id": 604392, "method2_id": 942693, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 141041, "method2_id": 352343, "code1": "private void initSource () {\n    try {\n        for (int i = 0;\n        i < NUM_TRANSFORMATIONS; i ++) {\n            final String sourceXMLURI = (new File (XML_IN_BASE + i + XML_EXT)).toURL ().toString ();\n            m_inStream [i] = new FileInputStream (XML_IN_BASE + i + XML_EXT);\n            switch (SOURCE_FLAVOR) {\n                case STREAM :\n                    m_inSource [i] = new StreamSource (m_inStream [i]);\n                    break;\n                case SAX :\n                    m_inSource [i] = new SAXSource (new InputSource (m_inStream [i]));\n                    break;\n                case DOM :\n                    try {\n                        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n                        dfactory.setNamespaceAware (true);\n                        m_inSource [i] = new DOMSource (dfactory.newDocumentBuilder ().parse (m_inStream [i]));\n                    } catch (Exception e) {\n                        e.printStackTrace ();\n                    }\n                    break;\n            }\n            if (m_inSource [i] != null) {\n                m_inSource [i].setSystemId (sourceXMLURI);\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "private void initSource () {\n    try {\n        for (int i = 0;\n        i < NUM_TRANSFORMATIONS; i ++) {\n            final String sourceXMLURI = (new File (XML_IN_BASE + i + XML_EXT)).toURL ().toString ();\n            m_inStream [i] = new FileInputStream (XML_IN_BASE + i + XML_EXT);\n            switch (SOURCE_FLAVOR) {\n                case STREAM :\n                    m_inSource [i] = new StreamSource (m_inStream [i]);\n                    break;\n                case SAX :\n                    m_inSource [i] = new SAXSource (new InputSource (m_inStream [i]));\n                    break;\n                case DOM :\n                    try {\n                        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n                        dfactory.setNamespaceAware (true);\n                        m_inSource [i] = new DOMSource (dfactory.newDocumentBuilder ().parse (m_inStream [i]));\n                    } catch (Exception e) {\n                        e.printStackTrace ();\n                    }\n                    break;\n            }\n            if (m_inSource [i] != null) {\n                m_inSource [i].setSystemId (sourceXMLURI);\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 211061, "method2_id": 330930, "code1": "private void displayDiffResults () throws IOException {\n    File outFile = File.createTempFile (\"diff\", \".htm\");\n    outFile.deleteOnExit ();\n    FileOutputStream outStream = new FileOutputStream (outFile);\n    BufferedWriter out = new BufferedWriter (new OutputStreamWriter (outStream));\n    out.write (\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n    if (addedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n        out.write (addedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    if (modifiedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n        out.write (modifiedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    if (deletedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n        out.write (deletedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    out.write (\"<table name=METRICS BORDER>\\n\");\n    if (modifiedTable.length () > 0 || deletedTable.length () > 0) {\n        out.write (\"<tr><td>Base:&nbsp;</td><td>\");\n        out.write (Long.toString (base));\n        out.write (\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n        out.write (Long.toString (deleted));\n        out.write (\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n        out.write (Long.toString (modified));\n        out.write (\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n        out.write (Long.toString (added));\n        out.write (\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n        out.write (Long.toString (added + modified));\n        out.write (\"</td></tr>\\n\");\n    }\n    out.write (\"<tr><td>Total:&nbsp;</td><td>\");\n    out.write (Long.toString (total));\n    out.write (\"</td></tr>\\n</table></div>\");\n    redlinesOut.close ();\n    out.flush ();\n    InputStream redlines = new FileInputStream (redlinesTempFile);\n    byte [] buffer = new byte [4096];\n    int bytesRead;\n    while ((bytesRead = redlines.read (buffer)) != - 1) outStream.write (buffer, 0, bytesRead);\n\n    outStream.write (\"</BODY></HTML>\".getBytes ());\n    outStream.close ();\n    Browser.launch (outFile.toURL ().toString ());\n}\n", "code2": "private void displayDiffResults () throws IOException {\n    File outFile = File.createTempFile (\"diff\", \".htm\");\n    outFile.deleteOnExit ();\n    FileOutputStream outStream = new FileOutputStream (outFile);\n    BufferedWriter out = new BufferedWriter (new OutputStreamWriter (outStream));\n    out.write (\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n    if (addedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n        out.write (addedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    if (modifiedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n        out.write (modifiedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    if (deletedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n        out.write (deletedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    out.write (\"<table name=METRICS BORDER>\\n\");\n    if (modifiedTable.length () > 0 || deletedTable.length () > 0) {\n        out.write (\"<tr><td>Base:&nbsp;</td><td>\");\n        out.write (Long.toString (base));\n        out.write (\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n        out.write (Long.toString (deleted));\n        out.write (\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n        out.write (Long.toString (modified));\n        out.write (\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n        out.write (Long.toString (added));\n        out.write (\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n        out.write (Long.toString (added + modified));\n        out.write (\"</td></tr>\\n\");\n    }\n    out.write (\"<tr><td>Total:&nbsp;</td><td>\");\n    out.write (Long.toString (total));\n    out.write (\"</td></tr>\\n</table></div>\");\n    redlinesOut.close ();\n    out.flush ();\n    InputStream redlines = new FileInputStream (redlinesTempFile);\n    byte [] buffer = new byte [4096];\n    int bytesRead;\n    while ((bytesRead = redlines.read (buffer)) != - 1) outStream.write (buffer, 0, bytesRead);\n\n    outStream.write (\"</BODY></HTML>\".getBytes ());\n    outStream.close ();\n    Browser.launch (outFile.toURL ().toString ());\n}\n"}
{"clone_type": "T1", "method1_id": 169904, "method2_id": 274170, "code1": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n", "code2": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 9563, "method2_id": 320979, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 279855, "method2_id": 292890, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 2532322, "method2_id": 11319480, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "T1", "method1_id": 487412, "method2_id": 932291, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 203112, "method2_id": 403115, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 224086, "method2_id": 670344, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 27126, "method2_id": 440471, "code1": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n", "code2": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n"}
{"clone_type": "T1", "method1_id": 46158, "method2_id": 210587, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 157745, "method2_id": 821502, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 881838, "method2_id": 928483, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 184741, "method2_id": 414463, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 28334, "method2_id": 147668, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 10732, "method2_id": 881839, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 314561, "method2_id": 775735, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 160739, "method2_id": 427727, "code1": "public BufferedWriter createOutputStream (String inFile, String outFile) throws IOException {\n    int k_blockSize = 1024;\n    int byteCount;\n    char [] buf = new char [k_blockSize];\n    File ofp = new File (outFile);\n    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (ofp));\n    zos.setMethod (ZipOutputStream.DEFLATED);\n    OutputStreamWriter osw = new OutputStreamWriter (zos, \"ISO-8859-1\");\n    BufferedWriter bw = new BufferedWriter (osw);\n    ZipEntry zot = null;\n    File ifp = new File (inFile);\n    ZipInputStream zis = new ZipInputStream (new FileInputStream (ifp));\n    InputStreamReader isr = new InputStreamReader (zis, \"ISO-8859-1\");\n    BufferedReader br = new BufferedReader (isr);\n    ZipEntry zit = null;\n    while ((zit = zis.getNextEntry ()) != null) {\n        if (zit.getName ().equals (\"content.xml\")) {\n            continue;\n        }\n        zot = new ZipEntry (zit.getName ());\n        zos.putNextEntry (zot);\n        while ((byteCount = br.read (buf, 0, k_blockSize)) >= 0) bw.write (buf, 0, byteCount);\n\n        bw.flush ();\n        zos.closeEntry ();\n    }\n    zos.putNextEntry (new ZipEntry (\"content.xml\"));\n    bw.flush ();\n    osw = new OutputStreamWriter (zos, \"UTF8\");\n    bw = new BufferedWriter (osw);\n    return bw;\n}\n", "code2": "public BufferedWriter createOutputStream (String inFile, String outFile) throws IOException {\n    int k_blockSize = 1024;\n    int byteCount;\n    char [] buf = new char [k_blockSize];\n    File ofp = new File (outFile);\n    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (ofp));\n    zos.setMethod (ZipOutputStream.DEFLATED);\n    OutputStreamWriter osw = new OutputStreamWriter (zos, \"ISO-8859-1\");\n    BufferedWriter bw = new BufferedWriter (osw);\n    ZipEntry zot = null;\n    File ifp = new File (inFile);\n    ZipInputStream zis = new ZipInputStream (new FileInputStream (ifp));\n    InputStreamReader isr = new InputStreamReader (zis, \"ISO-8859-1\");\n    BufferedReader br = new BufferedReader (isr);\n    ZipEntry zit = null;\n    while ((zit = zis.getNextEntry ()) != null) {\n        if (zit.getName ().equals (\"content.xml\")) {\n            continue;\n        }\n        zot = new ZipEntry (zit.getName ());\n        zos.putNextEntry (zot);\n        while ((byteCount = br.read (buf, 0, k_blockSize)) >= 0) bw.write (buf, 0, byteCount);\n\n        bw.flush ();\n        zos.closeEntry ();\n    }\n    zos.putNextEntry (new ZipEntry (\"content.xml\"));\n    bw.flush ();\n    osw = new OutputStreamWriter (zos, \"UTF8\");\n    bw = new BufferedWriter (osw);\n    return bw;\n}\n"}
{"clone_type": "T1", "method1_id": 65492, "method2_id": 776779, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 45590, "method2_id": 820538, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 281039, "method2_id": 510801, "code1": "private void addAdditional2 (Message response, int section) {\n    Enumeration e = response.getSection (section);\n    while (e.hasMoreElements ()) {\n        Record r = (Record) e.nextElement ();\n        try {\n            Method m = r.getClass ().getMethod (\"getTarget\", null);\n            Name glueName = (Name) m.invoke (r, null);\n            addGlue (response, glueName);\n        } catch (Exception ex) {\n        }\n    }\n}\n", "code2": "private void addAdditional2 (Message response, int section) {\n    Enumeration e = response.getSection (section);\n    while (e.hasMoreElements ()) {\n        Record r = (Record) e.nextElement ();\n        try {\n            Method m = r.getClass ().getMethod (\"getTarget\", null);\n            Name glueName = (Name) m.invoke (r, null);\n            addGlue (response, glueName);\n        } catch (Exception ex) {\n        }\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 286788, "method2_id": 755766, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 162828, "method2_id": 821503, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 345907, "method2_id": 640608, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 211684, "method2_id": 843063, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 1966262, "method2_id": 9693856, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "T1", "method1_id": 65493, "method2_id": 789019, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 541800, "method2_id": 714205, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 2746, "method2_id": 748154, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 737699, "method2_id": 860848, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 739813, "method2_id": 892626, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 12935, "method2_id": 646740, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 187827, "method2_id": 489465, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 53722, "method2_id": 3814208, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 162827, "method2_id": 928483, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 217749, "method2_id": 334117, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 353068, "method2_id": 487413, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 116119, "method2_id": 911774, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 165906, "method2_id": 640608, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 469060, "method2_id": 631361, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 136067, "method2_id": 513245, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 353068, "method2_id": 947101, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 428050, "method2_id": 912097, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 14024, "method2_id": 784373, "code1": "public sendhtml (String [] argv) {\n    String to, subject = null, from = null, cc = null, bcc = null, url = null;\n    String mailhost = null;\n    String mailer = \"sendhtml\";\n    String protocol = null, host = null, user = null, password = null;\n    String record = null;\n    boolean debug = false;\n    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n    int optind;\n    for (optind = 0; optind < argv.length; optind ++) {\n        if (argv [optind].equals (\"-T\")) {\n            protocol = argv [++ optind];\n        } else if (argv [optind].equals (\"-H\")) {\n            host = argv [++ optind];\n        } else if (argv [optind].equals (\"-U\")) {\n            user = argv [++ optind];\n        } else if (argv [optind].equals (\"-P\")) {\n            password = argv [++ optind];\n        } else if (argv [optind].equals (\"-M\")) {\n            mailhost = argv [++ optind];\n        } else if (argv [optind].equals (\"-f\")) {\n            record = argv [++ optind];\n        } else if (argv [optind].equals (\"-s\")) {\n            subject = argv [++ optind];\n        } else if (argv [optind].equals (\"-o\")) {\n            from = argv [++ optind];\n        } else if (argv [optind].equals (\"-c\")) {\n            cc = argv [++ optind];\n        } else if (argv [optind].equals (\"-b\")) {\n            bcc = argv [++ optind];\n        } else if (argv [optind].equals (\"-L\")) {\n            url = argv [++ optind];\n        } else if (argv [optind].equals (\"-d\")) {\n            debug = true;\n        } else if (argv [optind].equals (\"--\")) {\n            optind ++;\n            break;\n        } else if (argv [optind].startsWith (\"-\")) {\n            System.out.println (\"Usage: sendhtml [[-L store-url] | [-T prot] [-H host] [-U user] [-P passwd]]\");\n            System.out.println (\"\\t[-s subject] [-o from-address] [-c cc-addresses] [-b bcc-addresses]\");\n            System.out.println (\"\\t[-f record-mailbox] [-M transport-host] [-d] [address]\");\n            System.exit (1);\n        } else {\n            break;\n        }\n\n    }\n    try {\n        if (optind < argv.length) {\n            to = argv [optind];\n            System.out.println (\"To: \" + to);\n        } else {\n            System.out.print (\"To: \");\n            System.out.flush ();\n            to = in.readLine ();\n        }\n        if (subject == null) {\n            System.out.print (\"Subject: \");\n            System.out.flush ();\n            subject = in.readLine ();\n        } else {\n            System.out.println (\"Subject: \" + subject);\n        }\n        Properties props = System.getProperties ();\n        if (mailhost != null) props.put (\"mail.smtp.host\", mailhost);\n\n        Session session = Session.getInstance (props, null);\n        if (debug) session.setDebug (true);\n\n        Message msg = new MimeMessage (session);\n        if (from != null) msg.setFrom (new InternetAddress (from));\n        else msg.setFrom ();\n\n        msg.setRecipients (Message.RecipientType.TO, InternetAddress.parse (to, false));\n        if (cc != null) msg.setRecipients (Message.RecipientType.CC, InternetAddress.parse (cc, false));\n\n        if (bcc != null) msg.setRecipients (Message.RecipientType.BCC, InternetAddress.parse (bcc, false));\n\n        msg.setSubject (subject);\n        collect (in, msg);\n        msg.setHeader (\"X-Mailer\", mailer);\n        msg.setSentDate (new Date ());\n        Transport.send (msg);\n        System.out.println (\"\\nMail was sent successfully.\");\n        if (record != null) {\n            Store store = null;\n            if (url != null) {\n                URLName urln = new URLName (url);\n                store = session.getStore (urln);\n                store.connect ();\n            } else {\n                if (protocol != null) store = session.getStore (protocol);\n                else store = session.getStore ();\n\n                if (host != null || user != null || password != null) store.connect (host, user, password);\n                else store.connect ();\n\n            }\n            Folder folder = store.getFolder (record);\n            if (folder == null) {\n                System.err.println (\"Can't get record folder.\");\n                System.exit (1);\n            }\n            if (! folder.exists ()) folder.create (Folder.HOLDS_MESSAGES);\n\n            Message [] msgs = new Message [1];\n            msgs [0] = msg;\n            folder.appendMessages (msgs);\n            System.out.println (\"Mail was recorded successfully.\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public sendhtml (String [] argv) {\n    String to, subject = null, from = null, cc = null, bcc = null, url = null;\n    String mailhost = null;\n    String mailer = \"sendhtml\";\n    String protocol = null, host = null, user = null, password = null;\n    String record = null;\n    boolean debug = false;\n    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n    int optind;\n    for (optind = 0; optind < argv.length; optind ++) {\n        if (argv [optind].equals (\"-T\")) {\n            protocol = argv [++ optind];\n        } else if (argv [optind].equals (\"-H\")) {\n            host = argv [++ optind];\n        } else if (argv [optind].equals (\"-U\")) {\n            user = argv [++ optind];\n        } else if (argv [optind].equals (\"-P\")) {\n            password = argv [++ optind];\n        } else if (argv [optind].equals (\"-M\")) {\n            mailhost = argv [++ optind];\n        } else if (argv [optind].equals (\"-f\")) {\n            record = argv [++ optind];\n        } else if (argv [optind].equals (\"-s\")) {\n            subject = argv [++ optind];\n        } else if (argv [optind].equals (\"-o\")) {\n            from = argv [++ optind];\n        } else if (argv [optind].equals (\"-c\")) {\n            cc = argv [++ optind];\n        } else if (argv [optind].equals (\"-b\")) {\n            bcc = argv [++ optind];\n        } else if (argv [optind].equals (\"-L\")) {\n            url = argv [++ optind];\n        } else if (argv [optind].equals (\"-d\")) {\n            debug = true;\n        } else if (argv [optind].equals (\"--\")) {\n            optind ++;\n            break;\n        } else if (argv [optind].startsWith (\"-\")) {\n            System.out.println (\"Usage: sendhtml [[-L store-url] | [-T prot] [-H host] [-U user] [-P passwd]]\");\n            System.out.println (\"\\t[-s subject] [-o from-address] [-c cc-addresses] [-b bcc-addresses]\");\n            System.out.println (\"\\t[-f record-mailbox] [-M transport-host] [-d] [address]\");\n            System.exit (1);\n        } else {\n            break;\n        }\n\n    }\n    try {\n        if (optind < argv.length) {\n            to = argv [optind];\n            System.out.println (\"To: \" + to);\n        } else {\n            System.out.print (\"To: \");\n            System.out.flush ();\n            to = in.readLine ();\n        }\n        if (subject == null) {\n            System.out.print (\"Subject: \");\n            System.out.flush ();\n            subject = in.readLine ();\n        } else {\n            System.out.println (\"Subject: \" + subject);\n        }\n        Properties props = System.getProperties ();\n        if (mailhost != null) props.put (\"mail.smtp.host\", mailhost);\n\n        Session session = Session.getInstance (props, null);\n        if (debug) session.setDebug (true);\n\n        Message msg = new MimeMessage (session);\n        if (from != null) msg.setFrom (new InternetAddress (from));\n        else msg.setFrom ();\n\n        msg.setRecipients (Message.RecipientType.TO, InternetAddress.parse (to, false));\n        if (cc != null) msg.setRecipients (Message.RecipientType.CC, InternetAddress.parse (cc, false));\n\n        if (bcc != null) msg.setRecipients (Message.RecipientType.BCC, InternetAddress.parse (bcc, false));\n\n        msg.setSubject (subject);\n        collect (in, msg);\n        msg.setHeader (\"X-Mailer\", mailer);\n        msg.setSentDate (new Date ());\n        Transport.send (msg);\n        System.out.println (\"\\nMail was sent successfully.\");\n        if (record != null) {\n            Store store = null;\n            if (url != null) {\n                URLName urln = new URLName (url);\n                store = session.getStore (urln);\n                store.connect ();\n            } else {\n                if (protocol != null) store = session.getStore (protocol);\n                else store = session.getStore ();\n\n                if (host != null || user != null || password != null) store.connect (host, user, password);\n                else store.connect ();\n\n            }\n            Folder folder = store.getFolder (record);\n            if (folder == null) {\n                System.err.println (\"Can't get record folder.\");\n                System.exit (1);\n            }\n            if (! folder.exists ()) folder.create (Folder.HOLDS_MESSAGES);\n\n            Message [] msgs = new Message [1];\n            msgs [0] = msg;\n            folder.appendMessages (msgs);\n            System.out.println (\"Mail was recorded successfully.\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 47756, "method2_id": 838844, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 157777, "method2_id": 296921, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 718536, "method2_id": 916273, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 28134, "method2_id": 235425, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 90593, "method2_id": 664803, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "T1", "method1_id": 563744, "method2_id": 695351, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 469340, "method2_id": 863587, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 203113, "method2_id": 928484, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 47337, "method2_id": 116038, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 203112, "method2_id": 801886, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 53722, "method2_id": 881839, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 858382, "method2_id": 910689, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 332635, "method2_id": 850680, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 680174, "method2_id": 727183, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 689531, "method2_id": 801886, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 274159, "method2_id": 280040, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 53722, "method2_id": 910479, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 207271, "method2_id": 250688, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 24854, "method2_id": 638430, "code1": "File createJar (String name, String...entries) throws IOException {\n    File jar = new File (name);\n    OutputStream out = new FileOutputStream (jar);\n    try {\n        JarOutputStream jos = new JarOutputStream (out);\n        for (String e : entries) {\n            jos.putNextEntry (new ZipEntry (e));\n            jos.write (e.getBytes ());\n        }\n        jos.close ();\n    } finally {\n        out.close ();\n    }\n    return jar;\n}\n", "code2": "File createJar (String name, String...entries) throws IOException {\n    File jar = new File (name);\n    OutputStream out = new FileOutputStream (jar);\n    try {\n        JarOutputStream jos = new JarOutputStream (out);\n        for (String e : entries) {\n            jos.putNextEntry (new ZipEntry (e));\n            jos.write (e.getBytes ());\n        }\n        jos.close ();\n    } finally {\n        out.close ();\n    }\n    return jar;\n}\n"}
{"clone_type": "T1", "method1_id": 2461168, "method2_id": 14183083, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "T1", "method1_id": 172115, "method2_id": 293080, "code1": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n", "code2": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 820538, "method2_id": 821502, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 44823, "method2_id": 280040, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 2461169, "method2_id": 16351776, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "T1", "method1_id": 310182, "method2_id": 441377, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 136068, "method2_id": 512227, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 681079, "method2_id": 911774, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 636262, "method2_id": 804637, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 116295, "method2_id": 490648, "code1": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n", "code2": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n"}
{"clone_type": "T1", "method1_id": 383565, "method2_id": 428050, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 298516, "method2_id": 518705, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 128736, "method2_id": 661980, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 474315, "method2_id": 789018, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 141462, "method2_id": 298973, "code1": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n", "code2": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n"}
{"clone_type": "T1", "method1_id": 396827, "method2_id": 843063, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 670345, "method2_id": 946511, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 2791310, "method2_id": 16761836, "code1": "protected synchronized AbstractBaseObject insert (AbstractBaseObject obj) throws ApplicationException {\n    PreparedStatement preStat = null;\n    StringBuffer sqlStat = new StringBuffer ();\n    DmsRelationalWord tmpDmsRelationalWord = (DmsRelationalWord) ((DmsRelationalWord) obj).clone ();\n    synchronized (dbConn) {\n        try {\n            Integer nextID = getNextPrimaryID ();\n            Timestamp currTime = Utility.getCurrentTimestamp ();\n            sqlStat.append (\"INSERT \");\n            sqlStat.append (\"INTO   DMS_RELATIONAL_WORD(ID, RECORD_STATUS, UPDATE_COUNT, CREATOR_ID, CREATE_DATE, UPDATER_ID, UPDATE_DATE, WORD, PARENT_ID, TYPE) \");\n            sqlStat.append (\"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) \");\n            preStat = dbConn.prepareStatement (sqlStat.toString (), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n            setPrepareStatement (preStat, 1, nextID);\n            setPrepareStatement (preStat, 2, tmpDmsRelationalWord.getRecordStatus ());\n            setPrepareStatement (preStat, 3, new Integer (0));\n            setPrepareStatement (preStat, 4, tmpDmsRelationalWord.getCreatorID ());\n            setPrepareStatement (preStat, 5, currTime);\n            setPrepareStatement (preStat, 6, tmpDmsRelationalWord.getUpdaterID ());\n            setPrepareStatement (preStat, 7, currTime);\n            if (tmpDmsRelationalWord.getWord () == null || \"\".equals (tmpDmsRelationalWord.getWord ().trim ())) {\n                return null;\n            }\n            setPrepareStatement (preStat, 8, tmpDmsRelationalWord.getWord ());\n            setPrepareStatement (preStat, 9, tmpDmsRelationalWord.getParentID ());\n            setPrepareStatement (preStat, 10, tmpDmsRelationalWord.getType ());\n            preStat.executeUpdate ();\n            tmpDmsRelationalWord.setID (nextID);\n            tmpDmsRelationalWord.setCreatorID (tmpDmsRelationalWord.getCreatorID ());\n            tmpDmsRelationalWord.setCreateDate (currTime);\n            tmpDmsRelationalWord.setUpdaterID (tmpDmsRelationalWord.getUpdaterID ());\n            tmpDmsRelationalWord.setUpdateDate (currTime);\n            tmpDmsRelationalWord.setUpdateCount (new Integer (0));\n            tmpDmsRelationalWord.setCreatorName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getCreatorID ()));\n            tmpDmsRelationalWord.setUpdaterName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getUpdaterID ()));\n            dbConn.commit ();\n            return (tmpDmsRelationalWord);\n        } catch (Exception e) {\n            try {\n                dbConn.rollback ();\n            } catch (Exception ee) {\n            }\n            log.error (e, e);\n            throw new ApplicationException (ErrorConstant.DB_INSERT_ERROR, e);\n        } finally {\n            try {\n                preStat.close ();\n            } catch (Exception ignore) {\n            } finally {\n                preStat = null;\n            }\n        }\n    }\n}\n", "code2": "protected synchronized AbstractBaseObject insert (AbstractBaseObject obj) throws ApplicationException {\n    PreparedStatement preStat = null;\n    StringBuffer sqlStat = new StringBuffer ();\n    DmsRelationalWord tmpDmsRelationalWord = (DmsRelationalWord) ((DmsRelationalWord) obj).clone ();\n    synchronized (dbConn) {\n        try {\n            Integer nextID = getNextPrimaryID ();\n            Timestamp currTime = Utility.getCurrentTimestamp ();\n            sqlStat.append (\"INSERT \");\n            sqlStat.append (\"INTO   DMS_RELATIONAL_WORD(ID, RECORD_STATUS, UPDATE_COUNT, CREATOR_ID, CREATE_DATE, UPDATER_ID, UPDATE_DATE, WORD, PARENT_ID, TYPE) \");\n            sqlStat.append (\"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) \");\n            preStat = dbConn.prepareStatement (sqlStat.toString (), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n            setPrepareStatement (preStat, 1, nextID);\n            setPrepareStatement (preStat, 2, tmpDmsRelationalWord.getRecordStatus ());\n            setPrepareStatement (preStat, 3, new Integer (0));\n            setPrepareStatement (preStat, 4, tmpDmsRelationalWord.getCreatorID ());\n            setPrepareStatement (preStat, 5, currTime);\n            setPrepareStatement (preStat, 6, tmpDmsRelationalWord.getUpdaterID ());\n            setPrepareStatement (preStat, 7, currTime);\n            if (tmpDmsRelationalWord.getWord () == null || \"\".equals (tmpDmsRelationalWord.getWord ().trim ())) {\n                return null;\n            }\n            setPrepareStatement (preStat, 8, tmpDmsRelationalWord.getWord ());\n            setPrepareStatement (preStat, 9, tmpDmsRelationalWord.getParentID ());\n            setPrepareStatement (preStat, 10, tmpDmsRelationalWord.getType ());\n            preStat.executeUpdate ();\n            tmpDmsRelationalWord.setID (nextID);\n            tmpDmsRelationalWord.setCreatorID (tmpDmsRelationalWord.getCreatorID ());\n            tmpDmsRelationalWord.setCreateDate (currTime);\n            tmpDmsRelationalWord.setUpdaterID (tmpDmsRelationalWord.getUpdaterID ());\n            tmpDmsRelationalWord.setUpdateDate (currTime);\n            tmpDmsRelationalWord.setUpdateCount (new Integer (0));\n            tmpDmsRelationalWord.setCreatorName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getCreatorID ()));\n            tmpDmsRelationalWord.setUpdaterName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getUpdaterID ()));\n            dbConn.commit ();\n            return (tmpDmsRelationalWord);\n        } catch (Exception e) {\n            try {\n                dbConn.rollback ();\n            } catch (Exception ee) {\n            }\n            log.error (e, e);\n            throw new ApplicationException (ErrorConstant.DB_INSERT_ERROR, e);\n        } finally {\n            try {\n                preStat.close ();\n            } catch (Exception ignore) {\n            } finally {\n                preStat = null;\n            }\n        }\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 38361, "method2_id": 131811, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 62362, "method2_id": 679959, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 210006, "method2_id": 764085, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 30466, "method2_id": 55217, "code1": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n", "code2": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n"}
{"clone_type": "T1", "method1_id": 238319, "method2_id": 932291, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 461151, "method2_id": 853457, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 151248, "method2_id": 666031, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (- 1);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 419664, "method2_id": 665420, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "T1", "method1_id": 131811, "method2_id": 310580, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 9563, "method2_id": 145197, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 244233, "method2_id": 605829, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 80861, "method2_id": 299389, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 529863, "method2_id": 926011, "code1": "public static Object newInstance (Class o_clazz, Object [] args, Class [] clazzes) throws Throwable {\n    boolean [] is_null = new boolean [args.length];\n    for (int i = 0;\n    i < args.length; i ++) {\n        is_null [i] = (args [i] == null);\n    }\n    Constructor cons = getConstructor (o_clazz, clazzes, is_null);\n    boolean access = cons.isAccessible ();\n    cons.setAccessible (true);\n    Object o;\n    try {\n        o = cons.newInstance (args);\n    } catch (InvocationTargetException e) {\n        throw e.getTargetException ();\n    } finally {\n        cons.setAccessible (access);\n    }\n    return o;\n}\n", "code2": "public static Object newInstance (Class o_clazz, Object [] args, Class [] clazzes) throws Throwable {\n    boolean [] is_null = new boolean [args.length];\n    for (int i = 0;\n    i < args.length; i ++) {\n        is_null [i] = (args [i] == null);\n    }\n    Constructor cons = getConstructor (o_clazz, clazzes, is_null);\n    boolean access = cons.isAccessible ();\n    cons.setAccessible (true);\n    Object o;\n    try {\n        o = cons.newInstance (args);\n    } catch (InvocationTargetException e) {\n        throw e.getTargetException ();\n    } finally {\n        cons.setAccessible (access);\n    }\n    return o;\n}\n"}
{"clone_type": "T1", "method1_id": 13335071, "method2_id": 16529002, "code1": "public static boolean copy (File source, File dest) {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    } catch (IOException e) {\n        e.printStackTrace ();\n        return false;\n    }\n    return true;\n}\n", "code2": "public static boolean copy (File source, File dest) {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    } catch (IOException e) {\n        e.printStackTrace ();\n        return false;\n    }\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 177743, "method2_id": 454857, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 222604, "method2_id": 662293, "code1": "private static boolean delete (File resource) throws IOException {\n    if (resource.isDirectory ()) {\n        File [] childFiles = resource.listFiles ();\n        for (File child : childFiles) {\n            delete (child);\n        }\n    }\n    return resource.delete ();\n}\n", "code2": "private static boolean delete (File resource) throws IOException {\n    if (resource.isDirectory ()) {\n        File [] childFiles = resource.listFiles ();\n        for (File child : childFiles) {\n            delete (child);\n        }\n    }\n    return resource.delete ();\n}\n"}
{"clone_type": "T1", "method1_id": 13476, "method2_id": 776780, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 939305, "method2_id": 946511, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 203112, "method2_id": 652689, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 489465, "method2_id": 605828, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 136067, "method2_id": 946510, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 513245, "method2_id": 725500, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 489465, "method2_id": 670344, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 44949, "method2_id": 811157, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 6244936, "method2_id": 19584877, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "T1", "method1_id": 258490, "method2_id": 850680, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 345907, "method2_id": 927500, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 44823, "method2_id": 62362, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 546905, "method2_id": 820538, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 473025, "method2_id": 812839, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 86512, "method2_id": 206478, "code1": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n", "code2": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 120730, "method2_id": 849586, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 145197, "method2_id": 727183, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 28134, "method2_id": 187827, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 45375, "method2_id": 293081, "code1": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n", "code2": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 379080, "method2_id": 695790, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 714206, "method2_id": 739814, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 28134, "method2_id": 202241, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 47756, "method2_id": 364438, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 53655, "method2_id": 474315, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 124388, "method2_id": 695351, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 748153, "method2_id": 927500, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 111977, "method2_id": 242004, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 529863, "method2_id": 768940, "code1": "public static Object newInstance (Class o_clazz, Object [] args, Class [] clazzes) throws Throwable {\n    boolean [] is_null = new boolean [args.length];\n    for (int i = 0;\n    i < args.length; i ++) {\n        is_null [i] = (args [i] == null);\n    }\n    Constructor cons = getConstructor (o_clazz, clazzes, is_null);\n    boolean access = cons.isAccessible ();\n    cons.setAccessible (true);\n    Object o;\n    try {\n        o = cons.newInstance (args);\n    } catch (InvocationTargetException e) {\n        throw e.getTargetException ();\n    } finally {\n        cons.setAccessible (access);\n    }\n    return o;\n}\n", "code2": "public static Object newInstance (Class o_clazz, Object [] args, Class [] clazzes) throws Throwable {\n    boolean [] is_null = new boolean [args.length];\n    for (int i = 0;\n    i < args.length; i ++) {\n        is_null [i] = (args [i] == null);\n    }\n    Constructor cons = getConstructor (o_clazz, clazzes, is_null);\n    boolean access = cons.isAccessible ();\n    cons.setAccessible (true);\n    Object o;\n    try {\n        o = cons.newInstance (args);\n    } catch (InvocationTargetException e) {\n        throw e.getTargetException ();\n    } finally {\n        cons.setAccessible (access);\n    }\n    return o;\n}\n"}
{"clone_type": "T1", "method1_id": 244232, "method2_id": 370546, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 116118, "method2_id": 296921, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 168320, "method2_id": 679416, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 169905, "method2_id": 270828, "code1": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n", "code2": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 161844, "method2_id": 288978, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 63416, "method2_id": 913382, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 63417, "method2_id": 162828, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 211685, "method2_id": 314561, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 649595, "method2_id": 662799, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 682785, "method2_id": 812803, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 120707, "method2_id": 860578, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 86513, "method2_id": 299622, "code1": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n", "code2": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 193560, "method2_id": 345908, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 88047, "method2_id": 223631, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 162827, "method2_id": 281391, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 646739, "method2_id": 789018, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 160204, "method2_id": 801886, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 235245, "method2_id": 653371, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 621362, "method2_id": 662799, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 296603, "method2_id": 347683, "code1": "public Metadata (DefaultValuesProvider dvp, File file) throws Exception {\n    this.dvp = dvp;\n    this.file = file;\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();\n    dbf.setValidating (false);\n    DocumentBuilder b = dbf.newDocumentBuilder ();\n    if (file.exists ()) {\n        doc = b.parse (file);\n        changed = false;\n    } else {\n        doc = b.newDocument ();\n        Element root = doc.createElement (\"metadata\");\n        doc.appendChild (root);\n        changed = true;\n    }\n    root = doc.getDocumentElement ();\n    lang = DEFAULT_LANG;\n}\n", "code2": "public Metadata (DefaultValuesProvider dvp, File file) throws Exception {\n    this.dvp = dvp;\n    this.file = file;\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();\n    dbf.setValidating (false);\n    DocumentBuilder b = dbf.newDocumentBuilder ();\n    if (file.exists ()) {\n        doc = b.parse (file);\n        changed = false;\n    } else {\n        doc = b.newDocument ();\n        Element root = doc.createElement (\"metadata\");\n        doc.appendChild (root);\n        changed = true;\n    }\n    root = doc.getDocumentElement ();\n    lang = DEFAULT_LANG;\n}\n"}
{"clone_type": "T1", "method1_id": 245665, "method2_id": 311166, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 46158, "method2_id": 811157, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 567476, "method2_id": 801395, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 912096, "method2_id": 928483, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 645756, "method2_id": 861011, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 80860, "method2_id": 242004, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 66329, "method2_id": 290430, "code1": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n", "code2": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n"}
{"clone_type": "T1", "method1_id": 11548510, "method2_id": 21870536, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "T1", "method1_id": 587124, "method2_id": 727183, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 543096, "method2_id": 709767, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 4764618, "method2_id": 6983973, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 8024375, "method2_id": 15500892, "code1": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n", "code2": "private void getRandomGUID (boolean secure) {\n    MessageDigest md5 = null;\n    StringBuffer sbValueBeforeMD5 = new StringBuffer ();\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println (\"Error: \" + e);\n    }\n    try {\n        long time = System.currentTimeMillis ();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong ();\n        } else {\n            rand = myRand.nextLong ();\n        }\n        sbValueBeforeMD5.append (s_id);\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (time));\n        sbValueBeforeMD5.append (\":\");\n        sbValueBeforeMD5.append (Long.toString (rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString ();\n        md5.update (valueBeforeMD5.getBytes ());\n        byte [] array = md5.digest ();\n        StringBuffer sb = new StringBuffer ();\n        for (int j = 0;\n        j < array.length; ++ j) {\n            int b = array [j] & 0xFF;\n            if (b < 0x10) sb.append ('0');\n\n            sb.append (Integer.toHexString (b));\n        }\n        valueAfterMD5 = sb.toString ();\n    } catch (Exception e) {\n        System.out.println (\"Error:\" + e);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 2532321, "method2_id": 6814854, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "T1", "method1_id": 111977, "method2_id": 946510, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 116038, "method2_id": 896372, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 437883, "method2_id": 922376, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "T1", "method1_id": 211685, "method2_id": 396828, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 601526, "method2_id": 689011, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 380998, "method2_id": 488477, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 245664, "method2_id": 383564, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 6102140, "method2_id": 9449064, "code1": "public static void main (String [] args) {\n    try {\n        boolean readExp = Utils.getFlag ('l', args);\n        final boolean writeExp = Utils.getFlag ('s', args);\n        final String expFile = Utils.getOption ('f', args);\n        if ((readExp || writeExp) && (expFile.length () == 0)) {\n            throw new Exception (\"A filename must be given with the -f option\");\n        }\n        Experiment exp = null;\n        if (readExp) {\n            FileInputStream fi = new FileInputStream (expFile);\n            ObjectInputStream oi = new ObjectInputStream (new BufferedInputStream (fi));\n            exp = (Experiment) oi.readObject ();\n            oi.close ();\n        } else {\n            exp = new Experiment ();\n        }\n        System.err.println (\"Initial Experiment:\\n\" + exp.toString ());\n        final JFrame jf = new JFrame (\"Weka Experiment Setup\");\n        jf.getContentPane ().setLayout (new BorderLayout ());\n        final SetupPanel sp = new SetupPanel ();\n        jf.getContentPane ().add (sp, BorderLayout.CENTER);\n        jf.addWindowListener (new WindowAdapter () {\n            public void windowClosing (WindowEvent e) {\n                System.err.println (\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString ());\n                if (writeExp) {\n                    try {\n                        FileOutputStream fo = new FileOutputStream (expFile);\n                        ObjectOutputStream oo = new ObjectOutputStream (new BufferedOutputStream (fo));\n                        oo.writeObject (sp.m_Exp);\n                        oo.close ();\n                    } catch (Exception ex) {\n                        ex.printStackTrace ();\n                        System.err.println (\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage ());\n                    }\n                }\n                jf.dispose ();\n                System.exit (0);\n            }}\n\n        );\n        jf.pack ();\n        jf.setVisible (true);\n        System.err.println (\"Short nap\");\n        Thread.currentThread ().sleep (3000);\n        System.err.println (\"Done\");\n        sp.setExperiment (exp);\n    } catch (Exception ex) {\n        ex.printStackTrace ();\n        System.err.println (ex.getMessage ());\n    }\n}\n", "code2": "public static void main (String [] args) {\n    try {\n        boolean readExp = Utils.getFlag ('l', args);\n        final boolean writeExp = Utils.getFlag ('s', args);\n        final String expFile = Utils.getOption ('f', args);\n        if ((readExp || writeExp) && (expFile.length () == 0)) {\n            throw new Exception (\"A filename must be given with the -f option\");\n        }\n        Experiment exp = null;\n        if (readExp) {\n            FileInputStream fi = new FileInputStream (expFile);\n            ObjectInputStream oi = new ObjectInputStream (new BufferedInputStream (fi));\n            exp = (Experiment) oi.readObject ();\n            oi.close ();\n        } else {\n            exp = new Experiment ();\n        }\n        System.err.println (\"Initial Experiment:\\n\" + exp.toString ());\n        final JFrame jf = new JFrame (\"Weka Experiment Setup\");\n        jf.getContentPane ().setLayout (new BorderLayout ());\n        final SetupPanel sp = new SetupPanel ();\n        jf.getContentPane ().add (sp, BorderLayout.CENTER);\n        jf.addWindowListener (new WindowAdapter () {\n            public void windowClosing (WindowEvent e) {\n                System.err.println (\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString ());\n                if (writeExp) {\n                    try {\n                        FileOutputStream fo = new FileOutputStream (expFile);\n                        ObjectOutputStream oo = new ObjectOutputStream (new BufferedOutputStream (fo));\n                        oo.writeObject (sp.m_Exp);\n                        oo.close ();\n                    } catch (Exception ex) {\n                        ex.printStackTrace ();\n                        System.err.println (\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage ());\n                    }\n                }\n                jf.dispose ();\n                System.exit (0);\n            }}\n\n        );\n        jf.pack ();\n        jf.setVisible (true);\n        System.err.println (\"Short nap\");\n        Thread.currentThread ().sleep (3000);\n        System.err.println (\"Done\");\n        sp.setExperiment (exp);\n    } catch (Exception ex) {\n        ex.printStackTrace ();\n        System.err.println (ex.getMessage ());\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 83060, "method2_id": 230567, "code1": "public static void exampleAsSerializer (String sourceID, String xslID) throws TransformerException, TransformerConfigurationException, SAXException, IOException, ParserConfigurationException {\n    DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n    DocumentBuilder docBuilder = dfactory.newDocumentBuilder ();\n    org.w3c.dom.Document outNode = docBuilder.newDocument ();\n    Node doc = docBuilder.parse (new InputSource (sourceID));\n    TransformerFactory tfactory = TransformerFactory.newInstance ();\n    Transformer serializer = tfactory.newTransformer ();\n    Properties oprops = new Properties ();\n    oprops.put (\"method\", \"html\");\n    serializer.setOutputProperties (oprops);\n    serializer.transform (new DOMSource (doc), new StreamResult (new OutputStreamWriter (System.out)));\n}\n", "code2": "public static void exampleAsSerializer (String sourceID, String xslID) throws TransformerException, TransformerConfigurationException, SAXException, IOException, ParserConfigurationException {\n    DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();\n    DocumentBuilder docBuilder = dfactory.newDocumentBuilder ();\n    org.w3c.dom.Document outNode = docBuilder.newDocument ();\n    Node doc = docBuilder.parse (new InputSource (sourceID));\n    TransformerFactory tfactory = TransformerFactory.newInstance ();\n    Transformer serializer = tfactory.newTransformer ();\n    Properties oprops = new Properties ();\n    oprops.put (\"method\", \"html\");\n    serializer.setOutputProperties (oprops);\n    serializer.transform (new DOMSource (doc), new StreamResult (new OutputStreamWriter (System.out)));\n}\n"}
{"clone_type": "T1", "method1_id": 518705, "method2_id": 863587, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 162828, "method2_id": 487413, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 28135, "method2_id": 694024, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 714206, "method2_id": 843064, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 574279, "method2_id": 852143, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "T1", "method1_id": 55697, "method2_id": 769146, "code1": "private String [] execSingleLineOutputCmd (String cmdWithParams) {\n    String result = \"\";\n    try {\n        Process p = Runtime.getRuntime ().exec (cmdWithParams.split (\" \"));\n        BufferedReader sin = new BufferedReader (new InputStreamReader (p.getInputStream ()));\n        result = sin.readLine ();\n        sin.close ();\n        return result.split (\" \");\n    } catch (Exception ex) {\n        System.out.println (\"ERROR: \" + ex.getMessage ());\n        return null;\n    }\n}\n", "code2": "private String [] execSingleLineOutputCmd (String cmdWithParams) {\n    String result = \"\";\n    try {\n        Process p = Runtime.getRuntime ().exec (cmdWithParams.split (\" \"));\n        BufferedReader sin = new BufferedReader (new InputStreamReader (p.getInputStream ()));\n        result = sin.readLine ();\n        sin.close ();\n        return result.split (\" \");\n    } catch (Exception ex) {\n        System.out.println (\"ERROR: \" + ex.getMessage ());\n        return null;\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 157745, "method2_id": 881838, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 280040, "method2_id": 756962, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 2401, "method2_id": 299388, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 680174, "method2_id": 838844, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 116295, "method2_id": 299793, "code1": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n", "code2": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n"}
{"clone_type": "T1", "method1_id": 512227, "method2_id": 913383, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 12934, "method2_id": 128025, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 853457, "method2_id": 928484, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 621591, "method2_id": 682785, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 291040, "method2_id": 313606, "code1": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n", "code2": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 555513, "method2_id": 935017, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 653541, "method2_id": 792644, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 217750, "method2_id": 843064, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 150478, "method2_id": 335223, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 18731109, "method2_id": 21488868, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "T1", "method1_id": 8671162, "method2_id": 12820666, "code1": "private static Object extendArray (Object a1) {\n    int n = Array.getLength (a1);\n    Object a2 = Array.newInstance (a1.getClass ().getComponentType (), n + ARRAY_SIZE_INCREMENT);\n    System.arraycopy (a1, 0, a2, 0, n);\n    return a2;\n}\n", "code2": "private static Object extendArray (Object a1) {\n    int n = Array.getLength (a1);\n    Object a2 = Array.newInstance (a1.getClass ().getComponentType (), n + ARRAY_SIZE_INCREMENT);\n    System.arraycopy (a1, 0, a2, 0, n);\n    return a2;\n}\n"}
{"clone_type": "T1", "method1_id": 280040, "method2_id": 820872, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 614390, "method2_id": 751335, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 3746738, "method2_id": 5701319, "code1": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n", "code2": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n"}
{"clone_type": "T1", "method1_id": 56285, "method2_id": 273486, "code1": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (InetAddress.getByName (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (null);\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                String addrString;\n                addUDP (addr, port);\n                addTCP (addr, port);\n                if (addr == null) addrString = \"0.0.0.0\";\n                else addrString = addr.getHostAddress ();\n\n                System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n", "code2": "public jnamed (String conffile) throws IOException, ZoneTransferException {\n    FileInputStream fs;\n    List ports = new ArrayList ();\n    List addresses = new ArrayList ();\n    try {\n        fs = new FileInputStream (conffile);\n    } catch (Exception e) {\n        System.out.println (\"Cannot open \" + conffile);\n        return;\n    }\n    try {\n        caches = new HashMap ();\n        znames = new HashMap ();\n        TSIGs = new HashMap ();\n        InputStreamReader isr = new InputStreamReader (fs);\n        BufferedReader br = new BufferedReader (isr);\n        String line = null;\n        while ((line = br.readLine ()) != null) {\n            StringTokenizer st = new StringTokenizer (line);\n            if (! st.hasMoreTokens ()) continue;\n\n            String keyword = st.nextToken ();\n            if (! st.hasMoreTokens ()) {\n                System.out.println (\"Invalid line: \" + line);\n                continue;\n            }\n            if (keyword.charAt (0) == '#') continue;\n\n            if (keyword.equals (\"primary\")) addPrimaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"secondary\")) addSecondaryZone (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"cache\")) {\n                Cache cache = new Cache (st.nextToken ());\n                caches.put (new Integer (DClass.IN), cache);\n            } else if (keyword.equals (\"key\")) addTSIG (st.nextToken (), st.nextToken ());\n            else if (keyword.equals (\"port\")) ports.add (Integer.valueOf (st.nextToken ()));\n            else if (keyword.equals (\"address\")) {\n                String addr = st.nextToken ();\n                addresses.add (InetAddress.getByName (addr));\n            } else {\n                System.out.println (\"unknown keyword: \" + keyword);\n            }\n\n        }\n        if (ports.size () == 0) ports.add (new Integer (53));\n\n        if (addresses.size () == 0) addresses.add (null);\n\n        Iterator iaddr = addresses.iterator ();\n        while (iaddr.hasNext ()) {\n            InetAddress addr = (InetAddress) iaddr.next ();\n            Iterator iport = ports.iterator ();\n            while (iport.hasNext ()) {\n                int port = ((Integer) iport.next ()).intValue ();\n                String addrString;\n                addUDP (addr, port);\n                addTCP (addr, port);\n                if (addr == null) addrString = \"0.0.0.0\";\n                else addrString = addr.getHostAddress ();\n\n                System.out.println (\"jnamed: listening on \" + addrString + \"#\" + port);\n            }\n        }\n        System.out.println (\"jnamed: running\");\n    } finally {\n        fs.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 351290, "method2_id": 383565, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 203112, "method2_id": 518705, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 575998, "method2_id": 665895, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 147667, "method2_id": 299388, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 202150, "method2_id": 789018, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 162828, "method2_id": 461151, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 13908, "method2_id": 506382, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "T1", "method1_id": 546906, "method2_id": 681079, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 793635, "method2_id": 814473, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 776780, "method2_id": 789019, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 168320, "method2_id": 683983, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 136068, "method2_id": 217750, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 5615645, "method2_id": 5961180, "code1": "public static boolean zip (File [] filesToZip, File zipFile) {\n    byte [] buf = new byte [2048];\n    ZipOutputStream out = null;\n    FileInputStream in = null;\n    try {\n        out = new ZipOutputStream (new FileOutputStream (zipFile));\n        for (int i = 0;\n        i < filesToZip.length; i ++) {\n            in = new FileInputStream (filesToZip [i]);\n            out.putNextEntry (new ZipEntry (filesToZip [i].getName ()));\n            int len;\n            while ((len = in.read (buf)) != - 1) {\n                out.write (buf, 0, len);\n            }\n            out.closeEntry ();\n            in.close ();\n        }\n        out.close ();\n    } catch (IOException e) {\n        System.err.println (\"Can't zip()\");\n        e.printStackTrace ();\n        safeClose (out);\n        safeClose (in);\n        return false;\n    }\n    return true;\n}\n", "code2": "public static boolean zip (File [] filesToZip, File zipFile) {\n    byte [] buf = new byte [2048];\n    ZipOutputStream out = null;\n    FileInputStream in = null;\n    try {\n        out = new ZipOutputStream (new FileOutputStream (zipFile));\n        for (int i = 0;\n        i < filesToZip.length; i ++) {\n            in = new FileInputStream (filesToZip [i]);\n            out.putNextEntry (new ZipEntry (filesToZip [i].getName ()));\n            int len;\n            while ((len = in.read (buf)) != - 1) {\n                out.write (buf, 0, len);\n            }\n            out.closeEntry ();\n            in.close ();\n        }\n        out.close ();\n    } catch (IOException e) {\n        System.err.println (\"Can't zip()\");\n        e.printStackTrace ();\n        safeClose (out);\n        safeClose (in);\n        return false;\n    }\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 278438, "method2_id": 820538, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 128736, "method2_id": 193053, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 383565, "method2_id": 681079, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 65493, "method2_id": 245665, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 90593, "method2_id": 885948, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "T1", "method1_id": 241850, "method2_id": 673501, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 25975, "method2_id": 172116, "code1": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n", "code2": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 1966262, "method2_id": 19584877, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "T1", "method1_id": 10731, "method2_id": 739813, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 227071, "method2_id": 911773, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 51334, "method2_id": 66428, "code1": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n", "code2": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n"}
{"clone_type": "T1", "method1_id": 168607, "method2_id": 662799, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 28334, "method2_id": 370547, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 232916, "method2_id": 314443, "code1": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n", "code2": "public static void main (String argv []) {\n    example.setIvar (42);\n    example.setSvar ((short) - 31000);\n    example.setLvar (65537);\n    example.setUivar (123456);\n    example.setUsvar (61000);\n    example.setUlvar (654321);\n    example.setScvar ((byte) - 13);\n    example.setUcvar ((short) 251);\n    example.setCvar ('S');\n    example.setFvar ((float) 3.14159);\n    example.setDvar (2.1828);\n    example.setStrvar (\"Hello World\");\n    example.setIptrvar (example.new_int (37));\n    example.setPtptr (example.new_Point (37, 42));\n    example.setName (\"Bill\");\n    System.out.println (\"Variables (values printed from Java)\");\n    System.out.println (\"ivar      =\" + example.getIvar ());\n    System.out.println (\"svar      =\" + example.getSvar ());\n    System.out.println (\"lvar      =\" + example.getLvar ());\n    System.out.println (\"uivar     =\" + example.getUivar ());\n    System.out.println (\"usvar     =\" + example.getUsvar ());\n    System.out.println (\"ulvar     =\" + example.getUlvar ());\n    System.out.println (\"scvar     =\" + example.getScvar ());\n    System.out.println (\"ucvar     =\" + example.getUcvar ());\n    System.out.println (\"fvar      =\" + example.getFvar ());\n    System.out.println (\"dvar      =\" + example.getDvar ());\n    System.out.println (\"cvar      =\" + (char) example.getCvar ());\n    System.out.println (\"strvar    =\" + example.getStrvar ());\n    System.out.println (\"cstrvar   =\" + example.getCstrvar ());\n    System.out.println (\"iptrvar   =\" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));\n    System.out.println (\"name      =\" + example.getName ());\n    System.out.println (\"ptptr     =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));\n    System.out.println (\"pt        =\" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));\n    System.out.println (\"\\nVariables (values printed from C)\");\n    example.print_vars ();\n    System.out.println (\"\\nNow I'm going to try and modify some read only variables\");\n    System.out.println (\"     Trying to set 'path'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setPath\", new Class [] {String.class});\n        m.invoke (example.class, new Object [] {\"Whoa!\"});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"     Trying to set 'status'\");\n    try {\n        Method m = example.class.getDeclaredMethod (\"setStatus\", new Class [] {Integer.class});\n        m.invoke (example.class, new Object [] {new Integer (0)});\n        System.out.println (\"Hey, what's going on?!?! This shouldn't work\");\n    } catch (NoSuchMethodException e) {\n        System.out.println (\"Good.\");\n    } catch (Throwable t) {\n        System.out.println (\"You shouldn't see this!\");\n    }\n    System.out.println (\"\\nI'm going to try and update a structure variable.\\n\");\n    example.setPt (example.getPtptr ());\n    System.out.println (\"The new value is\");\n    example.pt_print ();\n    System.out.println (\"You should see the value\" + example.Point_print (example.getPtptr ()));\n}\n"}
{"clone_type": "T1", "method1_id": 189496, "method2_id": 289774, "code1": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n", "code2": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 308643, "method2_id": 569269, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 2746, "method2_id": 403116, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 539536, "method2_id": 649158, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 333433, "method2_id": 860578, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 134257, "method2_id": 172116, "code1": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n", "code2": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 311165, "method2_id": 497855, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 4518933, "method2_id": 6244936, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "T1", "method1_id": 91509, "method2_id": 150671, "code1": "private void addAdditional2 (Message response, int section) {\n    Enumeration e = response.getSection (section);\n    while (e.hasMoreElements ()) {\n        Record r = (Record) e.nextElement ();\n        try {\n            Method m = r.getClass ().getMethod (\"getTarget\", null);\n            Name glueName = (Name) m.invoke (r, null);\n            addGlue (response, glueName);\n        } catch (Exception ex) {\n        }\n    }\n}\n", "code2": "private void addAdditional2 (Message response, int section) {\n    Enumeration e = response.getSection (section);\n    while (e.hasMoreElements ()) {\n        Record r = (Record) e.nextElement ();\n        try {\n            Method m = r.getClass ().getMethod (\"getTarget\", null);\n            Name glueName = (Name) m.invoke (r, null);\n            addGlue (response, glueName);\n        } catch (Exception ex) {\n        }\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 104050, "method2_id": 207614, "code1": "public MNewProject (JFrame par, String projFileName, int msg) {\n    super (par, true);\n    m_dialogOK = false;\n    setSize (650, 500);\n    if (projFileName == null) reset ();\n\n    m_message = msg;\n    if (projFileName == null) {\n        m_srcLang = CommandThread.core.getPreference (OConsts.PREF_SRCLANG);\n        m_locLang = CommandThread.core.getPreference (OConsts.PREF_LOCLANG);\n        if (m_srcLang.equals (\"\")) m_srcLang = \"EN-US\";\n\n        if (m_locLang.equals (\"\")) m_locLang = \"ES\";\n\n    }\n    m_browseTarget = 0;\n    m_messageLabel = new JLabel ();\n    Box bMes = Box.createHorizontalBox ();\n    bMes.add (m_messageLabel);\n    bMes.add (Box.createHorizontalGlue ());\n    m_srcRootLabel = new JLabel ();\n    Box bSrc = Box.createHorizontalBox ();\n    bSrc.add (m_srcRootLabel);\n    bSrc.add (Box.createHorizontalGlue ());\n    m_srcBrowse = new JButton ();\n    bSrc.add (m_srcBrowse);\n    m_srcRootField = new JTextField ();\n    m_srcRootField.setEditable (false);\n    m_locRootLabel = new JLabel ();\n    Box bLoc = Box.createHorizontalBox ();\n    bLoc.add (m_locRootLabel);\n    bLoc.add (Box.createHorizontalGlue ());\n    m_locBrowse = new JButton ();\n    bLoc.add (m_locBrowse);\n    m_locRootField = new JTextField ();\n    m_locRootField.setEditable (false);\n    m_glosRootLabel = new JLabel ();\n    Box bGlos = Box.createHorizontalBox ();\n    bGlos.add (m_glosRootLabel);\n    bGlos.add (Box.createHorizontalGlue ());\n    m_glosBrowse = new JButton ();\n    bGlos.add (m_glosBrowse);\n    m_glosRootField = new JTextField ();\n    m_glosRootField.setEditable (false);\n    m_tmRootLabel = new JLabel ();\n    Box bTM = Box.createHorizontalBox ();\n    bTM.add (m_tmRootLabel);\n    bTM.add (Box.createHorizontalGlue ());\n    m_tmBrowse = new JButton ();\n    bTM.add (m_tmBrowse);\n    m_tmRootField = new JTextField ();\n    m_tmRootField.setEditable (false);\n    m_srcLangLabel = new JLabel ();\n    Box bSL = Box.createHorizontalBox ();\n    bSL.add (m_srcLangLabel);\n    bSL.add (Box.createHorizontalGlue ());\n    m_srcLangField = new JTextField ();\n    m_srcLangField.setText (m_srcLang);\n    m_locLangLabel = new JLabel ();\n    Box bLL = Box.createHorizontalBox ();\n    bLL.add (m_locLangLabel);\n    bLL.add (Box.createHorizontalGlue ());\n    m_locLangField = new JTextField ();\n    m_locLangField.setText (m_locLang);\n    m_okButton = new JButton ();\n    m_cancelButton = new JButton ();\n    Box b = Box.createVerticalBox ();\n    b.add (bMes);\n    b.add (bSrc);\n    b.add (m_srcRootField);\n    b.add (bLoc);\n    b.add (m_locRootField);\n    b.add (bGlos);\n    b.add (m_glosRootField);\n    b.add (bTM);\n    b.add (m_tmRootField);\n    b.add (bSL);\n    b.add (m_srcLangField);\n    b.add (bLL);\n    b.add (m_locLangField);\n    getContentPane ().add (b, \"North\");\n    Box b2 = Box.createHorizontalBox ();\n    b2.add (Box.createHorizontalGlue ());\n    b2.add (m_cancelButton);\n    b2.add (Box.createHorizontalStrut (5));\n    b2.add (m_okButton);\n    getContentPane ().add (b2, \"South\");\n    m_okButton.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            doOK ();\n        }}\n\n    );\n    m_cancelButton.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            doCancel ();\n        }}\n\n    );\n    m_srcBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 1;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    m_locBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 2;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    m_glosBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 3;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    m_tmBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 4;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    if (projFileName == null) {\n        NewDirectoryChooser ndc = new NewDirectoryChooser ();\n        String label;\n        label = OStrings.PP_SAVE_PROJECT_FILE;\n        ndc.setDialogTitle (label);\n        String curDir = CommandThread.core.getPreference (OConsts.PREF_CUR_DIR);\n        if (curDir != null) {\n            File dir = new File (curDir);\n            if (dir.exists () && dir.isDirectory ()) {\n                ndc.setCurrentDirectory (dir);\n            }\n        }\n        int val = ndc.showSaveDialog (this);\n        if (val != JFileChooser.APPROVE_OPTION) {\n            m_dialogCancelled = true;\n            return;\n        }\n        m_projRoot = ndc.getSelectedFile ().getAbsolutePath () + File.separator;\n        m_projFile = m_projRoot + OConsts.PROJ_FILENAME;\n        CommandThread.core.setPreference (OConsts.PREF_CUR_DIR, ndc.getSelectedFile ().getParent ());\n        m_projName = m_projFile.substring (m_projRoot.length ());\n        m_srcRoot = m_projRoot + OConsts.DEFAULT_SRC + File.separator;\n        m_locRoot = m_projRoot + OConsts.DEFAULT_LOC + File.separator;\n        m_glosRoot = m_projRoot + OConsts.DEFAULT_GLOS + File.separator;\n        m_tmRoot = m_projRoot + OConsts.DEFAULT_TM + File.separator;\n    } else {\n        m_projFile = projFileName;\n        m_projRoot = m_projFile.substring (0, m_projFile.lastIndexOf (File.separator));\n    }\n    m_projInternal = m_projRoot + OConsts.DEFAULT_INTERNAL + File.separator;\n    m_srcRootField.setText (m_srcRoot);\n    m_locRootField.setText (m_locRoot);\n    m_glosRootField.setText (m_glosRoot);\n    m_tmRootField.setText (m_tmRoot);\n    m_srcLangField.setText (m_srcLang);\n    m_locLangField.setText (m_locLang);\n    updateUIText ();\n}\n", "code2": "public MNewProject (JFrame par, String projFileName, int msg) {\n    super (par, true);\n    m_dialogOK = false;\n    setSize (650, 500);\n    if (projFileName == null) reset ();\n\n    m_message = msg;\n    if (projFileName == null) {\n        m_srcLang = CommandThread.core.getPreference (OConsts.PREF_SRCLANG);\n        m_locLang = CommandThread.core.getPreference (OConsts.PREF_LOCLANG);\n        if (m_srcLang.equals (\"\")) m_srcLang = \"EN-US\";\n\n        if (m_locLang.equals (\"\")) m_locLang = \"ES\";\n\n    }\n    m_browseTarget = 0;\n    m_messageLabel = new JLabel ();\n    Box bMes = Box.createHorizontalBox ();\n    bMes.add (m_messageLabel);\n    bMes.add (Box.createHorizontalGlue ());\n    m_srcRootLabel = new JLabel ();\n    Box bSrc = Box.createHorizontalBox ();\n    bSrc.add (m_srcRootLabel);\n    bSrc.add (Box.createHorizontalGlue ());\n    m_srcBrowse = new JButton ();\n    bSrc.add (m_srcBrowse);\n    m_srcRootField = new JTextField ();\n    m_srcRootField.setEditable (false);\n    m_locRootLabel = new JLabel ();\n    Box bLoc = Box.createHorizontalBox ();\n    bLoc.add (m_locRootLabel);\n    bLoc.add (Box.createHorizontalGlue ());\n    m_locBrowse = new JButton ();\n    bLoc.add (m_locBrowse);\n    m_locRootField = new JTextField ();\n    m_locRootField.setEditable (false);\n    m_glosRootLabel = new JLabel ();\n    Box bGlos = Box.createHorizontalBox ();\n    bGlos.add (m_glosRootLabel);\n    bGlos.add (Box.createHorizontalGlue ());\n    m_glosBrowse = new JButton ();\n    bGlos.add (m_glosBrowse);\n    m_glosRootField = new JTextField ();\n    m_glosRootField.setEditable (false);\n    m_tmRootLabel = new JLabel ();\n    Box bTM = Box.createHorizontalBox ();\n    bTM.add (m_tmRootLabel);\n    bTM.add (Box.createHorizontalGlue ());\n    m_tmBrowse = new JButton ();\n    bTM.add (m_tmBrowse);\n    m_tmRootField = new JTextField ();\n    m_tmRootField.setEditable (false);\n    m_srcLangLabel = new JLabel ();\n    Box bSL = Box.createHorizontalBox ();\n    bSL.add (m_srcLangLabel);\n    bSL.add (Box.createHorizontalGlue ());\n    m_srcLangField = new JTextField ();\n    m_srcLangField.setText (m_srcLang);\n    m_locLangLabel = new JLabel ();\n    Box bLL = Box.createHorizontalBox ();\n    bLL.add (m_locLangLabel);\n    bLL.add (Box.createHorizontalGlue ());\n    m_locLangField = new JTextField ();\n    m_locLangField.setText (m_locLang);\n    m_okButton = new JButton ();\n    m_cancelButton = new JButton ();\n    Box b = Box.createVerticalBox ();\n    b.add (bMes);\n    b.add (bSrc);\n    b.add (m_srcRootField);\n    b.add (bLoc);\n    b.add (m_locRootField);\n    b.add (bGlos);\n    b.add (m_glosRootField);\n    b.add (bTM);\n    b.add (m_tmRootField);\n    b.add (bSL);\n    b.add (m_srcLangField);\n    b.add (bLL);\n    b.add (m_locLangField);\n    getContentPane ().add (b, \"North\");\n    Box b2 = Box.createHorizontalBox ();\n    b2.add (Box.createHorizontalGlue ());\n    b2.add (m_cancelButton);\n    b2.add (Box.createHorizontalStrut (5));\n    b2.add (m_okButton);\n    getContentPane ().add (b2, \"South\");\n    m_okButton.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            doOK ();\n        }}\n\n    );\n    m_cancelButton.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            doCancel ();\n        }}\n\n    );\n    m_srcBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 1;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    m_locBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 2;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    m_glosBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 3;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    m_tmBrowse.addActionListener (new ActionListener () {\n        public void actionPerformed (ActionEvent e) {\n            m_browseTarget = 4;\n            doBrowseDirectoy ();\n        }}\n\n    );\n    if (projFileName == null) {\n        NewDirectoryChooser ndc = new NewDirectoryChooser ();\n        String label;\n        label = OStrings.PP_SAVE_PROJECT_FILE;\n        ndc.setDialogTitle (label);\n        String curDir = CommandThread.core.getPreference (OConsts.PREF_CUR_DIR);\n        if (curDir != null) {\n            File dir = new File (curDir);\n            if (dir.exists () && dir.isDirectory ()) {\n                ndc.setCurrentDirectory (dir);\n            }\n        }\n        int val = ndc.showSaveDialog (this);\n        if (val != JFileChooser.APPROVE_OPTION) {\n            m_dialogCancelled = true;\n            return;\n        }\n        m_projRoot = ndc.getSelectedFile ().getAbsolutePath () + File.separator;\n        m_projFile = m_projRoot + OConsts.PROJ_FILENAME;\n        CommandThread.core.setPreference (OConsts.PREF_CUR_DIR, ndc.getSelectedFile ().getParent ());\n        m_projName = m_projFile.substring (m_projRoot.length ());\n        m_srcRoot = m_projRoot + OConsts.DEFAULT_SRC + File.separator;\n        m_locRoot = m_projRoot + OConsts.DEFAULT_LOC + File.separator;\n        m_glosRoot = m_projRoot + OConsts.DEFAULT_GLOS + File.separator;\n        m_tmRoot = m_projRoot + OConsts.DEFAULT_TM + File.separator;\n    } else {\n        m_projFile = projFileName;\n        m_projRoot = m_projFile.substring (0, m_projFile.lastIndexOf (File.separator));\n    }\n    m_projInternal = m_projRoot + OConsts.DEFAULT_INTERNAL + File.separator;\n    m_srcRootField.setText (m_srcRoot);\n    m_locRootField.setText (m_locRoot);\n    m_glosRootField.setText (m_glosRoot);\n    m_tmRootField.setText (m_tmRoot);\n    m_srcLangField.setText (m_srcLang);\n    m_locLangField.setText (m_locLang);\n    updateUIText ();\n}\n"}
{"clone_type": "T1", "method1_id": 871396, "method2_id": 920875, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 7761, "method2_id": 259443, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 640609, "method2_id": 689532, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 125352, "method2_id": 264478, "code1": "private void addAdditional2 (Message response, int section) {\n    Enumeration e = response.getSection (section);\n    while (e.hasMoreElements ()) {\n        Record r = (Record) e.nextElement ();\n        try {\n            Method m = r.getClass ().getMethod (\"getTarget\", null);\n            Name glueName = (Name) m.invoke (r, null);\n            addGlue (response, glueName);\n        } catch (Exception ex) {\n        }\n    }\n}\n", "code2": "private void addAdditional2 (Message response, int section) {\n    Enumeration e = response.getSection (section);\n    while (e.hasMoreElements ()) {\n        Record r = (Record) e.nextElement ();\n        try {\n            Method m = r.getClass ().getMethod (\"getTarget\", null);\n            Name glueName = (Name) m.invoke (r, null);\n            addGlue (response, glueName);\n        } catch (Exception ex) {\n        }\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 230246, "method2_id": 351290, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 472008, "method2_id": 726934, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "T1", "method1_id": 689531, "method2_id": 910478, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 5994, "method2_id": 454472, "code1": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n", "code2": "public void run () {\n    try {\n        charsExpected = 10000 * (testData [0].length () + testData [1].length ());\n        String fileName = \"/tmp/out\" + myNumber;\n        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File (\"/tmp\"));\n        Thread writer = new Thread () {\n            public void run () {\n                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            charsWritten += testData [i].length ();\n                            stdin.writeUTF (testData [i]);\n                        }\n                    }\n                    stdin.flush ();\n                    stdin.close ();\n                } catch (IOException e) {\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        Thread reader = new Thread () {\n            public void run () {\n                DataInputStream stdout = new DataInputStream (tac.getInputStream ());\n                try {\n                    for (int x = 0;\n                    x < 10000; x ++) {\n                        for (int i = 0;\n                        i < testData.length; i ++) {\n                            String in = stdout.readUTF ();\n                            charsRead += in.length ();\n                            if (! in.equals (testData [i])) throw new Error (\"TestRuntimeExec FAILED: bad input \" + in);\n\n                        }\n                    }\n                    int exitCode = tac.waitFor ();\n                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println (\"TestRuntimeExec SUCCESS\");\n                    else System.err.println (\"TestRuntimeExec FAILED\");\n\n                } catch (Throwable e) {\n                    e.printStackTrace ();\n                    throw new Error (\"TestRuntimeExec FAILED\");\n                }\n            }}\n\n        ;\n        writer.start ();\n        reader.start ();\n        final Thread waiter = new Thread () {\n            public void run () {\n                try {\n                    int exitCode = tac.waitFor ();\n                    System.out.println (\"waitFor(): Process exited with code \" + exitCode);\n                } catch (InterruptedException e) {\n                    if (! interruptWait) {\n                        System.out.println (\"Waiting thread uninterrupted unexpectedly!!!\");\n                        System.out.println (\"TestRuntimeExec FAILED\");\n                        System.exit (1);\n                    }\n                    System.out.println (\"Waiting thread interrupted! (THIS IS GOOD)\");\n                    e.printStackTrace ();\n                }\n            }}\n\n        ;\n        waiter.start ();\n        if (interruptWait) {\n            new Thread () {\n                public void run () {\n                    try {\n                        Thread.sleep (2000);\n                    } catch (Exception e) {\n                    }\n                    waiter.interrupt ();\n                }}\n\n            .start ();\n        }\n        Thread poller = new Thread () {\n            public void run () {\n                int exitCode = - 99;\n                boolean exited = false;\n                do {\n                    try {\n                        exitCode = tac.exitValue ();\n                        exited = true;\n                    } catch (IllegalThreadStateException e) {\n                        System.out.println (\"still alive!\");\n                        try {\n                            Thread.sleep (1000);\n                        } catch (Exception ee) {\n                        }\n                    }\n                } while (! exited);\n                System.out.println (\"exitValue(): Process exited with code \" + exitCode);\n            }}\n\n        ;\n        poller.start ();\n        try {\n            reader.join ();\n            writer.join ();\n            waiter.join ();\n            poller.join ();\n        } catch (InterruptedException eee) {\n            eee.printStackTrace ();\n        }\n    } catch (Throwable e) {\n        System.err.println (\"TestRuntimeExec FAILED with\");\n        e.printStackTrace ();\n        System.exit (1);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 258731, "method2_id": 313606, "code1": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n", "code2": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 120777, "method2_id": 279854, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 670345, "method2_id": 714206, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 708766, "method2_id": 777609, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 211685, "method2_id": 224087, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 111977, "method2_id": 881838, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 45091, "method2_id": 298973, "code1": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n", "code2": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n"}
{"clone_type": "T1", "method1_id": 93125, "method2_id": 278371, "code1": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n", "code2": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n"}
{"clone_type": "T1", "method1_id": 50947, "method2_id": 67188, "code1": "public LiferaySQL (String sql) {\n    System.out.println (sql);\n    Connection con = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    try {\n        Properties props = new Properties ();\n        try {\n            props.load (new FileInputStream (new File (\"db.properties\")));\n        } catch (IOException ioe) {\n            ioe.printStackTrace ();\n            return;\n        }\n        String driver = props.getProperty (\"driver\");\n        String url = props.getProperty (\"url\");\n        String user = props.getProperty (\"user\");\n        String password = props.getProperty (\"password\");\n        Class.forName (driver);\n        con = DriverManager.getConnection (url, user, password);\n        con.setAutoCommit (false);\n        File sqlFile = new File (sql);\n        if (sqlFile.exists ()) {\n            StringBuffer sb = new StringBuffer ();\n            BufferedReader br = new BufferedReader (new FileReader (sqlFile));\n            String line = null;\n            while ((line = br.readLine ()) != null) {\n                if (! line.startsWith (\"--\")) {\n                    sb.append (line);\n                }\n            }\n            br.close ();\n            StringTokenizer st = new StringTokenizer (sb.toString (), \";\");\n            while (st.hasMoreTokens ()) {\n                line = st.nextToken ();\n                System.out.println (line + \";\");\n                ps = con.prepareStatement (line);\n                ps.executeUpdate ();\n            }\n        } else if (sql.toLowerCase ().startsWith (\"insert \") || sql.toLowerCase ().startsWith (\"update \")) {\n            ps = con.prepareStatement (sql);\n            ps.executeUpdate (sql);\n        } else {\n            ps = con.prepareStatement (sql);\n            rs = ps.executeQuery (sql);\n            ResultSetMetaData rsmd = rs.getMetaData ();\n            int [] width = new int [rsmd.getColumnCount () + 1];\n            StringBuffer sb = new StringBuffer ();\n            for (int i = 1;\n            i <= rsmd.getColumnCount (); i ++) {\n                width [i] = rsmd.getColumnLabel (i).length ();\n            }\n            List results = new ArrayList ();\n            while (rs.next ()) {\n                String [] rowResult = new String [rsmd.getColumnCount () + 1];\n                for (int i = 1;\n                i <= rsmd.getColumnCount (); i ++) {\n                    Object obj = rs.getObject (i);\n                    if (obj != null) {\n                        rowResult [i] = obj.toString ();\n                        int objWidth = obj.toString ().length ();\n                        if (width [i] < objWidth) {\n                            width [i] = objWidth;\n                        }\n                    } else {\n                        rowResult [i] = \"\";\n                    }\n                }\n                results.add (rowResult);\n            }\n            _printLine (rsmd, width, sb);\n            for (int i = 1;\n            i <= rsmd.getColumnCount (); i ++) {\n                String label = rsmd.getColumnLabel (i);\n                sb.append (\"| \").append (label);\n                for (int j = 0;\n                j <= width [i] - label.length (); j ++) {\n                    sb.append (\" \");\n                }\n            }\n            sb.append (\"|\\n\");\n            _printLine (rsmd, width, sb);\n            Iterator itr = results.iterator ();\n            while (itr.hasNext ()) {\n                String [] rowResult = (String []) itr.next ();\n                for (int i = 1;\n                i <= rsmd.getColumnCount (); i ++) {\n                    String s = rowResult [i];\n                    sb.append (\"| \").append (s);\n                    for (int j = 0;\n                    j <= width [i] - s.length (); j ++) {\n                        sb.append (\" \");\n                    }\n                }\n                sb.append (\"|\\n\");\n            }\n            _printLine (rsmd, width, sb);\n            System.out.println (sb.toString ());\n        }\n\n        con.commit ();\n    } catch (SQLException sqle) {\n        while (sqle != null) {\n            sqle.printStackTrace ();\n            sqle = sqle.getNextException ();\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    } finally {\n        _cleanUp (con, ps, rs);\n    }\n}\n", "code2": "public LiferaySQL (String sql) {\n    System.out.println (sql);\n    Connection con = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    try {\n        Properties props = new Properties ();\n        try {\n            props.load (new FileInputStream (new File (\"db.properties\")));\n        } catch (IOException ioe) {\n            ioe.printStackTrace ();\n            return;\n        }\n        String driver = props.getProperty (\"driver\");\n        String url = props.getProperty (\"url\");\n        String user = props.getProperty (\"user\");\n        String password = props.getProperty (\"password\");\n        Class.forName (driver);\n        con = DriverManager.getConnection (url, user, password);\n        con.setAutoCommit (false);\n        File sqlFile = new File (sql);\n        if (sqlFile.exists ()) {\n            StringBuffer sb = new StringBuffer ();\n            BufferedReader br = new BufferedReader (new FileReader (sqlFile));\n            String line = null;\n            while ((line = br.readLine ()) != null) {\n                if (! line.startsWith (\"--\")) {\n                    sb.append (line);\n                }\n            }\n            br.close ();\n            StringTokenizer st = new StringTokenizer (sb.toString (), \";\");\n            while (st.hasMoreTokens ()) {\n                line = st.nextToken ();\n                System.out.println (line + \";\");\n                ps = con.prepareStatement (line);\n                ps.executeUpdate ();\n            }\n        } else if (sql.toLowerCase ().startsWith (\"insert \") || sql.toLowerCase ().startsWith (\"update \")) {\n            ps = con.prepareStatement (sql);\n            ps.executeUpdate (sql);\n        } else {\n            ps = con.prepareStatement (sql);\n            rs = ps.executeQuery (sql);\n            ResultSetMetaData rsmd = rs.getMetaData ();\n            int [] width = new int [rsmd.getColumnCount () + 1];\n            StringBuffer sb = new StringBuffer ();\n            for (int i = 1;\n            i <= rsmd.getColumnCount (); i ++) {\n                width [i] = rsmd.getColumnLabel (i).length ();\n            }\n            List results = new ArrayList ();\n            while (rs.next ()) {\n                String [] rowResult = new String [rsmd.getColumnCount () + 1];\n                for (int i = 1;\n                i <= rsmd.getColumnCount (); i ++) {\n                    Object obj = rs.getObject (i);\n                    if (obj != null) {\n                        rowResult [i] = obj.toString ();\n                        int objWidth = obj.toString ().length ();\n                        if (width [i] < objWidth) {\n                            width [i] = objWidth;\n                        }\n                    } else {\n                        rowResult [i] = \"\";\n                    }\n                }\n                results.add (rowResult);\n            }\n            _printLine (rsmd, width, sb);\n            for (int i = 1;\n            i <= rsmd.getColumnCount (); i ++) {\n                String label = rsmd.getColumnLabel (i);\n                sb.append (\"| \").append (label);\n                for (int j = 0;\n                j <= width [i] - label.length (); j ++) {\n                    sb.append (\" \");\n                }\n            }\n            sb.append (\"|\\n\");\n            _printLine (rsmd, width, sb);\n            Iterator itr = results.iterator ();\n            while (itr.hasNext ()) {\n                String [] rowResult = (String []) itr.next ();\n                for (int i = 1;\n                i <= rsmd.getColumnCount (); i ++) {\n                    String s = rowResult [i];\n                    sb.append (\"| \").append (s);\n                    for (int j = 0;\n                    j <= width [i] - s.length (); j ++) {\n                        sb.append (\" \");\n                    }\n                }\n                sb.append (\"|\\n\");\n            }\n            _printLine (rsmd, width, sb);\n            System.out.println (sb.toString ());\n        }\n\n        con.commit ();\n    } catch (SQLException sqle) {\n        while (sqle != null) {\n            sqle.printStackTrace ();\n            sqle = sqle.getNextException ();\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    } finally {\n        _cleanUp (con, ps, rs);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 4623013, "method2_id": 7760801, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "T1", "method1_id": 76427, "method2_id": 506382, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n"}
{"clone_type": "T1", "method1_id": 370547, "method2_id": 821503, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 727183, "method2_id": 820872, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 281237, "method2_id": 305472, "code1": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "T1", "method1_id": 126187, "method2_id": 258490, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 370982, "method2_id": 636262, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 181591, "method2_id": 778641, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 7760, "method2_id": 748153, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 311165, "method2_id": 353067, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 520192, "method2_id": 946510, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 131705, "method2_id": 511030, "code1": "public static void main (String args []) {\n    if (args.length != 2) {\n        String u = \"Usage: java -cp . UpgradeRomizedProperties <infile> <outfile>\";\n        System.out.println (u);\n        System.exit (0);\n    }\n    Runtime rt = Runtime.getRuntime ();\n    String cmd = \"javac -d \" + System.getProperty (\"user.dir\") + \" \" + args [0];\n    int exitCode;\n    try {\n        Process p = rt.exec (cmd);\n        exitCode = p.waitFor ();\n    } catch (Exception e) {\n        System.err.println (e);\n        System.exit (1);\n    }\n    Hashtable rp = new Hashtable ();\n    Object [] argz = {rp};\n    try {\n        String cn = \"com.sun.midp.chameleon.skins.resources.RomizedProperties\";\n        Class clazz = Class.forName (cn);\n        Method loadProperties;\n        loadProperties = clazz.getMethod (\"load\", new Class [] {Hashtable.class});\n        loadProperties.invoke (null, argz);\n    } catch (Exception e) {\n        System.err.println (e);\n        System.exit (1);\n    }\n    Converter converter = new Converter (SkinProperty.properties, rp);\n    converter.convert ();\n    try {\n        FileOutputStream fout = new FileOutputStream (args [1]);\n        OutputStreamWriter w = new OutputStreamWriter (fout);\n        writer = new PrintWriter (w);\n    } catch (Exception e) {\n        System.err.println (e);\n        System.exit (1);\n    }\n    printHeader ();\n    printSkinProperties ();\n    printFooter ();\n    writer.close ();\n    reportUnknownProperties (converter.unknownProps);\n    reportMissingProperties (converter.missingProps);\n}\n", "code2": "public static void main (String args []) {\n    if (args.length != 2) {\n        String u = \"Usage: java -cp . UpgradeRomizedProperties <infile> <outfile>\";\n        System.out.println (u);\n        System.exit (0);\n    }\n    Runtime rt = Runtime.getRuntime ();\n    String cmd = \"javac -d \" + System.getProperty (\"user.dir\") + \" \" + args [0];\n    int exitCode;\n    try {\n        Process p = rt.exec (cmd);\n        exitCode = p.waitFor ();\n    } catch (Exception e) {\n        System.err.println (e);\n        System.exit (1);\n    }\n    Hashtable rp = new Hashtable ();\n    Object [] argz = {rp};\n    try {\n        String cn = \"com.sun.midp.chameleon.skins.resources.RomizedProperties\";\n        Class clazz = Class.forName (cn);\n        Method loadProperties;\n        loadProperties = clazz.getMethod (\"load\", new Class [] {Hashtable.class});\n        loadProperties.invoke (null, argz);\n    } catch (Exception e) {\n        System.err.println (e);\n        System.exit (1);\n    }\n    Converter converter = new Converter (SkinProperty.properties, rp);\n    converter.convert ();\n    try {\n        FileOutputStream fout = new FileOutputStream (args [1]);\n        OutputStreamWriter w = new OutputStreamWriter (fout);\n        writer = new PrintWriter (w);\n    } catch (Exception e) {\n        System.err.println (e);\n        System.exit (1);\n    }\n    printHeader ();\n    printSkinProperties ();\n    printFooter ();\n    writer.close ();\n    reportUnknownProperties (converter.unknownProps);\n    reportMissingProperties (converter.missingProps);\n}\n"}
{"clone_type": "T1", "method1_id": 387353, "method2_id": 452268, "code1": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n", "code2": "public static void main (String [] args) {\n    try {\n        String jar = \"./test340.jar\";\n        URLClassLoader theLoader = new URLClassLoader (new URL [] {new URL (\"file:\" + jar)});\n        Object theLoadedClass = Class.forName (\"test340c\", true, theLoader).newInstance ();\n        String [] array = new String [] {};\n        Method main = theLoadedClass.getClass ().getMethod (\"main\", new Class [] {array.getClass ()});\n        main.invoke (theLoadedClass, new Object [] {new String [] {}});\n    } catch (Throwable t) {\n        System.exit (42);\n    }\n    System.exit (43);\n}\n"}
{"clone_type": "T1", "method1_id": 689531, "method2_id": 821502, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 164142, "method2_id": 189496, "code1": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n", "code2": "public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {\n    this.applet = applet;\n    if (applet == null) {\n        frame = new JFrame (gc);\n        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);\n    }\n    setLayout (new BorderLayout ());\n    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));\n    Action openAction = new AbstractAction (\"Open File\", new ImageIcon (getClass ().getResource (\"/open.gif\"))) {\n        public void actionPerformed (ActionEvent e) {\n            if (filechooser == null) {\n                filechooser = new JFileChooser ();\n                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n            }\n            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n                open (filechooser.getSelectedFile ());\n            }\n        }}\n\n    ;\n    JToolBar bar = new JToolBar ();\n    bar.add (new ToolBarButton (openAction));\n    add (bar, BorderLayout.NORTH);\n    if (applet == null) {\n        frame.setTitle (\"Image Display - Control Panel\");\n        frame.getContentPane ().add (this, BorderLayout.CENTER);\n        frame.pack ();\n        frame.show ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 79780, "method2_id": 335711, "code1": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n", "code2": "public void actionPerformed (ActionEvent e) {\n    if (filechooser == null) {\n        filechooser = new JFileChooser ();\n        filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    }\n    if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {\n        open (filechooser.getSelectedFile ());\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 223631, "method2_id": 916271, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 46158, "method2_id": 850680, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 137780, "method2_id": 665978, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 230700, "method2_id": 514648, "code1": "public static void main (String [] args) {\n    final String version = System.getProperty (\"java.version\");\n    if (version.startsWith (\"1.0\") || version.startsWith (\"1.1\") || version.startsWith (\"1.2\") || version.startsWith (\"1.3\")) {\n        System.err.println (\"\");\n        System.err.print (\"J requires Java 1.4 or later.\");\n        System.err.println (\" (Java 1.4.2 is recommended.)\");\n        System.err.println (\"\");\n        System.exit (1);\n    }\n    try {\n        Class c = Class.forName (\"org.armedbear.j.Editor\");\n        Class [] parameterTypes = new Class [1];\n        parameterTypes [0] = String [].class;\n        Method method = c.getMethod (\"main\", parameterTypes);\n        Object [] parameters = new Object [1];\n        parameters [0] = args;\n        method.invoke (null, parameters);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static void main (String [] args) {\n    final String version = System.getProperty (\"java.version\");\n    if (version.startsWith (\"1.0\") || version.startsWith (\"1.1\") || version.startsWith (\"1.2\") || version.startsWith (\"1.3\")) {\n        System.err.println (\"\");\n        System.err.print (\"J requires Java 1.4 or later.\");\n        System.err.println (\" (Java 1.4.2 is recommended.)\");\n        System.err.println (\"\");\n        System.exit (1);\n    }\n    try {\n        Class c = Class.forName (\"org.armedbear.j.Editor\");\n        Class [] parameterTypes = new Class [1];\n        parameterTypes [0] = String [].class;\n        Method method = c.getMethod (\"main\", parameterTypes);\n        Object [] parameters = new Object [1];\n        parameters [0] = args;\n        method.invoke (null, parameters);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 286788, "method2_id": 946510, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 7667, "method2_id": 709767, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 470160, "method2_id": 822452, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "T1", "method1_id": 211684, "method2_id": 741288, "code1": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n", "code2": "public static boolean isPalindrome (String string) {\n    if (string.length () == 0) return true;\n\n    int limit = string.length () / 2;\n    for (int forward = 0, backward = string.length () - 1;\n    forward < limit; forward ++, backward --) if (string.charAt (forward) != string.charAt (backward)) return false;\n\n    return true;\n}\n"}
{"clone_type": "T1", "method1_id": 890509, "method2_id": 939749, "code1": "public static void main (String [] args) {\n    if (args.length != 4) {\n        usage ();\n        System.exit (1);\n    }\n    System.out.println ();\n    String to = args [0];\n    String from = args [1];\n    String host = args [2];\n    boolean debug = Boolean.valueOf (args [3]).booleanValue ();\n    Properties props = new Properties ();\n    props.put (\"mail.smtp.host\", host);\n    if (debug) props.put (\"mail.debug\", args [3]);\n\n    Session session = Session.getInstance (props, null);\n    session.setDebug (debug);\n    try {\n        Message msg = new MimeMessage (session);\n        msg.setFrom (new InternetAddress (from));\n        InternetAddress [] address = {new InternetAddress (args [0])};\n        msg.setRecipients (Message.RecipientType.TO, address);\n        msg.setSubject (\"JavaMail APIs Test\");\n        msg.setSentDate (new Date ());\n        msg.setText (msgText);\n        Transport.send (msg);\n    } catch (MessagingException mex) {\n        System.out.println (\"\\n--Exception handling in msgsendsample.java\");\n        mex.printStackTrace ();\n        System.out.println ();\n        Exception ex = mex;\n        do {\n            if (ex instanceof SendFailedException) {\n                SendFailedException sfex = (SendFailedException) ex;\n                Address [] invalid = sfex.getInvalidAddresses ();\n                if (invalid != null) {\n                    System.out.println (\"    ** Invalid Addresses\");\n                    if (invalid != null) {\n                        for (int i = 0;\n                        i < invalid.length; i ++) System.out.println (\"         \" + invalid [i]);\n\n                    }\n                }\n                Address [] validUnsent = sfex.getValidUnsentAddresses ();\n                if (validUnsent != null) {\n                    System.out.println (\"    ** ValidUnsent Addresses\");\n                    if (validUnsent != null) {\n                        for (int i = 0;\n                        i < validUnsent.length; i ++) System.out.println (\"         \" + validUnsent [i]);\n\n                    }\n                }\n                Address [] validSent = sfex.getValidSentAddresses ();\n                if (validSent != null) {\n                    System.out.println (\"    ** ValidSent Addresses\");\n                    if (validSent != null) {\n                        for (int i = 0;\n                        i < validSent.length; i ++) System.out.println (\"         \" + validSent [i]);\n\n                    }\n                }\n            }\n            System.out.println ();\n            if (ex instanceof MessagingException) ex = ((MessagingException) ex).getNextException ();\n            else ex = null;\n\n        } while (ex != null);\n    }\n}\n", "code2": "public static void main (String [] args) {\n    if (args.length != 4) {\n        usage ();\n        System.exit (1);\n    }\n    System.out.println ();\n    String to = args [0];\n    String from = args [1];\n    String host = args [2];\n    boolean debug = Boolean.valueOf (args [3]).booleanValue ();\n    Properties props = new Properties ();\n    props.put (\"mail.smtp.host\", host);\n    if (debug) props.put (\"mail.debug\", args [3]);\n\n    Session session = Session.getInstance (props, null);\n    session.setDebug (debug);\n    try {\n        Message msg = new MimeMessage (session);\n        msg.setFrom (new InternetAddress (from));\n        InternetAddress [] address = {new InternetAddress (args [0])};\n        msg.setRecipients (Message.RecipientType.TO, address);\n        msg.setSubject (\"JavaMail APIs Test\");\n        msg.setSentDate (new Date ());\n        msg.setText (msgText);\n        Transport.send (msg);\n    } catch (MessagingException mex) {\n        System.out.println (\"\\n--Exception handling in msgsendsample.java\");\n        mex.printStackTrace ();\n        System.out.println ();\n        Exception ex = mex;\n        do {\n            if (ex instanceof SendFailedException) {\n                SendFailedException sfex = (SendFailedException) ex;\n                Address [] invalid = sfex.getInvalidAddresses ();\n                if (invalid != null) {\n                    System.out.println (\"    ** Invalid Addresses\");\n                    if (invalid != null) {\n                        for (int i = 0;\n                        i < invalid.length; i ++) System.out.println (\"         \" + invalid [i]);\n\n                    }\n                }\n                Address [] validUnsent = sfex.getValidUnsentAddresses ();\n                if (validUnsent != null) {\n                    System.out.println (\"    ** ValidUnsent Addresses\");\n                    if (validUnsent != null) {\n                        for (int i = 0;\n                        i < validUnsent.length; i ++) System.out.println (\"         \" + validUnsent [i]);\n\n                    }\n                }\n                Address [] validSent = sfex.getValidSentAddresses ();\n                if (validSent != null) {\n                    System.out.println (\"    ** ValidSent Addresses\");\n                    if (validSent != null) {\n                        for (int i = 0;\n                        i < validSent.length; i ++) System.out.println (\"         \" + validSent [i]);\n\n                    }\n                }\n            }\n            System.out.println ();\n            if (ex instanceof MessagingException) ex = ((MessagingException) ex).getNextException ();\n            else ex = null;\n\n        } while (ex != null);\n    }\n}\n"}
{"clone_type": "T1", "method1_id": 6550, "method2_id": 56346, "code1": "public static void main (String [] args) throws Exception {\n    Class testClass = AllTests.class;\n    ArrayList < Method > setups = new ArrayList < Method > ();\n    ArrayList < Method > tearDowns = new ArrayList < Method > ();\n    for (Method method : testClass.getDeclaredMethods ()) {\n        int modifiers = method.getModifiers ();\n        if (Modifier.isPublic (modifiers) && ! Modifier.isStatic (modifiers) && method.getAnnotation (Ignore.class) == null) {\n            if (method.getAnnotation (Before.class) != null) {\n                setups.add (method);\n            }\n            if (method.getAnnotation (After.class) != null) {\n                setups.add (method);\n            }\n        }\n    }\n    System.out.println (\"Starting all tests.\");\n    Object instance = testClass.newInstance ();\n    for (Method method : testClass.getDeclaredMethods ()) {\n        int modifiers = method.getModifiers ();\n        if (Modifier.isPublic (modifiers) && ! Modifier.isStatic (modifiers) && method.getAnnotation (Ignore.class) == null) {\n            Test testAnnotation = method.getAnnotation (Test.class);\n            if (testAnnotation != null) {\n                for (Method setup : setups) {\n                    setup.invoke (instance, (Object []) null);\n                }\n                Class expectedException = testAnnotation.expected ();\n                if (expectedException.getName ().equals (\"org.junit.Test$None\")) {\n                    expectedException = null;\n                }\n                try {\n                    method.invoke (instance, (Object []) null);\n                } catch (Exception e) {\n                    if (expectedException == null) {\n                        System.out.println (testClass.getName () + \".\" + method.getName () + \": \" + e.getCause ().getMessage ());\n                        new BufferedReader (new InputStreamReader (System.in)).readLine ();\n                    } else {\n                        if (! e.getCause ().getClass ().equals (testAnnotation.expected ())) {\n                            System.out.println (testClass.getName () + \".\" + method.getName () + \": \" + \"Exception expected: \" + testAnnotation.expected ().getName () + \", Exception thrown: \" + e.getCause ().getMessage ());\n                            new BufferedReader (new InputStreamReader (System.in)).readLine ();\n                        }\n                        expectedException = null;\n                    }\n                }\n                if (expectedException != null) {\n                    System.out.println (testClass.getName () + \".\" + method.getName () + \": \" + \"Expected exception not thrown: \" + testAnnotation.expected ().getName ());\n                    new BufferedReader (new InputStreamReader (System.in)).readLine ();\n                }\n                for (Method tearDown : tearDowns) {\n                    tearDown.invoke (instance, (Object []) null);\n                }\n            }\n        }\n    }\n    System.out.println (\"Done with all tests.\");\n}\n", "code2": "public static void main (String [] args) throws Exception {\n    Class testClass = AllTests.class;\n    ArrayList < Method > setups = new ArrayList < Method > ();\n    ArrayList < Method > tearDowns = new ArrayList < Method > ();\n    for (Method method : testClass.getDeclaredMethods ()) {\n        int modifiers = method.getModifiers ();\n        if (Modifier.isPublic (modifiers) && ! Modifier.isStatic (modifiers) && method.getAnnotation (Ignore.class) == null) {\n            if (method.getAnnotation (Before.class) != null) {\n                setups.add (method);\n            }\n            if (method.getAnnotation (After.class) != null) {\n                setups.add (method);\n            }\n        }\n    }\n    System.out.println (\"Starting all tests.\");\n    Object instance = testClass.newInstance ();\n    for (Method method : testClass.getDeclaredMethods ()) {\n        int modifiers = method.getModifiers ();\n        if (Modifier.isPublic (modifiers) && ! Modifier.isStatic (modifiers) && method.getAnnotation (Ignore.class) == null) {\n            Test testAnnotation = method.getAnnotation (Test.class);\n            if (testAnnotation != null) {\n                for (Method setup : setups) {\n                    setup.invoke (instance, (Object []) null);\n                }\n                Class expectedException = testAnnotation.expected ();\n                if (expectedException.getName ().equals (\"org.junit.Test$None\")) {\n                    expectedException = null;\n                }\n                try {\n                    method.invoke (instance, (Object []) null);\n                } catch (Exception e) {\n                    if (expectedException == null) {\n                        System.out.println (testClass.getName () + \".\" + method.getName () + \": \" + e.getCause ().getMessage ());\n                        new BufferedReader (new InputStreamReader (System.in)).readLine ();\n                    } else {\n                        if (! e.getCause ().getClass ().equals (testAnnotation.expected ())) {\n                            System.out.println (testClass.getName () + \".\" + method.getName () + \": \" + \"Exception expected: \" + testAnnotation.expected ().getName () + \", Exception thrown: \" + e.getCause ().getMessage ());\n                            new BufferedReader (new InputStreamReader (System.in)).readLine ();\n                        }\n                        expectedException = null;\n                    }\n                }\n                if (expectedException != null) {\n                    System.out.println (testClass.getName () + \".\" + method.getName () + \": \" + \"Expected exception not thrown: \" + testAnnotation.expected ().getName ());\n                    new BufferedReader (new InputStreamReader (System.in)).readLine ();\n                }\n                for (Method tearDown : tearDowns) {\n                    tearDown.invoke (instance, (Object []) null);\n                }\n            }\n        }\n    }\n    System.out.println (\"Done with all tests.\");\n}\n"}
