{"clone_type": "WT3_T4", "method1_id": 489128, "method2_id": 541801, "code1": "public int fib (int n) {\n    if (n == 0 || n == 1) return n;\n    else return fib (n - 1) + fib (n - 2);\n\n}\n", "code2": "private int fib (int x) {\n    if (x == 0) return 0;\n\n    if (x == 1) return 1;\n\n    return fib (x - 1) + fib (x - 2);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10220823, "method2_id": 22556550, "code1": "@Test\npublic void testCopy () throws IOException {\n    final byte [] input = {0x00, 0x01, 0x7F, 0x03, 0x40};\n    final byte [] verification = input.clone ();\n    Assert.assertNotSame (\"Expecting verification to be a new array.\", input, verification);\n    final ByteArrayInputStream in = new ByteArrayInputStream (input);\n    final ByteArrayOutputStream out = new ByteArrayOutputStream ();\n    IOUtils.copy (in, out);\n    final byte [] output = out.toByteArray ();\n    Assert.assertTrue (\"Expecting input to be unchanged.\", Arrays.equals (verification, input));\n    Assert.assertTrue (\"Expecting output to be like input.\", Arrays.equals (verification, output));\n    Assert.assertNotSame (\"Expecting output to be a new array.\", input, output);\n    Assert.assertNotSame (\"Expecting output to be a new array.\", verification, output);\n}\n", "code2": "private void copyFiles (File oldFolder, File newFolder) {\n    for (File fileToCopy : oldFolder.listFiles ()) {\n        File copiedFile = new File (newFolder.getAbsolutePath () + \"\\\\\" + fileToCopy.getName ());\n        try {\n            FileInputStream source = new FileInputStream (fileToCopy);\n            FileOutputStream destination = new FileOutputStream (copiedFile);\n            FileChannel sourceFileChannel = source.getChannel ();\n            FileChannel destinationFileChannel = destination.getChannel ();\n            long size = sourceFileChannel.size ();\n            sourceFileChannel.transferTo (0, size, destinationFileChannel);\n            source.close ();\n            destination.close ();\n        } catch (Exception exc) {\n            exc.printStackTrace ();\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8702780, "method2_id": 9482315, "code1": "final void saveProject (Project project, final File file) {\n    if (projectsList.contains (project)) {\n        if (project.isDirty () || ! file.getParentFile ().equals (workspaceDirectory)) {\n            try {\n                if (! file.exists ()) {\n                    if (! file.createNewFile ()) throw new IOException (\"cannot create file \" + file.getAbsolutePath ());\n\n                }\n                File tmpFile = File.createTempFile (\"JFPSM\", \".tmp\");\n                ZipOutputStream zoStream = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (file)));\n                zoStream.setMethod (ZipOutputStream.DEFLATED);\n                ZipEntry projectXMLEntry = new ZipEntry (\"project.xml\");\n                projectXMLEntry.setMethod (ZipEntry.DEFLATED);\n                zoStream.putNextEntry (projectXMLEntry);\n                CustomXMLEncoder encoder = new CustomXMLEncoder (new BufferedOutputStream (new FileOutputStream (tmpFile)));\n                encoder.writeObject (project);\n                encoder.close ();\n                int bytesIn;\n                byte [] readBuffer = new byte [1024];\n                FileInputStream fis = new FileInputStream (tmpFile);\n                while ((bytesIn = fis.read (readBuffer)) != - 1) zoStream.write (readBuffer, 0, bytesIn);\n\n                fis.close ();\n                ZipEntry entry;\n                String floorDirectory;\n                for (FloorSet floorSet : project.getLevelSet ().getFloorSetsList ()) for (Floor floor : floorSet.getFloorsList ()) {\n                    floorDirectory = \"levelset/\" + floorSet.getName () + \"/\" + floor.getName () + \"/\";\n                    for (MapType type : MapType.values ()) {\n                        entry = new ZipEntry (floorDirectory + type.getFilename ());\n                        entry.setMethod (ZipEntry.DEFLATED);\n                        zoStream.putNextEntry (entry);\n                        ImageIO.write (floor.getMap (type).getImage (), \"png\", zoStream);\n                    }\n                }\n\n                final String tileDirectory = \"tileset/\";\n                for (Tile tile : project.getTileSet ().getTilesList ()) for (int textureIndex = 0;\n                textureIndex < tile.getMaxTextureCount (); textureIndex ++) if (tile.getTexture (textureIndex) != null) {\n                    entry = new ZipEntry (tileDirectory + tile.getName () + textureIndex + \".png\");\n                    entry.setMethod (ZipEntry.DEFLATED);\n                    zoStream.putNextEntry (entry);\n                    ImageIO.write (tile.getTexture (textureIndex), \"png\", zoStream);\n                }\n\n                zoStream.close ();\n                tmpFile.delete ();\n            } catch (IOException ioe) {\n                throw new RuntimeException (\"The project \" + project.getName () + \" cannot be saved!\", ioe);\n            }\n        }\n    } else throw new IllegalArgumentException (\"The project \" + project.getName () + \" is not handled by this project set!\");\n\n}\n", "code2": "public void sendStringToZipStream (String userbaseDir, String fileStr, String fileValueString, ZipOutputStream zipout) throws Exception {\n    if (! userbaseDir.endsWith (sep)) {\n        userbaseDir += sep;\n    }\n    BufferedInputStream in = null;\n    byte dataBuff [] = new byte [bufferSize];\n    String entryPath = fileStr;\n    in = new BufferedInputStream (new ByteArrayInputStream (fileValueString.getBytes ()), bufferSize);\n    ZipEntry zipEntry = new ZipEntry (entryPath);\n    zipout.putNextEntry (zipEntry);\n    int writeLen;\n    while ((writeLen = in.read (dataBuff)) > 0) {\n        zipout.write (dataBuff, 0, writeLen);\n    }\n    zipout.flush ();\n    zipout.closeEntry ();\n    in.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 5967901, "method2_id": 11130567, "code1": "public void run () {\n    try {\n        IOUtils.copy (in, out);\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static boolean copyFile (File sourceFile, File destFile) throws IOException {\n    long flag = 0;\n    if (! destFile.exists ()) destFile.createNewFile ();\n\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        flag = destination.transferFrom (source, 0, source.size ());\n    } catch (Exception e) {\n        Logger.getLogger (FileUtils.class.getPackage ().getName ()).log (Level.WARNING, \"ERROR: Problem copying file\", e);\n    } finally {\n        if (source != null) source.close ();\n\n        if (destination != null) destination.close ();\n\n    }\n    if (flag == 0) return false;\n    else return true;\n\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 687117, "method2_id": 9318114, "code1": "public boolean zipDir (String inputDirPath, String dir2zip, ZipOutputStream zos) {\n    try {\n        File zipDir = new File (inputDirPath);\n        String dirList [] = zipDir.list ();\n        byte readBuffer [] = new byte [2156];\n        int bytesIn = 0;\n        for (int i = 0;\n        i < dirList.length; i ++) {\n            File f = new File (zipDir, dirList [i]);\n            if (f.isDirectory ()) {\n                String fileDirPath = f.getPath ();\n                zipDir (fileDirPath, fileDirPath, zos);\n                continue;\n            }\n            FileInputStream fis = new FileInputStream (f);\n            String filePath = f.getPath ();\n            ZipEntry anEntry = new ZipEntry (filePath);\n            zos.putNextEntry (anEntry);\n            while ((bytesIn = fis.read (readBuffer)) != - 1) zos.write (readBuffer, 0, bytesIn);\n\n            fis.close ();\n        }\n        return (true);\n    } catch (Exception e) {\n        errMsgLog += \"Problem zipping to zip file '\" + dir2zip + \"' in zipDir() failed.\";\n        lastErrMsgLog = errMsgLog;\n        return (false);\n    }\n}\n", "code2": "private void writeClassFile (File zipFile, ZipOutputStream out, JAssembler asm) {\n    ClassDef def = asm.def;\n    Box box = asm.classFile;\n    String path = def.ns.replace ('.', '/') + '/' + def.name + \".class\";\n    try {\n        out.putNextEntry (new ZipEntry (path));\n        out.write (box.buf, 0, box.len);\n        out.closeEntry ();\n    } catch (IOException e) {\n        throw err (\"Cannot write zip entry \" + path, zipFile);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 606859, "method2_id": 17670291, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "public void createNewFile (String filePath, InputStream in) throws IOException {\n    FileOutputStream out = null;\n    try {\n        File file = newFileRef (filePath);\n        FileHelper.createNewFile (file, true);\n        out = new FileOutputStream (file);\n        IOUtils.copy (in, out);\n    } finally {\n        IOUtils.closeQuietly (in);\n        IOUtils.closeQuietly (out);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2424996, "method2_id": 18760096, "code1": "protected void migrateOnDemand () {\n    try {\n        if (fso.fileExists (prefix + \".fat\") && ! fso.fileExists (prefix + EXTENSIONS [UBM_FILE])) {\n            RandomAccessFile ubm, meta, ctr, rbm;\n            InputStream inputStream;\n            OutputStream outputStream;\n            fso.renameFile (prefix + \".fat\", prefix + EXTENSIONS [UBM_FILE]);\n            ubm = fso.openFile (prefix + EXTENSIONS [UBM_FILE], \"rw\");\n            meta = fso.openFile (prefix + EXTENSIONS [MTD_FILE], \"rw\");\n            ctr = fso.openFile (prefix + EXTENSIONS [CTR_FILE], \"rw\");\n            ubm.seek (ubm.length () - 16);\n            meta.writeInt (blockSize = ubm.readInt ());\n            meta.writeInt (size = ubm.readInt ());\n            ctr.setLength (ubm.readLong () + blockSize);\n            ctr.close ();\n            meta.close ();\n            ubm.setLength (ubm.length () - 16);\n            ubm.seek (0);\n            rbm = fso.openFile (prefix + EXTENSIONS [UBM_FILE], \"rw\");\n            inputStream = new BufferedInputStream (new RandomAccessFileInputStream (ubm));\n            outputStream = new BufferedOutputStream (new RandomAccessFileOutputStream (rbm));\n            for (int b;\n            (b = inputStream.read ()) != - 1;) outputStream.write (b);\n\n            outputStream.close ();\n            inputStream.close ();\n            rbm.close ();\n            ubm.close ();\n        }\n    } catch (IOException ie) {\n        throw new WrappingRuntimeException (ie);\n    }\n}\n", "code2": "protected String saveJar2TmpFile (String jarUrl, boolean reportError) {\n    InputStream is = null;\n    try {\n        URL url = new URL (jad.getJarURL ());\n        URLConnection conn = url.openConnection ();\n        if (url.getUserInfo () != null) {\n            String userInfo = new String (Base64Coder.encode (url.getUserInfo ().getBytes (\"UTF-8\")));\n            conn.setRequestProperty (\"Authorization\", \"Basic \" + userInfo);\n        }\n        is = conn.getInputStream ();\n        File tmpDir = null;\n        String systemTmpDir = MIDletSystemProperties.getSystemProperty (\"java.io.tmpdir\");\n        if (systemTmpDir != null) {\n            tmpDir = new File (systemTmpDir, \"microemulator-apps\");\n            if ((! tmpDir.exists ()) && (! tmpDir.mkdirs ())) {\n                tmpDir = null;\n            }\n        }\n        File tmp = File.createTempFile (\"me2-app-\", \".jar\", tmpDir);\n        tmp.deleteOnExit ();\n        IOUtils.copyToFile (is, tmp);\n        return IOUtils.getCanonicalFileClassLoaderURL (tmp);\n    } catch (IOException e) {\n        if (reportError) {\n            Message.error (\"Unable to open jar \" + jarUrl, e);\n        }\n        return null;\n    } finally {\n        IOUtils.closeQuietly (is);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 23069799, "method2_id": 23532405, "code1": "public static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "public void persist (FreeFormConfigurable ffConfigurable, String relativePath) {\n    File file = getConfigFile (ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n    InputStream is = ffConfigurable.getInputConfigStream ();\n    try {\n        OutputStream os = new FileOutputStream (file);\n        IOUtils.copy (is, os);\n    } catch (Exception e) {\n        throw new ConfigurationException (\"Failed to store free from config for class \" + ffConfigurable.getClass ().getName () + \" into file \" + file.getAbsolutePath ());\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6081622, "method2_id": 12820117, "code1": "public String encryptStringWithKey (String to_be_encrypted, String aKey) {\n    String encrypted_value = \"\";\n    char xdigit [] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n    MessageDigest messageDigest;\n    try {\n        messageDigest = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException exc) {\n        globalErrorDictionary.takeValueForKey ((\"Security package does not contain appropriate algorithm\"), (\"Security package does not contain appropriate algorithm\"));\n        log.error (\"Security package does not contain appropriate algorithm\");\n        return encrypted_value;\n    }\n    if (to_be_encrypted != null) {\n        byte digest [];\n        byte fudge_constant [];\n        try {\n            fudge_constant = (\"X#@!\").getBytes (\"UTF8\");\n        } catch (UnsupportedEncodingException uee) {\n            fudge_constant = (\"X#@!\").getBytes ();\n        }\n        byte fudgetoo_part [] = {(byte) xdigit [(int) (MSiteConfig.myrand () % 16)], (byte) xdigit [(int) (MSiteConfig.myrand () % 16)], (byte) xdigit [(int) (MSiteConfig.myrand () % 16)], (byte) xdigit [(int) (MSiteConfig.myrand () % 16)]};\n        int i = 0;\n        if (aKey != null) {\n            try {\n                fudgetoo_part = aKey.getBytes (\"UTF8\");\n            } catch (UnsupportedEncodingException uee) {\n                fudgetoo_part = aKey.getBytes ();\n            }\n        }\n        messageDigest.update (fudge_constant);\n        try {\n            messageDigest.update (to_be_encrypted.getBytes (\"UTF8\"));\n        } catch (UnsupportedEncodingException uee) {\n            messageDigest.update (to_be_encrypted.getBytes ());\n        }\n        messageDigest.update (fudgetoo_part);\n        digest = messageDigest.digest ();\n        encrypted_value = new String (fudgetoo_part);\n        for (i = 0; i < digest.length; i ++) {\n            int mashed;\n            char temp [] = new char [2];\n            if (digest [i] < 0) {\n                mashed = 127 + (- 1 * digest [i]);\n            } else {\n                mashed = digest [i];\n            }\n            temp [0] = xdigit [mashed / 16];\n            temp [1] = xdigit [mashed % 16];\n            encrypted_value = encrypted_value + (new String (temp));\n        }\n    }\n    return encrypted_value;\n}\n", "code2": "static void invalidSlave (String msg, Socket sock) throws IOException {\n    BufferedReader _sinp = null;\n    PrintWriter _sout = null;\n    try {\n        _sout = new PrintWriter (sock.getOutputStream (), true);\n        _sinp = new BufferedReader (new InputStreamReader (sock.getInputStream ()));\n        _sout.println (msg);\n        logger.info (\"NEW< \" + msg);\n        String txt = SocketSlaveListener.readLine (_sinp, 30);\n        String sname = \"\";\n        String spass = \"\";\n        String shash = \"\";\n        try {\n            String [] items = txt.split (\" \");\n            sname = items [1].trim ();\n            spass = items [2].trim ();\n            shash = items [3].trim ();\n        } catch (Exception e) {\n            throw new IOException (\"Slave Inititalization Faailed\");\n        }\n        String pass = sname + spass + _pass;\n        MessageDigest md5 = MessageDigest.getInstance (\"MD5\");\n        md5.reset ();\n        md5.update (pass.getBytes ());\n        String hash = SocketSlaveListener.hash2hex (md5.digest ()).toLowerCase ();\n        if (! hash.equals (shash)) {\n            throw new IOException (\"Slave Inititalization Faailed\");\n        }\n    } catch (Exception e) {\n    }\n    throw new IOException (\"Slave Inititalization Faailed\");\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 11082019, "method2_id": 17065100, "code1": "private void compressFile (File file, String path) throws IOException {\n    if (! file.isDirectory ()) {\n        byte [] buf = new byte [BUFFER_SIZE];\n        int len;\n        FileInputStream in = new FileInputStream (file);\n        zos.putNextEntry (new ZipEntry (path + \"/\" + file.getName ()));\n        while ((len = in.read (buf)) > 0) {\n            zos.write (buf, 0, len);\n        }\n        in.close ();\n        return;\n    }\n    if (file.list () == null) {\n        return;\n    }\n    for (String fileName : file.list ()) {\n        File f = new File (file.getAbsolutePath () + File.separator + fileName);\n        compressFile (f, path + File.separator + file.getName ());\n        isCompressed ++;\n        progressDialog.setProgress ((isCompressed * 100) / fileCount);\n    }\n}\n", "code2": "public static final void zipDirectory (String zipFileName, File baseDir, File directory) throws IOException {\n    if (directory == null || zipFileName == null) {\n        throw new IllegalArgumentException (\"Directory or zip file name was null\");\n    }\n    if (! directory.isDirectory ()) {\n        throw new IllegalArgumentException (directory + \" is not a directory\");\n    }\n    if (! directory.exists ()) {\n        throw new IllegalArgumentException (directory + \" does not exist\");\n    }\n    List < String > allDescendentFiles = FileUtils.getFilesInDir (directory, null);\n    byte [] buffer = new byte [4096];\n    int bytesRead;\n    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFileName));\n    for (String fileEntry : allDescendentFiles) {\n        File f = new File (fileEntry);\n        if (f.isDirectory ()) {\n            continue;\n        }\n        FileInputStream in = new FileInputStream (f);\n        String localPath = baseDir != null ? f.getAbsolutePath ().substring (baseDir.getAbsolutePath ().length () + 1) : f.getPath ();\n        Logger.debug (LOG_INSTANCE, \"Basedir   : \" + baseDir.getPath ());\n        Logger.debug (LOG_INSTANCE, \"File path : \" + f.getPath ());\n        Logger.debug (LOG_INSTANCE, \"Local path: \" + localPath);\n        ZipEntry entry = new ZipEntry (localPath);\n        out.putNextEntry (entry);\n        while ((bytesRead = in.read (buffer)) != - 1) {\n            out.write (buffer, 0, bytesRead);\n        }\n        in.close ();\n    }\n    out.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3008655, "method2_id": 20885480, "code1": "public static void copyFile (File srcFile, File desFile) throws IOException {\n    AssertUtility.notNull (srcFile);\n    AssertUtility.notNull (desFile);\n    FileInputStream fis = new FileInputStream (srcFile);\n    FileOutputStream fos = new FileOutputStream (desFile);\n    try {\n        FileChannel srcChannel = fis.getChannel ();\n        FileChannel dstChannel = fos.getChannel ();\n        dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n        srcChannel.close ();\n        dstChannel.close ();\n    } finally {\n        fis.close ();\n        fos.close ();\n    }\n}\n", "code2": "private void anneal (final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments < Phrase > references, final int n, final int maxNbest, File stateFile, boolean keepState) {\n    float gamma = 0;\n    boolean annealObjective = true;\n    double [] convergedScores = new double [n];\n    double [] totalLogScores = new double [n];\n    boolean [] isConverged = new boolean [n];\n    GradientPoint [] initPoints = new GradientPoint [n];\n    GradientPoint [] prevInitPoints = new GradientPoint [n];\n    GradientPoint [] bestInitPoints = new GradientPoint [n];\n    GradientPoint [] prevMinPoints = new GradientPoint [n];\n    Random rand = new Random (randomSeed);\n    Time time = new Time ();\n    if (stateFile != null && stateFile.length () > 0) {\n        time.reset ();\n        try {\n            ObjectInputStream stream = new ObjectInputStream (new FileInputStream (stateFile));\n            gamma = stream.readFloat ();\n            annealObjective = stream.readBoolean ();\n            convergedScores = (double []) stream.readObject ();\n            totalLogScores = (double []) stream.readObject ();\n            isConverged = (boolean []) stream.readObject ();\n            initPoints = (GradientPoint []) stream.readObject ();\n            prevInitPoints = (GradientPoint []) stream.readObject ();\n            bestInitPoints = (GradientPoint []) stream.readObject ();\n            prevMinPoints = (GradientPoint []) stream.readObject ();\n            rand = (Random) stream.readObject ();\n            int size = stream.readInt ();\n            for (int id = 0;\n            id < size; id ++) {\n                Feature feature = FEATURES.getRaw (CONFIG, stream.readUTF (), 0f);\n                if (feature.getId () != id) throw new Exception (\"Features have changed\");\n\n            }\n            evaluation.read (stream);\n            stream.close ();\n            output.println (\"# Resuming from previous optimization state (\" + time + \")\");\n            output.println ();\n        } catch (Exception e) {\n            e.printStackTrace ();\n            Log.getInstance ().severe (\"Failed loading optimization state (\" + stateFile + \"): \" + e.getMessage ());\n        }\n    } else {\n        final int evaluations = ProjectedEvaluation.CFG_OPT_HISTORY_SIZE.getValue ();\n        final GradientPoint [] randPoints = new GradientPoint [n * evaluations];\n        for (int i = 0;\n        i < n; i ++) {\n            evaluation.setParallelId (i);\n            for (int j = 0;\n            j < evaluations; j ++) {\n                if (i != 0) randPoints [i * n + j] = getRandomPoint (rand, randPoints [0], distanceLimit, null);\n\n                evaluate (references, i + \":\" + j);\n                if (i == 0) {\n                    randPoints [0] = new GradientPoint (evaluation, null);\n                    gamma = LogFeatureModel.FEAT_MODEL_GAMMA.getValue ();\n                    break;\n                }\n            }\n        }\n        for (int i = 0;\n        i < randPoints.length; i ++) if (randPoints [i] != null) randPoints [i] = new GradientPoint (evaluation, randPoints [i], output);\n\n        for (int i = 0;\n        i < n; i ++) {\n            prevInitPoints [i] = null;\n            initPoints [i] = randPoints [i * n];\n            if (i != 0) for (int j = 1;\n            j < evaluations; j ++) if (randPoints [i * n + j].getScore () < initPoints [i].getScore ()) initPoints [i] = randPoints [i * n + j];\n\n            bestInitPoints [i] = initPoints [i];\n            convergedScores [i] = Float.MAX_VALUE;\n        }\n    }\n    for (int searchCount = 1;\n    ; searchCount ++) {\n        boolean isFinished = true;\n        for (int i = 0;\n        i < n; i ++) isFinished = isFinished && isConverged [i];\n\n        if (isFinished) {\n            output.println (\"*** N-best list converged. Modifying annealing schedule. ***\");\n            output.println ();\n            if (annealObjective) {\n                boolean objectiveConverged = true;\n                for (int i = 0;\n                objectiveConverged && i < n; i ++) objectiveConverged = isConverged (bestInitPoints [i].getScore (), convergedScores [i], objectiveTolerance, SCORE_EPSILON);\n\n                annealObjective = false;\n                for (Metric < ProjectedSentenceEvaluation > metric : AbstractEvaluation.CFG_EVAL_METRICS.getValue ()) if (metric.doAnnealing ()) {\n                    float weight = metric.getWeight ();\n                    if (weight != 0) if (objectiveConverged) metric.setWeight (0);\n                    else {\n                        annealObjective = true;\n                        metric.setWeight (weight / objectiveAccel);\n                    }\n\n                }\n\n            }\n            if (! annealObjective) {\n                if (Math.abs (gamma) >= maxGamma) {\n                    GradientPoint bestPoint = bestInitPoints [0];\n                    for (int i = 1;\n                    i < n; i ++) if (bestInitPoints [i].getScore () < bestPoint.getScore ()) bestPoint = bestInitPoints [i];\n\n                    output.format (\"Best Score: %+.7g%n\", bestPoint.getScore ());\n                    output.println ();\n                    bestPoint = new GradientPoint (evaluation, bestPoint, output);\n                    break;\n                }\n                gamma *= gammaAccel;\n                if (Math.abs (gamma) + GAMMA_EPSILON >= maxGamma) gamma = gamma >= 0 ? maxGamma : - maxGamma;\n\n            }\n            for (int i = 0;\n            i < n; i ++) {\n                convergedScores [i] = bestInitPoints [i].getScore ();\n                initPoints [i] = new GradientPoint (evaluation, bestInitPoints [i], gamma, output);\n                bestInitPoints [i] = initPoints [i];\n                prevInitPoints [i] = null;\n                prevMinPoints [i] = null;\n                isConverged [i] = false;\n            }\n            searchCount = 0;\n        }\n        for (int i = 0;\n        i < n; i ++) {\n            if (isConverged [i]) continue;\n\n            if (n > 1) output.println (\"Minimizing point \" + i);\n\n            Gradient gradient = initPoints [i].getGradient ();\n            for (int id = 0;\n            id < FEATURES.size (); id ++) output.format (\"GRAD %-65s %-+13.7g%n\", FEATURES.getName (id), gradient.get (id));\n\n            output.println ();\n            time.reset ();\n            GradientPoint minPoint = minimize (initPoints [i], prevInitPoints [i], bestInitPoints [i], scoreTolerance, paramTolerance, distanceLimit, randomLimit, rand);\n            final float [] weights = minPoint.getWeights ();\n            for (int j = 0;\n            j < weights.length; j ++) output.format (\"PARM %-65s %-+13.7g%n\", FEATURES.getName (j), weights [j]);\n\n            output.println ();\n            output.format (\"Minimum Score: %+.7g (average distance of %.2f)%n\", minPoint.getScore (), minPoint.getAverageDistance ());\n            output.println ();\n            output.println (\"# Minimized gradient (\" + time + \")\");\n            output.println ();\n            output.flush ();\n            isConverged [i] = weights == initPoints [i].getWeights ();\n            prevInitPoints [i] = initPoints [i];\n            prevMinPoints [i] = minPoint;\n            initPoints [i] = minPoint;\n        }\n        for (int i = 0;\n        i < n; i ++) {\n            if (isConverged [i]) continue;\n\n            isConverged [i] = isConvergedScore (\"minimum\", prevMinPoints [i], prevInitPoints [i], scoreTolerance) && isConvergedWeights (prevMinPoints [i], prevInitPoints [i], paramTolerance);\n            prevMinPoints [i].setWeightsAndRescore (evaluation);\n            evaluation.setParallelId (i);\n            evaluate (references, Integer.toString (i));\n        }\n        Set < Point > prunePoints = new HashSet < Point > ();\n        prunePoints.addAll (Arrays.asList (bestInitPoints));\n        prunePoints.addAll (Arrays.asList (prevInitPoints));\n        prunePoints.addAll (Arrays.asList (initPoints));\n        evaluation.prune (prunePoints, maxNbest, output);\n        for (int i = 0;\n        i < n; i ++) {\n            final boolean bestIsPrev = bestInitPoints [i] == prevInitPoints [i];\n            final boolean bestIsInit = bestInitPoints [i] == initPoints [i];\n            bestInitPoints [i] = new GradientPoint (evaluation, bestInitPoints [i], bestIsInit ? output : null);\n            if (bestIsPrev) prevInitPoints [i] = bestInitPoints [i];\n\n            if (bestIsInit) initPoints [i] = bestInitPoints [i];\n\n            if (! bestIsPrev && prevInitPoints [i] != null) {\n                prevInitPoints [i] = new GradientPoint (evaluation, prevInitPoints [i], null);\n                if (prevInitPoints [i].getScore () <= bestInitPoints [i].getScore ()) bestInitPoints [i] = prevInitPoints [i];\n\n            }\n            if (! bestIsInit) {\n                initPoints [i] = new GradientPoint (evaluation, initPoints [i], output);\n                if (initPoints [i].getScore () <= bestInitPoints [i].getScore ()) bestInitPoints [i] = initPoints [i];\n\n            }\n        }\n        for (int i = 0;\n        i < n; i ++) if (isConverged [i]) if (prevMinPoints [i] == null) {\n            output.println (\"# Convergence failed: no previous minimum is defined\");\n            output.println ();\n            isConverged [i] = false;\n        } else {\n            isConverged [i] = isConvergedScore (\"best known\", bestInitPoints [i], initPoints [i], scoreTolerance) && isConvergedScore (\"previous minimum\", prevMinPoints [i], initPoints [i], scoreTolerance);\n        }\n\n        if (stateFile != null) {\n            time.reset ();\n            try {\n                File dir = stateFile.getCanonicalFile ().getParentFile ();\n                File temp = File.createTempFile (\"cunei-opt-\", \".tmp\", dir);\n                ObjectOutputStream stream = new ObjectOutputStream (new FileOutputStream (temp));\n                stream.writeFloat (gamma);\n                stream.writeBoolean (annealObjective);\n                stream.writeObject (convergedScores);\n                stream.writeObject (totalLogScores);\n                stream.writeObject (isConverged);\n                stream.writeObject (initPoints);\n                stream.writeObject (prevInitPoints);\n                stream.writeObject (bestInitPoints);\n                stream.writeObject (prevMinPoints);\n                stream.writeObject (rand);\n                stream.writeInt (FEATURES.size ());\n                for (int id = 0;\n                id < FEATURES.size (); id ++) stream.writeUTF (FEATURES.getName (id));\n\n                evaluation.write (stream);\n                stream.close ();\n                if (! temp.renameTo (stateFile)) {\n                    FileChannel in = null;\n                    FileChannel out = null;\n                    try {\n                        in = new FileInputStream (temp).getChannel ();\n                        out = new FileOutputStream (stateFile).getChannel ();\n                        in.transferTo (0, in.size (), out);\n                        temp.delete ();\n                    } finally {\n                        if (in != null) in.close ();\n\n                        if (out != null) out.close ();\n\n                    }\n                }\n                output.println (\"# Saved optimization state (\" + time + \")\");\n                output.println ();\n            } catch (IOException e) {\n                Log.getInstance ().severe (\"Failed writing optimization state: \" + e.getMessage ());\n            }\n        }\n    }\n    if (stateFile != null && ! keepState) stateFile.delete ();\n\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 17638226, "method2_id": 21204167, "code1": "public static String hash (final String s) {\n    if (s == null || s.length () == 0) return null;\n\n    try {\n        final MessageDigest hashEngine = MessageDigest.getInstance (\"SHA-1\");\n        hashEngine.update (s.getBytes (\"iso-8859-1\"), 0, s.length ());\n        return convertToHex (hashEngine.digest ());\n    } catch (final Exception e) {\n        return null;\n    }\n}\n", "code2": "private String getEncryptedPassword () {\n    String encrypted;\n    char [] pwd = password.getPassword ();\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"SHA-1\");\n        md.update (new String (pwd).getBytes (\"UTF-8\"));\n        byte [] digested = md.digest ();\n        encrypted = new String (Base64Coder.encode (digested));\n    } catch (Exception e) {\n        encrypted = new String (pwd);\n    }\n    for (int i = 0;\n    i < pwd.length; i ++) pwd [i] = 0;\n\n    return encrypted;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1188506, "method2_id": 1241104, "code1": "public Stream getStreamValue (StreamContext context) {\n    Stream candidate = context.getStreamIfPresent (this);\n    if (candidate != null) {\n        return candidate;\n    }\n    String name;\n    if (nameExpr == null) {\n        name = \"_\" + System.nanoTime ();\n    } else {\n        name = nameExpr.getStringValue (context);\n    }\n    String className = classExpr.getStringValue (context);\n    Class < ? > streamClass = null;\n    if (className == null) {\n        streamClass = EventStream.class;\n    } else {\n        if (className.indexOf ('.') == - 1) {\n            int prefixIndex = 0;\n            while (streamClass == null && prefixIndex < STREAM_CLASS_PREFIXES.length) {\n                String fullClassName = STREAM_CLASS_PREFIXES [prefixIndex ++] + className;\n                try {\n                    streamClass = Class.forName (fullClassName);\n                } catch (ClassNotFoundException e) {\n                }\n            }\n        } else {\n            try {\n                streamClass = Class.forName (className);\n            } catch (ClassNotFoundException e) {\n            }\n        }\n        if (streamClass == null) {\n            throw new IllegalArgumentException (\"Could not resolve \" + className + \" needed for stream construction\");\n        }\n    }\n    if (! Stream.class.isAssignableFrom (streamClass)) {\n        throw new IllegalArgumentException (\"Class \" + streamClass.getName () + \" was specified as stream type but is not a subclass of Stream\");\n    }\n    Constructor < ? > cons;\n    try {\n        cons = streamClass.getConstructor (String.class, StreamContext.class, TupleExpression.class, Unit.class);\n    } catch (SecurityException e) {\n        cons = null;\n    } catch (NoSuchMethodException e) {\n        cons = null;\n    }\n    if (cons == null) {\n        throw new IllegalArgumentException (\"Class \" + streamClass.getName () + \" was specified as stream type but does not have a ForkTalk constructor\");\n    }\n    Throwable exception = null;\n    try {\n        Stream ans = (Stream) cons.newInstance (name, tupleExpr.getStreamContext (), tupleExpr, getUnitFrom (tupleExpr.getType ()));\n        if (nameExpr == null) {\n            ans.setInvisible (true);\n        }\n        return ans;\n    } catch (InvocationTargetException e) {\n        exception = e.getCause ();\n    } catch (IllegalAccessException e) {\n        throw new IllegalArgumentException (\"Class \" + streamClass.getName () + \" was specified as stream type but it's ForkTalk constructor is not public\");\n    } catch (InstantiationException e) {\n        throw new IllegalArgumentException (\"Class \" + streamClass.getName () + \" was specified as stream type but is abstract\");\n    } catch (Exception e) {\n        exception = e;\n    }\n    if (exception instanceof RuntimeException) {\n        throw (RuntimeException) exception;\n    } else if (exception instanceof Error) {\n        throw (Error) exception;\n    } else {\n        throw new IllegalArgumentException (exception.getMessage (), exception);\n    }\n\n}\n", "code2": "private SearchEngine makeEngine (NavigatorView view) {\n    Hashtable params = view.getParameters ();\n    if (params == null || (params != null && ! params.containsKey (\"data\"))) {\n        return null;\n    }\n    String engineName = (String) params.get (\"engine\");\n    HelpSet hs = view.getHelpSet ();\n    URL base = hs.getHelpSetURL ();\n    ClassLoader loader = hs.getLoader ();\n    if (engineName == null) {\n        engineName = HelpUtilities.getDefaultQueryEngine ();\n        params.put (\"engine\", engineName);\n    }\n    SearchEngine back = null;\n    Constructor konstructor;\n    Class types [] = {URL.class, Hashtable.class};\n    Object args [] = {base, params};\n    Class klass;\n    debug (\"makeEngine\");\n    debug (\"  base: \" + base);\n    debug (\"  params: \" + params);\n    try {\n        if (loader == null) {\n            klass = Class.forName (engineName);\n        } else {\n            klass = loader.loadClass (engineName);\n        }\n    } catch (Throwable t) {\n        throw new Error (\"Could not load engine named \" + engineName + \" for view: \" + view);\n    }\n    try {\n        konstructor = klass.getConstructor (types);\n    } catch (Throwable t) {\n        throw new Error (\"Could not find constructor for \" + engineName + \". For view: \" + view);\n    }\n    try {\n        back = (SearchEngine) konstructor.newInstance (args);\n    } catch (InvocationTargetException e) {\n        System.err.println (\"Exception while creating engine named \" + engineName + \" for view: \" + view);\n        e.printStackTrace ();\n    } catch (Throwable t) {\n        throw new Error (\"Could not create engine named \" + engineName + \" for view: \" + view);\n    }\n    return back;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10067028, "method2_id": 11103539, "code1": "public static void copyFile (File source, File destination) throws IOException {\n    FileChannel in = null;\n    FileChannel out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (destination).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buffer = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buffer);\n    } finally {\n        if (in != null) {\n            in.close ();\n        }\n        if (out != null) {\n            out.close ();\n        }\n    }\n}\n", "code2": "public void compressFile (String filePath) {\n    String outPut = filePath + \".zip\";\n    try {\n        FileInputStream in = new FileInputStream (filePath);\n        GZIPOutputStream out = new GZIPOutputStream (new FileOutputStream (outPut));\n        byte [] buffer = new byte [4096];\n        int bytes_read;\n        while ((bytes_read = in.read (buffer)) != - 1) out.write (buffer, 0, bytes_read);\n\n        in.close ();\n        out.close ();\n    } catch (Exception c) {\n        c.printStackTrace ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 460892, "method2_id": 9856200, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public static void copyFile (File srcFile, File destFolder) {\n    try {\n        File destFile = new File (destFolder, srcFile.getName ());\n        if (destFile.exists ()) {\n            throw new BuildException (\"Could not copy \" + srcFile + \" to \" + destFolder + \" as \" + destFile + \" already exists\");\n        }\n        FileChannel srcChannel = null;\n        FileChannel destChannel = null;\n        try {\n            srcChannel = new FileInputStream (srcFile).getChannel ();\n            destChannel = new FileOutputStream (destFile).getChannel ();\n            destChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n        } finally {\n            if (srcChannel != null) {\n                srcChannel.close ();\n            }\n            if (destChannel != null) {\n                destChannel.close ();\n            }\n        }\n        destFile.setLastModified ((srcFile.lastModified ()));\n    } catch (IOException e) {\n        throw new BuildException (\"Could not copy \" + srcFile + \" to \" + destFolder + \": \" + e, e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 849718, "method2_id": 3157576, "code1": "private void gotoURLWithMethod (String url, String clazz, String method) {\n    Class c = null;\n    Object obj = null;\n    try {\n        c = Class.forName (clazz);\n    } catch (Throwable e) {\n        GUIUtilities.error (null, \"infoviewer.error.classnotfound\", new Object [] {clazz});\n        return;\n    }\n    if (method == null || (method != null && method.length () == 0)) {\n        Constructor constr = null;\n        try {\n            constr = c.getConstructor (new Class [] {URL.class});\n            if (constr != null) obj = constr.newInstance (new Object [] {new URL (url)});\n\n        } catch (Exception ex) {\n            Log.log (Log.DEBUG, this, ex);\n        }\n        if (obj == null) {\n            try {\n                constr = c.getConstructor (new Class [] {String.class});\n                if (constr != null) obj = constr.newInstance (new Object [] {url});\n\n            } catch (Exception ex) {\n                Log.log (Log.DEBUG, this, ex);\n            }\n        }\n        if (obj == null) {\n            try {\n                constr = c.getConstructor (new Class [0]);\n                if (constr != null) obj = constr.newInstance (new Object [0]);\n\n            } catch (Exception ex) {\n                Log.log (Log.DEBUG, this, ex);\n            }\n        }\n        if (obj == null) {\n            GUIUtilities.error (null, \"infoviewer.error.classnotfound\", new Object [] {clazz});\n            return;\n        }\n    } else {\n        Method meth = null;\n        boolean ok = false;\n        try {\n            meth = c.getDeclaredMethod (method, new Class [] {URL.class});\n            if (meth != null) {\n                obj = meth.invoke (null, new Object [] {new URL (url)});\n                ok = true;\n            }\n        } catch (Exception ex) {\n            Log.log (Log.DEBUG, this, ex);\n        }\n        if (! ok) {\n            try {\n                meth = c.getDeclaredMethod (method, new Class [] {String.class});\n                if (meth != null) {\n                    obj = meth.invoke (null, new Object [] {url});\n                    ok = true;\n                }\n            } catch (Exception ex) {\n                Log.log (Log.DEBUG, this, ex);\n            }\n        }\n        if (! ok) {\n            try {\n                meth = c.getDeclaredMethod (method, new Class [0]);\n                if (meth != null) {\n                    obj = meth.invoke (null, new Object [0]);\n                    ok = true;\n                }\n            } catch (Exception ex) {\n                Log.log (Log.DEBUG, this, ex);\n            }\n        }\n        if (! ok) {\n            GUIUtilities.error (null, \"infoviewer.error.methodnotfound\", new Object [] {clazz, method});\n            return;\n        }\n    }\n    if (obj != null) {\n        if (obj instanceof Window) {\n            ((Window) obj).show ();\n        } else if (obj instanceof JComponent) {\n            JFrame f = new JFrame (\"Infoviewer JWrapper\");\n            f.getContentPane ().add ((JComponent) obj);\n            f.pack ();\n            f.setVisible (true);\n        } else if (obj instanceof Component) {\n            Frame f = new Frame (\"Infoviewer Wrapper\");\n            f.add ((Component) obj);\n            f.pack ();\n            f.setVisible (true);\n        }\n\n    }\n}\n", "code2": "public static JComponent findEditor (Attribute attribute) {\n    JComponent editor = null;\n    AttributeName an = attribute.getOfType ();\n    String className = an.getDataTypeAsString ();\n    String editorName = Config.config.getProperty (\"Dialog.Attribute.Editor.\" + attribute.getOfType ().getId ());\n    if (editorName == null) editorName = Config.config.getProperty (\"Dialog.Attribute.\" + className);\n\n    if (editorName == null) editorName = \"DefaultEditor\";\n\n    try {\n        Class < ? > editorClass = null;\n        try {\n            editorClass = Class.forName (\"net.sourceforge.ondex.ovtk2.ui.gds.\" + editorName);\n        } catch (ClassNotFoundException cnfe) {\n        }\n        if (editorClass == null) {\n            editor = (JComponent) OVTK2PluginLoader.getInstance ().loadAttributeEditor (editorName, attribute);\n        } else {\n            Class < ? > [] args = new Class < ? > [] {Attribute.class};\n            Constructor < ? > constr = editorClass.getConstructor (args);\n            editor = (JComponent) constr.newInstance (attribute);\n        }\n        if (! (editor instanceof GDSEditor)) {\n            throw new RuntimeException (editor.getClass ().getName () + \" does not implement required \" + GDSEditor.class + \" interface\");\n        }\n        editor.setMinimumSize (new Dimension (100, 100));\n        editor.setPreferredSize (new Dimension (100, 100));\n    } catch (InstantiationException e) {\n        e.printStackTrace ();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace ();\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n    return editor;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8232814, "method2_id": 22431492, "code1": "public ChatClient registerPlayer (int playerId, String playerLogin) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md = MessageDigest.getInstance (\"SHA-256\");\n    md.reset ();\n    md.update (playerLogin.getBytes (\"UTF-8\"), 0, playerLogin.length ());\n    byte [] accountToken = md.digest ();\n    byte [] token = generateToken (accountToken);\n    ChatClient chatClient = new ChatClient (playerId, token);\n    players.put (playerId, chatClient);\n    return chatClient;\n}\n", "code2": "public static String generateNonce (boolean is32) {\n    Random random = new Random ();\n    String result = String.valueOf (random.nextInt (9876599) + 123400);\n    if (is32) {\n        try {\n            MessageDigest md = MessageDigest.getInstance (\"MD5\");\n            md.update (result.getBytes ());\n            byte b [] = md.digest ();\n            int i;\n            StringBuffer buf = new StringBuffer (\"\");\n            for (int offset = 0;\n            offset < b.length; offset ++) {\n                i = b [offset];\n                if (i < 0) i += 256;\n\n                if (i < 16) buf.append (\"0\");\n\n                buf.append (Integer.toHexString (i));\n            }\n            result = buf.toString ();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace ();\n        }\n    }\n    return result;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4588029, "method2_id": 18416601, "code1": "@Override\npublic void execute () throws ExecutionException {\n    interrupted = false;\n    if (document == null) throw new ExecutionException (\"No Document provided!\");\n\n    AnnotationSet outputAS = document.getAnnotations (outputAnnotationSetName);\n    long startTime = System.currentTimeMillis ();\n    fireStatusChanged (\"Tagging Roman Numerals in \" + document.getName ());\n    fireProgressChanged (0);\n    Pattern pattern;\n    if (allowLowerCase) {\n        if (maxTailLength > 0) {\n            pattern = Pattern.compile (\"\\\\b((?:[mdclxvi]+)|(?:[MDCLCVI]+))(\\\\w{0,\" + maxTailLength + \"})\\\\b\");\n        } else {\n            pattern = Pattern.compile (\"\\\\b((?:[mdclxvi]+)|(?:[MDCLCVI]+))\\\\b\");\n        }\n    } else {\n        if (maxTailLength > 0) {\n            pattern = Pattern.compile (\"\\\\b([MDCLCVI]+)(\\\\w{0,\" + maxTailLength + \"})\\\\b\");\n        } else {\n            pattern = Pattern.compile (\"\\\\b([MDCLCVI]+)\\\\b\");\n        }\n    }\n    String content = document.getContent ().toString ();\n    Matcher matcher = pattern.matcher (content);\n    while (matcher.find ()) {\n        if (isInterrupted ()) {\n            throw new ExecutionInterruptedException (\"The execution of the \\\"\" + getName () + \"\\\" Roman Numerals Tagger has been abruptly interrupted!\");\n        }\n        int numStart = matcher.start (1);\n        int numEnd = matcher.end (1);\n        if (numStart >= 0 && numEnd > numStart) {\n            String romanNumeral = content.substring (numStart, numEnd);\n            int value = romanToInt (romanNumeral);\n            if (value > 0) {\n                String tail = null;\n                if (maxTailLength > 0) {\n                    int tailStart = matcher.start (2);\n                    int tailEnd = matcher.end (2);\n                    if (tailStart < tailEnd) {\n                        tail = content.substring (tailStart, tailEnd);\n                        numEnd = tailEnd;\n                    }\n                }\n                FeatureMap fm = Factory.newFeatureMap ();\n                fm.put (VALUE_FEATURE_NAME, Integer.valueOf (value).doubleValue ());\n                fm.put (TYPE_FEATURE_NAME, \"roman\");\n                if (tail != null) fm.put (\"tail\", tail);\n\n                try {\n                    outputAS.add ((long) numStart, (long) numEnd, NUMBER_ANNOTATION_NAME, fm);\n                } catch (InvalidOffsetException e) {\n                }\n            }\n        }\n    }\n    fireProcessFinished ();\n    fireStatusChanged (document.getName () + \" tagged with Roman Numerals in \" + NumberFormat.getInstance ().format ((double) (System.currentTimeMillis () - startTime) / 1000) + \" seconds!\");\n}\n", "code2": "protected static Object getNextMatchPosRegExImpl (String regEx, CharSequence searchIn, boolean goForward, boolean matchCase, boolean wholeWord, String replaceStr) {\n    int flags = matchCase ? 0 : (Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\n    Pattern pattern = Pattern.compile (regEx, flags);\n    Matcher m = pattern.matcher (searchIn);\n    if (goForward) {\n        if (! wholeWord) {\n            if (m.find ()) {\n                if (replaceStr == null) {\n                    return new Point (m.start (), m.end ());\n                } else {\n                    return new RegExReplaceInfo (m.group (0), m.start (), m.end (), getReplacementText (m, replaceStr));\n                }\n            }\n        } else {\n            while (m.find ()) {\n                Point loc = new Point (m.start (), m.end ());\n                if (isWholeWord (searchIn, loc.x, loc.y - loc.x)) {\n                    if (replaceStr == null) {\n                        return loc;\n                    } else {\n                        return new RegExReplaceInfo (m.group (0), loc.x, loc.y, getReplacementText (m, replaceStr));\n                    }\n                }\n            }\n        }\n    } else {\n        List matches = getMatches (m, replaceStr);\n        if (matches.isEmpty ()) return null;\n\n        int pos = matches.size () - 1;\n        if (wholeWord == false) {\n            if (replaceStr == null) {\n                return matches.get (pos);\n            } else {\n                return matches.get (pos);\n            }\n        }\n        while (pos >= 0) {\n            Object matchObj = matches.get (pos);\n            if (replaceStr == null) {\n                Point loc = (Point) matchObj;\n                if (isWholeWord (searchIn, loc.x, loc.y - loc.x)) {\n                    return matchObj;\n                }\n            } else {\n                RegExReplaceInfo info = (RegExReplaceInfo) matchObj;\n                int x = info.getStartIndex ();\n                int y = info.getEndIndex ();\n                if (isWholeWord (searchIn, x, y - x)) {\n                    return matchObj;\n                }\n            }\n            pos --;\n        }\n    }\n    return null;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 19705487, "method2_id": 20144221, "code1": "private void zipDir (File zipDir, ZipOutputStream zos, String startingPath, PXBuildContext context) {\n    try {\n        String [] dirList = zipDir.list ();\n        byte [] readBuffer = new byte [2156];\n        int bytesIn = 0;\n        for (int i = 0;\n        i < dirList.length; i ++) {\n            File f = new File (zipDir, dirList [i]);\n            String entryPath = f.getPath ();\n            if (entryPath.startsWith (startingPath)) {\n                entryPath = entryPath.substring (startingPath.length (), entryPath.length ());\n            }\n            if (f.isDirectory ()) {\n                String filePath = entryPath;\n                zipDir (f, zos, startingPath, context);\n                continue;\n            }\n            FileInputStream fis = new FileInputStream (f);\n            ZipEntry anEntry = new ZipEntry (entryPath);\n            zos.putNextEntry (anEntry);\n            while ((bytesIn = fis.read (readBuffer)) != - 1) {\n                zos.write (readBuffer, 0, bytesIn);\n            }\n            fis.close ();\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n        NSDictionary info = new NSDictionary (new Object [] {e.getMessage ()}, new String [] {NSError.LocalizedDescriptionKey});\n        NSError message = new NSError (\"Pachyderm Build Domain\", - 1, info);\n        context.appendBuildMessage (message);\n    }\n}\n", "code2": "public static void addFilesToZip (File zipFile, File [] files, String [] fileNames) throws IOException {\n    File tempFile = new File (zipFile.getAbsoluteFile () + \".temp\");\n    if (! zipFile.renameTo (tempFile)) {\n        throw new RuntimeException (\"could not rename\");\n    }\n    byte [] buf = new byte [1024];\n    ZipInputStream zin = new ZipInputStream (new FileInputStream (tempFile));\n    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));\n    ZipEntry entry = zin.getNextEntry ();\n    while (entry != null) {\n        String name = entry.getName ();\n        boolean notInFiles = true;\n        for (String f : fileNames) {\n            if (f.equals (name)) {\n                notInFiles = false;\n                break;\n            }\n        }\n        if (notInFiles) {\n            out.putNextEntry (new ZipEntry (name));\n            int len;\n            while ((len = zin.read (buf)) > 0) {\n                out.write (buf, 0, len);\n            }\n        }\n        entry = zin.getNextEntry ();\n    }\n    zin.close ();\n    for (int i = 0;\n    i < files.length; i ++) {\n        InputStream in = new FileInputStream (files [i]);\n        out.putNextEntry (new ZipEntry (fileNames [i]));\n        int len;\n        while ((len = in.read (buf)) > 0) {\n            out.write (buf, 0, len);\n        }\n        out.closeEntry ();\n        in.close ();\n    }\n    out.close ();\n    tempFile.delete ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 310580, "method2_id": 19279820, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "private void copyFile (URL from, File to) {\n    try {\n        InputStream is = from.openStream ();\n        IOUtils.copy (is, new FileOutputStream (to));\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 5021577, "method2_id": 20827140, "code1": "public static boolean copyDataToNewTable (EboContext p_eboctx, String srcTableName, String destTableName, String where, boolean log, int mode) throws boRuntimeException {\n    srcTableName = srcTableName.toUpperCase ();\n    destTableName = destTableName.toUpperCase ();\n    Connection cn = null;\n    Connection cndef = null;\n    boolean ret = false;\n    try {\n        boolean srcexists = false;\n        boolean destexists = false;\n        final InitialContext ic = new InitialContext ();\n        cn = p_eboctx.getConnectionData ();\n        cndef = p_eboctx.getConnectionDef ();\n        PreparedStatement pstm = cn.prepareStatement (\"SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME=?\");\n        pstm.setString (1, srcTableName);\n        ResultSet rslt = pstm.executeQuery ();\n        if (rslt.next ()) {\n            srcexists = true;\n        }\n        rslt.close ();\n        pstm.setString (1, destTableName);\n        rslt = pstm.executeQuery ();\n        if (rslt.next ()) {\n            destexists = true;\n        }\n        if (! destexists) {\n            rslt.close ();\n            pstm.close ();\n            pstm = cn.prepareStatement (\"SELECT VIEW_NAME FROM USER_VIEWS WHERE VIEW_NAME=?\");\n            pstm.setString (1, destTableName);\n            rslt = pstm.executeQuery ();\n            if (rslt.next ()) {\n                CallableStatement cstm = cn.prepareCall (\"DROP VIEW \" + destTableName);\n                cstm.execute ();\n                cstm.close ();\n            }\n        }\n        rslt.close ();\n        pstm.close ();\n        if (srcexists && ! destexists) {\n            if (log) {\n                logger.finest (LoggerMessageLocalizer.getMessage (\"CREATING_AND_COPY_DATA_FROM\") + \" [\" + srcTableName + \"] \" + LoggerMessageLocalizer.getMessage (\"TO\") + \" [\" + destTableName + \"]\");\n            }\n            CallableStatement cstm = cn.prepareCall (\"CREATE TABLE \" + destTableName + \" AS SELECT * FROM \" + srcTableName + \" \" + (((where != null) && (where.length () > 0)) ? (\" WHERE \" + where) : \"\"));\n            cstm.execute ();\n            cstm.close ();\n            if (log) {\n                logger.finest (LoggerMessageLocalizer.getMessage (\"UPDATING_NGTDIC\"));\n            }\n            cn.commit ();\n            ret = true;\n        } else if (srcexists && destexists) {\n            if (log) {\n                logger.finest (LoggerMessageLocalizer.getMessage (\"COPY_DATA_FROM\") + \" [\" + srcTableName + \"] \" + LoggerMessageLocalizer.getMessage (\"TO\") + \"  [\" + destTableName + \"]\");\n            }\n            PreparedStatement pstm2 = cn.prepareStatement (\"SELECT COLUMN_NAME FROM USER_TAB_COLUMNS WHERE TABLE_NAME = ? \");\n            pstm2.setString (1, destTableName);\n            ResultSet rslt2 = pstm2.executeQuery ();\n            StringBuffer fields = new StringBuffer ();\n            PreparedStatement pstm3 = cn.prepareStatement (\"SELECT COLUMN_NAME FROM USER_TAB_COLUMNS WHERE TABLE_NAME = ? and COLUMN_NAME=?\");\n            while (rslt2.next ()) {\n                pstm3.setString (1, srcTableName);\n                pstm3.setString (2, rslt2.getString (1));\n                ResultSet rslt3 = pstm3.executeQuery ();\n                if (rslt3.next ()) {\n                    if (fields.length () > 0) {\n                        fields.append (',');\n                    }\n                    fields.append ('\"').append (rslt2.getString (1)).append ('\"');\n                }\n                rslt3.close ();\n            }\n            pstm3.close ();\n            rslt2.close ();\n            pstm2.close ();\n            CallableStatement cstm;\n            int recs = 0;\n            if ((mode == 0) || (mode == 1)) {\n                cstm = cn.prepareCall (\"INSERT INTO \" + destTableName + \"( \" + fields.toString () + \" ) ( SELECT \" + fields.toString () + \" FROM \" + srcTableName + \" \" + (((where != null) && (where.length () > 0)) ? (\" WHERE \" + where) : \"\") + \")\");\n                recs = cstm.executeUpdate ();\n                cstm.close ();\n                if (log) {\n                    logger.finest (LoggerMessageLocalizer.getMessage (\"DONE\") + \" [\" + recs + \"] \" + LoggerMessageLocalizer.getMessage (\"RECORDS_COPIED\"));\n                }\n            }\n            cn.commit ();\n            ret = true;\n        }\n\n    } catch (Exception e) {\n        try {\n            cn.rollback ();\n        } catch (Exception z) {\n            throw new boRuntimeException (\"boBuildDB.moveTable\", \"BO-1304\", z);\n        }\n        throw new boRuntimeException (\"boBuildDB.moveTable\", \"BO-1304\", e);\n    } finally {\n        try {\n            cn.close ();\n        } catch (Exception e) {\n        }\n        try {\n            cndef.close ();\n        } catch (Exception e) {\n        }\n    }\n    return ret;\n}\n", "code2": "public static Chunk updateLastSend (Chunk c) throws Exception {\n    DBConnectionManager dbm = null;\n    Connection conn = null;\n    PreparedStatement stmt = null;\n    Chunk ret = null;\n    String SQL = \"UPDATE CHUNK SET SENT=? WHERE FILEHASH=? AND STARTOFF=? AND LENGTH=?\";\n    log.debug (\"update chunk last sent for chunk \" + c.getHash () + \" startoff \" + c.getStartOffset ());\n    try {\n        dbm = DBConnectionManager.getInstance ();\n        conn = dbm.getConnection (\"satmule\");\n        stmt = conn.prepareStatement (SQL);\n        stmt.setDate (1, new java.sql.Date (c.getLastSend ().getTime ()));\n        stmt.setString (2, c.getHash ());\n        stmt.setLong (3, c.getStartOffset ());\n        stmt.setLong (4, c.getSize ());\n        stmt.executeUpdate ();\n        conn.commit ();\n        stmt.close ();\n        dbm.freeConnection (\"satmule\", conn);\n    } catch (Exception e) {\n        log.error (\"Error while updating chunk \" + c.getHash () + \"offset:\" + c.getStartOffset () + \"SQL error: \" + SQL, e);\n        Exception excep;\n        if (dbm == null) excep = new Exception (\"Could not obtain pool object DbConnectionManager\");\n        else if (conn == null) excep = new Exception (\"The Db connection pool could not obtain a database connection\");\n        else {\n            conn.rollback ();\n            excep = new Exception (\"SQL Error : \" + SQL + \" error: \" + e);\n            dbm.freeConnection (\"satmule\", conn);\n        }\n\n        throw excep;\n    }\n    return ret;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8015400, "method2_id": 20028790, "code1": "protected synchronized InputStream openURLConnection (StreamDataSetDescriptor dsd, Datum start, Datum end, StringBuffer additionalFormData) throws DasException {\n    String [] tokens = dsd.getDataSetID ().split (\"\\\\?|\\\\&\");\n    String dataSetID = tokens [1];\n    try {\n        String formData = createFormDataString (dataSetID, start, end, additionalFormData);\n        if (dsd.isRestrictedAccess ()) {\n            key = server.getKey (\"\");\n            if (key != null) {\n                formData += \"&key=\" + URLEncoder.encode (key.toString (), \"UTF-8\");\n            }\n        }\n        if (redirect) {\n            formData += \"&redirect=1\";\n        }\n        URL serverURL = this.server.getURL (formData);\n        this.lastRequestURL = String.valueOf (serverURL);\n        DasLogger.getLogger (DasLogger.DATA_TRANSFER_LOG).info (\"opening \" + serverURL.toString ());\n        URLConnection urlConnection = serverURL.openConnection ();\n        urlConnection.connect ();\n        String contentType = urlConnection.getContentType ();\n        if (! contentType.equalsIgnoreCase (\"application/octet-stream\")) {\n            BufferedReader bin = new BufferedReader (new InputStreamReader (urlConnection.getInputStream ()));\n            String line = bin.readLine ();\n            String message = \"\";\n            while (line != null) {\n                message = message.concat (line);\n                line = bin.readLine ();\n            }\n            throw new DasIOException (message);\n        }\n        InputStream in = urlConnection.getInputStream ();\n        if (isLegacyStream ()) {\n            return processLegacyStream (in);\n        } else {\n            throw new UnsupportedOperationException ();\n        }\n    } catch (IOException e) {\n        throw new DasIOException (e);\n    }\n}\n", "code2": "private static boolean setBundleInfoName (String location, List < BundleInfo > list) {\n    try {\n        URL url = new URL (location);\n        BufferedReader br = new BufferedReader (new InputStreamReader (url.openStream (), \"UTF-8\"));\n        while (true) {\n            String line = br.readLine ();\n            if (line == null) {\n                break;\n            }\n            int pos1 = line.indexOf ('=');\n            if (pos1 < 0) {\n                continue;\n            }\n            String bundleSymbolicName = line.substring (0, pos1);\n            String bundleName = line.substring (pos1 + 1);\n            for (BundleInfo info : list) {\n                if (info.bundleSymbolicName.equals (bundleSymbolicName)) {\n                    info.bundleName = bundleName;\n                    break;\n                }\n            }\n        }\n        return true;\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n    return false;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3880859, "method2_id": 5389884, "code1": "public static final long crc32 (byte [] data) {\n    CRC32 crc32 = new CRC32 ();\n    crc32.update (data);\n    return crc32.getValue ();\n}\n", "code2": "public static long getDummyCRC (long count) throws IOException {\n    CRC32 crc = new CRC32 ();\n    byte [] data = new byte [1024];\n    int done = 0;\n    while (done < count) {\n        int tbw = (int) Math.min (count - done, data.length);\n        crc.update (data, 0, tbw);\n        done += tbw;\n    }\n    return crc.getValue ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 14194234, "method2_id": 18046659, "code1": "private String File2String (String directory, String filename) {\n    String line;\n    InputStream in = null;\n    try {\n        File f = new File (filename);\n        System.out.println (\"File On:>>>>>>>>>> \" + f.getCanonicalPath ());\n        in = new FileInputStream (f);\n    } catch (FileNotFoundException ex) {\n        in = null;\n    } catch (IOException ex) {\n        in = null;\n    }\n    try {\n        if (in == null) {\n            filename = directory + \"/\" + filename;\n            java.net.URL urlFile = ClassLoader.getSystemResource (filename);\n            if (urlFile == null) {\n                System.out.println (\"Integrated Chips list file not found: \" + filename);\n                System.exit (- 1);\n            }\n            in = urlFile.openStream ();\n        }\n        BufferedReader reader = new BufferedReader (new InputStreamReader (in));\n        StringBuffer xmlText = new StringBuffer ();\n        while ((line = reader.readLine ()) != null) {\n            xmlText.append (line);\n        }\n        reader.close ();\n        return xmlText.toString ();\n    } catch (FileNotFoundException ex) {\n        System.out.println (\"Integrated Chips list file not found\");\n        System.exit (- 1);\n    } catch (IOException ex) {\n        ex.printStackTrace ();\n        System.exit (- 1);\n    }\n    return null;\n}\n", "code2": "public String fetch (final String address) throws EncoderException {\n    final String escapedAddress = new URLCodec ().encode (address);\n    final String requestUrl = GeoCodeFetch.urlXmlPath + \"&\" + \"address=\" + escapedAddress;\n    this.log.debug (\"requestUrl: {}\", requestUrl);\n    try {\n        final StringBuffer sb = new StringBuffer ();\n        final URL url = new URL (requestUrl);\n        final BufferedReader reader = new BufferedReader (new InputStreamReader (url.openStream ()));\n        String line;\n        while ((line = reader.readLine ()) != null) {\n            this.log.debug (\"line: {}\", line);\n            sb.append (line);\n        }\n        reader.close ();\n        return (sb.toString ());\n    } catch (final MalformedURLException ex) {\n        this.log.error (ExceptionUtils.getStackTrace (ex));\n    } catch (final IOException ex) {\n        this.log.error (ExceptionUtils.getStackTrace (ex));\n    }\n    return (\"\");\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6387775, "method2_id": 11159237, "code1": "public static String hashSHA1 (String value) {\n    try {\n        MessageDigest digest = MessageDigest.getInstance (\"SHA-1\");\n        digest.update (value.getBytes ());\n        BigInteger hash = new BigInteger (1, digest.digest ());\n        return hash.toString (16);\n    } catch (NoSuchAlgorithmException e) {\n    }\n    return null;\n}\n", "code2": "public static String hash (final String text) {\n    try {\n        MessageDigest md;\n        md = MessageDigest.getInstance (\"SHA-1\");\n        byte [] sha1hash;\n        md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n        sha1hash = md.digest ();\n        return Sha1.convertToHex (sha1hash);\n    } catch (NoSuchAlgorithmException e) {\n        return null;\n    } catch (UnsupportedEncodingException e) {\n        return null;\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4791144, "method2_id": 18293811, "code1": "private String sendMessage (HttpURLConnection connection, String reqMessage) throws IOException {\n    if (msgLog.isTraceEnabled ()) msgLog.trace (\"Outgoing SOAPMessage\\n\" + reqMessage);\n\n    BufferedOutputStream out = new BufferedOutputStream (connection.getOutputStream ());\n    out.write (reqMessage.getBytes (\"UTF-8\"));\n    out.close ();\n    InputStream inputStream = null;\n    if (connection.getResponseCode () < 400) inputStream = connection.getInputStream ();\n    else inputStream = connection.getErrorStream ();\n\n    ByteArrayOutputStream baos = new ByteArrayOutputStream (1024);\n    IOUtils.copyStream (baos, inputStream);\n    inputStream.close ();\n    String response = new String (baos.toByteArray (), \"UTF-8\");\n    if (msgLog.isTraceEnabled ()) msgLog.trace (\"Incoming Response SOAPMessage\\n\" + response);\n\n    return response;\n}\n", "code2": "private static void copy (String from_name, String to_name) throws IOException {\n    File from_file = new File (from_name);\n    File to_file = new File (to_name);\n    if (! from_file.exists ()) abort (\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\" + from_file);\n\n    if (! from_file.isFile ()) abort (\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\" + from_file);\n\n    if (! from_file.canRead ()) abort (\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\" + from_file);\n\n    if (from_file.isDirectory ()) to_file = new File (to_file, from_file.getName ());\n\n    if (to_file.exists ()) {\n        if (! to_file.canWrite ()) abort (\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\" + to_file);\n\n        System.out.println (\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd?\" + to_file.getName () + \"?(Y/N):\");\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) abort (\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\");\n\n    } else {\n        String parent = to_file.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) abort (\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\" + parent);\n\n        if (! dir.isFile ()) abort (\"\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\" + parent);\n\n        if (! dir.canWrite ()) abort (\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (from_file);\n        to = new FileOutputStream (to_file);\n        byte [] buffer = new byte [4096];\n        int bytes_read;\n        while ((bytes_read = from.read (buffer)) != - 1) to.write (buffer, 0, bytes_read);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 892279, "method2_id": 5150160, "code1": "File zip (File dir, File zipFile) throws IOException {\n    ZipOutputStream zipOut = new ZipOutputStream (new FileOutputStream (zipFile));\n    for (File file : dir.listFiles ()) {\n        if (file.isFile ()) {\n            byte [] data = new byte [(int) file.length ()];\n            DataInputStream in = new DataInputStream (new FileInputStream (file));\n            in.readFully (data);\n            in.close ();\n            zipOut.putNextEntry (new ZipEntry (file.getName ()));\n            zipOut.write (data, 0, data.length);\n            zipOut.closeEntry ();\n        }\n    }\n    zipOut.close ();\n    return zipFile;\n}\n", "code2": "public void createZippedFile (String [] fileNameList, String dirName, String outputZippedFileName) throws Exception {\n    ZipOutputStream zipOutput = null;\n    FileInputStream inputFile = null;\n    try {\n        if (fileNameList.length <= 0) {\n            throw new Exception (\"Passed fileNameList is empty!\");\n        }\n        FileOutputStream out = new FileOutputStream (new File (outputZippedFileName));\n        zipOutput = new ZipOutputStream (out);\n        ZipEntry tmpZipEntry = null;\n        CRC32 crc = new CRC32 ();\n        for (int i = 0;\n        i < fileNameList.length; i ++) {\n            String tmpFile = fileNameList [i];\n            File tmpFileHandle = new File (dirName + fileSeparator + tmpFile);\n            inputFile = new FileInputStream (tmpFileHandle);\n            if (! tmpFileHandle.exists ()) {\n                throw new Exception (\"One or more files specified in fileNameList do not exist!\");\n            }\n            if (! tmpFileHandle.isFile ()) {\n                throw new Exception (\"One or more files specified in fileNameList is not a normal file!\");\n            }\n            if (! tmpFileHandle.canRead ()) {\n                throw new Exception (\"One or more files specified in fileNameList is not readable!\");\n            }\n            int fileSize = (int) tmpFileHandle.length ();\n            byte [] b = new byte [fileSize];\n            crc.reset ();\n            int bytesRead = 0;\n            while (fileSize > 0 && ((bytesRead = inputFile.read (b)) != - 1)) {\n                crc.update (b, 0, bytesRead);\n            }\n            tmpZipEntry = new ZipEntry (tmpFile);\n            tmpZipEntry.setMethod (ZipEntry.STORED);\n            tmpZipEntry.setCompressedSize (tmpFileHandle.length ());\n            tmpZipEntry.setSize (tmpFileHandle.length ());\n            tmpZipEntry.setCrc (crc.getValue ());\n            zipOutput.putNextEntry (tmpZipEntry);\n            zipOutput.write (b);\n            zipOutput.flush ();\n            inputFile.close ();\n        }\n        zipOutput.close ();\n    } catch (Exception ex) {\n        throw ex;\n    } finally {\n        if (zipOutput != null) {\n            zipOutput.close ();\n        }\n        if (inputFile != null) {\n            inputFile.close ();\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1708100, "method2_id": 4204663, "code1": "private void sendFile (File file, HttpExchange response) throws IOException {\n    response.getResponseHeaders ().add (FileUploadBase.CONTENT_LENGTH, Long.toString (file.length ()));\n    InputStream inputStream = null;\n    try {\n        inputStream = new FileInputStream (file);\n        IOUtils.copy (inputStream, response.getResponseBody ());\n    } catch (Exception exception) {\n        throw new IOException (\"error sending file\", exception);\n    } finally {\n        IOUtils.closeQuietly (inputStream);\n    }\n}\n", "code2": "@org.junit.Test\npublic void testReadWrite () throws Exception {\n    final byte [] testBytes = \"testString\".getBytes ();\n    final InputStream istream = new ByteArrayInputStream (testBytes);\n    final ByteArrayOutputStream destination = new ByteArrayOutputStream ();\n    final InputStream teeStream = new TeeInputStreamOutputStream (istream, destination);\n    IOUtils.copy (teeStream, new NullOutputStream ());\n    teeStream.close ();\n    assertArrayEquals (\"array are equals\", testBytes, destination.toByteArray ());\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4076629, "method2_id": 8788331, "code1": "public void uploadFile (String filename) throws RQLException {\n    checkFtpClient ();\n    OutputStream out = null;\n    try {\n        out = ftpClient.storeFileStream (filename);\n        IOUtils.copy (new FileReader (filename), out);\n        out.close ();\n        ftpClient.completePendingCommand ();\n    } catch (IOException ex) {\n        throw new RQLException (\"Upload of local file with name \" + filename + \" via FTP to server \" + server + \" failed.\", ex);\n    }\n}\n", "code2": "private void copyFromStdin (Path dst, FileSystem dstFs) throws IOException {\n    if (dstFs.isDirectory (dst)) {\n        throw new IOException (\"When source is stdin, destination must be a file.\");\n    }\n    if (dstFs.exists (dst)) {\n        throw new IOException (\"Target \" + dst.toString () + \" already exists.\");\n    }\n    FSDataOutputStream out = dstFs.create (dst);\n    try {\n        IOUtils.copyBytes (System.in, out, getConf (), false);\n    } finally {\n        out.close ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 5977352, "method2_id": 18465677, "code1": "public static void copyFile (File src, File dest, int bufSize, boolean force) throws IOException {\n    if (dest.exists ()) if (force) dest.delete ();\n    else throw new IOException (\"Cannot overwrite existing file: \" + dest.getName ());\n\n    byte [] buffer = new byte [bufSize];\n    int read = 0;\n    InputStream in = null;\n    OutputStream out = null;\n    try {\n        in = new FileInputStream (src);\n        out = new FileOutputStream (dest);\n        while (true) {\n            read = in.read (buffer);\n            if (read == - 1) break;\n\n            out.write (buffer, 0, read);\n        }\n    } finally {\n        if (in != null) try {\n            in.close ();\n        } finally {\n            if (out != null) out.close ();\n\n        }\n\n    }\n}\n", "code2": "public void download (RequestContext ctx) throws IOException {\n    if (ctx.isRobot ()) {\n        ctx.forbidden ();\n        return;\n    }\n    long id = ctx.id ();\n    File bean = File.INSTANCE.Get (id);\n    if (bean == null) {\n        ctx.not_found ();\n        return;\n    }\n    String f_ident = ctx.param (\"fn\", \"\");\n    if (id >= 100 && ! StringUtils.equals (f_ident, bean.getIdent ())) {\n        ctx.not_found ();\n        return;\n    }\n    if (bean.IsLoginRequired () && ctx.user () == null) {\n        StringBuilder login = new StringBuilder (LinkTool.home (\"home/login?goto_page=\"));\n        ctx.redirect (login.toString ());\n        return;\n    }\n    FileInputStream fis = null;\n    try {\n        java.io.File file = StorageService.FILES.readFile (bean.getPath ());\n        fis = new FileInputStream (file);\n        ctx.response ().setContentLength ((int) file.length ());\n        String ext = FilenameUtils.getExtension (bean.getPath ());\n        String mine_type = Multimedia.mime_types.get (ext);\n        if (mine_type != null) ctx.response ().setContentType (mine_type);\n\n        String ua = ctx.header (\"user-agent\");\n        if (ua != null && ua.indexOf (\"Firefox\") >= 0) ctx.header (\"Content-Disposition\", \"attachment; filename*=\\\"utf8''\" + LinkTool.encode_url (bean.getName ()) + \".\" + ext + \"\\\"\");\n        else ctx.header (\"Content-Disposition\", \"attachment; filename=\" + LinkTool.encode_url (bean.getName () + \".\" + ext));\n\n        IOUtils.copy (fis, ctx.response ().getOutputStream ());\n        bean.IncDownloadCount (1);\n    } finally {\n        IOUtils.closeQuietly (fis);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 624356, "method2_id": 753876, "code1": "public boolean start (ReportBridge bridge, Gedcom gedcom) {\n    String cmd = bridge.getValueFromUser (\"Please enter path and name of the executable to run\", new String [0], \"executables\");\n    try {\n        Process process = Runtime.getRuntime ().exec (cmd);\n        BufferedReader in = new BufferedReader (new InputStreamReader (process.getInputStream ()));\n        while (true) {\n            String line = in.readLine ();\n            if (line == null) break;\n\n            bridge.println (line);\n        }\n    } catch (IOException ioe) {\n        bridge.println (\"*** Sorry, failed with \" + ioe.getMessage ());\n    }\n    return true;\n}\n", "code2": "public int runLoad (int requestId, int loadId, int server) throws RemoteException {\n    int ret = 0;\n    try {\n        Process P;\n        System.out.println (\"LINUX: \" + linuxPath + \"/Load1 \" + requestId);\n        System.out.println (\"java \" + linuxPath + \"/LoadId \" + requestId);\n        if (loadId == 1) P = Runtime.getRuntime ().exec (\"cr_run java LoadId \" + requestId);\n        else P = Runtime.getRuntime ().exec (\"cr_run java LoadId \" + requestId);\n\n        StringBuffer strBuf = new StringBuffer ();\n        String strLine = \"\";\n        String strLine1 = \"\";\n        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));\n        while ((strLine = outCommand.readLine ()) != null) {\n            strLine1 = strLine;\n        }\n        P.waitFor ();\n        return ret;\n    } catch (Exception e) {\n        e.printStackTrace ();\n        return - 1;\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10052448, "method2_id": 18665189, "code1": "private void copyFileToStream (String filename, String dirname, ZipOutputStream zipper, String comment) throws IOException {\n    File file = new File (filename);\n    String entryName;\n    if (dirname != null) {\n        entryName = dirname + \"/\" + file.getName ();\n    } else {\n        entryName = file.getName ();\n    }\n    ZipEntry zipEntry = new ZipEntry (entryName);\n    zipEntry.setTime (file.lastModified ());\n    zipEntry.setSize (file.length ());\n    if (comment != null) {\n        zipEntry.setComment (comment);\n    }\n    zipper.putNextEntry (zipEntry);\n    FileInputStream fis = new FileInputStream (file);\n    try {\n        int c;\n        while ((c = fis.read ()) != - 1) {\n            zipper.write (c);\n        }\n    } finally {\n        fis.close ();\n    }\n    zipper.closeEntry ();\n}\n", "code2": "public static void saveZipFile (String srFile, String dtFile) {\n    try {\n        BufferedInputStream origin = null;\n        OutputStream dest = new FileOutputStream (dtFile);\n        CheckedOutputStream checksum = new CheckedOutputStream (dest, new Adler32 ());\n        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (checksum));\n        byte data [] = new byte [BUFFER];\n        File f = new File (srFile);\n        String [] files = f.list ();\n        for (int i = 0;\n        i < files.length; i ++) {\n            String fullname = f.getName () + \"/\" + files [i];\n            InputStream fi = new FileInputStream (fullname);\n            origin = new BufferedInputStream (fi, BUFFER);\n            ZipEntry entry = new ZipEntry (fullname);\n            out.putNextEntry (entry);\n            int count;\n            while ((count = origin.read (data, 0, BUFFER)) != - 1) {\n                out.write (data, 0, count);\n            }\n            origin.close ();\n        }\n        out.close ();\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 7945594, "method2_id": 17569036, "code1": "public static void fileDownload (String fAddress, String destinationDir) {\n    int slashIndex = fAddress.lastIndexOf ('/');\n    int periodIndex = fAddress.lastIndexOf ('.');\n    String fileName = fAddress.substring (slashIndex + 1);\n    URL url;\n    try {\n        url = new URL (fAddress);\n        URLConnection uc = url.openConnection ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (uc.getInputStream ()));\n        File file = new File (destinationDir + \"/download.pdf\");\n        FileOutputStream fos = new FileOutputStream (file);\n        BufferedWriter out = new BufferedWriter (new OutputStreamWriter (fos));\n        int inputLine;\n        while ((inputLine = in.read ()) != - 1) out.write (inputLine);\n\n        in.close ();\n    } catch (Exception ex) {\n        Logger.getLogger (UrlDownload.class.getName ()).log (Level.SEVERE, null, ex);\n    }\n}\n", "code2": "public void search () throws Exception {\n    URL searchurl = new URL (\"\" + \"http://www.ncbi.nlm.nih.gov/blast/Blast.cgi\" + \"?CMD=Put\" + \"&DATABASE=\" + this.database + \"&PROGRAM=\" + this.program + \"&QUERY=\" + this.sequence.seqString ());\n    BufferedReader reader = new BufferedReader (new InputStreamReader (searchurl.openStream (), \"UTF-8\"));\n    String line = \"\";\n    while ((line = reader.readLine ()) != null) {\n        if (line.contains (\"Request ID\")) this.rid += line.substring (70, 81);\n\n    }\n    reader.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 23537684, "method2_id": 23658098, "code1": "public static void copyResourceToFile (Class owningClass, String resourceName, File destinationDir) {\n    final byte [] resourceBytes = readResource (owningClass, resourceName);\n    final ByteArrayInputStream inputStream = new ByteArrayInputStream (resourceBytes);\n    final File destinationFile = new File (destinationDir, resourceName);\n    final FileOutputStream fileOutputStream;\n    try {\n        fileOutputStream = new FileOutputStream (destinationFile);\n    } catch (FileNotFoundException e) {\n        throw new RuntimeException (e);\n    }\n    try {\n        IOUtils.copy (inputStream, fileOutputStream);\n    } catch (IOException e) {\n        throw new RuntimeException (e);\n    }\n}\n", "code2": "public void copyFile (File in, File out) throws Exception {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 14864066, "method2_id": 17119760, "code1": "protected boolean downloadFile (TestThread thread, ActionResult result) {\n    result.setRequestString (\"download file \" + remoteFile);\n    InputStream input = null;\n    OutputStream output = null;\n    OutputStream target = null;\n    boolean status = false;\n    ftpClient.enterLocalPassiveMode ();\n    try {\n        if (localFile != null) {\n            File lcFile = new File (localFile);\n            if (lcFile.exists () && lcFile.isDirectory ()) output = new FileOutputStream (new File (lcFile, remoteFile));\n            else output = new FileOutputStream (lcFile);\n\n            target = output;\n        } else {\n            target = new FileOutputStream (remoteFile);\n        }\n        input = ftpClient.retrieveFileStream (remoteFile);\n        long bytes = IOUtils.copy (input, target);\n        status = bytes > 0;\n        if (status) {\n            result.setResponseLength (bytes);\n        }\n    } catch (Exception e) {\n        result.setException (new TestActionException (config, e));\n    } finally {\n        IOUtils.closeQuietly (input);\n        IOUtils.closeQuietly (output);\n    }\n    return status;\n}\n", "code2": "public void testReaderWriterF2 () throws Exception {\n    String inFile = \"test_data/mri.png\";\n    String outFile = \"test_output/mri__smooth_testReaderWriter.mhd\";\n    itkImageFileReaderF2_Pointer reader = itkImageFileReaderF2.itkImageFileReaderF2_New ();\n    itkImageFileWriterF2_Pointer writer = itkImageFileWriterF2.itkImageFileWriterF2_New ();\n    reader.SetFileName (inFile);\n    writer.SetFileName (outFile);\n    writer.SetInput (reader.GetOutput ());\n    writer.Update ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2943254, "method2_id": 12768281, "code1": "public void saveDownloadFiles (List downloadFiles) throws SQLException {\n    Connection conn = AppLayerDatabase.getInstance ().getPooledConnection ();\n    try {\n        conn.setAutoCommit (false);\n        Statement s = conn.createStatement ();\n        s.executeUpdate (\"DELETE FROM DOWNLOADFILES\");\n        s.close ();\n        s = null;\n        PreparedStatement ps = conn.prepareStatement (\"INSERT INTO DOWNLOADFILES \" + \"(name,targetpath,size,fnkey,enabled,state,downloadaddedtime,downloadstartedtime,downloadfinishedtime,\" + \"retries,lastdownloadstoptime,gqid,filelistfilesha) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)\");\n        for (Iterator i = downloadFiles.iterator ();\n        i.hasNext ();) {\n            FrostDownloadItem dlItem = (FrostDownloadItem) i.next ();\n            int ix = 1;\n            ps.setString (ix ++, dlItem.getFilename ());\n            ps.setString (ix ++, dlItem.getTargetPath ());\n            ps.setLong (ix ++, (dlItem.getFileSize () == null ? 0 : dlItem.getFileSize ().longValue ()));\n            ps.setString (ix ++, dlItem.getKey ());\n            ps.setBoolean (ix ++, (dlItem.isEnabled () == null ? true : dlItem.isEnabled ().booleanValue ()));\n            ps.setInt (ix ++, dlItem.getState ());\n            ps.setLong (ix ++, dlItem.getDownloadAddedTime ());\n            ps.setLong (ix ++, dlItem.getDownloadStartedTime ());\n            ps.setLong (ix ++, dlItem.getDownloadFinishedTime ());\n            ps.setInt (ix ++, dlItem.getRetries ());\n            ps.setLong (ix ++, dlItem.getLastDownloadStopTime ());\n            ps.setString (ix ++, dlItem.getGqIdentifier ());\n            ps.setString (ix ++, dlItem.getFileListFileObject () == null ? null : dlItem.getFileListFileObject ().getSha ());\n            ps.executeUpdate ();\n        }\n        ps.close ();\n        conn.commit ();\n        conn.setAutoCommit (true);\n    } catch (Throwable t) {\n        logger.log (Level.SEVERE, \"Exception during save\", t);\n        try {\n            conn.rollback ();\n        } catch (Throwable t1) {\n            logger.log (Level.SEVERE, \"Exception during rollback\", t1);\n        }\n        try {\n            conn.setAutoCommit (true);\n        } catch (Throwable t1) {\n        }\n    } finally {\n        AppLayerDatabase.getInstance ().givePooledConnection (conn);\n    }\n}\n", "code2": "int doOne (int bid, int tid, int aid, int delta) {\n    int aBalance = 0;\n    if (Conn == null) {\n        incrementFailedTransactionCount ();\n        return 0;\n    }\n    try {\n        if (prepared_stmt) {\n            pstmt1.setInt (1, delta);\n            pstmt1.setInt (2, aid);\n            pstmt1.executeUpdate ();\n            pstmt1.clearWarnings ();\n            pstmt2.setInt (1, aid);\n            ResultSet RS = pstmt2.executeQuery ();\n            pstmt2.clearWarnings ();\n            while (RS.next ()) {\n                aBalance = RS.getInt (1);\n            }\n            pstmt3.setInt (1, delta);\n            pstmt3.setInt (2, tid);\n            pstmt3.executeUpdate ();\n            pstmt3.clearWarnings ();\n            pstmt4.setInt (1, delta);\n            pstmt4.setInt (2, bid);\n            pstmt4.executeUpdate ();\n            pstmt4.clearWarnings ();\n            pstmt5.setInt (1, tid);\n            pstmt5.setInt (2, bid);\n            pstmt5.setInt (3, aid);\n            pstmt5.setInt (4, delta);\n            pstmt5.executeUpdate ();\n            pstmt5.clearWarnings ();\n        } else {\n            Statement Stmt = Conn.createStatement ();\n            String Query = \"UPDATE accounts \";\n            Query += \"SET     Abalance = Abalance + \" + delta + \" \";\n            Query += \"WHERE   Aid = \" + aid;\n            int res = Stmt.executeUpdate (Query);\n            Stmt.clearWarnings ();\n            Query = \"SELECT Abalance \";\n            Query += \"FROM   accounts \";\n            Query += \"WHERE  Aid = \" + aid;\n            ResultSet RS = Stmt.executeQuery (Query);\n            Stmt.clearWarnings ();\n            while (RS.next ()) {\n                aBalance = RS.getInt (1);\n            }\n            Query = \"UPDATE tellers \";\n            Query += \"SET    Tbalance = Tbalance + \" + delta + \" \";\n            Query += \"WHERE  Tid = \" + tid;\n            Stmt.executeUpdate (Query);\n            Stmt.clearWarnings ();\n            Query = \"UPDATE branches \";\n            Query += \"SET    Bbalance = Bbalance + \" + delta + \" \";\n            Query += \"WHERE  Bid = \" + bid;\n            Stmt.executeUpdate (Query);\n            Stmt.clearWarnings ();\n            Query = \"INSERT INTO history(Tid, Bid, Aid, delta) \";\n            Query += \"VALUES (\";\n            Query += tid + \",\";\n            Query += bid + \",\";\n            Query += aid + \",\";\n            Query += delta + \")\";\n            Stmt.executeUpdate (Query);\n            Stmt.clearWarnings ();\n            Stmt.close ();\n        }\n        if (transactions) {\n            Conn.commit ();\n        }\n        return aBalance;\n    } catch (Exception E) {\n        if (verbose) {\n            System.out.println (\"Transaction failed: \" + E.getMessage ());\n            E.printStackTrace ();\n        }\n        incrementFailedTransactionCount ();\n        if (transactions) {\n            try {\n                Conn.rollback ();\n            } catch (SQLException E1) {\n            }\n        }\n    }\n    return 0;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 21715891, "method2_id": 22427840, "code1": "protected void copy (File src, File dest) throws IOException {\n    if (src.isDirectory () && dest.isFile ()) throw new IOException (\"Cannot copy a directory to a file\");\n\n    if (src.isDirectory ()) {\n        File newDir = new File (dest, src.getName ());\n        if (! newDir.mkdirs ()) throw new IOException (\"Cannot create a new Directory\");\n\n        File [] entries = src.listFiles ();\n        for (int i = 0;\n        i < entries.length; ++ i) copy (entries [i], newDir);\n\n        return;\n    }\n    if (dest.isDirectory ()) {\n        File newFile = new File (dest, src.getName ());\n        newFile.createNewFile ();\n        copy (src, newFile);\n        return;\n    }\n    try {\n        if (src.length () == 0) {\n            dest.createNewFile ();\n            return;\n        }\n        FileChannel fc = new FileInputStream (src).getChannel ();\n        FileChannel dstChannel = new FileOutputStream (dest).getChannel ();\n        long transfered = 0;\n        long totalLength = src.length ();\n        while (transfered < totalLength) {\n            long num = fc.transferTo (transfered, totalLength - transfered, dstChannel);\n            if (num == 0) throw new IOException (\"Error while copying\");\n\n            transfered += num;\n        }\n        dstChannel.close ();\n        fc.close ();\n    } catch (IOException e) {\n        if (os.equals (\"Unix\")) {\n            _logger.fine (\"Trying to use cp to copy file...\");\n            File cp = new File (\"/usr/bin/cp\");\n            if (! cp.exists ()) cp = new File (\"/bin/cp\");\n\n            if (! cp.exists ()) cp = new File (\"/usr/local/bin/cp\");\n\n            if (! cp.exists ()) cp = new File (\"/sbin/cp\");\n\n            if (! cp.exists ()) cp = new File (\"/usr/sbin/cp\");\n\n            if (! cp.exists ()) cp = new File (\"/usr/local/sbin/cp\");\n\n            if (cp.exists ()) {\n                Process cpProcess = Runtime.getRuntime ().exec (cp.getAbsolutePath () + \" '\" + src.getAbsolutePath () + \"' '\" + dest.getAbsolutePath () + \"'\");\n                int errCode;\n                try {\n                    errCode = cpProcess.waitFor ();\n                } catch (java.lang.InterruptedException ie) {\n                    throw e;\n                }\n                return;\n            }\n        }\n        throw e;\n    }\n}\n", "code2": "public static void copyFile (File from, File to) {\n    try {\n        FileInputStream in = new FileInputStream (from);\n        FileOutputStream out = new FileOutputStream (to);\n        byte [] buffer = new byte [1024 * 16];\n        int read = 0;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        in.close ();\n        out.close ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1423646, "method2_id": 21438069, "code1": "public void removerDisciplina (Disciplina disciplina) throws ClassNotFoundException, SQLException {\n    this.criaConexao (false);\n    String sql = \"DELETE FROM \\\"Disciplina\\\"    \" + \"      WHERE ID_Disciplina =  ? )\";\n    PreparedStatement stmt = null;\n    try {\n        stmt = connection.prepareStatement (sql);\n        stmt.setString (1, disciplina.getId ());\n        stmt.executeUpdate ();\n        connection.commit ();\n    } catch (SQLException e) {\n        connection.rollback ();\n        throw e;\n    } finally {\n        try {\n            stmt.close ();\n            this.fechaConexao ();\n        } catch (SQLException e) {\n            throw e;\n        }\n    }\n}\n", "code2": "public ProjectDeploymentConfiguration createNewProjectDeploymentConfig (int projectID, String name, String description) throws AdaptationException {\n    ProjectDeploymentConfiguration config = null;\n    Connection connection = null;\n    Statement statement = null;\n    ResultSet resultSet = null;\n    try {\n        String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n        connection = DriverManager.getConnection (CONN_STR);\n        statement = connection.createStatement ();\n        statement.executeUpdate (query);\n        query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n        resultSet = statement.executeQuery (query);\n        if (! resultSet.next ()) {\n            connection.rollback ();\n            String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n            log.error (msg);\n            throw new AdaptationException (msg);\n        }\n        config = getProjectDeploymentConfiguration (resultSet);\n        connection.commit ();\n    } catch (SQLException ex) {\n        try {\n            connection.rollback ();\n        } catch (Exception e) {\n        }\n        String msg = \"SQLException in createNewProjectDeploymentConfig\";\n        log.error (msg, ex);\n        throw new AdaptationException (msg, ex);\n    } finally {\n        try {\n            resultSet.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            statement.close ();\n        } catch (Exception ex) {\n        }\n        try {\n            connection.close ();\n        } catch (Exception ex) {\n        }\n    }\n    return config;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 13563706, "method2_id": 16590954, "code1": "public void doGet (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    String selectedPage = request.getParameter (\"SelectedPage\");\n    Page page = null;\n    PortalRequest portalRequest = PortalRequest.getCurrentRequest ();\n    if (selectedPage == null) {\n        try {\n            Property pageProp = Property.getProperty (\"HomePage\");\n            selectedPage = pageProp.getValue ();\n        } catch (PersistentModelException e) {\n            myLogger.info (\"Page could not be found due to an exception\");\n            response.sendError (response.SC_NOT_FOUND);\n            return;\n        }\n    }\n    myLogger.info (\"Handling Page Request for Page \" + selectedPage);\n    try {\n        if (page == null) {\n            try {\n                page = Page.getPage (Long.parseLong (selectedPage));\n            } catch (NumberFormatException e) {\n                List < Page > possiblePage = Page.findByName (selectedPage);\n                if (possiblePage.size () > 0) {\n                    page = possiblePage.get (0);\n                } else {\n                    response.sendError (response.SC_NOT_FOUND);\n                    return;\n                }\n            }\n        }\n        if (! page.isVisibleTo (portalRequest.getCurrentUser ())) {\n            Property pageProp = Property.getProperty (\"HomePage\");\n            selectedPage = pageProp.getValue ();\n            page = Page.getPage (Long.parseLong (selectedPage));\n        }\n        try {\n            Property property = Property.getProperty (\"LogPageRequests\");\n            if (property.getValue ().toLowerCase ().equals (\"true\")) {\n                String referer = request.getHeader (\"Referer\");\n                if (referer == null || referer.indexOf (portalRequest.getRequest ().getServerName ()) > 0) {\n                    referer = \" \";\n                } else {\n                    if (referer.length () >= 200) {\n                        referer = referer.substring (0, 198);\n                    }\n                }\n                PageRequest.createRequest (portalRequest.getCurrentHREF (), page, portalRequest.getCurrentUser (), portalRequest.getRequest ().getRemoteAddr (), referer);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log (Level.WARNING, \"Log Page Requests property was not found.\", e);\n        }\n        if (page.isVisibleTo (portalRequest.getCurrentUser ())) {\n            HttpSession session = request.getSession ();\n            if (session != null) {\n                RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute (\"ipoint.RecentlyViewedManager\");\n                if (rvm == null) {\n                    rvm = new RecentlyViewedManager ();\n                }\n                rvm.add (page);\n                session.setAttribute (\"ipoint.RecentlyViewedManager\", rvm);\n            }\n            PageCacheEntry entry = null;\n            if (! portalRequest.isPost () && ! page.isEditableBy (portalRequest.getCurrentUser ())) {\n                try {\n                    int pageCacheTime = 60000;\n                    try {\n                        Property pageCacheTimeProperty = Property.getProperty (\"PageCacheTime\");\n                        pageCacheTime = Integer.parseInt (pageCacheTimeProperty.getValue ());\n                        pageCacheTime *= 1000;\n                    } catch (PersistentModelException pme) {\n                        myLogger.warning (\"Ignoring Exception when retrieving PageCacheTime property\");\n                    } catch (NumberFormatException nfe) {\n                    }\n                    entry = PageCacheEntry.find (portalRequest.getCurrentHREF (), page, portalRequest.getCurrentUser (), pageCacheTime);\n                } catch (PersistentModelException e) {\n                    myLogger.log (Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                }\n            }\n            response.setContentType (\"text/html\");\n            response.setHeader (\"Cache-Control\", \"no-cache\");\n            boolean processed = false;\n            if (entry != null) {\n                String tempFile = entry.getTempFile ();\n                File file = new File (tempFile);\n                if (file.exists () && file.isFile () && file.canRead ()) {\n                    FileReader reader = new FileReader (file);\n                    BufferedReader br = new BufferedReader (reader);\n                    PrintWriter out = response.getWriter ();\n                    out.write (\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime () + \" ms -->\\n\");\n                    while (br.ready ()) {\n                        out.write (br.readLine () + \"\\n\");\n                    }\n                    out.write (\"<!-- Cached output produced in \" + portalRequest.elapsedTime () + \" ms -->\\n\");\n                    reader.close ();\n                    processed = true;\n                    portalRequest.getMBeans ().incrementStatistics (ManagementMBeans.StatisticsType.PageTotal, page.getName () + \"-\" + page.getID (), portalRequest.elapsedTime (), true);\n                } else {\n                    entry.delete ();\n                }\n            }\n            if (! processed) {\n                PrintWriter out = response.getWriter ();\n                out.write (\"<!-- Output produced by iPoint Portal -->\\n\");\n                PageRenderer renderer = new PageRenderer (page);\n                long startTime = System.currentTimeMillis ();\n                request.setAttribute (ELConstants.IPOINT_USER, portalRequest.getCurrentUser ());\n                request.setAttribute (ELConstants.IPOINT_PAGE, page);\n                request.setAttribute (ELConstants.IPOINT_TEMPLATE, page.getTemplate ());\n                request.setAttribute (ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap ());\n                request.setAttribute (ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser ().getProperties ());\n                renderer.preProcess ();\n                portalRequest.getMBeans ().incrementStatistics (ManagementMBeans.StatisticsType.PagePreProcess, page.getName () + \"-\" + page.getID (), System.currentTimeMillis () - startTime, false);\n                long renderStart = System.currentTimeMillis ();\n                renderer.render ();\n                portalRequest.getMBeans ().incrementStatistics (ManagementMBeans.StatisticsType.PageRender, page.getName () + \"-\" + page.getID (), System.currentTimeMillis () - renderStart, false);\n                portalRequest.getMBeans ().incrementStatistics (ManagementMBeans.StatisticsType.PageTotal, page.getName () + \"-\" + page.getID (), System.currentTimeMillis () - startTime, false);\n                out.write (\"<!-- output produced in \" + PortalRequest.getCurrentRequest ().elapsedTime () + \" ms -->\\n\");\n                if (! page.isEditableBy (portalRequest.getCurrentUser ())) {\n                    if (response instanceof CachingResponseWrapper) {\n                        CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                        crw.flushBuffer ();\n                        Property tempProperty = Property.getProperty (\"UploadLocation\");\n                        File tempDirectory = new File (tempProperty.getValue ());\n                        if (tempDirectory.exists () && tempDirectory.canWrite ()) {\n                            File file = File.createTempFile (\"iPointPage\", \".html\", tempDirectory);\n                            try {\n                                FileWriter fw = new FileWriter (file);\n                                fw.write (crw.getOutput ());\n                                fw.flush ();\n                                fw.close ();\n                                PageCacheEntry.create (portalRequest.getCurrentHREF (), page, portalRequest.getCurrentUser (), file.getAbsolutePath ());\n                            } catch (IOException e) {\n                            }\n                        } else {\n                            myLogger.warning (\"Can not write to directory \" + tempProperty.getValue ());\n                        }\n                    }\n                }\n            }\n        } else {\n            myLogger.info (\"Current User is Forbidden from seeing this Page\");\n            response.sendError (response.SC_FORBIDDEN);\n        }\n    } catch (PersistentModelException e) {\n        myLogger.log (Level.INFO, \"Unable to find page \" + selectedPage, e);\n        response.sendError (response.SC_NOT_FOUND);\n    } catch (PresentationException pe) {\n        pe.printStackTrace ();\n        throw new ServletException (\"Error processing the page\", pe);\n    }\n}\n", "code2": "public void createJAR (String fileString, String ext) {\n    try {\n        File file = new File (fileString);\n        int i = fileString.lastIndexOf (java.io.File.separator);\n        String dir = fileString.substring (0, i + 1);\n        if (ext.matches (\"jar\")) {\n            jarFile = new File (getClass ().getClassLoader ().getResource (\"jsdviewer.jar\").toURI ());\n            java.io.FileOutputStream fstrm = new java.io.FileOutputStream (file);\n            FileChannel in = (new java.io.FileInputStream (jarFile)).getChannel ();\n            FileChannel out = fstrm.getChannel ();\n            in.transferTo (0, jarFile.length (), out);\n            in.close ();\n            out.close ();\n        } else {\n            file.mkdir ();\n        }\n        File.umount (file);\n        File temp = new File (dir + \"document.jsd\");\n        FileOutputStream fstrm2 = new FileOutputStream (temp.getCanonicalPath ());\n        ostrm = new ObjectOutputStream (fstrm2);\n        ostrm.writeObject (doc);\n        ostrm.flush ();\n        ostrm.close ();\n        File.umount ();\n        File docFile = new File (file.getCanonicalPath () + java.io.File.separator + \"document.jsd\");\n        File.cp_p (temp, docFile);\n        File.umount ();\n        temp.delete ();\n        File.umount (file);\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 442381, "method2_id": 7760031, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "private void loadDateFormats () {\n    String fileToLocate = \"/\" + FILENAME_DATE_FMT;\n    URL url = getClass ().getClassLoader ().getResource (fileToLocate);\n    if (url == null) {\n        return;\n    }\n    List < String > lines;\n    try {\n        lines = IOUtils.readLines (url.openStream ());\n    } catch (IOException e) {\n        throw new ConfigurationException (\"Problem loading file \" + fileToLocate, e);\n    }\n    for (String line : lines) {\n        if (line.startsWith (\"#\") || StringUtils.isBlank (line)) {\n            continue;\n        }\n        String [] parts = StringUtils.split (line, \"=\");\n        addFormat (parts [0], new SimpleDateFormat (parts [1]));\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 18324701, "method2_id": 20591865, "code1": "public final boolean parseAuxFile (String filename) {\n    Pattern pattern;\n    Matcher matcher;\n    boolean weiter = false;\n    boolean back = true;\n    boolean loopFileOpen = false;\n    pattern = Pattern.compile (\"\\\\\\\\citation\\\\{.+\\\\}\");\n    BufferedReader br = null;\n    Vector < String > fileList = new Vector < String > (5);\n    fileList.add (filename);\n    File dummy = new File (filename);\n    String path = dummy.getParent ();\n    if (path != null) path = path + File.separator;\n    else path = \"\";\n\n    nestedAuxCounter = - 1;\n    int fileIndex = 0;\n    while (fileIndex < fileList.size ()) {\n        String fName = fileList.elementAt (fileIndex);\n        try {\n            br = new BufferedReader (new FileReader (fName));\n            weiter = true;\n            loopFileOpen = true;\n        } catch (FileNotFoundException fnfe) {\n            System.out.println (\"Cannot locate input file! \" + fnfe.getMessage ());\n            back = false;\n            weiter = false;\n            loopFileOpen = false;\n        }\n        while (weiter) {\n            String line;\n            try {\n                if (br == null) throw new IOException ();\n\n                line = br.readLine ();\n            } catch (IOException ioe) {\n                line = null;\n                weiter = false;\n            }\n            if (line != null) {\n                matcher = pattern.matcher (line);\n                while (matcher.find ()) {\n                    int len = matcher.end () - matcher.start ();\n                    if (len > 11) {\n                        String str = matcher.group ().substring (matcher.start () + 10, matcher.end () - 1);\n                        String keys [] = str.split (\",\");\n                        if (keys != null) {\n                            int keyCount = keys.length;\n                            for (int t = 0;\n                            t < keyCount; t ++) {\n                                String dummyStr = keys [t];\n                                if (dummyStr != null) {\n                                    mySet.add (dummyStr.trim ());\n                                }\n                            }\n                        }\n                    }\n                }\n                int index = line.indexOf (\"\\\\@input{\");\n                if (index >= 0) {\n                    int start = index + 8;\n                    int end = line.indexOf (\"}\", start);\n                    if (end > start) {\n                        String str = path + line.substring (index + 8, end);\n                        if (! fileList.contains (str)) {\n                            fileList.add (str);\n                        }\n                    }\n                }\n            } else weiter = false;\n\n        }\n        if (loopFileOpen) {\n            try {\n                if (br != null) br.close ();\n\n                nestedAuxCounter ++;\n            } catch (IOException ioe) {\n            }\n        }\n        fileIndex ++;\n    }\n    return back;\n}\n", "code2": "public static String autoLink (final String txt) {\n    if (url_pattern == null) {\n        url_pattern = Pattern.compile (\"(http(s)?|ftp)://([\\\\w-]+\\\\.)+[\\\\w-]+(/[\\\\w-./?%&=]*)?\");\n    }\n    final StringBuilder html = new StringBuilder ();\n    int lastIdx = 0;\n    final Matcher matchr = url_pattern.matcher (txt);\n    while (matchr.find ()) {\n        final String str = matchr.group ();\n        html.append (txt.substring (lastIdx, matchr.start ()));\n        html.append (\"<a target=\\\"_blank\\\" href=\\\"\");\n        html.append (str).append (\"\\\">\").append (str).append (\"</a>\");\n        lastIdx = matchr.end ();\n    }\n    html.append (txt.substring (lastIdx));\n    return html.toString ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 14129929, "method2_id": 22327409, "code1": "public static void copy (String sourceFile, String targetFile) throws IOException {\n    FileChannel sourceChannel = new FileInputStream (sourceFile).getChannel ();\n    FileChannel targetChannel = new FileOutputStream (targetFile).getChannel ();\n    targetChannel.transferFrom (sourceChannel, 0, sourceChannel.size ());\n    sourceChannel.close ();\n    targetChannel.close ();\n}\n", "code2": "@Override\nprotected void doPost (HttpServletRequest request, HttpServletResponse response) throws ServletException {\n    PrintWriter writer = null;\n    InputStream is = null;\n    FileOutputStream fos = null;\n    try {\n        writer = response.getWriter ();\n    } catch (IOException ex) {\n        log (OctetStreamReader.class.getName () + \"has thrown an exception: \" + ex.getMessage ());\n    }\n    String filename = request.getHeader (\"X-File-Name\");\n    try {\n        is = request.getInputStream ();\n        fos = new FileOutputStream (new File (targetPath + filename));\n        IOUtils.copy (is, fos);\n        response.setStatus (HttpServletResponse.SC_OK);\n        writer.print (\"{success: true}\");\n    } catch (FileNotFoundException ex) {\n        response.setStatus (HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        writer.print (\"{success: false}\");\n        log (OctetStreamReader.class.getName () + \"has thrown an exception: \" + ex.getMessage ());\n    } catch (IOException ex) {\n        response.setStatus (HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        writer.print (\"{success: false}\");\n        log (OctetStreamReader.class.getName () + \"has thrown an exception: \" + ex.getMessage ());\n    } finally {\n        try {\n            fos.close ();\n            is.close ();\n        } catch (IOException ignored) {\n        }\n    }\n    writer.flush ();\n    writer.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 17061710, "method2_id": 19214553, "code1": "public int [] [] simulate () {\n    int [] [] data = new int [n] [loci];\n    int [] [] tetrad = new int [4] [loci];\n    int [] iAndj = new int [2];\n    for (int i = 0;\n    i < n; i ++) {\n        tetrad = new int [4] [loci];\n        tetrad [0] [0] = 1;\n        tetrad [1] [0] = 1;\n        tetrad [2] [0] = 0;\n        tetrad [3] [0] = 0;\n        for (int index = 1;\n        index < loci; index ++) {\n            iAndj = getIandJ (cProb [index - 1]);\n            int swap = 0;\n            switch (iAndj [0]) {\n                case 0 :\n                    tetrad [0] [index] = tetrad [0] [index - 1];\n                    tetrad [1] [index] = tetrad [1] [index - 1];\n                    tetrad [2] [index] = tetrad [2] [index - 1];\n                    tetrad [3] [index] = tetrad [3] [index - 1];\n                    break;\n                case 1 :\n                    tetrad [0] [index] = tetrad [2] [index - 1];\n                    tetrad [1] [index] = tetrad [1] [index - 1];\n                    tetrad [2] [index] = tetrad [0] [index - 1];\n                    tetrad [3] [index] = tetrad [3] [index - 1];\n                    break;\n                case 2 :\n                    tetrad [0] [index] = tetrad [0] [index - 1];\n                    tetrad [1] [index] = tetrad [2] [index - 1];\n                    tetrad [2] [index] = tetrad [1] [index - 1];\n                    tetrad [3] [index] = tetrad [3] [index - 1];\n                    break;\n                case 3 :\n                    tetrad [0] [index] = tetrad [0] [index - 1];\n                    tetrad [1] [index] = tetrad [3] [index - 1];\n                    tetrad [2] [index] = tetrad [2] [index - 1];\n                    tetrad [3] [index] = tetrad [1] [index - 1];\n                    break;\n                case 4 :\n                    tetrad [0] [index] = tetrad [3] [index - 1];\n                    tetrad [1] [index] = tetrad [1] [index - 1];\n                    tetrad [2] [index] = tetrad [2] [index - 1];\n                    tetrad [3] [index] = tetrad [0] [index - 1];\n                    break;\n            }\n            switch (iAndj [1]) {\n                case 0 :\n                    tetrad [0] [index] = tetrad [0] [index];\n                    tetrad [1] [index] = tetrad [1] [index];\n                    tetrad [2] [index] = tetrad [2] [index];\n                    tetrad [3] [index] = tetrad [3] [index];\n                    break;\n                case 1 :\n                    swap = tetrad [0] [index];\n                    tetrad [0] [index] = tetrad [2] [index];\n                    tetrad [1] [index] = tetrad [1] [index];\n                    tetrad [2] [index] = swap;\n                    tetrad [3] [index] = tetrad [3] [index];\n                    break;\n                case 2 :\n                    swap = tetrad [1] [index];\n                    tetrad [0] [index] = tetrad [0] [index];\n                    tetrad [1] [index] = tetrad [2] [index];\n                    tetrad [2] [index] = swap;\n                    tetrad [3] [index] = tetrad [3] [index];\n                    break;\n                case 3 :\n                    swap = tetrad [1] [index];\n                    tetrad [0] [index] = tetrad [0] [index];\n                    tetrad [1] [index] = tetrad [3] [index];\n                    tetrad [2] [index] = tetrad [2] [index];\n                    tetrad [3] [index] = swap;\n                    break;\n                case 4 :\n                    swap = tetrad [0] [index];\n                    tetrad [0] [index] = tetrad [3] [index];\n                    tetrad [1] [index] = tetrad [1] [index];\n                    tetrad [2] [index] = tetrad [2] [index];\n                    tetrad [3] [index] = swap;\n                    break;\n            }\n        }\n        data [i] = tetrad [randomIndex ()];\n    }\n    int [] [] rflp = new int [data [0].length] [data.length];\n    for (int index1 = 0;\n    index1 < data [0].length; index1 ++) {\n        for (int index2 = 0;\n        index2 < data.length; index2 ++) {\n            rflp [index1] [index2] = data [index2] [index1];\n        }\n    }\n    return rflp;\n}\n", "code2": "public IntSquareMatrix copyUpperToLower () {\n    for (int i = 0;\n    i < cols - 1; i ++) {\n        for (int j = i + 1;\n        j < cols; j ++) {\n            flmat [j] [i] = flmat [i] [j];\n        }\n    }\n    return this;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9782242, "method2_id": 18599251, "code1": "private void createUser (AddEditUserForm addform, HttpServletRequest request, ActionMapping mapping) throws Exception {\n    MessageDigest md = (MessageDigest) MessageDigest.getInstance (\"MD5\").clone ();\n    md.update (addform.getPassword ().getBytes (\"UTF-8\"));\n    byte [] pd = md.digest ();\n    StringBuffer app = new StringBuffer ();\n    for (int i = 0;\n    i < pd.length; i ++) {\n        String s2 = Integer.toHexString (pd [i] & 0xFF);\n        app.append ((s2.length () == 1) ? \"0\" + s2 : s2);\n    }\n    Session hbsession = HibernateUtil.currentSession ();\n    try {\n        Transaction tx = hbsession.beginTransaction ();\n        NvUsers user = new NvUsers ();\n        user.setLogin (addform.getLogin ());\n        user.setPassword (app.toString ());\n        hbsession.save (user);\n        hbsession.flush ();\n        if (! hbsession.connection ().getAutoCommit ()) {\n            tx.commit ();\n        }\n    } finally {\n        HibernateUtil.closeSession ();\n    }\n}\n", "code2": "public static String hash (String plainTextPwd) {\n    MessageDigest hashAlgo;\n    try {\n        hashAlgo = java.security.MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new QwickException (e);\n    }\n    hashAlgo.update (plainTextPwd.getBytes ());\n    return new String (hashAlgo.digest ());\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10912335, "method2_id": 11705784, "code1": "public void guardarCantidad () {\n    try {\n        String can = String.valueOf (cantidadArchivos);\n        File archivo = new File (\"cantidadArchivos.txt\");\n        FileWriter fw = new FileWriter (archivo);\n        BufferedWriter bw = new BufferedWriter (fw);\n        PrintWriter salida = new PrintWriter (bw);\n        salida.print (can);\n        salida.close ();\n        BufferedInputStream origin = null;\n        FileOutputStream dest = new FileOutputStream (\"cantidadArchivos.zip\");\n        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));\n        byte data [] = new byte [buffer];\n        File f = new File (\"cantidadArchivos.txt\");\n        FileInputStream fi = new FileInputStream (f);\n        origin = new BufferedInputStream (fi, buffer);\n        ZipEntry entry = new ZipEntry (\"cantidadArchivos.txt\");\n        out.putNextEntry (entry);\n        int count;\n        while ((count = origin.read (data, 0, buffer)) != - 1) out.write (data, 0, count);\n\n        out.close ();\n    } catch (Exception e) {\n        JOptionPane.showMessageDialog (null, \"Error en: \" + e.toString (), \"Error\", JOptionPane.ERROR_MESSAGE);\n    }\n}\n", "code2": "private void saveInternal (File file, Collection < EdgeMappingDescriptor > descriptors, TaskMonitor monitor) throws IOException {\n    if (! file.getName ().endsWith (\".ov1\")) {\n        file = new File (file.getAbsolutePath () + \".ov1\");\n    }\n    File graphFile = OndexPlugin.getInstance ().getOndexGraphFile ();\n    File mappingFile = new File (System.getProperty (\"java.io.tmpdir\") + File.separator + \"ondex_mapping.tsv\");\n    monitor.setStatus (\"saving mapping descriptors...\");\n    monitor.setPercentCompleted (10);\n    saveMapping (mappingFile, descriptors);\n    File [] inFiles = new File [] {graphFile, mappingFile};\n    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (file));\n    monitor.setStatus (\"compressing...\");\n    for (File inFile : inFiles) {\n        FileInputStream in = new FileInputStream (inFile);\n        out.putNextEntry (new ZipEntry (inFile.getName ()));\n        int len;\n        byte [] buf = new byte [1024];\n        while ((len = in.read (buf)) > 0) {\n            out.write (buf, 0, len);\n        }\n        in.close ();\n        out.closeEntry ();\n    }\n    out.close ();\n    monitor.setPercentCompleted (95);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 11082670, "method2_id": 17804386, "code1": "@SuppressWarnings(\"unchecked\")\npublic List < Event > lookupFutureEvents (String groupIdentifier) throws GtugsException {\n    StringBuilder json = new StringBuilder ();\n    String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n    try {\n        URL url = new URL (requestUrl.toString ());\n        BufferedReader in = new BufferedReader (new InputStreamReader (url.openStream ()));\n        String inputLine;\n        while ((inputLine = in.readLine ()) != null) {\n            json.append (inputLine);\n        }\n        in.close ();\n    } catch (IOException e) {\n        throw new GtugsException (e);\n    }\n    List < Event > events = new ArrayList < Event > ();\n    JSONObject jsonObj = (JSONObject) JSONValue.parse (json.toString ());\n    JSONArray results = (JSONArray) jsonObj.get (\"results\");\n    for (int i = 0;\n    i < results.size (); i ++) {\n        JSONObject result = (JSONObject) results.get (i);\n        Event e = new Event ();\n        e.setAttendeeCount (Integer.parseInt ((String) result.get (\"rsvpcount\")));\n        e.setCity ((String) result.get (\"venue_city\"));\n        e.setDescription ((String) result.get (\"description\"));\n        e.setLatitude (Double.parseDouble ((String) result.get (\"venue_lat\")));\n        e.setLongitude (Double.parseDouble ((String) result.get (\"venue_lon\")));\n        e.setName ((String) result.get (\"name\"));\n        Date myDate = null;\n        String time = (String) result.get (\"time\");\n        try {\n            myDate = meetupDateFormat.parse (time);\n            e.setStartTime (timeDateFormat.format (myDate));\n            e.setEndTime (timeDateFormat.format (myDate));\n            e.setStartDate (myDate);\n            e.setEndDate (myDate);\n            String tz = tzDateFormat.format (myDate);\n            if (tz != null && tz.startsWith (\"+\")) {\n                tz = tz.substring (1);\n            }\n            e.setTimeZone (Integer.toString (Integer.parseInt (tz) / 100));\n        } catch (ParseException ex) {\n            ex.printStackTrace ();\n            continue;\n        }\n        e.setState ((String) result.get (\"venue_state\"));\n        StringBuilder addressBuilder = new StringBuilder ();\n        if (result.get (\"venue_address1\") != null) {\n            addressBuilder.append ((String) result.get (\"venue_address1\") + \" \");\n        }\n        if (result.get (\"venue_address2\") != null) {\n            addressBuilder.append ((String) result.get (\"venue_address2\") + \" \");\n        }\n        if (result.get (\"venue_address3\") != null) {\n            addressBuilder.append ((String) result.get (\"venue_address3\") + \" \");\n        }\n        if (result.get (\"venue_address4\") != null) {\n            addressBuilder.append ((String) result.get (\"venue_address4\"));\n        }\n        e.setStreetAddress (addressBuilder.toString ().trim ());\n        e.setZipCode ((String) result.get (\"venue_zip\"));\n        e.setUrl ((String) result.get (\"event_url\"));\n        events.add (e);\n    }\n    return events;\n}\n", "code2": "public void refreshStatus () {\n    if (! enabledDisplay) return;\n\n    try {\n        String url = getServerFortURL ();\n        BufferedReader reader = new BufferedReader (new InputStreamReader (new URL (url).openStream ()));\n        String data = null;\n        int counter = 0;\n        while ((data = reader.readLine ()) != null && counter < 9) {\n            status [counter] = UNKNOWN;\n            if (data.matches (\".*_alsius.gif.*\")) {\n                status [counter] = ALSIUS;\n                counter ++;\n            }\n            if (data.matches (\".*_syrtis.gif.*\")) {\n                status [counter] = SYRTIS;\n                counter ++;\n            }\n            if (data.matches (\".*_ignis.gif.*\")) {\n                status [counter] = IGNIS;\n                counter ++;\n            }\n        }\n    } catch (Exception exc) {\n        for (int i = 0;\n        i < status.length; i ++) status [i] = UNKNOWN;\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 14776293, "method2_id": 22716726, "code1": "@Override\npublic void listener (UploadEvent event) throws Exception {\n    this.log.debug (\"listener\");\n    UploadItem item = event.getUploadItem ();\n    this.log.debug (\"filename: #0\", item.getFileName ());\n    this.filename = item.getFileName ();\n    this.log.debug (\"content type: #0\", item.getContentType ());\n    String extension = FilenameUtils.getExtension (this.filename).toLowerCase ();\n    this.contentType = supportedFileExtensions.get (extension);\n    if (null == this.contentType) {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream ();\n        ZipOutputStream zipOutputStream = new ZipOutputStream (outputStream);\n        ZipEntry zipEntry = new ZipEntry (this.filename);\n        zipOutputStream.putNextEntry (zipEntry);\n        IOUtils.write (item.getData (), zipOutputStream);\n        zipOutputStream.close ();\n        this.filename = FilenameUtils.getBaseName (this.filename) + \".zip\";\n        this.document = outputStream.toByteArray ();\n        this.contentType = \"application/zip\";\n        return;\n    }\n    this.log.debug (\"file size: #0\", item.getFileSize ());\n    this.log.debug (\"data bytes available: #0\", (null != item.getData ()));\n    if (null != item.getData ()) {\n        this.document = item.getData ();\n        return;\n    }\n    File file = item.getFile ();\n    if (null != file) {\n        this.log.debug (\"tmp file: #0\", file.getAbsolutePath ());\n        this.document = FileUtils.readFileToByteArray (file);\n    }\n}\n", "code2": "public static File zipFile (String pathToBeZipped, String pathZippedFile) throws IOException {\n    if (pathZippedFile.indexOf (\".zip\") < 0) {\n        pathZippedFile += \".zip\";\n    }\n    File fileASerZipado = new File (pathToBeZipped);\n    byte [] buf = new byte [BUFFER_SIZE];\n    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (pathZippedFile));\n    FileInputStream in = new FileInputStream (pathToBeZipped);\n    out.putNextEntry (new ZipEntry (fileASerZipado.getName ()));\n    int len;\n    while ((len = in.read (buf)) > 0) {\n        out.write (buf, 0, len);\n    }\n    out.closeEntry ();\n    in.close ();\n    out.close ();\n    return new File (pathZippedFile);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 13946915, "method2_id": 23114340, "code1": "public void handleEntry (ZipEntry entry, byte [] byteCode) throws Exception {\n    logger.verbose (\"starting entry : \" + entry.toString ());\n    if (! entry.isDirectory ()) {\n        DataInputStream din = new DataInputStream (new ByteArrayInputStream (byteCode));\n        if (din.readInt () == CLASS_MAGIC) {\n            ClassDescriptor descriptor = getClassDescriptor (byteCode);\n            ClassTransformer transformer = getClassTransformer (descriptor);\n            if (transformer == null) {\n                logger.verbose (\"skipping entry : \" + entry.toString ());\n            } else {\n                logger.info (\"processing class [\" + descriptor.getName () + \"]; entry = \" + file.toURL ());\n                byteCode = transformer.transform (getClass ().getClassLoader (), descriptor.getName (), null, null, descriptor.getBytes ());\n            }\n        } else {\n            logger.verbose (\"ignoring zip entry : \" + entry.toString ());\n        }\n    }\n    ZipEntry outEntry = new ZipEntry (entry.getName ());\n    outEntry.setMethod (entry.getMethod ());\n    outEntry.setComment (entry.getComment ());\n    outEntry.setSize (byteCode.length);\n    if (outEntry.getMethod () == ZipEntry.STORED) {\n        CRC32 crc = new CRC32 ();\n        crc.update (byteCode);\n        outEntry.setCrc (crc.getValue ());\n        outEntry.setCompressedSize (byteCode.length);\n    }\n    out.putNextEntry (outEntry);\n    out.write (byteCode);\n    out.closeEntry ();\n}\n", "code2": "protected static void saveRom (E4Device device) throws IOException {\n    File file = new File (device.remote.getDeviceLocalDir (), LAST_ROM_SESSION_FILENAME + \".\" + SESSION_EXT);\n    Object [] rom = device.sampleDB.getRomSnapshot ();\n    ZipOutputStream zos = null;\n    ObjectOutputStream oos = null;\n    zos = new ZipOutputStream (new FileOutputStream (file));\n    zos.setMethod (ZipOutputStream.DEFLATED);\n    zos.setLevel (Deflater.BEST_SPEED);\n    zos.putNextEntry (new ZipEntry (FLASH_SESSION_CONTENT_ENTRY));\n    oos = new ObjectOutputStream (zos);\n    oos.writeObject (rom);\n    oos.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 730844, "method2_id": 3068587, "code1": "private static boolean loadClasses () {\n    switch (jvm) {\n        case MRJ_2_0 :\n            try {\n                Class aeTargetClass = Class.forName (\"com.apple.MacOS.AETarget\");\n                Class osUtilsClass = Class.forName (\"com.apple.MacOS.OSUtils\");\n                Class appleEventClass = Class.forName (\"com.apple.MacOS.AppleEvent\");\n                Class aeClass = Class.forName (\"com.apple.MacOS.ae\");\n                aeDescClass = Class.forName (\"com.apple.MacOS.AEDesc\");\n                aeTargetConstructor = aeTargetClass.getDeclaredConstructor (new Class [] {int.class});\n                appleEventConstructor = appleEventClass.getDeclaredConstructor (new Class [] {int.class, int.class, aeTargetClass, int.class, int.class});\n                aeDescConstructor = aeDescClass.getDeclaredConstructor (new Class [] {String.class});\n                makeOSType = osUtilsClass.getDeclaredMethod (\"makeOSType\", new Class [] {String.class});\n                putParameter = appleEventClass.getDeclaredMethod (\"putParameter\", new Class [] {int.class, aeDescClass});\n                sendNoReply = appleEventClass.getDeclaredMethod (\"sendNoReply\", new Class [] {});\n                Field keyDirectObjectField = aeClass.getDeclaredField (\"keyDirectObject\");\n                keyDirectObject = (Integer) keyDirectObjectField.get (null);\n                Field autoGenerateReturnIDField = appleEventClass.getDeclaredField (\"kAutoGenerateReturnID\");\n                kAutoGenerateReturnID = (Integer) autoGenerateReturnIDField.get (null);\n                Field anyTransactionIDField = appleEventClass.getDeclaredField (\"kAnyTransactionID\");\n                kAnyTransactionID = (Integer) anyTransactionIDField.get (null);\n            } catch (ClassNotFoundException cnfe) {\n                errorMessage = cnfe.getMessage ();\n                return false;\n            } catch (NoSuchMethodException nsme) {\n                errorMessage = nsme.getMessage ();\n                return false;\n            } catch (NoSuchFieldException nsfe) {\n                errorMessage = nsfe.getMessage ();\n                return false;\n            } catch (IllegalAccessException iae) {\n                errorMessage = iae.getMessage ();\n                return false;\n            }\n            break;\n        case MRJ_2_1 :\n            try {\n                mrjFileUtilsClass = Class.forName (\"com.apple.mrj.MRJFileUtils\");\n                mrjOSTypeClass = Class.forName (\"com.apple.mrj.MRJOSType\");\n                Field systemFolderField = mrjFileUtilsClass.getDeclaredField (\"kSystemFolderType\");\n                kSystemFolderType = systemFolderField.get (null);\n                findFolder = mrjFileUtilsClass.getDeclaredMethod (\"findFolder\", new Class [] {mrjOSTypeClass});\n                getFileCreator = mrjFileUtilsClass.getDeclaredMethod (\"getFileCreator\", new Class [] {File.class});\n                getFileType = mrjFileUtilsClass.getDeclaredMethod (\"getFileType\", new Class [] {File.class});\n            } catch (ClassNotFoundException cnfe) {\n                errorMessage = cnfe.getMessage ();\n                return false;\n            } catch (NoSuchFieldException nsfe) {\n                errorMessage = nsfe.getMessage ();\n                return false;\n            } catch (NoSuchMethodException nsme) {\n                errorMessage = nsme.getMessage ();\n                return false;\n            } catch (SecurityException se) {\n                errorMessage = se.getMessage ();\n                return false;\n            } catch (IllegalAccessException iae) {\n                errorMessage = iae.getMessage ();\n                return false;\n            }\n            break;\n        case MRJ_3_0 :\n            try {\n                Class linker = Class.forName (\"com.apple.mrj.jdirect.Linker\");\n                Constructor constructor = linker.getConstructor (new Class [] {Class.class});\n                constructor.newInstance (new Object [] {BrowserLauncher.class});\n            } catch (ClassNotFoundException cnfe) {\n                errorMessage = cnfe.getMessage ();\n                return false;\n            } catch (NoSuchMethodException nsme) {\n                errorMessage = nsme.getMessage ();\n                return false;\n            } catch (InvocationTargetException ite) {\n                errorMessage = ite.getMessage ();\n                return false;\n            } catch (InstantiationException ie) {\n                errorMessage = ie.getMessage ();\n                return false;\n            } catch (IllegalAccessException iae) {\n                errorMessage = iae.getMessage ();\n                return false;\n            }\n            break;\n        case MRJ_3_1 :\n            try {\n                mrjFileUtilsClass = Class.forName (\"com.apple.mrj.MRJFileUtils\");\n                openURL = mrjFileUtilsClass.getDeclaredMethod (\"openURL\", new Class [] {String.class});\n            } catch (ClassNotFoundException cnfe) {\n                errorMessage = cnfe.getMessage ();\n                return false;\n            } catch (NoSuchMethodException nsme) {\n                errorMessage = nsme.getMessage ();\n                return false;\n            }\n            break;\n        default :\n            break;\n    }\n    return true;\n}\n", "code2": "private void createValue (Object key, Class createClass) {\n    if (createClass == null || _destination == null) {\n        return;\n    }\n    Object addValue = null;\n    try {\n        Class [] classArgs = null;\n        Constructor constructor = createClass.getConstructor (classArgs);\n        Object [] objectArgs = null;\n        addValue = constructor.newInstance (objectArgs);\n        _destination.addProperty (key, null, addValue);\n    } catch (Exception e) {\n        AssertUtility.exception (e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 7330695, "method2_id": 18396375, "code1": "static final String md5 (String text) throws RtmApiException {\n    MessageDigest md;\n    try {\n        md = MessageDigest.getInstance (\"MD5\");\n        byte [] md5hash = new byte [32];\n        md.update (text.getBytes (\"UTF-8\"), 0, text.length ());\n        md5hash = md.digest ();\n        return convertToHex (md5hash);\n    } catch (NoSuchAlgorithmException e) {\n        throw new RtmApiException (\"Md5 error: NoSuchAlgorithmException - \" + e.getMessage ());\n    } catch (UnsupportedEncodingException e) {\n        throw new RtmApiException (\"Md5 error: UnsupportedEncodingException - \" + e.getMessage ());\n    }\n}\n", "code2": "public static String hash (String plaintext) {\n    if (plaintext == null) {\n        return \"\";\n    }\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"SHA1\");\n        md.update (plaintext.getBytes (\"UTF-8\"));\n    } catch (Exception e) {\n    }\n    return new String (Base64.encodeBase64 (md.digest ()));\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8990222, "method2_id": 9678341, "code1": "private boolean get (String surl, File dst, Get get) throws IOException {\n    boolean ret = false;\n    InputStream is = null;\n    OutputStream os = null;\n    try {\n        try {\n            if (surl.startsWith (\"file://\")) {\n                is = new FileInputStream (surl.substring (7));\n            } else {\n                URL url = new URL (surl);\n                is = url.openStream ();\n            }\n            if (is != null) {\n                os = new FileOutputStream (dst);\n                int read;\n                byte [] buffer = new byte [4096];\n                while ((read = is.read (buffer)) > 0) {\n                    os.write (buffer, 0, read);\n                }\n                ret = true;\n            }\n        } catch (ConnectException ex) {\n            log (\"Connect exception \" + ex.getMessage (), ex, 3);\n            if (dst.exists ()) dst.delete ();\n\n        } catch (UnknownHostException ex) {\n            log (\"Unknown host \" + ex.getMessage (), ex, 3);\n        } catch (FileNotFoundException ex) {\n            log (\"File not found: \" + ex.getMessage (), 3);\n        }\n    } finally {\n        if (is != null) is.close ();\n\n        if (os != null) os.close ();\n\n        is = null;\n        os = null;\n    }\n    if (ret) {\n        try {\n            is = new FileInputStream (dst);\n            os = new FileOutputStream (getCachedFile (get));\n            int read;\n            byte [] buffer = new byte [4096];\n            while ((read = is.read (buffer)) > 0) {\n                os.write (buffer, 0, read);\n            }\n        } finally {\n            if (is != null) is.close ();\n\n            if (os != null) os.close ();\n\n            is = null;\n            os = null;\n        }\n    }\n    return ret;\n}\n", "code2": "public static void copy (Object arg1, Object arg2) {\n    Writer writer = null;\n    Reader reader = null;\n    InputStream inStream = null;\n    OutputStream outStream = null;\n    try {\n        if (arg2 instanceof Writer) {\n            writer = (Writer) arg2;\n            if (arg1 instanceof Reader) {\n                reader = (Reader) arg1;\n                copy (reader, writer);\n            } else if (arg1 instanceof String) {\n                reader = new FileReader (new File ((String) arg1));\n                copy (reader, writer);\n            } else if (arg1 instanceof File) {\n                reader = new FileReader ((File) arg1);\n                copy (reader, writer);\n            } else if (arg1 instanceof URL) {\n                copy (((URL) arg1).openStream (), writer);\n            } else if (arg1 instanceof InputStream) {\n                reader = new InputStreamReader ((InputStream) arg1);\n                copy (reader, writer);\n            } else if (arg1 instanceof RandomAccessFile) {\n                copy ((RandomAccessFile) arg1, writer);\n            } else {\n                throw new TypeError (\"Invalid first argument to copy()\");\n            }\n\n        } else if (arg2 instanceof OutputStream) {\n            outStream = (OutputStream) arg2;\n            if (arg1 instanceof Reader) {\n                copy ((Reader) arg1, new OutputStreamWriter (outStream));\n            } else if (arg1 instanceof String) {\n                inStream = new FileInputStream (new File ((String) arg1));\n                copy (inStream, outStream);\n            } else if (arg1 instanceof File) {\n                inStream = new FileInputStream ((File) arg1);\n                copy (inStream, outStream);\n            } else if (arg1 instanceof URL) {\n                copy (((URL) arg1).openStream (), outStream);\n            } else if (arg1 instanceof InputStream) {\n                copy ((InputStream) arg1, outStream);\n            } else if (arg1 instanceof RandomAccessFile) {\n                copy ((RandomAccessFile) arg1, outStream);\n            } else {\n                throw new TypeError (\"Invalid first argument to copy()\");\n            }\n\n        } else if (arg2 instanceof RandomAccessFile) {\n            RandomAccessFile out = (RandomAccessFile) arg2;\n            if (arg1 instanceof Reader) {\n                copy ((Reader) arg1, out);\n            } else if (arg1 instanceof String) {\n                inStream = new FileInputStream (new File ((String) arg1));\n                copy (inStream, out);\n            } else if (arg1 instanceof File) {\n                inStream = new FileInputStream ((File) arg1);\n                copy (inStream, out);\n            } else if (arg1 instanceof URL) {\n                copy (((URL) arg1).openStream (), out);\n            } else if (arg1 instanceof InputStream) {\n                copy ((InputStream) arg1, out);\n            } else if (arg1 instanceof RandomAccessFile) {\n                copy ((RandomAccessFile) arg1, out);\n            } else {\n                throw new TypeError (\"Invalid first argument to copy()\");\n            }\n\n        } else if (arg2 instanceof File || arg2 instanceof String) {\n            File outFile = null;\n            if (arg2 instanceof File) {\n                outFile = (File) arg2;\n            } else {\n                outFile = new File ((String) arg2);\n            }\n            outStream = new FileOutputStream (outFile);\n            if (arg1 instanceof Reader) {\n                copy ((Reader) arg1, new OutputStreamWriter (outStream));\n            } else if (arg1 instanceof String) {\n                inStream = new FileInputStream (new File ((String) arg1));\n                copy (inStream, outStream);\n            } else if (arg1 instanceof File) {\n                inStream = new FileInputStream ((File) arg1);\n                copy (inStream, outStream);\n            } else if (arg1 instanceof URL) {\n                copy (((URL) arg1).openStream (), outStream);\n            } else if (arg1 instanceof InputStream) {\n                copy ((InputStream) arg1, outStream);\n            } else if (arg1 instanceof RandomAccessFile) {\n                copy ((RandomAccessFile) arg1, outStream);\n            } else {\n                throw new TypeError (\"Invalid first argument to copy()\");\n            }\n\n        } else {\n            throw new TypeError (\"Invalid second argument to copy()\");\n        }\n\n    } catch (IOException e) {\n        throw new IOError (e.getMessage (), e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8856524, "method2_id": 17296395, "code1": "@Action (value = \"ajaxFileUploads\", results = {})\npublic void ajaxFileUploads () throws IOException {\n    String extName = \"\";\n    String newFilename = \"\";\n    String nowTimeStr = \"\";\n    String realpath = \"\";\n    if (Validate.StrNotNull (this.getImgdirpath ())) {\n        realpath = \"Uploads/\" + this.getImgdirpath () + \"/\";\n    } else {\n        realpath = this.isexistdir ();\n    }\n    SimpleDateFormat sDateFormat;\n    Random r = new Random ();\n    String savePath = ServletActionContext.getServletContext ().getRealPath (\"\");\n    savePath = savePath + realpath;\n    HttpServletResponse response = ServletActionContext.getResponse ();\n    int rannum = (int) (r.nextDouble () * (99999 - 1000 + 1)) + 10000;\n    sDateFormat = new SimpleDateFormat (\"yyyyMMddHHmmss\");\n    nowTimeStr = sDateFormat.format (new Date ());\n    String filename = request.getHeader (\"X-File-Name\");\n    if (filename.lastIndexOf (\".\") >= 0) {\n        extName = filename.substring (filename.lastIndexOf (\".\"));\n    }\n    newFilename = nowTimeStr + rannum + extName;\n    PrintWriter writer = null;\n    InputStream is = null;\n    FileOutputStream fos = null;\n    try {\n        writer = response.getWriter ();\n    } catch (IOException ex) {\n        log.debug (ImgTAction.class.getName () + \"has thrown an exception:\" + ex.getMessage ());\n    }\n    try {\n        is = request.getInputStream ();\n        fos = new FileOutputStream (new File (savePath + newFilename));\n        IOUtils.copy (is, fos);\n        response.setStatus (response.SC_OK);\n        writer.print (\"{success:'\" + realpath + newFilename + \"'}\");\n    } catch (FileNotFoundException ex) {\n        response.setStatus (response.SC_INTERNAL_SERVER_ERROR);\n        writer.print (\"{success: false}\");\n        log.debug (ImgTAction.class.getName () + \"has thrown an exception: \" + ex.getMessage ());\n    } catch (IOException ex) {\n        response.setStatus (response.SC_INTERNAL_SERVER_ERROR);\n        writer.print (\"{success: false}\");\n        log.debug (ImgTAction.class.getName () + \"has thrown an exception: \" + ex.getMessage ());\n    } finally {\n        try {\n            this.setImgdirpath (null);\n            fos.close ();\n            is.close ();\n        } catch (IOException ignored) {\n        }\n    }\n    writer.flush ();\n    writer.close ();\n}\n", "code2": "public static File copyToLibDirectory (final File file) throws FileNotFoundException, IOException {\n    if (file == null || ! file.exists ()) {\n        throw new FileNotFoundException ();\n    }\n    File directory = new File (\"lib/\");\n    File dest = new File (directory, file.getName ());\n    File parent = dest.getParentFile ();\n    while (parent != null && ! parent.equals (directory)) {\n        parent = parent.getParentFile ();\n    }\n    if (parent.equals (directory)) {\n        return file;\n    }\n    FileChannel in = null;\n    FileChannel out = null;\n    try {\n        in = new FileInputStream (file).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        in.transferTo (0, in.size (), out);\n    } finally {\n        if (in != null) {\n            try {\n                in.close ();\n            } catch (IOException e) {\n            }\n        }\n        if (out != null) {\n            try {\n                out.close ();\n            } catch (IOException e) {\n            }\n        }\n    }\n    return dest;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 7422454, "method2_id": 17927694, "code1": "public void run () {\n    if (name == null) {\n        System.err.println (\"Must set file name for retrieval\");\n        return;\n    }\n    if (handle == null) {\n        System.err.println (\"Must set CCNHandle\");\n        return;\n    }\n    if (htmlPane == null) {\n        System.err.println (\"Must set JEditorPane\");\n        return;\n    }\n    JFrame frame = new JFrame ();\n    JFileChooser chooser = new JFileChooser ();\n    File f = null;\n    chooser.setCurrentDirectory (null);\n    int returnVal = chooser.showSaveDialog (frame);\n    if (returnVal == JFileChooser.APPROVE_OPTION) {\n        f = chooser.getSelectedFile ();\n    } else {\n        htmlPane.setText (\"Save File cancelled\");\n        return;\n    }\n    boolean overwrite = false;\n    try {\n        if (f.exists ()) {\n            htmlPane.setText (\"Overwriting contents of \" + f.getPath ());\n            overwrite = true;\n        } else {\n            f.createNewFile ();\n        }\n        if (f.canWrite ()) {\n        } else {\n            htmlPane.setText (\"The ContentExplorer is unable to write the content to the specified file.\");\n            return;\n        }\n    } catch (IOException e) {\n        System.err.println (\"could not create \" + f.getPath () + \" for saving content to filesystem\");\n        htmlPane.setText (\"could not create \" + f.getPath () + \" for saving content to filesystem\");\n    }\n    try {\n        if (! overwrite) htmlPane.setText (\"saving \" + name + \" to \" + f.getCanonicalPath ());\n        else htmlPane.setText (\"overwriting contents of \" + f.getCanonicalPath () + \" to save \" + name);\n\n        CCNFileInputStream fis = new CCNFileInputStream (name, handle);\n        FileOutputStream output = new FileOutputStream (f);\n        byte [] buffer = new byte [readsize];\n        int readcount = 0;\n        int readtotal = 0;\n        while ((readcount = fis.read (buffer)) != - 1) {\n            readtotal += readcount;\n            output.write (buffer, 0, readcount);\n            output.flush ();\n        }\n        htmlPane.setText (\"Saved \" + name + \" to \" + f.getCanonicalPath ());\n    } catch (Exception e) {\n        htmlPane.setText (\"Could not save \" + name + \" to \" + f.getPath () + \" This may be a prefix for an object or just may not be available at this time.\");\n        System.err.println (\"Could not retrieve file: \" + name);\n    }\n}\n", "code2": "public static void copyFile (FileInputStream source, FileOutputStream target) throws Exception {\n    FileChannel inChannel = source.getChannel ();\n    FileChannel outChannel = target.getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 543096, "method2_id": 8539546, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "private static void unpackEntry (File destinationFile, ZipInputStream zin, ZipEntry entry) throws Exception {\n    if (! entry.isDirectory ()) {\n        createFolders (destinationFile.getParentFile ());\n        FileOutputStream fis = new FileOutputStream (destinationFile);\n        try {\n            IOUtils.copy (zin, fis);\n        } finally {\n            zin.closeEntry ();\n            fis.close ();\n        }\n    } else {\n        createFolders (destinationFile);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 264408, "method2_id": 1394207, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public Controller lookupController (HttpServletRequest request, AbstractTransformerFactory factory) {\n    Class [] argsClass = new Class [] {HttpServletRequest.class};\n    Object [] args = new Object [] {request};\n    for (Class < ? extends AbstractInspectRequest > c : classes) {\n        try {\n            Constructor < ? extends AbstractInspectRequest > constructor = c.getConstructor (argsClass);\n            AbstractInspectRequest inspectRequest = (AbstractInspectRequest) constructor.newInstance (args);\n            if (inspectRequest.isValidate ()) {\n                if (inspectRequest instanceof IControllerProvider) {\n                    return ((IControllerProvider) inspectRequest).getController (factory);\n                }\n            }\n        } catch (Exception e) {\n            LOG.error (\"Couldn't resolve AbstractInspectRequest class [\" + c.getName () + \"], using constructor: \" + c, e);\n        }\n    }\n    return null;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 16623181, "method2_id": 23094550, "code1": "public static void main (String [] args) {\n    File srcDir = new File (args [0]);\n    File dstDir = new File (args [1]);\n    File [] srcFiles = srcDir.listFiles ();\n    for (File f : srcFiles) {\n        if (f.isDirectory ()) continue;\n\n        try {\n            FileChannel srcChannel = new FileInputStream (f).getChannel ();\n            FileChannel dstChannel = new FileOutputStream (dstDir.getAbsolutePath () + System.getProperty (\"file.separator\") + f.getName ()).getChannel ();\n            ByteBuffer buffer = ByteBuffer.allocate (1024);\n            int nr = 0;\n            srcChannel.position (nr);\n            nr += srcChannel.read (buffer);\n            while (nr < f.length ()) {\n                buffer.flip ();\n                dstChannel.write (buffer);\n                buffer.clear ();\n                nr += srcChannel.read (buffer);\n            }\n            srcChannel.close ();\n            dstChannel.close ();\n        } catch (IOException e) {\n        }\n    }\n}\n", "code2": "public StringBuffer render (RenderEngine c) {\n    String logTime = null;\n    if (c.getWorkerContext () != null) {\n        logTime = c.getWorkerContext ().getWorkerStart ();\n    }\n    if (c.isBreakState () || ! c.canRender (\"u\")) {\n        return new StringBuffer ();\n    }\n    StringBuffer buffer = new StringBuffer ();\n    varname = TagInspector.processElement (varname, c);\n    action = TagInspector.processElement (action, c);\n    filemode = TagInspector.processElement (filemode, c);\n    xmlparse = TagInspector.processElement (xmlparse, c);\n    encoding = TagInspector.processElement (encoding, c);\n    decoding = TagInspector.processElement (decoding, c);\n    filter = TagInspector.processElement (filter, c);\n    sort = TagInspector.processElement (sort, c);\n    useDocroot = TagInspector.processElement (useDocroot, c);\n    useFilename = TagInspector.processElement (useFilename, c);\n    useDest = TagInspector.processElement (useDest, c);\n    xmlOutput = TagInspector.processElement (xmlOutput, c);\n    renderOutput = TagInspector.processElement (renderOutput, c);\n    callProc = TagInspector.processElement (callProc, c);\n    vartype = TagInspector.processElement (vartype, c);\n    if (sort == null || sort.equals (\"\")) {\n        sort = \"asc\";\n    }\n    if (useFilename.equals (\"\") && ! action.equalsIgnoreCase (\"listing\")) {\n        return new StringBuffer ();\n    }\n    boolean isRooted = true;\n    if (useDocroot.equalsIgnoreCase (\"true\")) {\n        if (c.getVendContext ().getVend ().getIgnorableDocroot (c.getClientContext ().getMatchedHost ())) {\n            isRooted = false;\n        }\n    }\n    if (isRooted && (useFilename.indexOf (\"/\") == - 1 || useFilename.startsWith (\"./\"))) {\n        if (c.getWorkerContext () != null && useFilename.startsWith (\"./\")) {\n            useFilename = c.getWorkerContext ().getClientContext ().getPostVariable (\"current_path\") + useFilename.substring (2);\n            Debug.inform (\"CWD path specified in filename, rewritten to '\" + useFilename + \"'\");\n        } else if (c.getWorkerContext () != null && useFilename.indexOf (\"/\") == - 1) {\n            useFilename = c.getWorkerContext ().getClientContext ().getPostVariable (\"current_path\") + useFilename;\n            Debug.inform (\"No path specified in filename, rewritten to '\" + useFilename + \"'\");\n        } else {\n            Debug.inform (\"No path specified in filename, no worker context, not rewriting filename.\");\n        }\n\n    }\n    StringBuffer filenameData = null;\n    StringBuffer contentsData = null;\n    StringBuffer fileDestData = null;\n    contentsData = TagInspector.processBody (this, c);\n    filenameData = new StringBuffer (useFilename);\n    fileDestData = new StringBuffer (useDest);\n    String currentDocroot = null;\n    if (c.getWorkerContext () == null) {\n        if (c.getRenderContext ().getCurrentDocroot () == null) {\n            currentDocroot = \".\";\n        } else {\n            currentDocroot = c.getRenderContext ().getCurrentDocroot ();\n        }\n    } else {\n        currentDocroot = c.getWorkerContext ().getDocRoot ();\n    }\n    if (! isRooted) {\n        currentDocroot = \"\";\n    }\n    if (useDocroot.equalsIgnoreCase (\"true\")) {\n        if (c.getVendContext ().getVend ().getIgnorableDocroot (c.getClientContext ().getMatchedHost ())) {\n            isRooted = false;\n            currentDocroot = \"\";\n        }\n    }\n    if (! currentDocroot.endsWith (\"/\")) {\n        if (! currentDocroot.equals (\"\") && currentDocroot.length () > 0) {\n            currentDocroot += \"/\";\n        }\n    }\n    if (filenameData != null) {\n        filenameData = new StringBuffer (filenameData.toString ().replaceAll (\"\\\\.\\\\.\", \"\"));\n    }\n    if (fileDestData != null) {\n        fileDestData = new StringBuffer (fileDestData.toString ().replaceAll (\"\\\\.\\\\.\", \"\"));\n    }\n    if (action.equalsIgnoreCase (\"read\")) {\n        java.io.File file = new java.io.File (currentDocroot + filenameData.toString ());\n        FileInputStream is = null;\n        ByteArrayOutputStream bos = new ByteArrayOutputStream ();\n        byte data [] = null;\n        boolean vfsLoaded = false;\n        try {\n            data = c.getVendContext ().getFileAccess ().getFile (c.getWorkerContext (), filenameData.toString ().replaceAll (\"\\\\.\\\\.\", \"\"), c.getClientContext ().getMatchedHost (), c.getVendContext ().getVend ().getRenderExtension (c.getClientContext ().getMatchedHost ()), null);\n            bos.write (data, 0, data.length);\n            vfsLoaded = true;\n        } catch (Exception e) {\n            Debug.user (logTime, \"Included file attempt with VFS of file '\" + filenameData + \"' failed: \" + e);\n        }\n        if (data == null) {\n            try {\n                is = new FileInputStream (file);\n            } catch (Exception e) {\n                Debug.user (logTime, \"Unable to render: Filename '\" + currentDocroot + filenameData + \"' does not exist.\");\n                return new StringBuffer ();\n            }\n        }\n        if (xmlparse == null || xmlparse.equals (\"\")) {\n            if (data == null) {\n                Debug.user (logTime, \"Opening filename '\" + currentDocroot + filenameData + \"' for reading into buffer '\" + varname + \"'\");\n                data = new byte [32768];\n                int totalBytesRead = 0;\n                while (true) {\n                    int bytesRead;\n                    try {\n                        bytesRead = is.read (data);\n                        bos.write (data, 0, bytesRead);\n                    } catch (Exception e) {\n                        break;\n                    }\n                    if (bytesRead <= 0) {\n                        break;\n                    }\n                    totalBytesRead += bytesRead;\n                }\n            }\n            byte docOutput [] = bos.toByteArray ();\n            if (renderOutput != null && renderOutput.equalsIgnoreCase (\"ssp\")) {\n                String outputData = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\\n\" + new String (FileAccess.getDefault ().processServerPageData (c.getWorkerContext (), docOutput));\n                docOutput = outputData.getBytes ();\n            }\n            Debug.user (logTime, \"File read complete: \" + docOutput.length + \" byte(s)\");\n            if (is != null) {\n                try {\n                    is.close ();\n                } catch (Exception e) {\n                }\n            }\n            is = null;\n            if (encoding != null && encoding.equalsIgnoreCase (\"url\")) {\n                if (! varname.equals (\"\")) {\n                    if (c.isProtectedVariable (varname)) {\n                        c.setExceptionState (true, \"Attempted to modify a read-only variable '\" + varname + \"'\");\n                        return new StringBuffer ();\n                    }\n                    c.getVariableContainer ().setVariable (varname, Encoder.URLEncode (new String (docOutput)));\n                } else {\n                    if (callProc != null && ! callProc.equals (\"\")) {\n                        Call call = new Call ();\n                        call.callProcedure (c, null, null, callProc, null);\n                    }\n                    return new StringBuffer (Encoder.URLEncode (new String (docOutput)));\n                }\n            } else if (encoding != null && encoding.equalsIgnoreCase (\"xml\")) {\n                if (! varname.equals (\"\")) {\n                    if (c.isProtectedVariable (varname)) {\n                        c.setExceptionState (true, \"Attempted to modify a read-only variable '\" + varname + \"'\");\n                        return new StringBuffer ();\n                    }\n                    c.getVariableContainer ().setVariable (varname, Encoder.XMLEncode (new String (docOutput)));\n                } else {\n                    if (callProc != null && ! callProc.equals (\"\")) {\n                        Call call = new Call ();\n                        call.callProcedure (c, null, null, callProc, null);\n                    }\n                    return new StringBuffer (Encoder.XMLEncode (new String (docOutput)));\n                }\n            } else if (encoding != null && encoding.equalsIgnoreCase (\"base64\")) {\n                if (! varname.equals (\"\")) {\n                    if (c.isProtectedVariable (varname)) {\n                        c.setExceptionState (true, \"Attempted to modify a read-only variable '\" + varname + \"'\");\n                        return new StringBuffer ();\n                    }\n                    c.getVariableContainer ().setVariable (varname, Base64.encode (docOutput));\n                } else {\n                    if (callProc != null && ! callProc.equals (\"\")) {\n                        Call call = new Call ();\n                        call.callProcedure (c, null, null, callProc, null);\n                    }\n                    return new StringBuffer (Base64.encode (docOutput));\n                }\n            } else if (encoding != null && (encoding.equalsIgnoreCase (\"javascript\") || encoding.equalsIgnoreCase (\"js\"))) {\n                if (! varname.equals (\"\")) {\n                    if (c.isProtectedVariable (varname)) {\n                        c.setExceptionState (true, \"Attempted to modify a read-only variable '\" + varname + \"'\");\n                        return new StringBuffer ();\n                    }\n                    c.getVariableContainer ().setVariable (varname, Encoder.JavascriptEncode (new String (docOutput)));\n                } else {\n                    if (callProc != null && ! callProc.equals (\"\")) {\n                        Call call = new Call ();\n                        call.callProcedure (c, null, null, callProc, null);\n                    }\n                    return new StringBuffer (Encoder.JavascriptEncode (new String (docOutput)));\n                }\n            } else {\n                if (! varname.equals (\"\")) {\n                    if (c.isProtectedVariable (varname)) {\n                        c.setExceptionState (true, \"Attempted to modify a read-only variable '\" + varname + \"'\");\n                        return new StringBuffer ();\n                    }\n                    c.getVariableContainer ().setVariable (varname, new String (docOutput));\n                } else {\n                    if (callProc != null && ! callProc.equals (\"\")) {\n                        Call call = new Call ();\n                        call.callProcedure (c, null, null, callProc, null);\n                    }\n                    return new StringBuffer (new String (docOutput));\n                }\n            }\n\n        } else {\n            RenderEngine engine = new RenderEngine (null);\n            DocumentEngine docEngine = null;\n            try {\n                if (vfsLoaded) {\n                    ByteArrayInputStream bais = new ByteArrayInputStream (data);\n                    docEngine = new DocumentEngine (bais);\n                } else {\n                    docEngine = new DocumentEngine (is);\n                }\n            } catch (Exception e) {\n                c.setExceptionState (true, \"XML parse of data read from file failed: \" + e.getMessage ());\n            }\n            engine.setDocumentEngine (docEngine);\n            c.addNodeSet (varname, docEngine.rootTag.thisNode);\n        }\n        if (is != null) {\n            try {\n                is.close ();\n            } catch (Exception e) {\n            }\n        }\n        is = null;\n        if (callProc != null && ! callProc.equals (\"\")) {\n            Call call = new Call ();\n            call.callProcedure (c, null, null, callProc, null);\n        }\n        return new StringBuffer ();\n    } else if (action.equalsIgnoreCase (\"write\")) {\n        try {\n            String rootDir = filenameData.toString ();\n            if (rootDir.lastIndexOf (\"/\") != - 1 && rootDir.lastIndexOf (\"/\") != 0) {\n                rootDir = rootDir.substring (0, rootDir.lastIndexOf (\"/\"));\n                java.io.File mkdirFile = new java.io.File (currentDocroot + rootDir);\n                if (! mkdirFile.mkdirs ()) {\n                    Debug.inform (\"Unable to create directory '\" + currentDocroot + rootDir + \"'\");\n                } else {\n                    Debug.inform (\"Created directory '\" + currentDocroot + rootDir + \"'\");\n                }\n            }\n            java.io.File file = new java.io.File (currentDocroot + filenameData.toString ());\n            FileOutputStream fos = null;\n            if (file == null) {\n                c.setExceptionState (true, \"Unable to write to file '\" + filenameData + \"': Cannot write to location specified\");\n                return new StringBuffer ();\n            } else if (file.isDirectory ()) {\n                c.setExceptionState (true, \"Unable to write to file '\" + filenameData + \"': Is a directory.\");\n                return new StringBuffer ();\n            }\n\n            if (filemode.equalsIgnoreCase (\"append\")) {\n                fos = new FileOutputStream (file, true);\n            } else {\n                fos = new FileOutputStream (file, false);\n            }\n            if (decoding != null && ! decoding.equals (\"\")) {\n                if (decoding.equalsIgnoreCase (\"base64\")) {\n                    try {\n                        byte contentsDecoded [] = Base64.decode (contentsData.toString ().getBytes ());\n                        fos.write (contentsDecoded);\n                    } catch (Exception e) {\n                        c.setExceptionState (true, \"Encoded data in &lt;content&gt; element does not contain valid Base64-\" + \"encoded data.\");\n                    }\n                } else {\n                    fos.write (contentsData.toString ().getBytes ());\n                }\n            } else {\n                fos.write (contentsData.toString ().getBytes ());\n            }\n            try {\n                fos.flush ();\n            } catch (IOException e) {\n                Debug.inform (\"Unable to flush output data: \" + e.getMessage ());\n            }\n            fos.close ();\n            Debug.user (logTime, \"Wrote contents to filename '\" + currentDocroot + filenameData + \"' (length=\" + contentsData.length () + \")\");\n        } catch (IOException e) {\n            c.setExceptionState (true, \"Unable to write to filename '\" + filenameData + \"': \" + e.getMessage ());\n        } catch (Exception e) {\n            c.setExceptionState (true, \"Unable to write to filename '\" + filenameData + \"': \" + e.getMessage ());\n        }\n    } else if (action.equalsIgnoreCase (\"listing\")) {\n        String filenameDataString = filenameData.toString ();\n        if (filenameDataString.equals (\"\")) {\n            filenameDataString = c.getClientContext ().getPostVariable (\"current_path\");\n        }\n        if (filenameDataString == null) {\n            c.setExceptionState (true, \"Filename cannot be blank when listing.\");\n            return new StringBuffer ();\n        }\n        while (filenameDataString.endsWith (\"/\")) {\n            filenameDataString = filenameDataString.substring (0, filenameDataString.length () - 1);\n        }\n        Vector fileList = new Vector ();\n        java.io.File file = new java.io.File (currentDocroot + filenameData.toString ());\n        String curDirname = filenameData.toString ();\n        String parentDirectory = null;\n        String [] dirEntries = curDirname.split (\"/\");\n        int numSlashes = 0;\n        for (int i = 0;\n        i < curDirname.length (); i ++) {\n            if (curDirname.toString ().charAt (i) == '/') {\n                numSlashes ++;\n            }\n        }\n        parentDirectory = \"/\";\n        if (numSlashes > 1) {\n            for (int i = 0;\n            i < (dirEntries.length - 1); i ++) {\n                if (dirEntries [i] != null && ! dirEntries [i].equals (\"\")) {\n                    parentDirectory += dirEntries [i] + \"/\";\n                }\n            }\n        }\n        if (parentDirectory.length () > 1 && parentDirectory.endsWith (\"/\")) {\n            parentDirectory = parentDirectory.substring (0, parentDirectory.length () - 1);\n        }\n        if (c.getVendContext () != null && c.getVendContext ().getFileAccess () != null && c.getVendContext ().getFileAccess ().getVFSType (filenameData.toString (), c.getClientContext ().getMatchedHost ()) == FileAccess.TYPE_JAR) {\n            Vector listFiles = c.getVendContext ().getFileAccess ().listFiles (filenameData.toString (), c.getClientContext ().getMatchedHost ());\n            Object [] list = listFiles.toArray ();\n            int depth = 0;\n            for (int i = 0;\n            i < filenameData.toString ().length (); i ++) {\n                if (filenameData.toString ().charAt (i) == '/') {\n                    depth ++;\n                }\n            }\n            buffer = new StringBuffer ();\n            buffer.append (\"<listing filter=\\\"\");\n            buffer.append (filter);\n            buffer.append (\"\\\" path=\\\"\");\n            buffer.append (filenameData);\n            if (parentDirectory != null) {\n                buffer.append (\"\\\" parent=\\\"\");\n                buffer.append (parentDirectory);\n            }\n            buffer.append (\"\\\">\\n\");\n            c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(filter)\", false, filter);\n            c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(path)\", false, filenameData);\n            if (parentDirectory != null) {\n                c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(parent)\", false, parentDirectory);\n            } else {\n                c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(parent)\", false, \"/\");\n            }\n            if (sort.equalsIgnoreCase (\"asc\")) {\n                Arrays.sort (list, new ZipSorterAscending ());\n            } else {\n                Arrays.sort (list, new ZipSorterDescending ());\n            }\n            for (int i = 0;\n            i < list.length; i ++) {\n                ZipEntry zEntry = (ZipEntry) list [i];\n                String zipFile = filenameData.toString () + \"/\" + zEntry.getName ();\n                String displayFilename = zipFile.replaceFirst (filenameData.toString (), \"\");\n                int curDepth = 0;\n                if (zipFile.equalsIgnoreCase (\".acl\") || zipFile.equalsIgnoreCase (\"access.list\") || zipFile.equalsIgnoreCase (\"application.inc\") || zipFile.equalsIgnoreCase (\"global.inc\") || zipFile.indexOf (\"/.proc\") != - 1 || zipFile.indexOf (\"/procedures\") != - 1) {\n                    continue;\n                }\n                for (int x = 0;\n                x < displayFilename.length (); x ++) {\n                    if (displayFilename.charAt (x) == '/') {\n                        curDepth ++;\n                    }\n                }\n                if (zipFile.startsWith (filenameData.toString ())) {\n                    String fileLength = \"\" + zEntry.getSize ();\n                    String fileType = \"file\";\n                    if (curDepth == depth) {\n                        if (zEntry.isDirectory ()) {\n                            fileType = \"directory\";\n                        } else {\n                            fileType = \"file\";\n                        }\n                        String fileMode = \"read-only\";\n                        String fileTime = Long.toString (zEntry.getTime ());\n                        buffer.append (\"    <file name=\\\"\");\n                        buffer.append (displayFilename);\n                        buffer.append (\"\\\" length=\\\"\");\n                        buffer.append (fileLength);\n                        buffer.append (\"\\\" type=\\\"\");\n                        buffer.append (fileType);\n                        buffer.append (\"\\\" mode=\\\"\");\n                        buffer.append (fileMode);\n                        buffer.append (\"\\\" modtime=\\\"\");\n                        buffer.append (fileTime);\n                        buffer.append (\"\\\"/>\\n\");\n                        c.getVariableContainer ().setVariable (c, varname + \"(\" + displayFilename + \")(length)\", false, \"\" + fileLength);\n                        c.getVariableContainer ().setVariable (c, varname + \"(\" + displayFilename + \")(type)\", false, fileType);\n                        c.getVariableContainer ().setVariable (c, varname + \"(\" + displayFilename + \")(mode)\", false, fileMode);\n                        c.getVariableContainer ().setVariable (c, varname + \"(\" + displayFilename + \")(time)\", false, fileTime);\n                    }\n                } else {\n                    if (curDepth == depth) {\n                        fileList.add (zipFile);\n                    }\n                }\n            }\n            buffer.append (\"</listing>\");\n            if (xmlOutput.equalsIgnoreCase (\"true\")) {\n                if (c.isProtectedVariable (varname)) {\n                    c.setExceptionState (true, \"Attempted to modify a read-only variable '\" + varname + \"'\");\n                    return new StringBuffer ();\n                }\n                c.getVariableContainer ().setVariable (varname, buffer.toString ());\n                return new StringBuffer ();\n            }\n            c.getVariableContainer ().setVector (varname, fileList);\n        } else if (c.getVendContext () != null && c.getVendContext ().getFileAccess () != null && c.getVendContext ().getFileAccess ().getVFSType (filenameData.toString (), c.getClientContext ().getMatchedHost ()) == FileAccess.TYPE_FS) {\n            Vector listFiles = c.getVendContext ().getFileAccess ().listFiles (filenameData.toString (), c.getClientContext ().getMatchedHost ());\n            Object [] list = listFiles.toArray ();\n            java.io.File [] filesorted = new java.io.File [list.length];\n            for (int i = 0;\n            i < list.length; i ++) {\n                filesorted [i] = (java.io.File) list [i];\n            }\n            if (sort.equalsIgnoreCase (\"asc\")) {\n                Arrays.sort (filesorted, new FileSorterAscending ());\n            } else {\n                Arrays.sort (filesorted, new FileSorterDescending ());\n            }\n            buffer = new StringBuffer ();\n            buffer.append (\"<listing filter=\\\"\");\n            buffer.append (filter);\n            buffer.append (\"\\\" path=\\\"\");\n            buffer.append (filenameData);\n            if (parentDirectory != null) {\n                buffer.append (\"\\\" parent=\\\"\");\n                buffer.append (parentDirectory);\n            }\n            buffer.append (\"\\\">\\n\");\n            c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(filter)\", false, filter);\n            c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(path)\", false, filenameData);\n            if (parentDirectory != null) {\n                c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(parent)\", false, parentDirectory);\n            } else {\n                c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(parent)\", false, \"/\");\n            }\n            for (int i = 0;\n            i < filesorted.length; i ++) {\n                java.io.File zEntry = filesorted [i];\n                String filename = filenameData.toString () + \"/\" + zEntry.getName ();\n                if (filename.equalsIgnoreCase (\".acl\") || filename.equalsIgnoreCase (\"access.list\") || filename.equalsIgnoreCase (\"application.inc\") || filename.equalsIgnoreCase (\"global.inc\") || filename.indexOf (\"/.proc\") != - 1 || filename.indexOf (\"/procedures\") != - 1) {\n                    continue;\n                }\n                String displayFilename = filename.replaceFirst (filenameData.toString (), \"\");\n                String fileLength = \"\" + zEntry.length ();\n                String fileType = \"file\";\n                if (zEntry.isDirectory ()) {\n                    fileType = \"directory\";\n                } else if (zEntry.isFile ()) {\n                    fileType = \"file\";\n                } else if (zEntry.isHidden ()) {\n                    fileType = \"hidden\";\n                } else if (zEntry.isAbsolute ()) {\n                    fileType = \"absolute\";\n                }\n\n                String fileMode = \"read-only\";\n                if (zEntry.canRead () && ! zEntry.canWrite ()) {\n                    fileMode = \"read-only\";\n                } else if (! zEntry.canRead () && zEntry.canWrite ()) {\n                    fileMode = \"write-only\";\n                } else if (zEntry.canRead () && zEntry.canWrite ()) {\n                    fileMode = \"read/write\";\n                }\n\n                String fileTime = Long.toString (zEntry.lastModified ());\n                if (xmlOutput.equalsIgnoreCase (\"true\")) {\n                    buffer.append (\"    <file name=\\\"\");\n                    buffer.append (filename);\n                    buffer.append (\"\\\" length=\\\"\");\n                    buffer.append (fileLength);\n                    buffer.append (\"\\\" type=\\\"\");\n                    buffer.append (fileType);\n                    buffer.append (\"\\\" mode=\\\"\");\n                    buffer.append (fileMode);\n                    buffer.append (\"\\\" modtime=\\\"\");\n                    buffer.append (fileTime);\n                    buffer.append (\"\\\"/>\\n\");\n                } else {\n                    fileList.add (zEntry);\n                }\n                c.getVariableContainer ().setVariable (c, varname + \"(\" + filename + \")(length)\", false, \"\" + fileLength);\n                c.getVariableContainer ().setVariable (c, varname + \"(\" + filename + \")(type)\", false, fileType);\n                c.getVariableContainer ().setVariable (c, varname + \"(\" + filename + \")(mode)\", false, fileMode);\n                c.getVariableContainer ().setVariable (c, varname + \"(\" + filename + \")(time)\", false, fileTime);\n            }\n            buffer.append (\"</listing>\");\n            if (xmlOutput.equalsIgnoreCase (\"true\")) {\n                if (c.isProtectedVariable (varname)) {\n                    c.setExceptionState (true, \"Attempted to modify a read-only variable '\" + varname + \"'\");\n                    return new StringBuffer ();\n                }\n                c.getVariableContainer ().setVariable (varname, buffer.toString ());\n                return new StringBuffer ();\n            }\n            c.getVariableContainer ().setVector (varname, fileList);\n        } else {\n            String [] fileStringList = null;\n            if (! filter.equals (\"\")) {\n                fileStringList = file.list (new ListFilter (filter));\n            } else {\n                fileStringList = file.list ();\n            }\n            if (sort.equalsIgnoreCase (\"asc\")) {\n                Arrays.sort (fileStringList, new StringSorterAscending ());\n            } else {\n                Arrays.sort (fileStringList, new StringSorterDescending ());\n            }\n            if (fileStringList == null) {\n                buffer.append (\"<listing filter=\\\"\");\n                buffer.append (filter);\n                buffer.append (\"\\\" path=\\\"\");\n                buffer.append (filenameData);\n                if (parentDirectory != null) {\n                    buffer.append (\"\\\" parent=\\\"\");\n                    buffer.append (parentDirectory);\n                }\n                buffer.append (\"\\\"/>\\n\");\n                c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(filter)\", false, filter);\n                c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(path)\", false, filenameData);\n                if (parentDirectory != null) {\n                    c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(parent)\", false, parentDirectory);\n                } else {\n                    c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(parent)\", false, \"/\");\n                }\n                if (xmlOutput.equalsIgnoreCase (\"true\")) {\n                    if (c.isProtectedVariable (varname)) {\n                        c.setExceptionState (true, \"Attempted to modify a read-only variable '\" + varname + \"'\");\n                        return new StringBuffer ();\n                    }\n                    c.getVariableContainer ().setVariable (varname, buffer.toString ());\n                } else {\n                    c.getVariableContainer ().setVector (varname, fileList);\n                }\n                return new StringBuffer ();\n            } else {\n                Debug.user (logTime, \"Directory '\" + currentDocroot + filenameData + \"' returns \" + fileStringList.length + \" entry(ies)\");\n            }\n            buffer = new StringBuffer ();\n            buffer.append (\"<listing filter=\\\"\");\n            buffer.append (filter);\n            buffer.append (\"\\\" path=\\\"\");\n            buffer.append (filenameData);\n            if (parentDirectory != null) {\n                buffer.append (\"\\\" parent=\\\"\");\n                buffer.append (parentDirectory);\n            }\n            buffer.append (\"\\\">\\n\");\n            c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(filter)\", false, filter);\n            c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(path)\", false, filenameData);\n            if (parentDirectory != null) {\n                c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(parent)\", false, parentDirectory);\n            } else {\n                c.getVariableContainer ().setVariable (c, varname + \"(fileinfo)(parent)\", false, \"/\");\n            }\n            for (int i = 0;\n            i < fileStringList.length; i ++) {\n                file = new java.io.File (currentDocroot + filenameData.toString () + \"/\" + fileStringList [i]);\n                String fileLength = Long.toString (file.length ());\n                String fileType = \"file\";\n                if (file.isDirectory ()) {\n                    fileType = \"directory\";\n                } else if (file.isFile ()) {\n                    fileType = \"file\";\n                } else if (file.isHidden ()) {\n                    fileType = \"hidden\";\n                } else if (file.isAbsolute ()) {\n                    fileType = \"absolute\";\n                }\n\n                String fileMode = \"read-only\";\n                if (file.canRead () && ! file.canWrite ()) {\n                    fileMode = \"read-only\";\n                } else if (! file.canRead () && file.canWrite ()) {\n                    fileMode = \"write-only\";\n                } else if (file.canRead () && file.canWrite ()) {\n                    fileMode = \"read/write\";\n                }\n\n                String fileTime = Long.toString (file.lastModified ());\n                if (xmlOutput.equalsIgnoreCase (\"true\")) {\n                    buffer.append (\"    <file name=\\\"\");\n                    buffer.append (fileStringList [i]);\n                    buffer.append (\"\\\" length=\\\"\");\n                    buffer.append (fileLength);\n                    buffer.append (\"\\\" type=\\\"\");\n                    buffer.append (fileType);\n                    buffer.append (\"\\\" mode=\\\"\");\n                    buffer.append (fileMode);\n                    buffer.append (\"\\\" modtime=\\\"\");\n                    buffer.append (fileTime);\n                    buffer.append (\"\\\"/>\\n\");\n                } else {\n                    fileList.add (fileStringList [i]);\n                }\n                c.getVariableContainer ().setVariable (c, varname + \"(\" + fileStringList [i] + \")(length)\", false, \"\" + fileLength);\n                c.getVariableContainer ().setVariable (c, varname + \"(\" + fileStringList [i] + \")(type)\", false, fileType);\n                c.getVariableContainer ().setVariable (c, varname + \"(\" + fileStringList [i] + \")(mode)\", false, fileMode);\n                c.getVariableContainer ().setVariable (c, varname + \"(\" + fileStringList [i] + \")(time)\", false, fileTime);\n            }\n            buffer.append (\"</listing>\");\n            if (xmlOutput.equalsIgnoreCase (\"true\")) {\n                if (c.isProtectedVariable (varname)) {\n                    c.setExceptionState (true, \"Attempted to modify a read-only variable '\" + varname + \"'\");\n                    return new StringBuffer ();\n                }\n                c.getVariableContainer ().setVariable (varname, buffer.toString ());\n                return new StringBuffer ();\n            }\n            c.getVariableContainer ().setVector (varname, fileList);\n        }\n\n    } else if (action.equalsIgnoreCase (\"delete\")) {\n        java.io.File file = new java.io.File (currentDocroot + filenameData.toString ());\n        if (file.isDirectory ()) {\n            boolean success = deleteDir (new java.io.File (currentDocroot + filenameData.toString ()));\n            if (! success) {\n                c.setExceptionState (true, \"Unable to delete '\" + currentDocroot + filenameData + \"'\");\n            }\n        } else {\n            String filenamePattern = null;\n            if (filenameData.toString ().indexOf (\"/\") != - 1) {\n                filenamePattern = filenameData.toString ().substring (filenameData.toString ().lastIndexOf (\"/\") + 1);\n            }\n            String filenameDirectory = currentDocroot;\n            if (filenameData.toString ().indexOf (\"/\") != - 1) {\n                filenameDirectory += filenameData.substring (0, filenameData.toString ().lastIndexOf (\"/\"));\n            }\n            String [] fileStringList = null;\n            file = new java.io.File (filenameDirectory);\n            fileStringList = file.list (new ListFilter (filenamePattern));\n            for (int i = 0;\n            i < fileStringList.length; i ++) {\n                (new java.io.File (filenameDirectory + \"/\" + fileStringList [i])).delete ();\n            }\n        }\n    } else if (action.equalsIgnoreCase (\"rename\") || action.equalsIgnoreCase (\"move\")) {\n        if (fileDestData.equals (\"\")) {\n            c.getVariableContainer ().setVariable (varname + \"-result\", filenameData + \": File operation failed: No destination filename given.\");\n            return new StringBuffer ();\n        }\n        java.io.File file = new java.io.File (currentDocroot + filenameData.toString ());\n        boolean success = file.renameTo (new java.io.File (currentDocroot + fileDestData.toString (), file.getName ()));\n        if (! success) {\n            c.setExceptionState (true, \"Unable to rename '\" + currentDocroot + filenameData + \"' to '\" + currentDocroot + fileDestData + \"'\");\n        }\n    } else if (action.equalsIgnoreCase (\"copy\")) {\n        if (fileDestData.equals (\"\")) {\n            c.setExceptionState (true, \"File copy operation failed for file '\" + filenameData + \"': No destination file specified.\");\n            return new StringBuffer ();\n        }\n        FileChannel srcChannel;\n        FileChannel destChannel;\n        String filename = null;\n        filename = currentDocroot + filenameData.toString ();\n        if (vartype != null && vartype.equalsIgnoreCase (\"file\")) {\n            if (useFilename.indexOf (\"/\") != - 1) {\n                useFilename = useFilename.substring (useFilename.lastIndexOf (\"/\") + 1);\n            }\n            filename = c.getVariableContainer ().getFileVariable (useFilename);\n        }\n        try {\n            Debug.debug (\"Copying from file '\" + filename + \"' to '\" + fileDestData.toString () + \"'\");\n            srcChannel = new FileInputStream (filename).getChannel ();\n        } catch (IOException e) {\n            c.setExceptionState (true, \"Filecopy from '\" + filenameData + \"' failed to read: \" + e.getMessage ());\n            return new StringBuffer ();\n        }\n        try {\n            destChannel = new FileOutputStream (currentDocroot + fileDestData.toString ()).getChannel ();\n        } catch (IOException e) {\n            c.setExceptionState (true, \"Filecopy to '\" + fileDestData + \"' failed to write: \" + e.getMessage ());\n            return new StringBuffer ();\n        }\n        try {\n            destChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n            srcChannel.close ();\n            destChannel.close ();\n            if (varname != null) {\n                c.getVariableContainer ().setVariable (varname + \"-result\", filenameData + \" copy to \" + fileDestData + \": File copy succeeded.\");\n            } else {\n                return new StringBuffer (\"true\");\n            }\n        } catch (IOException e) {\n            c.setExceptionState (true, \"Filecopy from '\" + filenameData + \"' to '\" + fileDestData + \"' failed: \" + e.getMessage ());\n        }\n    } else if (action.equalsIgnoreCase (\"exists\")) {\n        java.io.File file = new java.io.File (currentDocroot + filenameData.toString ());\n        if (file.exists ()) {\n            if (varname != null) {\n                if (c.isProtectedVariable (varname)) {\n                    c.setExceptionState (true, \"Attempted to modify a read-only variable '\" + varname + \"'\");\n                    return new StringBuffer ();\n                }\n                c.getVariableContainer ().setVariable (varname, \"true\");\n            } else {\n                return new StringBuffer (\"true\");\n            }\n        } else {\n            if (varname != null) {\n                if (c.isProtectedVariable (varname)) {\n                    c.setExceptionState (true, \"Attempted to modify a read-only variable '\" + varname + \"'\");\n                    return new StringBuffer ();\n                }\n                c.getVariableContainer ().setVariable (varname, \"false\");\n            } else {\n                return new StringBuffer (\"false\");\n            }\n        }\n    } else if (action.equalsIgnoreCase (\"mkdir\")) {\n        java.io.File file = new java.io.File (currentDocroot + filenameData.toString ());\n        if (file.mkdirs ()) {\n            if (varname != null) {\n                c.getVariableContainer ().setVariable (varname + \"-result\", \"created\");\n            } else {\n                return new StringBuffer (\"true\");\n            }\n        } else {\n            c.setExceptionState (true, \"Unable to create directory '\" + filenameData + \"'\");\n        }\n    } else if (action.equalsIgnoreCase (\"info\")) {\n        java.io.File file = new java.io.File (currentDocroot + filenameData.toString ());\n        String fileLength = Long.toString (file.length ());\n        String fileType = \"file\";\n        if (file.isAbsolute ()) {\n            fileType = \"absolute\";\n        } else if (file.isDirectory ()) {\n            fileType = \"directory\";\n        } else if (file.isFile ()) {\n            fileType = \"file\";\n        } else if (file.isHidden ()) {\n            fileType = \"hidden\";\n        }\n\n        String fileMode = \"read-only\";\n        if (file.canRead () && ! file.canWrite ()) {\n            fileMode = \"read-only\";\n        } else if (! file.canRead () && file.canWrite ()) {\n            fileMode = \"write-only\";\n        } else if (file.canRead () && file.canWrite ()) {\n            fileMode = \"read/write\";\n        }\n\n        String fileTime = Long.toString (file.lastModified ());\n        if (varname != null && ! varname.equals (\"\")) {\n            c.getVariableContainer ().setVariable (varname + \".length\", fileLength);\n            c.getVariableContainer ().setVariable (varname + \".type\", fileType);\n            c.getVariableContainer ().setVariable (varname + \".mode\", fileMode);\n            c.getVariableContainer ().setVariable (varname + \".modtime\", fileTime);\n        } else {\n            buffer = new StringBuffer ();\n            buffer.append (\"<file name=\\\"\");\n            buffer.append (filenameData);\n            buffer.append (\"\\\" length=\\\"\");\n            buffer.append (fileLength);\n            buffer.append (\"\\\" type=\\\"\");\n            buffer.append (fileType);\n            buffer.append (\"\\\" mode=\\\"\");\n            buffer.append (fileMode);\n            buffer.append (\"\\\" modtime=\\\"\");\n            buffer.append (fileTime);\n            buffer.append (\"\\\"/>\\n\");\n            return buffer;\n        }\n    }\n\n    if (callProc != null && ! callProc.equals (\"\")) {\n        Call call = new Call ();\n        call.callProcedure (c, null, null, callProc, null);\n    }\n    return new StringBuffer ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 848240, "method2_id": 5980224, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String version = null;\n        String build = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".version\")) version = line.substring (8).trim ();\n            else if (line.startsWith (\".build\")) build = line.substring (6).trim ();\n\n        }\n        bin.close ();\n        if (version != null && build != null) {\n            if (jEdit.getBuild ().compareTo (build) < 0) newVersionAvailable (view, version, url);\n            else {\n                GUIUtilities.message (view, \"version-check\" + \".up-to-date\", new String [0]);\n            }\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "public static final TreeSet < String > getValues (String baseurl, String rftId, String svcId) {\n    TreeSet < String > values = new TreeSet < String > ();\n    String [] fragments = rftId.split (\"/\");\n    String e_repoUri = null;\n    String e_svcId = null;\n    try {\n        e_repoUri = URLEncoder.encode (rftId, \"UTF-8\");\n        e_svcId = URLEncoder.encode (svcId, \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n        log.error (\"UnsupportedEncodingException resulted attempting to encode \" + rftId);\n    }\n    String openurl = baseurl + \"/\" + fragments [2] + \"/openurl-aDORe7\" + \"?rft_id=\" + e_repoUri + \"&svc_id=\" + e_svcId + \"&url_ver=Z39.88-2004\";\n    log.info (\"Obtaining Content Values from: \" + openurl);\n    try {\n        URL url = new URL (openurl);\n        long s = System.currentTimeMillis ();\n        URLConnection conn = url.openConnection ();\n        int timeoutMs = 1000 * 60 * 30;\n        conn.setConnectTimeout (timeoutMs);\n        conn.setReadTimeout (timeoutMs);\n        BufferedReader in = new BufferedReader (new InputStreamReader (conn.getInputStream ()));\n        log.info (\"Query Time: \" + (System.currentTimeMillis () - s) + \"ms\");\n        String line;\n        while ((line = in.readLine ()) != null) {\n            values.add (line);\n        }\n        in.close ();\n    } catch (Exception ex) {\n        log.error (\"problem with openurl:\" + openurl + ex.getMessage ());\n        throw new RuntimeException (ex);\n    }\n    return values;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 850680, "method2_id": 3551701, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "public static void copyFile (File src, File dst) throws IOException {\n    FileInputStream fis = null;\n    FileOutputStream fos = null;\n    fis = new FileInputStream (src);\n    fos = new FileOutputStream (dst);\n    byte [] buffer = new byte [16384];\n    int read = 0;\n    while ((read = fis.read (buffer)) != - 1) {\n        fos.write (buffer, 0, read);\n    }\n    fis.close ();\n    fos.flush ();\n    fos.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2033320, "method2_id": 20508693, "code1": "public static void gunzip (File gzippedFile, File destinationFile) throws IOException {\n    int buffer = 2048;\n    FileInputStream in = new FileInputStream (gzippedFile);\n    GZIPInputStream zipin = new GZIPInputStream (in);\n    byte [] data = new byte [buffer];\n    FileOutputStream out = new FileOutputStream (destinationFile);\n    int length;\n    while ((length = zipin.read (data, 0, buffer)) != - 1) out.write (data, 0, length);\n\n    out.close ();\n    zipin.close ();\n}\n", "code2": "private void zip (FileHolder fileHolder, int zipCompressionLevel) {\n    byte [] buffer = new byte [BUFFER_SIZE];\n    int bytes_read;\n    if (fileHolder.selectedFileList.size () == 0) {\n        return;\n    }\n    File zipDestFile = new File (fileHolder.destFiles [0]);\n    try {\n        ZipOutputStream outStream = new ZipOutputStream (new FileOutputStream (zipDestFile));\n        for (int i = 0;\n        i < fileHolder.selectedFileList.size (); i ++) {\n            File selectedFile = fileHolder.selectedFileList.get (i);\n            super.currentObjBeingProcessed = selectedFile;\n            this.inStream = new FileInputStream (selectedFile);\n            ZipEntry entry = new ZipEntry (selectedFile.getName ());\n            outStream.setLevel (zipCompressionLevel);\n            outStream.putNextEntry (entry);\n            while ((bytes_read = this.inStream.read (buffer)) != - 1) {\n                outStream.write (buffer, 0, bytes_read);\n            }\n            outStream.closeEntry ();\n            this.inStream.close ();\n        }\n        outStream.close ();\n    } catch (IOException e) {\n        errEntry.setThrowable (e);\n        errEntry.setAppContext (\"gzip()\");\n        errEntry.setAppMessage (\"Error zipping: \" + zipDestFile);\n        logger.logError (errEntry);\n    }\n    return;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3928959, "method2_id": 18880061, "code1": "public static void copyFile (File from, File to) throws IOException {\n    FileInputStream in = null;\n    FileOutputStream out = null;\n    try {\n        in = new FileInputStream (from);\n        out = new FileOutputStream (to);\n        byte [] bytes = new byte [1024 * 4];\n        int len = 0;\n        while ((len = in.read (bytes)) >= 0) out.write (bytes, 0, len);\n\n    } finally {\n        Streams.closeQuietly (in);\n        Streams.closeQuietly (out);\n    }\n}\n", "code2": "public static boolean compress (File source, File target, Manifest manifest) {\n    try {\n        if (! (source.exists () & source.isDirectory ())) return false;\n\n        if (target.exists ()) target.delete ();\n\n        ZipOutputStream output = null;\n        boolean isJar = target.getName ().toLowerCase ().endsWith (\".jar\");\n        if (isJar) {\n            File manifestDir = new File (source, \"META-INF\");\n            remove (manifestDir);\n            if (manifest != null) output = new JarOutputStream (new FileOutputStream (target), manifest);\n            else output = new JarOutputStream (new FileOutputStream (target));\n\n        } else output = new ZipOutputStream (new FileOutputStream (target));\n\n        ArrayList list = getContents (source);\n        String baseDir = source.getAbsolutePath ().replace ('\\\\', '/');\n        if (! baseDir.endsWith (\"/\")) baseDir = baseDir + \"/\";\n\n        int baseDirLength = baseDir.length ();\n        byte [] buffer = new byte [1024];\n        int bytesRead;\n        for (int i = 0, n = list.size ();\n        i < n; i ++) {\n            File file = (File) list.get (i);\n            FileInputStream f_in = new FileInputStream (file);\n            String filename = file.getAbsolutePath ().replace ('\\\\', '/');\n            if (filename.startsWith (baseDir)) filename = filename.substring (baseDirLength);\n\n            if (isJar) output.putNextEntry (new JarEntry (filename));\n            else output.putNextEntry (new ZipEntry (filename));\n\n            while ((bytesRead = f_in.read (buffer)) != - 1) output.write (buffer, 0, bytesRead);\n\n            f_in.close ();\n            output.closeEntry ();\n        }\n        output.close ();\n    } catch (Exception exc) {\n        exc.printStackTrace ();\n        return false;\n    }\n    return true;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 411595, "method2_id": 13233956, "code1": "private void displayDiffResults () throws IOException {\n    File outFile = File.createTempFile (\"diff\", \".htm\");\n    outFile.deleteOnExit ();\n    FileOutputStream outStream = new FileOutputStream (outFile);\n    BufferedWriter out = new BufferedWriter (new OutputStreamWriter (outStream));\n    out.write (\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n    if (addedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n        out.write (addedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    if (modifiedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n        out.write (modifiedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    if (deletedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n        out.write (deletedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    out.write (\"<table name=METRICS BORDER>\\n\");\n    if (modifiedTable.length () > 0 || deletedTable.length () > 0) {\n        out.write (\"<tr><td>Base:&nbsp;</td><td>\");\n        out.write (Long.toString (base));\n        out.write (\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n        out.write (Long.toString (deleted));\n        out.write (\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n        out.write (Long.toString (modified));\n        out.write (\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n        out.write (Long.toString (added));\n        out.write (\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n        out.write (Long.toString (added + modified));\n        out.write (\"</td></tr>\\n\");\n    }\n    out.write (\"<tr><td>Total:&nbsp;</td><td>\");\n    out.write (Long.toString (total));\n    out.write (\"</td></tr>\\n</table></div>\");\n    redlinesOut.close ();\n    out.flush ();\n    InputStream redlines = new FileInputStream (redlinesTempFile);\n    byte [] buffer = new byte [4096];\n    int bytesRead;\n    while ((bytesRead = redlines.read (buffer)) != - 1) outStream.write (buffer, 0, bytesRead);\n\n    outStream.write (\"</BODY></HTML>\".getBytes ());\n    outStream.close ();\n    Browser.launch (outFile.toURL ().toString ());\n}\n", "code2": "public void addXSLT (InputStream in) throws IOException {\n    ByteArrayOutputStream bytes = new ByteArrayOutputStream ();\n    IOUtils.copy (in, bytes);\n    xslt.add (0, bytes.toByteArray ());\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 12937087, "method2_id": 20418573, "code1": "public ChatClient registerPlayer (int playerId, String playerLogin) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md = MessageDigest.getInstance (\"SHA-256\");\n    md.reset ();\n    md.update (playerLogin.getBytes (\"UTF-8\"), 0, playerLogin.length ());\n    byte [] accountToken = md.digest ();\n    byte [] token = generateToken (accountToken);\n    ChatClient chatClient = new ChatClient (playerId, token);\n    players.put (playerId, chatClient);\n    return chatClient;\n}\n", "code2": "public static String hashMD5 (String password) {\n    String hashword = null;\n    try {\n        MessageDigest md5 = MessageDigest.getInstance (\"MD5\");\n        md5.update (password.getBytes ());\n        BigInteger hash = new BigInteger (1, md5.digest ());\n        hashword = hash.toString (16);\n    } catch (NoSuchAlgorithmException nsae) {\n    }\n    return hashword;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3391668, "method2_id": 12079426, "code1": "public void setPropertyValue (String propertyName, Object value) throws BeansException {\n    try {\n        if (isAllowedXBinding (propertyName)) {\n            boolean createFirst = (jxpathcontext.getFactory () != null);\n            if (createFirst) {\n                jxpathcontext.createPath (propertyName);\n            }\n            Pointer pointer = jxpathcontext.getPointer (propertyName);\n            Object property = pointer.getValue ();\n            if (value.getClass ().isArray ()) {\n                Object [] values = (Object []) value;\n                if (property != null && property.getClass ().isArray ()) {\n                    Class componentType = property.getClass ().getComponentType ();\n                    property = java.lang.reflect.Array.newInstance (componentType, values.length);\n                    java.lang.System.arraycopy (values, 0, property, 0, values.length);\n                    pointer.setValue (property);\n                } else if (property instanceof Collection) {\n                    Collection cl = (Collection) property;\n                    cl.clear ();\n                    cl.addAll (java.util.Arrays.asList (values));\n                }\n\n            } else {\n                if (TypeUtils.canConvert (value, property.getClass ())) {\n                    pointer.setValue (value);\n                } else {\n                    throw new TypeMismatchException (createPropertyChangeEvent (propertyName, property, value), property.getClass ());\n                }\n            }\n        }\n    } catch (JXPathException e) {\n        throw new NotWritablePropertyException (getWrappedClass (), propertyName, e.getMessage (), e);\n    }\n}\n", "code2": "public static Object [] addObjectToArray (Object [] array, Object obj) {\n    Class compType = Object.class;\n    if (array != null) {\n        compType = array.getClass ().getComponentType ();\n    } else if (obj != null) {\n        compType = obj.getClass ();\n    }\n\n    int newArrLength = (array != null ? array.length + 1 : 1);\n    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);\n    if (array != null) {\n        System.arraycopy (array, 0, newArr, 0, array.length);\n    }\n    newArr [newArr.length - 1] = obj;\n    return newArr;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3874060, "method2_id": 8708602, "code1": "public static void copyFile (File sourceFile, File targetFile) throws IOException {\n    if (sourceFile == null || targetFile == null) {\n        throw new NullPointerException (\"Source file and target file must not be null\");\n    }\n    File directory = targetFile.getParentFile ();\n    if (! directory.exists () && ! directory.mkdirs ()) {\n        throw new IOException (\"Could not create directory '\" + directory + \"'\");\n    }\n    InputStream inputStream = null;\n    OutputStream outputStream = null;\n    try {\n        inputStream = new BufferedInputStream (new FileInputStream (sourceFile));\n        outputStream = new BufferedOutputStream (new FileOutputStream (targetFile));\n        try {\n            byte [] buffer = new byte [32768];\n            for (int readBytes = inputStream.read (buffer);\n            readBytes > 0; readBytes = inputStream.read (buffer)) {\n                outputStream.write (buffer, 0, readBytes);\n            }\n        } catch (IOException ex) {\n            targetFile.delete ();\n            throw ex;\n        }\n    } finally {\n        if (inputStream != null) {\n            try {\n                inputStream.close ();\n            } catch (IOException ex) {\n            }\n        }\n        if (outputStream != null) {\n            try {\n                outputStream.close ();\n            } catch (IOException ex) {\n            }\n        }\n    }\n}\n", "code2": "public void execute (File temporaryFile) throws Exception {\n    ZipArchive archive = new ZipArchive (temporaryFile.getPath ());\n    InputStream input = archive.getInputFrom (ARCHIVE_FILE_1);\n    if (input != null) {\n        ByteArrayOutputStream output = new ByteArrayOutputStream ();\n        IOUtils.copyAndClose (input, output);\n        assertEquals (ARCHIVE_FILE_1 + \" contents not correct\", ARCHIVE_FILE_1_CONTENT, output.toString ());\n    } else {\n        fail (\"cannot open \" + ARCHIVE_FILE_1);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 13361852, "method2_id": 23250845, "code1": "public static File copyFile (File from, File to) throws IOException {\n    FileOutputStream fos = new FileOutputStream (to);\n    FileInputStream fis = new FileInputStream (from);\n    FileChannel foc = fos.getChannel ();\n    FileChannel fic = fis.getChannel ();\n    foc.transferFrom (fic, 0, fic.size ());\n    foc.close ();\n    fic.close ();\n    return to;\n}\n", "code2": "private void unzipResource (final String resourceName, final File targetDirectory) throws IOException {\n    assertTrue (resourceName.startsWith (\"/\"));\n    final URL resource = this.getClass ().getResource (resourceName);\n    assertNotNull (\"Expected '\" + resourceName + \"' not found.\", resource);\n    assertTrue (targetDirectory.isAbsolute ());\n    FileUtils.deleteDirectory (targetDirectory);\n    assertTrue (targetDirectory.mkdirs ());\n    ZipInputStream in = null;\n    boolean suppressExceptionOnClose = true;\n    try {\n        in = new ZipInputStream (resource.openStream ());\n        ZipEntry e;\n        while ((e = in.getNextEntry ()) != null) {\n            if (e.isDirectory ()) {\n                continue;\n            }\n            final File dest = new File (targetDirectory, e.getName ());\n            assertTrue (dest.isAbsolute ());\n            OutputStream out = null;\n            try {\n                out = FileUtils.openOutputStream (dest);\n                IOUtils.copy (in, out);\n                suppressExceptionOnClose = false;\n            } finally {\n                try {\n                    if (out != null) {\n                        out.close ();\n                    }\n                    suppressExceptionOnClose = true;\n                } catch (final IOException ex) {\n                    if (! suppressExceptionOnClose) {\n                        throw ex;\n                    }\n                }\n            }\n            in.closeEntry ();\n        }\n        suppressExceptionOnClose = false;\n    } finally {\n        try {\n            if (in != null) {\n                in.close ();\n            }\n        } catch (final IOException e) {\n            if (! suppressExceptionOnClose) {\n                throw e;\n            }\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 5751313, "method2_id": 9120775, "code1": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        closeQuietly (in);\n        closeQuietly (out);\n    }\n    return success;\n}\n", "code2": "public void addFile (File fileobj, boolean delete) {\n    String oldFileName = fileobj.getPath ();\n    String currFileName = setUpFile (fileobj);\n    if (currFileName != null) {\n        File f = new File (currFileName);\n        int deleteFiles = JOptionPane.CANCEL_OPTION;\n        if (oldFileName.equals (currFileName)) {\n            currFileName = currFileName.substring (openProject.getPath ().length ());\n            openProject.addFile (currFileName);\n            if (f.getName ().toLowerCase ().endsWith (\".exp\")) addExpFile (f.getPath ());\n\n        } else if (! f.exists () || JOptionPane.OK_OPTION == (deleteFiles = JOptionPane.showConfirmDialog (this, \"File\" + f.getName () + \" Already Exists! Do You Wish To Overwrite That File?\" + (f.getName ().toLowerCase ().endsWith (\".exp\") ? \"\\nOverwriting An Expression File Will Delete All Files Which Previously Required The Orginal File\" : \"\")))) {\n            try {\n                if (deleteFiles == JOptionPane.OK_OPTION && f.getName ().toLowerCase ().endsWith (\".exp\")) {\n                    File expF [] = f.getParentFile ().listFiles ();\n                    for (int i = 0;\n                    i < expF.length; i ++) {\n                        while (expF [i].exists ()) {\n                            expF [i].delete ();\n                        }\n                    }\n                    f.getParentFile ().delete ();\n                }\n                f.getParentFile ().mkdirs ();\n                f.createNewFile ();\n                FileInputStream in = new FileInputStream (fileobj);\n                FileOutputStream out = new FileOutputStream (f);\n                byte [] buffer = new byte [8 * 1024];\n                int count = 0;\n                do {\n                    out.write (buffer, 0, count);\n                    count = in.read (buffer, 0, buffer.length);\n                } while (count != - 1);\n                in.close ();\n                out.close ();\n                if (delete) fileobj.delete ();\n\n            } catch (Exception e2) {\n                JOptionPane.showMessageDialog (this, \"Error! Could Not Add \" + fileobj.getName () + \" To Project\");\n            }\n            currFileName = currFileName.substring (currFileName.lastIndexOf (openProject.getName ()) + openProject.getName ().length () + 1);\n            openProject.addFile (currFileName);\n            if (f.getName ().toLowerCase ().endsWith (\".exp\")) addExpFile (f.getPath ());\n\n        }\n\n    } else {\n        String message = \"Error! Could Not Add \" + fileobj.getName () + \" To Project\\n\";\n        if (fileobj.getName ().endsWith (\".gprj\")) {\n            message += \"You May Not Add A Project File To An Existing Project\";\n        } else if (fileobj.getName ().toLowerCase ().endsWith (\".ds_store\")) {\n            message = \"\";\n        } else if (fileobj.getName ().toLowerCase ().endsWith (\".txt\")) {\n            message = \"\";\n        } else if (fileobj.getName ().toLowerCase ().endsWith (\".gif\")) {\n            message = \"\";\n        } else if (fileobj.getName ().toLowerCase ().endsWith (\".jpeg\")) {\n            message = \"\";\n        } else if (fileobj.getName ().toLowerCase ().endsWith (\".jpg\")) {\n            message = \"\";\n        } else if (fileobj.getName ().toLowerCase ().endsWith (\".info\")) {\n            message = \"\";\n        } else if (fileobj.getName ().toLowerCase ().endsWith (\".html\")) {\n            message = \"\";\n        } else if (fileobj.getName ().toLowerCase ().endsWith (\".db\")) {\n            message = \"\";\n        } else if (fileobj.getName ().toLowerCase ().endsWith (\".raw\")) {\n            message = \"\";\n        } else if (fileobj.getName ().toLowerCase ().endsWith (\".cdt\")) {\n            message = \"\";\n        } else if (fileobj.getName ().toLowerCase ().endsWith (\".gtr\")) {\n            message = \"\";\n        } else if (fileobj.getName ().toLowerCase ().endsWith (\".jtv\")) {\n            message = \"\";\n        } else message += \"File Extension Unknown. Please Check The File To Ensure It Has The Correct Extension\";\n\n        if (! message.equals (\"\")) JOptionPane.showMessageDialog (this, message);\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10315160, "method2_id": 23149062, "code1": "public void saveSharedFiles (List < FrostSharedFileItem > sfFiles) throws SQLException {\n    Connection conn = AppLayerDatabase.getInstance ().getPooledConnection ();\n    try {\n        conn.setAutoCommit (false);\n        Statement s = conn.createStatement ();\n        s.executeUpdate (\"DELETE FROM SHAREDFILES\");\n        s.close ();\n        s = null;\n        PreparedStatement ps = conn.prepareStatement (\"INSERT INTO SHAREDFILES (\" + \"path,size,fnkey,sha,owner,comment,rating,keywords,\" + \"lastuploaded,uploadcount,reflastsent,requestlastreceived,requestsreceivedcount,lastmodified) \" + \"VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)\");\n        for (Iterator < FrostSharedFileItem > i = sfFiles.iterator ();\n        i.hasNext ();) {\n            FrostSharedFileItem sfItem = i.next ();\n            int ix = 1;\n            ps.setString (ix ++, sfItem.getFile ().getPath ());\n            ps.setLong (ix ++, sfItem.getFileSize ());\n            ps.setString (ix ++, sfItem.getChkKey ());\n            ps.setString (ix ++, sfItem.getSha ());\n            ps.setString (ix ++, sfItem.getOwner ());\n            ps.setString (ix ++, sfItem.getComment ());\n            ps.setInt (ix ++, sfItem.getRating ());\n            ps.setString (ix ++, sfItem.getKeywords ());\n            ps.setLong (ix ++, sfItem.getLastUploaded ());\n            ps.setInt (ix ++, sfItem.getUploadCount ());\n            ps.setLong (ix ++, sfItem.getRefLastSent ());\n            ps.setLong (ix ++, sfItem.getRequestLastReceived ());\n            ps.setInt (ix ++, sfItem.getRequestsReceived ());\n            ps.setLong (ix ++, sfItem.getLastModified ());\n            ps.executeUpdate ();\n        }\n        ps.close ();\n        conn.commit ();\n        conn.setAutoCommit (true);\n    } catch (Throwable t) {\n        logger.log (Level.SEVERE, \"Exception during save\", t);\n        try {\n            conn.rollback ();\n        } catch (Throwable t1) {\n            logger.log (Level.SEVERE, \"Exception during rollback\", t1);\n        }\n        try {\n            conn.setAutoCommit (true);\n        } catch (Throwable t1) {\n        }\n    } finally {\n        AppLayerDatabase.getInstance ().givePooledConnection (conn);\n    }\n}\n", "code2": "public static boolean insert (final CelulaFinanceira objCelulaFinanceira) {\n    int result = 0;\n    final Connection c = DBConnection.getConnection ();\n    PreparedStatement pst = null;\n    if (c == null) {\n        return false;\n    }\n    try {\n        c.setAutoCommit (false);\n        final String sql = \"insert into celula_financeira \" + \"(descricao, id_orgao, id_gestao, \" + \"id_natureza_despesa, id_programa_trabalho, \" + \"id_unidade_orcamentaria, id_fonte_recursos, \" + \"valor_provisionado, gasto_previsto, gasto_real, \" + \"saldo_previsto, saldo_real)\" + \" values (?, ?, ?, ?, ?, ?, ?, TRUNCATE(?,2), TRUNCATE(?,2), TRUNCATE(?,2), TRUNCATE(?,2), TRUNCATE(?,2))\";\n        pst = c.prepareStatement (sql);\n        pst.setString (1, objCelulaFinanceira.getDescricao ());\n        pst.setLong (2, (objCelulaFinanceira.getOrgao ()).getCodigo ());\n        pst.setString (3, (objCelulaFinanceira.getGestao ()).getCodigo ());\n        pst.setString (4, (objCelulaFinanceira.getNaturezaDespesa ()).getCodigo ());\n        pst.setString (5, (objCelulaFinanceira.getProgramaTrabalho ()).getCodigo ());\n        pst.setString (6, (objCelulaFinanceira.getUnidadeOrcamentaria ()).getCodigo ());\n        pst.setString (7, (objCelulaFinanceira.getFonteRecursos ()).getCodigo ());\n        pst.setDouble (8, objCelulaFinanceira.getValorProvisionado ());\n        pst.setDouble (9, objCelulaFinanceira.getGastoPrevisto ());\n        pst.setDouble (10, objCelulaFinanceira.getGastoReal ());\n        pst.setDouble (11, objCelulaFinanceira.getSaldoPrevisto ());\n        pst.setDouble (12, objCelulaFinanceira.getSaldoReal ());\n        result = pst.executeUpdate ();\n        c.commit ();\n    } catch (final SQLException e) {\n        try {\n            c.rollback ();\n        } catch (final SQLException e1) {\n            System.out.println (\"[CelulaFinanceiraDAO.insert] Erro ao inserir -> \" + e1.getMessage ());\n        }\n        System.out.println (\"[CelulaFinanceiraDAO.insert] Erro ao inserir -> \" + e.getMessage ());\n    } finally {\n        DBConnection.closePreparedStatement (pst);\n        DBConnection.closeConnection (c);\n    }\n    if (result > 0) {\n        return true;\n    } else {\n        return false;\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 268806, "method2_id": 19687458, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public void testMemberSeek () throws IOException {\n    GZIPMembersInputStream gzin = new GZIPMembersInputStream (new ByteArrayInputStream (allfour_gz));\n    gzin.setEofEachMember (true);\n    gzin.compressedSeek (noise1k_gz.length + noise32k_gz.length);\n    int count2 = IOUtils.copy (gzin, new NullOutputStream ());\n    assertEquals (\"wrong 1-byte member count\", 1, count2);\n    assertEquals (\"wrong Member2 start\", noise1k_gz.length + noise32k_gz.length, gzin.getCurrentMemberStart ());\n    assertEquals (\"wrong Member2 end\", noise1k_gz.length + noise32k_gz.length + a_gz.length, gzin.getCurrentMemberEnd ());\n    gzin.nextMember ();\n    int count3 = IOUtils.copy (gzin, new NullOutputStream ());\n    assertEquals (\"wrong 5-byte member count\", 5, count3);\n    assertEquals (\"wrong Member3 start\", noise1k_gz.length + noise32k_gz.length + a_gz.length, gzin.getCurrentMemberStart ());\n    assertEquals (\"wrong Member3 end\", noise1k_gz.length + noise32k_gz.length + a_gz.length + hello_gz.length, gzin.getCurrentMemberEnd ());\n    gzin.nextMember ();\n    int countEnd = IOUtils.copy (gzin, new NullOutputStream ());\n    assertEquals (\"wrong eof count\", 0, countEnd);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10912340, "method2_id": 11717079, "code1": "public boolean chequearMarca (int a, int m, int d) {\n    boolean existe = false;\n    try {\n        cantidadArchivos = obtenerCantidad () + 1;\n        String filenametxt = \"\";\n        String filenamezip = \"\";\n        int dia = 0;\n        int mes = 0;\n        int ano = 0;\n        for (int i = 1;\n        i < cantidadArchivos; i ++) {\n            filenamezip = \"recordatorio\" + i + \".zip\";\n            filenametxt = \"recordatorio\" + i + \".txt\";\n            BufferedOutputStream dest = null;\n            BufferedInputStream is = null;\n            ZipEntry entry;\n            ZipFile zipfile = new ZipFile (filenamezip);\n            Enumeration e = zipfile.entries ();\n            while (e.hasMoreElements ()) {\n                entry = (ZipEntry) e.nextElement ();\n                is = new BufferedInputStream (zipfile.getInputStream (entry));\n                int count;\n                byte data [] = new byte [buffer];\n                FileOutputStream fos = new FileOutputStream (entry.getName ());\n                dest = new BufferedOutputStream (fos, buffer);\n                while ((count = is.read (data, 0, buffer)) != - 1) dest.write (data, 0, count);\n\n                dest.flush ();\n                dest.close ();\n                is.close ();\n            }\n            DataInputStream input = new DataInputStream (new FileInputStream (filenametxt));\n            dia = Integer.parseInt (input.readLine ());\n            mes = Integer.parseInt (input.readLine ());\n            ano = Integer.parseInt (input.readLine ());\n            if (ano == a && mes == m && dia == d) existe = true;\n\n            input.close ();\n        }\n    } catch (Exception e) {\n        JOptionPane.showMessageDialog (null, \"Error en: \" + e.toString (), \"Error\", JOptionPane.ERROR_MESSAGE);\n    }\n    return (existe);\n}\n", "code2": "void copyFile (File inputFile, File outputFile) {\n    try {\n        FileReader in;\n        in = new FileReader (inputFile);\n        FileWriter out = new FileWriter (outputFile);\n        int c;\n        while ((c = in.read ()) != - 1) out.write (c);\n\n        in.close ();\n        out.close ();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 15664344, "method2_id": 16088469, "code1": "public static void backupGardenia (String gardeniaHome, String backupFile) throws Exception {\n    gardeniaHome = '\\\\' == File.separatorChar ? gardeniaHome.replace ('\\\\', '/') : gardeniaHome;\n    gardeniaHome = gardeniaHome.endsWith (\"/\") ? gardeniaHome : gardeniaHome + \"/\";\n    List allToZip = getFilesRecursive (new File (gardeniaHome + \"data\"));\n    byte [] buffer = new byte [4096];\n    FileOutputStream out = new FileOutputStream (backupFile);\n    ZipOutputStream zout = new ZipOutputStream (out);\n    zout.setLevel (9);\n    int baseNameSize = gardeniaHome.length ();\n    for (Iterator it = allToZip.iterator ();\n    it.hasNext ();) {\n        File f = (File) it.next ();\n        if (f.getName ().equals (\"gardenia01.lck\")) continue;\n\n        ZipEntry zipEntry = new ZipEntry (f.getCanonicalPath ().substring (baseNameSize));\n        zipEntry.setTime (f.lastModified ());\n        zout.putNextEntry (zipEntry);\n        FileInputStream fis = new FileInputStream (f);\n        int bytes = 0;\n        while ((bytes = fis.read (buffer, 0, buffer.length)) > 0) {\n            zout.write (buffer, 0, bytes);\n        }\n        fis.close ();\n    }\n    zout.close ();\n    out.close ();\n}\n", "code2": "static void addFile (String entryName, String fileName, ZipOutputStream zout) throws IOException {\n    ZipEntry mf = new ZipEntry (entryName);\n    File mfm = new File (fileName);\n    mf.setSize (mfm.length ());\n    mf.setTime (mfm.lastModified ());\n    zout.putNextEntry (mf);\n    zout.write (IOUtils.load (mfm));\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 19771110, "method2_id": 23677221, "code1": "public static final String mergeArguments (final String args, final String valueSeparator, final String argumentSeparator, final boolean acceptSingleArgs) {\n    HashMap < String, String > argumentsMap = new HashMap < String, String > ();\n    StringBuilder arguments = new StringBuilder ();\n    String arg;\n    Pattern keyValue = Pattern.compile (\"(?:^|\\\\s)([^\\\\\\\"\\\\s]+)=\\\"([^\\\\\\\"]+)\\\"\");\n    Matcher matcherKV = keyValue.matcher (args);\n    int last = 0;\n    while (matcherKV.find ()) {\n        arguments.append (args.subSequence (last, matcherKV.start ()));\n        last = matcherKV.end ();\n        if (argumentsMap.containsKey (matcherKV.group (1))) {\n            arg = argumentsMap.get (matcherKV.group (1)) + valueSeparator + matcherKV.group (2);\n            argumentsMap.put (matcherKV.group (1), arg);\n        } else {\n            argumentsMap.put (matcherKV.group (1), matcherKV.group (2));\n        }\n    }\n    if (argumentsMap.size () == 0) return args;\n\n    arguments.append (args.substring (last));\n    if (! acceptSingleArgs) {\n        arguments = new StringBuilder ();\n    }\n    for (Entry < String, String > m : argumentsMap.entrySet ()) {\n        arguments.append (argumentSeparator + m.getKey () + \"=\\\"\" + m.getValue () + \"\\\"\");\n    }\n    return arguments.toString ();\n}\n", "code2": "public static List < String > extractMatches (String text, String pattern) {\n    List < String > matches = new LinkedList < String > ();\n    Pattern p = Pattern.compile (pattern);\n    Matcher m = p.matcher (text);\n    while (m.find ()) {\n        matches.add (text.subSequence (m.start (), m.end ()).toString ());\n    }\n    return matches;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 832329, "method2_id": 6120970, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "public File nextEntry () {\n    try {\n        while (hasNext ()) {\n            String name = waitingArchEntry.getName ();\n            name = name.substring (name.indexOf (\"/\") + 1);\n            File file = new File (targetDir.getAbsolutePath () + \"/\" + name);\n            if (waitingArchEntry.isDirectory ()) {\n                file.mkdirs ();\n                waitingArchEntry = ais.getNextEntry ();\n            } else {\n                OutputStream os = new FileOutputStream (file);\n                try {\n                    IOUtils.copy (ais, os);\n                } finally {\n                    IOUtils.closeQuietly (os);\n                }\n                return file;\n            }\n        }\n    } catch (IOException e) {\n        return null;\n    }\n    return null;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 19842959, "method2_id": 19962044, "code1": "public boolean receiveFile (FileDescriptor fileDescriptor) {\n    try {\n        byte [] block = new byte [1024];\n        int sizeRead = 0;\n        int totalRead = 0;\n        File dir = new File (Constants.DOWNLOAD_DIR + fileDescriptor.getLocation ());\n        if (! dir.exists ()) {\n            dir.mkdirs ();\n        }\n        File file = new File (Constants.DOWNLOAD_DIR + fileDescriptor.getLocation () + fileDescriptor.getName ());\n        if (! file.exists ()) {\n            file.createNewFile ();\n        }\n        SSLSocket sslsocket = getFileTransferConectionConnectMode (ServerAdress.getServerAdress ());\n        OutputStream fileOut = new FileOutputStream (file);\n        InputStream dataIn = sslsocket.getInputStream ();\n        while ((sizeRead = dataIn.read (block)) >= 0) {\n            totalRead += sizeRead;\n            fileOut.write (block, 0, sizeRead);\n            propertyChangeSupport.firePropertyChange (\"fileByte\", 0, totalRead);\n        }\n        fileOut.close ();\n        dataIn.close ();\n        sslsocket.close ();\n        if (fileDescriptor.getName ().contains (\".snapshot\")) {\n            try {\n                File fileData = new File (Constants.DOWNLOAD_DIR + fileDescriptor.getLocation () + fileDescriptor.getName ());\n                File dirData = new File (Constants.PREVAYLER_DATA_DIRETORY + Constants.FILE_SEPARATOR);\n                File destino = new File (dirData, fileData.getName ());\n                boolean success = fileData.renameTo (destino);\n                if (! success) {\n                    deleteDir (Constants.DOWNLOAD_DIR);\n                    return false;\n                }\n                deleteDir (Constants.DOWNLOAD_DIR);\n            } catch (Exception e) {\n                e.printStackTrace ();\n            }\n        } else {\n            if (Server.isServerOpen ()) {\n                FileChannel inFileChannel = new FileInputStream (file).getChannel ();\n                File dirServer = new File (Constants.DOWNLOAD_DIR + fileDescriptor.getLocation ());\n                if (! dirServer.exists ()) {\n                    dirServer.mkdirs ();\n                }\n                File fileServer = new File (Constants.DOWNLOAD_DIR + fileDescriptor.getName ());\n                if (! fileServer.exists ()) {\n                    fileServer.createNewFile ();\n                }\n                inFileChannel.transferTo (0, inFileChannel.size (), new FileOutputStream (fileServer).getChannel ());\n                inFileChannel.close ();\n            }\n        }\n        if (totalRead == fileDescriptor.getSize ()) {\n            return true;\n        }\n    } catch (Exception e) {\n        logger.error (\"Receive File:\", e);\n    }\n    return false;\n}\n", "code2": "private static final void makeWF_JavaComponent_jwf (Hashtable pWriterFormats) {\n    pWriterFormats.put (\"JavaComponent.jwf\",\n\"!<header>\\n\\n\\n\\n$<{java.CodeWriter.package>package $<java.CodeWriter.package>;$<}java.CodeWriter.package>\\n\\n\\n\\nimport java.io.FileOutputStream;\\nimport java.io.File;\\nimport java.io.FileReader;\\nimport java.io.PrintWriter;\\nimport java.io.StringWriter;\\nimport java.io.StringReader;\\nimport java.io.BufferedReader;\\nimport java.io.FileWriter;\\nimport java.io.BufferedWriter;\\n\\nimport java.util.Vector;\\nimport java.util.Hashtable;\\nimport java.util.Calendar;\\n\\n\\n\\n!<{import>/* section:import << */\\n//\\n\\n!<import>\\n\\n//\\n/* section:import >> */!<}import>\\n\\n\\n\\npublic class $<main.CodeWriter> \\n$<{java.CodeWriter.extends>  extends $<java.CodeWriter.extends> $<}java.CodeWriter.extends> \\n$<{java.CodeWriter.implements>  implements $<java.CodeWriter.implements> $<}java.CodeWriter.implements>\\n{\\n\\n  /* Constants << */\\n \\n  // User Interface text message parts\\n  public static final String writer__UITEXT_Method                   = \\\"method \\\";\\n  public static final String writer__UITEXT_Main                     = \\\"main \\\";\\n  public static final String writer__UITEXT_ExceptionIn              = \\\"Exception in \\\";\\n  public static final String writer__UITEXT_ColonNewLine             = \\\":\\\\n\\\";\\n  public static final String writer__UITEXT_NewLine                  = \\\"\\\\n\\\";\\n  public static final String writer__UITEXT_Section                  = \\\"section \\\";\\n  public static final String writer__UITEXT_SavedFile                = \\\"Saved file:       \\\";\\n  public static final String writer__UITEXT_UnableToSaveFile         = \\\"Unable to save file: \\\";\\n  public static final String writer__UITEXT_UnableToBackupFile       = \\\"Unable to backup file: \\\";\\n  public static final String writer__UITEXT_ToBackupFolder           = \\\" to backup folder: \\\";\\n  public static final String writer__UITEXT_BackupFolderColon        = \\\"Backup folder: \\\";\\n  public static final String writer__UITEXT_BackupFolderExistFailure = \\\" does not exist and cannot be created.\\\";\\n  public static final String writer__UITEXT_BackupFolderNotAFolder   = \\\" is not a folder.\\\";\\n  public static final String writer__UITEXT_BackupFolderNotWritable  = \\\" is not writable.\\\";\\n  public static final String writer__UITEXT_CodeWriterState          = \\\"Code Writer State: \\\";\\n  public static final String writer__UITEXT_GetFileIndexEquals       = \\\"\\\\n_getFileIndex()    = \\\";\\n  public static final String writer__UITEXT_GetFullFileNameEquals    = \\\"\\\\n_getFullFileName() = \\\";\\n  public static final String writer__UITEXT_GetOutputFolderEquals    = \\\"\\\\n_getOutputFolder() = \\\";\\n  public static final String writer__UITEXT_ErrorHeader              = \\\"\\\\n\\\\n--- CodeWriter Error Description Start ---\\\\n\\\\n\\\";\\n  public static final String writer__UITEXT_ErrorFooter              = \\\"\\\\n--- CodeWriter Error Description End -----\\\\n\\\\n\\\";\\n  public static final String writer__UITEXT_PlaceHolderException \\n    = \\\"This placeholder Exception should never be thrown: there is an error in the WriterFormat.\\\";\\n\\n  public static final int writer__FILE_BUFFER_SIZE  = 4096;                // initial size of StringBuffer\\n\\n  /* Constants >> */\\n\\n\\n  /* Writer Variables << */\\n\\n  protected String[]     writer__iFileNameRoots     = new String[] {};     // generated file name roots\\n  protected int          writer__iNumFiles          = 0;                   // number of generated files\\n  \\n  protected String       writer__iFileNamePrefix    = \\\"\\\";                  // failsafe default\\n  protected String       writer__iFileNameSuffix    = \\\"\\\";                  // failsafe default\\n\\n  protected String       writer__iBackupPrefix      = \\\"\\\";                  // failsafe default\\n  protected String       writer__iBackupSuffix      = \\\"\\\";                  // failsafe default\\n\\n  protected StringBuffer writer__iCurrentText       = new StringBuffer();  // current text\\n  protected int          writer__iCurrentFileIndex  = 0;                   // current file index\\n\\n  protected boolean      writer__iSave              = true;                // save generated code to disk\\n  protected boolean      writer__iBackup            = true;                // make backups\\n\\n  protected String       writer__iOutputFolder      = \\\".\\\";                 // written code is output to this folder\\n  protected String       writer__iBackupFolder      = \\\".\\\";                 // overwritten files are placed here\\n\\n  protected Hashtable    writer__iProperties            = new Hashtable(); // lookup table for compile time properties\\n  protected boolean      writer__iPropertiesInitialised = false;           // true => lookup table initialiased\\n\\n  /* Writer Variables >> */\\n\\n\\n  !<{declare>/* section:declare << */\\n  //\\n\\n  !<declare>\\n\\n  //\\n  /* section:declare >> */!<}declare>\\n\\n\\n\\n  /* Writer Services << */\\n\\n  /* Initialize. */\\n  public void writer__initialize() {\\n    writer__iCurrentFileIndex = 0;\\n    writer__setDefaults();\\n  }\\n\\n\\n\\n  /** Main loop.\\n   *  Template script is placed here in the @body section.\\n   */\\n  public void writer__write() throws Exception {\\n\\n    // initialize\\n    String writer__currentSection = \\\"init\\\";\\n\\n    try {\\n      !<{init>/* section:init << */\\n      //\\n\\n      !<init>\\n\\n      //\\n      /* section:init >> */!<}init>\\n\\n\\n      // write files loop\\n      int      writer__numFiles = _getNumFiles();\\n      int      writer__fileI    = 0;\\n      writer__next_file: for( writer__fileI = 0; writer__fileI < writer__numFiles; writer__fileI++ ) {\\n\\n        !<{prewrite>/* section:prewrite << */\\n        // \\n\\n        writer__currentSection = \\\"prewrite\\\";\\n        !<prewrite>\\n\\n        //\\n        /* section:prewrite >> */!<}prewrite>\\n\\n\\n        if( ! writer__startFile() ) { continue writer__next_file; }\\n\\n\\n        !<{body>/* section:body << */\\n        //\\n\\n        writer__currentSection = \\\"body\\\";\\n        !<body>\\n\\n        //\\n        /* section:body >> */!<}body>\\n\\n\\n        if( ! writer__endFile() ) { continue writer__next_file; }\\n\\n\\n        !<{postwrite>/* section:postwrite << */\\n        // \\n\\n        writer__currentSection = \\\"postwrite\\\";\\n        !<postwrite>\\n\\n        //\\n        /* section:postwrite >> */!<}postwrite>\\n\\n        writer__nextFile();       \\n      }\\n \\n\\n      !<{cleanup>/* section:cleanup << */\\n      //\\n \\n      writer__currentSection = \\\"cleanup\\\";\\n      !<cleanup>\\n\\n      //\\n      /* section:cleanup >> */!<}cleanup>\\n\\n\\n    } \\n    catch( Exception e ) {\\n      writer__handleException( writer__UITEXT_ExceptionIn + writer__UITEXT_Section + writer__currentSection, e );\\n    }\\n\\n  }\\n\\n\\n\\n  /** Start writing a file. */\\n  public boolean writer__startFile() {\\n    writer__iCurrentText = new StringBuffer( writer__FILE_BUFFER_SIZE );\\n    return true;\\n  }\\n\\n\\n\\n  /** End writing a file. */\\n  public boolean writer__endFile() throws Exception {\\n    boolean endOK = true;\\n\\n    String fileName = _getFullFileName();\\n    String filePath \\n      = writer__iOutputFolder\\n      + \\\"$<\\\\jostraca.system.fileSeparator>\\\"\\n      + fileName\\n      ;\\n\\n    if( writer__iBackup ) {\\n      try {\\n        writer__backup( filePath, fileName, writer__iBackupFolder );\\n\\n      } \\n      catch( Exception e ) {\\n        writer__handleException( writer__UITEXT_UnableToBackupFile \\n                                + filePath \\n                                + writer__UITEXT_ToBackupFolder\\n                                + writer__iBackupFolder\\n                                ,e \\n                              );\\n        endOK = false;\\n      }\\n    }\\n \\n    if( endOK && writer__iSave ) {\\n      try {\\n        writer__save( filePath, writer__iCurrentText.toString() );\\n      } \\n      catch( Exception e ) {\\n        writer__handleException( writer__UITEXT_UnableToSaveFile + filePath, e );\\n        endOK = false;\\n      }\\n    }\\n\\n    return endOK;\\n  }\\n\\n\\n\\n  /** Move to next file. */\\n  public void writer__nextFile() {\\n    writer__iCurrentFileIndex = writer__iCurrentFileIndex + 1;\\n  }\\n\\n\\n\\n  /** Set defaults from configuration property set. */\\n  public void writer__setDefaults() {\\n\\n    $<{main.FileNameRoot>_setFileNameRoot( \\\"$<\\\\main.FileNameRoot>\\\" );$<}main.FileNameRoot>\\n    $<{main.FileNamePrefix>_setFileNamePrefix( \\\"$<\\\\main.FileNamePrefix>\\\" );$<}main.FileNamePrefix>\\n    $<{main.FileNameSuffix>_setFileNameSuffix( \\\"$<\\\\main.FileNameSuffix>\\\" );$<}main.FileNameSufffix>\\n\\n    $<{main.OutputFolder>_setOutputFolder( \\\"$<\\\\main.OutputFolder>\\\" );$<}main.OutputFolder>\\n\\n    $<{main.BackupFolder>_setBackupFolder( \\\"$<\\\\main.BackupFolder>\\\" );$<}main.BackupFolder>\\n    $<{main.BackupPrefix>_setBackupPrefix( \\\"$<\\\\main.BackupPrefix>\\\" );$<}main.BackupPrefix>\\n    $<{main.BackupSuffix>_setBackupSuffix( \\\"$<\\\\main.BackupSuffix>\\\" );$<}main.BackupSufffix>\\n    _backup( \\\"$<lang.TrueString>\\\".equals( \\\"$<jostraca.MakeBackup>\\\" ) );\\n\\n  }\\n\\n\\n\\n  /** Handle exceptions: print an explanation for user. */\\n  public void writer__handleException( String rMessage, Exception rException ) throws Exception {\\n\\n    StringBuffer userMsg = new StringBuffer( 111 );\\n\\n    userMsg.append( writer__UITEXT_ErrorHeader );\\n\\n    userMsg.append( writer__describeState() + rMessage + writer__UITEXT_ColonNewLine );\\n\\n    StringWriter stringWriter = new StringWriter();\\n    rException.printStackTrace( new PrintWriter( stringWriter) );\\n    userMsg.append( stringWriter.toString() );\\n\\n    userMsg.append( writer__UITEXT_ErrorFooter );\\n\\n    throw new Exception( userMsg.toString() );\\n  }\\n\\n\\n\\n  /** Provide a concise description of the state of the CodeWriter. */\\n  public String writer__describeState() {\\n    String currentState \\n      = writer__UITEXT_CodeWriterState\\n      + writer__UITEXT_GetFileIndexEquals    + _getFileIndex() \\n      + writer__UITEXT_GetFullFileNameEquals + _getFullFileName()\\n      + writer__UITEXT_GetOutputFolderEquals + _getOutputFolder()\\n      + writer__UITEXT_NewLine\\n      ; \\n    return currentState;\\n  }\\n\\n\\n\\n  /** Save written files to disk. \\n   *  @param rFilePath Save location.\\n   *  @param rContent  File content.\\n   */\\n  public void writer__save( String rFilePath, String rContent ) throws Exception {\\n    StringReader   sr = new StringReader( rContent );\\n    BufferedReader br = new BufferedReader( sr );\\n    FileWriter     fw = new FileWriter( rFilePath );\\n    BufferedWriter bw = new BufferedWriter( fw );\\n\\n    String line;\\n    while( null != (line = br.readLine()) ) {\\n      bw.write( line );\\n      bw.newLine();\\n    }\\n\\n    bw.close();\\n    br.close();\\n\\n  }\\n\\n\\n\\n  /** Read file from disk.\\n   *  @param rFilePath.\\n   */\\n  public String writer__read( String rFilePath ) throws Exception {\\n    File       file       = new File( rFilePath );\\n    FileReader in         = new FileReader( file );\\n    int        size       = (int) file.length();\\n    char[]     data       = new char[size];\\n    int        charsRead  = 0;\\n\\n    while( charsRead < size ) {\\n      charsRead += in.read( data, charsRead, size - charsRead );\\n    }\\n\\n    return new String( data );\\n  }\\n\\n\\n\\n  /** Backup overwritten files, if they exist.\\n   *  Backups have the format:\\n   *  [YYYYMMDDhhmmss][prefix][filename][suffix]\\n   *  @param rFilePath     Full Path of File to backup (including name).\\n   *  @param rFileName     Name of File to backup.\\n   *  @param rBackupFolder Folder to place backups in.\\n   */ \\n  public void writer__backup( String rFilePath, String rFileName, String rBackupFolder ) throws Exception {\\n\\n    File backupFolder = new File( rBackupFolder );\\n\\n    // check backup folder ( create if necessary )\\n    // ...\\n\\n    if( ! backupFolder.exists() ) {\\n      if( ! backupFolder.mkdir() ) {\\n        throw new Exception( writer__UITEXT_BackupFolderColon\\n                             + backupFolder\\n                             + writer__UITEXT_BackupFolderExistFailure );\\n      }\\n    }\\n    if( ! backupFolder.isDirectory() ) {\\n      throw new Exception( writer__UITEXT_BackupFolderColon \\n                           + backupFolder\\n                           + writer__UITEXT_BackupFolderNotAFolder );\\n    }\\n    if( ! backupFolder.canWrite() ) {\\n      throw new Exception( writer__UITEXT_BackupFolderColon\\n                           + backupFolder\\n                           + writer__UITEXT_BackupFolderNotWritable );\\n    }\\n\\n    // create backup file path\\n    Calendar calendar = Calendar.getInstance();\\n    String year_yyyy = _align( String.valueOf( calendar.get(Calendar.YEAR) ),         \\\"0\\\", 4, 'r' );\\n    String month_mm  = _align( String.valueOf( (1+calendar.get(Calendar.MONTH)) ),    \\\"0\\\", 2, 'r' );\\n    String day_dd    = _align( String.valueOf( calendar.get(Calendar.DAY_OF_MONTH) ), \\\"0\\\", 2, 'r' );\\n    String hour_hh   = _align( String.valueOf( calendar.get(Calendar.HOUR_OF_DAY) ),  \\\"0\\\", 2, 'r' );\\n    String minute_mm = _align( String.valueOf( calendar.get(Calendar.MINUTE) ),       \\\"0\\\", 2, 'r' );\\n    String second_ss = _align( String.valueOf( calendar.get(Calendar.SECOND) ),       \\\"0\\\", 2, 'r' );\\n    String dateTime       = year_yyyy+month_mm+day_dd+hour_hh+minute_mm+second_ss;\\n    String backupFileName = dateTime + writer__iBackupPrefix + rFileName + writer__iBackupSuffix;\\n    File   backupFilePath = new File( rBackupFolder, backupFileName );\\n    \\n    // save backup file\\n    File fileToBackup = new File( rFilePath );\\n    if( fileToBackup.exists() ) {\\n      String fileContents = writer__read( rFilePath );\\n      writer__save( backupFilePath.getPath(), fileContents );\\n    }\\n  }\\n\\n\\n\\n  /** Set compile time properties. */\\n  public void writer__initProperties() {\\n    $<{jostraca.properties.NameValueList>\\n    String[] propertyList = new String[] { $<jostraca.properties.NameValueList> };\\n    int numProperties = propertyList.length;\\n    for( int propI = 0; propI < numProperties; propI += 2 ) {\\n      writer__iProperties.put( propertyList[ propI ], propertyList[ propI+1 ] );\\n    }\\n    writer__iPropertiesInitialised = true;\\n    $<}jostraca.properties.NameValueList>\\n  }\\n\\n\\n  /* Writer Services >> */\\n \\n\\n\\n\\n  /* Template Services (File Generation) << */\\n\\n  /** Set the prefix of the files to be written. \\n   *  @param rPrefix Written files prefix.\\n   */\\n  public void _setFileNamePrefix( String rPrefix ) {\\n    if( null == rPrefix ) {\\n      return; // ignore\\n    }\\n    writer__iFileNamePrefix = rPrefix;\\n  }\\n\\n\\n\\n  /** Get prefix of files to be written. */\\n  public String _getFileNamePrefix() {\\n    return writer__iFileNamePrefix;\\n  }\\n\\n\\n\\n  /** Set the suffix of the files to be written. \\n   *  @param rSuffix Written files suffix.\\n   */\\n  public void _setFileNameSuffix( String rSuffix ) {\\n    if( null == rSuffix ) {\\n      return; // ignore\\n    }\\n    writer__iFileNameSuffix = rSuffix;\\n  }\\n\\n\\n\\n  /** Get suffix of files to be written. */\\n  public String _getFileNameSuffix() {\\n    return writer__iFileNameSuffix;\\n  }\\n\\n\\n\\n  /** Set the full name of the file to be written. \\n   *  Prefix and Suffix are set to empty\\n   *  @param rName Full name of the file to write.\\n   */\\n  public void _setFullFileName( String rName ) {\\n    _setFileNamePrefix( \\\"\\\" );\\n    _setFileNameRoot(   rName );\\n    _setFileNameSuffix( \\\"\\\" );\\n  }\\n\\n\\n\\n  /** Get the full name of current file being generated. */\\n  public String _getFullFileName() {\\n    return _getFileNamePrefix() + _getFileNameRoot() + _getFileNameSuffix();\\n  }\\n\\n\\n\\n  /** Set the names of the files to be written. \\n   *  Prefix and Suffix are set to empty\\n   *  @param rName Full name of the file to write.\\n   */\\n  public void _setFullFileNames( String[] rNames ) {\\n    _setFileNamePrefix( \\\"\\\" );\\n    _setFileNameRoots(  rNames );\\n    _setFileNameSuffix( \\\"\\\" );\\n  }\\n\\n\\n\\n  /** Get the full names of the files to be written. */\\n  public String[] _getFullFileNames() {\\n\\n    String[] fileNameRoots  = _getFileNameRoots();\\n    int      numFiles       = fileNameRoots.length;\\n    String[] fullFileNames  = new String[ numFiles ];\\n    String   fileNamePrefix = _getFileNamePrefix();\\n    String   fileNameSuffix = _getFileNameSuffix();\\n\\n    for( int fileI = 0; fileI < numFiles; fileI++ ) {\\n      fullFileNames[ fileI ] = fileNamePrefix + fileNameRoots[ fileI ] + fileNameSuffix;\\n    }\\n\\n    return fullFileNames;\\n  }\\n\\n\\n\\n  /** Set the root of the name of the file to be written. \\n   *  @param rFileNameRoot Root of the name of file to be written.\\n   */\\n  public void _setFileNameRoot( String rFileNameRoot ) {\\n    if( null == rFileNameRoot ) {\\n      return; // ignore\\n    }\\n    _setFileNameRoots( new String[] { rFileNameRoot } );\\n  }\\n\\n\\n\\n  /** Get the root of the name of current file being generated. */\\n  public String _getFileNameRoot() {\\n    if( 0 < writer__iFileNameRoots.length ) {\\n      return writer__iFileNameRoots[ writer__iCurrentFileIndex ];\\n    }\\n    return \\\"\\\";\\n  }\\n\\n\\n\\n  /** Set the roots of the names of the files to be written. \\n   *  @param rFileNameRoots Roots of names of files to be written.\\n   */\\n  public void _setFileNameRoots( String[] rFileNameRoots ) {\\n    if( null == rFileNameRoots ) {\\n      return; // ignore\\n    }\\n\\n    // copy\\n    String[] roots = (String[]) rFileNameRoots.clone();\\n\\n    // normalize - replace nulls\\n    int numRoots = roots.length;\\n    for(int rootI = 0; rootI < numRoots; rootI++) {\\n      if( null == roots[ rootI ] ) {\\n        roots[ rootI ] = \\\"\\\";\\n      }\\n    }\\n\\n    // save roots\\n    writer__iFileNameRoots = roots;\\n    writer__iNumFiles      = numRoots;\\n  }\\n\\n\\n\\n  /** Get roots of the names of files to be written. */\\n  public String[] _getFileNameRoots() {\\n    return writer__iFileNameRoots;\\n  }\\n\\n\\n\\n  /** Get index of file currently being generated. */\\n  public int _getFileIndex() {\\n    return writer__iCurrentFileIndex;\\n  }\\n\\n\\n\\n  /** Get number of generated files. */\\n  public int _getNumFiles() {\\n    return writer__iNumFiles;\\n  }\\n\\n\\n\\n  /** Set output folder.\\n   *  @param rOutputFolder Folder to output generated code to.\\n   */\\n  public void _setOutputFolder( String rOutputFolder ) {\\n    writer__iOutputFolder = rOutputFolder;\\n  }\\n\\n\\n\\n  /** Get output folder. */\\n  public String _getOutputFolder() {\\n    return writer__iOutputFolder;\\n  }\\n\\n\\n\\n  /** Set backup folder.\\n   *  @param rBackupFolder Folder to backup overwritten files to.\\n   */\\n  public void _setBackupFolder( String rBackupFolder ) {\\n    writer__iBackupFolder = writer__iOutputFolder + \\\"$<\\\\jostraca.system.fileSeparator>\\\" + rBackupFolder;\\n  }\\n\\n\\n\\n  /** Get backup folder. */\\n  public String _getBackupFolder() {\\n    return writer__iBackupFolder;\\n  }\\n\\n\\n\\n  /** Set the suffix of backup files.\\n   *  @param rSuffix Backup files suffix.\\n   */\\n  public void _setBackupSuffix( String rSuffix ) {\\n    if( null == rSuffix ) {\\n      return; // ignore\\n    }\\n    writer__iBackupSuffix = rSuffix;\\n  }\\n\\n\\n\\n  /** Set the prefix of backup files.\\n   *  @param rPrefix Backup files prefix.\\n   */\\n  public void _setBackupPrefix( String rPrefix ) {\\n    if( null == rPrefix ) {\\n      return; // ignore\\n    }\\n    writer__iBackupPrefix = rPrefix;\\n  }\\n\\n\\n\\n  /** Set to true if written files are to be backed up to disk automatically. \\n   *  @param rBackup True => Backup files to disk.\\n   */\\n  public void _backup( boolean rBackup ) {\\n    writer__iBackup = rBackup;\\n  }\\n\\n\\n\\n  /** Set to true if written files are to be saved to disk automatically. \\n   *  @param rSave True => Save written files to disk.\\n   */\\n  public void _save( boolean rSave ) {\\n    writer__iSave = rSave;\\n  }\\n\\n\\n  /* Template Services (File Generation) >> */\\n\\n\\n\\n\\n  /* Template Services (Control) << */\\n\\n  /** Get compile time property\\n   *  @param rName Name of property to get.\\n   */\\n  public String _getProperty( String rName ) {\\n    String result = \\\"\\\";\\n\\n    if( ! writer__iPropertiesInitialised ) {\\n      writer__initProperties();\\n    }\\n\\n    if( writer__iProperties.containsKey( rName ) ) {\\n      result = (String) writer__iProperties.get( rName );\\n    }\\n\\n    return result;\\n  }\\n\\n  /* Template Services (Control) >> */\\n\\n\\n\\n  /* Template Services (Text Production) << */\\n\\n\\n  // inserts\\n  // ...\\n\\n  /** Insert text into written file. \\n   *  Abbreviated by <%=foobar%>. \\n   *  @param rText Text to insert.\\n   */\\n  public void _insert( String rText ) {\\n    writer__iCurrentText.append( rText );\\n  }\\n\\n  /** Insert string representation of object into written file. \\n   *  Abbreviated by <%=foobar%>. \\n   *  @param rObject Object to insert.\\n   */\\n  public void _insert( Object rObject ) {\\n    writer__iCurrentText.append( \\\"\\\"+rObject );\\n  }\\n\\n  /** Insert string representation of primitive data type into written file. \\n   *  Abbreviated by <%=foobar%>. \\n   *  @param rInt int to insert\\n   */\\n  public void _insert( int rInt ) {\\n    writer__iCurrentText.append( rInt );\\n  }\\n\\n  /** Insert string representation of primitive data type into written file. \\n   *  Abbreviated by <%=foobar%>. \\n   *  @param rLong long to insert\\n   */\\n  public void _insert( long rLong ) {\\n    writer__iCurrentText.append( rLong );\\n  }\\n\\n  /** Insert string representation of primitive data type into written file. \\n   *  Abbreviated by <%=foobar%>. \\n   *  @param rShort short to insert\\n   */\\n  public void _insert( short rShort ) {\\n    writer__iCurrentText.append( rShort );\\n  }\\n\\n  /** Insert string representation of primitive data type into written file. \\n   *  Abbreviated by <%=foobar%>. \\n   *  @param rByte byte to insert\\n   */\\n  public void _insert( byte rByte ) {\\n    writer__iCurrentText.append( rByte );\\n  }\\n\\n  /** Insert string representation of primitive data type into written file. \\n   *  Abbreviated by <%=foobar%>. \\n   *  @param rDouble double to insert\\n   */\\n  public void _insert( double rDouble ) {\\n    writer__iCurrentText.append( rDouble );\\n  }\\n\\n  /** Insert string representation of primitive data type into written file. \\n   *  Abbreviated by <%=foobar%>. \\n   *  @param rFloat float to insert\\n   */\\n  public void _insert( float rFloat ) {\\n    writer__iCurrentText.append( rFloat );\\n  }\\n\\n  /** Insert string representation of primitive data type into written file. \\n   *  Abbreviated by <%=foobar%>. \\n   *  @param rChar char to insert\\n   */\\n  public void _insert( char rChar ) {\\n    writer__iCurrentText.append( rChar );\\n  }\\n\\n  /** Insert string representation of primitive data type into written file. \\n   *  Abbreviated by <%=foobar%>. \\n   *  @param rBoolean boolean to insert\\n   */\\n  public void _insert( boolean rBoolean ) {\\n    writer__iCurrentText.append( rBoolean );\\n  }\\n\\n\\n\\n  /** Create a String containing specified number of spaces.\\n   *  @param rNumSpaces Number of spaces to place in String\\n   */\\n  public String _spaces( int rNumSpaces ) {\\n    int numSpaces = rNumSpaces;\\n    if( 0 > numSpaces ) { numSpaces *= -1; }\\n    StringBuffer spaces = new StringBuffer( numSpaces );\\n    for(int spaceI = 0; spaceI < numSpaces; spaceI++) {\\n      spaces.append(\\\" \\\");\\n    }\\n    return spaces.toString();\\n  }\\n\\n\\n\\n  /** Left align String with spaces. */ \\n  public String _left( String rText, int rColWidth ) {\\n    return _align( rText, \\\" \\\", rColWidth, 'l' );\\n  } \\n\\n\\n\\n  /** Right align String with spaces. */ \\n  public String _right( String rText, int rColWidth ) {\\n    return _align( rText, \\\" \\\", rColWidth, 'r' );\\n  } \\n\\n\\n\\n  /** Center align String with spaces. */ \\n  public String _center( String rText, int rColWidth ) {\\n    return _align( rText, \\\" \\\", rColWidth, 'c' );\\n  } \\n\\n\\n\\n  /** Align text within background text to specified column width. \\n   *  Alignment can be 'l': left, 'c': center, 'r': right\\n   */\\n  public String _align( String rText, String rBackText, int rColWidth, char rAlignment ) {\\n    String result = rText;\\n \\n    if( null == rText ) { \\n       result = \\\"\\\"; \\n    }\\n    else if( null != rBackText ) {\\n      try {\\n        int textLen = rText.length();\\n        if( rColWidth > textLen ) {\\n          int    backTextLen     = rBackText.length();\\n          int    remainWidth     = rColWidth - textLen;\\n          int    backTextRepeats = remainWidth / backTextLen;\\n          int    backTextRemain  = remainWidth % backTextLen;\\n          String back            = \\\"\\\";\\n          for( int backTextI = 0; backTextI < backTextRepeats; backTextI++ ) {\\n            back = back + rBackText;\\n          }\\n          back = back + rBackText.substring( 0, backTextRemain );\\n \\n          switch( rAlignment ) {\\n          case 'l':\\n            result = result + back;\\n            break;\\n          case 'c':\\n            result = back.substring( 0, (back.length()/2) ) + result + back.substring( (back.length()/2) );\\n            break;\\n          case 'r':\\n            result = back + result;\\n            break;\\n          }\\n        }\\n      } \\n      catch( Exception e ) {\\n        result = rText;\\n      }\\n    }\\n    return result;\\n  }\\n\\n\\n\\n  /** Set current text of file currently being generated. */\\n  public void _setText( String rText) {\\n    writer__iCurrentText = new StringBuffer( rText );\\n  }\\n\\n\\n\\n  /** Get current text of file currently being generated. */\\n  public String _getText() {\\n    return writer__iCurrentText.toString();\\n  }\\n\\n  /* Template Services (Text Production) << */\\n\\n}\\n\\n\\n!<footer>\\n\"\n    );\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3985048, "method2_id": 23079228, "code1": "private void backupFile (ZipEntry oldEntry, ZipInputStream oldBackupIn, ZipOutputStream oldBackupOut, ZipOutputStream newBackupOut, File file, String filename) throws IOException {\n    ByteArrayOutputStream bytesSeen = null;\n    InputStream oldIn = null;\n    if (oldEntry != null && oldBackupIn != null && oldBackupOut != null) {\n        bytesSeen = new ByteArrayOutputStream ();\n        oldIn = oldBackupIn;\n    }\n    ZipEntry e = new ZipEntry (filename);\n    e.setTime (file.lastModified ());\n    e.setSize (file.length ());\n    newBackupOut.putNextEntry (e);\n    InputStream fileIn = new BufferedInputStream (new FileInputStream (file));\n    OutputStream fileOut = newBackupOut;\n    int c, d;\n    try {\n        while ((c = fileIn.read ()) != - 1) {\n            fileOut.write (c);\n            if (oldIn != null) {\n                d = oldIn.read ();\n                if (d != - 1) bytesSeen.write (d);\n\n                if (c != d) {\n                    copyZipEntry (oldIn, oldBackupOut, oldEntry, bytesSeen.toByteArray ());\n                    oldIn = null;\n                    bytesSeen = null;\n                    oldBackupIn = null;\n                    oldBackupOut = null;\n                    wroteEntryToOldBackup (filename);\n                }\n            }\n            ThreadThrottler.tick ();\n        }\n    } finally {\n        fileIn.close ();\n    }\n    if (oldIn != null) {\n        d = oldIn.read ();\n        if (d != - 1) {\n            bytesSeen.write (d);\n            copyZipEntry (oldIn, oldBackupOut, oldEntry, bytesSeen.toByteArray ());\n            wroteEntryToOldBackup (filename);\n        }\n    }\n    fileOut.flush ();\n    newBackupOut.closeEntry ();\n}\n", "code2": "public static byte [] zipObject (Object o) {\n    if (o == null) return null;\n\n    byte [] returnValue = null;\n    try {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream ();\n        ObjectOutputStream oos = new ObjectOutputStream (baos);\n        oos.writeObject (o);\n        oos.close ();\n        byte [] binaryData = baos.toByteArray ();\n        ByteArrayOutputStream baos2 = new ByteArrayOutputStream ();\n        ZipOutputStream zos = new ZipOutputStream (baos2);\n        ZipEntry ze = new ZipEntry (\"compressed_obj\");\n        zos.putNextEntry (ze);\n        zos.write (binaryData);\n        zos.closeEntry ();\n        zos.flush ();\n        zos.close ();\n        returnValue = baos2.toByteArray ();\n        baos.close ();\n        baos2.close ();\n    } catch (IOException ex) {\n        returnValue = null;\n    }\n    return returnValue;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8788371, "method2_id": 18583832, "code1": "private void tail (String [] cmd, int pos) throws IOException {\n    CommandFormat c = new CommandFormat (\"tail\", 1, 1, \"f\");\n    String src = null;\n    Path path = null;\n    try {\n        List < String > parameters = c.parse (cmd, pos);\n        src = parameters.get (0);\n    } catch (IllegalArgumentException iae) {\n        System.err.println (\"Usage: java FsShell \" + TAIL_USAGE);\n        throw iae;\n    }\n    boolean foption = c.getOpt (\"f\") ? true : false;\n    path = new Path (src);\n    FileSystem srcFs = path.getFileSystem (getConf ());\n    if (srcFs.isDirectory (path)) {\n        throw new IOException (\"Source must be a file.\");\n    }\n    long fileSize = srcFs.getFileStatus (path).getLen ();\n    long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n    while (true) {\n        FSDataInputStream in = srcFs.open (path);\n        in.seek (offset);\n        IOUtils.copyBytes (in, System.out, 1024, false);\n        offset = in.getPos ();\n        in.close ();\n        if (! foption) {\n            break;\n        }\n        fileSize = srcFs.getFileStatus (path).getLen ();\n        offset = (fileSize > offset) ? offset : fileSize;\n        try {\n            Thread.sleep (5000);\n        } catch (InterruptedException e) {\n            break;\n        }\n    }\n}\n", "code2": "private static void copy (File source, File target) throws IOException {\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (source);\n        to = new FileOutputStream (target);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 11290317, "method2_id": 11481709, "code1": "private void trainSRLParser (byte flag, JarArchiveOutputStream zout) throws Exception {\n    AbstractSRLParser labeler = null;\n    AbstractDecoder [] decoder = null;\n    if (flag == SRLParser.FLAG_TRAIN_LEXICON) {\n        System.out.println (\"\\n* Save lexica\");\n        labeler = new SRLParser (flag, s_featureXml);\n    } else if (flag == SRLParser.FLAG_TRAIN_INSTANCE) {\n        System.out.println (\"\\n* Print training instances\");\n        System.out.println (\"- loading lexica\");\n        labeler = new SRLParser (flag, t_xml, s_lexiconFiles);\n    } else if (flag == SRLParser.FLAG_TRAIN_BOOST) {\n        System.out.println (\"\\n* Train boost\");\n        decoder = new AbstractDecoder [m_model.length];\n        for (int i = 0;\n        i < decoder.length; i ++) decoder [i] = new OneVsAllDecoder ((OneVsAllModel) m_model [i]);\n\n        labeler = new SRLParser (flag, t_xml, t_map, decoder);\n    }\n\n    AbstractReader < DepNode, DepTree > reader = new SRLReader (s_trainFile, true);\n    DepTree tree;\n    int n;\n    labeler.setLanguage (s_language);\n    reader.setLanguage (s_language);\n    for (n = 0; (tree = reader.nextTree ()) != null; n ++) {\n        labeler.parse (tree);\n        if (n % 1000 == 0) System.out.printf (\"\\r- parsing: %dK\", n / 1000);\n\n    }\n    System.out.println (\"\\r- labeling: \" + n);\n    if (flag == SRLParser.FLAG_TRAIN_LEXICON) {\n        System.out.println (\"- labeling\");\n        labeler.saveTags (s_lexiconFiles);\n        t_xml = labeler.getSRLFtrXml ();\n    } else if (flag == SRLParser.FLAG_TRAIN_INSTANCE || flag == SRLParser.FLAG_TRAIN_BOOST) {\n        a_yx = labeler.a_trans;\n        zout.putArchiveEntry (new JarArchiveEntry (ENTRY_FEATURE));\n        IOUtils.copy (new FileInputStream (s_featureXml), zout);\n        zout.closeArchiveEntry ();\n        for (String lexicaFile : s_lexiconFiles) {\n            zout.putArchiveEntry (new JarArchiveEntry (lexicaFile));\n            IOUtils.copy (new FileInputStream (lexicaFile), zout);\n            zout.closeArchiveEntry ();\n        }\n        if (flag == SRLParser.FLAG_TRAIN_INSTANCE) t_map = labeler.getSRLFtrMap ();\n\n    }\n\n}\n", "code2": "public boolean copy (File fromFile) throws IOException {\n    FileUtility toFile = this;\n    if (! fromFile.exists ()) {\n        abort (\"FileUtility: no such source file: \" + fromFile.getAbsolutePath ());\n        return false;\n    }\n    if (! fromFile.isFile ()) {\n        abort (\"FileUtility: can't copy directory: \" + fromFile.getAbsolutePath ());\n        return false;\n    }\n    if (! fromFile.canRead ()) {\n        abort (\"FileUtility: source file is unreadable: \" + fromFile.getAbsolutePath ());\n        return false;\n    }\n    if (this.isDirectory ()) toFile = (FileUtility) (new File (this, fromFile.getName ()));\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) {\n            abort (\"FileUtility: destination file is unwriteable: \" + pathName);\n            return false;\n        }\n    } else {\n        String parent = toFile.getParent ();\n        File dir = new File (parent);\n        if (! dir.exists ()) {\n            abort (\"FileUtility: destination directory doesn't exist: \" + parent);\n            return false;\n        }\n        if (dir.isFile ()) {\n            abort (\"FileUtility: destination is not a directory: \" + parent);\n            return false;\n        }\n        if (! dir.canWrite ()) {\n            abort (\"FileUtility: destination directory is unwriteable: \" + parent);\n            return false;\n        }\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytes_read;\n        while ((bytes_read = from.read (buffer)) != - 1) to.write (buffer, 0, bytes_read);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n    return true;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 17147420, "method2_id": 22079999, "code1": "public final String latestVersion () {\n    String latestVersion = \"\";\n    try {\n        URL url = new URL (Constants.officialSite + \":80/LatestVersion\");\n        BufferedReader in = new BufferedReader (new InputStreamReader (url.openStream ()));\n        String str;\n        while ((str = in.readLine ()) != null) {\n            latestVersion = str;\n        }\n        in.close ();\n    } catch (MalformedURLException e) {\n    } catch (IOException e) {\n    }\n    return latestVersion;\n}\n", "code2": "public static SubstanceSkin.ColorSchemes getColorSchemes (URL url) {\n    List < SubstanceColorScheme > schemes = new ArrayList < SubstanceColorScheme > ();\n    BufferedReader reader = null;\n    Color ultraLight = null;\n    Color extraLight = null;\n    Color light = null;\n    Color mid = null;\n    Color dark = null;\n    Color ultraDark = null;\n    Color foreground = null;\n    String name = null;\n    ColorSchemeKind kind = null;\n    boolean inColorSchemeBlock = false;\n    try {\n        reader = new BufferedReader (new InputStreamReader (url.openStream ()));\n        while (true) {\n            String line = reader.readLine ();\n            if (line == null) break;\n\n            line = line.trim ();\n            if (line.length () == 0) continue;\n\n            if (line.startsWith (\"#\")) {\n                continue;\n            }\n            if (line.indexOf (\"{\") >= 0) {\n                if (inColorSchemeBlock) {\n                    throw new IllegalArgumentException (\"Already in color scheme definition\");\n                }\n                inColorSchemeBlock = true;\n                name = line.substring (0, line.indexOf (\"{\")).trim ();\n                continue;\n            }\n            if (line.indexOf (\"}\") >= 0) {\n                if (! inColorSchemeBlock) {\n                    throw new IllegalArgumentException (\"Not in color scheme definition\");\n                }\n                inColorSchemeBlock = false;\n                if ((name == null) || (kind == null) || (ultraLight == null) || (extraLight == null) || (light == null) || (mid == null) || (dark == null) || (ultraDark == null) || (foreground == null)) {\n                    throw new IllegalArgumentException (\"Incomplete specification\");\n                }\n                Color [] colors = new Color [] {ultraLight, extraLight, light, mid, dark, ultraDark, foreground};\n                if (kind == ColorSchemeKind.LIGHT) {\n                    schemes.add (getLightColorScheme (name, colors));\n                } else {\n                    schemes.add (getDarkColorScheme (name, colors));\n                }\n                name = null;\n                kind = null;\n                ultraLight = null;\n                extraLight = null;\n                light = null;\n                mid = null;\n                dark = null;\n                ultraDark = null;\n                foreground = null;\n                continue;\n            }\n            String [] split = line.split (\"=\");\n            if (split.length != 2) {\n                throw new IllegalArgumentException (\"Unsupported format in line \" + line);\n            }\n            String key = split [0].trim ();\n            String value = split [1].trim ();\n            if (\"kind\".equals (key)) {\n                if (kind == null) {\n                    if (\"Light\".equals (value)) {\n                        kind = ColorSchemeKind.LIGHT;\n                        continue;\n                    }\n                    if (\"Dark\".equals (value)) {\n                        kind = ColorSchemeKind.DARK;\n                        continue;\n                    }\n                    throw new IllegalArgumentException (\"Unsupported format in line \" + line);\n                }\n                throw new IllegalArgumentException (\"'kind' should only be defined once\");\n            }\n            if (\"colorUltraLight\".equals (key)) {\n                if (ultraLight == null) {\n                    ultraLight = Color.decode (value);\n                    continue;\n                }\n                throw new IllegalArgumentException (\"'ultraLight' should only be defined once\");\n            }\n            if (\"colorExtraLight\".equals (key)) {\n                if (extraLight == null) {\n                    extraLight = Color.decode (value);\n                    continue;\n                }\n                throw new IllegalArgumentException (\"'extraLight' should only be defined once\");\n            }\n            if (\"colorLight\".equals (key)) {\n                if (light == null) {\n                    light = Color.decode (value);\n                    continue;\n                }\n                throw new IllegalArgumentException (\"'light' should only be defined once\");\n            }\n            if (\"colorMid\".equals (key)) {\n                if (mid == null) {\n                    mid = Color.decode (value);\n                    continue;\n                }\n                throw new IllegalArgumentException (\"'mid' should only be defined once\");\n            }\n            if (\"colorDark\".equals (key)) {\n                if (dark == null) {\n                    dark = Color.decode (value);\n                    continue;\n                }\n                throw new IllegalArgumentException (\"'dark' should only be defined once\");\n            }\n            if (\"colorUltraDark\".equals (key)) {\n                if (ultraDark == null) {\n                    ultraDark = Color.decode (value);\n                    continue;\n                }\n                throw new IllegalArgumentException (\"'ultraDark' should only be defined once\");\n            }\n            if (\"colorForeground\".equals (key)) {\n                if (foreground == null) {\n                    foreground = Color.decode (value);\n                    continue;\n                }\n                throw new IllegalArgumentException (\"'foreground' should only be defined once\");\n            }\n            throw new IllegalArgumentException (\"Unsupported format in line \" + line);\n        }\n    } catch (IOException ioe) {\n        throw new IllegalArgumentException (ioe);\n    } finally {\n        if (reader != null) {\n            try {\n                reader.close ();\n            } catch (IOException ioe) {\n            }\n        }\n    }\n    return new SubstanceSkin.ColorSchemes (schemes);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 5759962, "method2_id": 10671991, "code1": "@Override\npublic User login (String username, String password) {\n    User user = null;\n    try {\n        user = (User) em.createQuery (\"Select o from User o where o.username = :username\").setParameter (\"username\", username).getSingleResult ();\n    } catch (NoResultException e) {\n        throw new NestedException (e.getMessage (), e);\n    }\n    try {\n        MessageDigest digest = java.security.MessageDigest.getInstance (\"MD5\");\n        digest.update (password.getBytes (\"UTF-8\"));\n        byte [] hash = digest.digest ();\n        BigInteger bigInt = new BigInteger (1, hash);\n        String hashtext = bigInt.toString (16);\n        while (hashtext.length () < 32) {\n            hashtext = \"0\" + hashtext;\n        }\n        if (hashtext.equals (user.getPassword ())) return user;\n\n    } catch (Exception e) {\n        throw new NestedException (e.getMessage (), e);\n    }\n    return null;\n}\n", "code2": "public static String md5 (String value) {\n    try {\n        MessageDigest messageDigest = MessageDigest.getInstance (\"MD5\");\n        messageDigest.update (value.getBytes ());\n        return bytesToString (messageDigest.digest ());\n    } catch (Exception ex) {\n        Tools.logException (Tools.class, ex, value);\n    }\n    return value;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9711032, "method2_id": 21908905, "code1": "private String expandText (String text) {\n    Pattern pattern = Pattern.compile (\"[\\\\$,%]\\\\{([^\\\\}]+)\\\\}\");\n    Matcher matcher = pattern.matcher (text);\n    int matchEnd = 0;\n    StringBuffer result = new StringBuffer ();\n    while (matcher.find ()) {\n        String subText = text.substring (matchEnd, matcher.start ());\n        subText = subText.replaceAll (\"\\\\s+\", \" \");\n        if (subText.length () > 0) {\n            if (result.length () > 0) {\n                result.append ('+');\n            }\n            result.append ('\"');\n            result.append (subText);\n            result.append ('\"');\n        }\n        if (result.length () > 0) {\n            result.append ('+');\n        }\n        result.append (matcher.group (1));\n        matchEnd = matcher.end ();\n    }\n    String subText = text.substring (matchEnd);\n    subText = subText.replaceAll (\"\\\\s+\", \" \");\n    if (subText.length () > 0) {\n        if (result.length () > 0) {\n            result.append ('+');\n        }\n        result.append ('\"');\n        result.append (subText);\n        result.append ('\"');\n    }\n    return result.toString ();\n}\n", "code2": "private String markup (String content) {\n    if (content == null || content.length () == 0) {\n        return \"\";\n    }\n    Pattern p = Pattern.compile (PHOTOS_START_TAG + \".+?\" + PHOTOS_END_TAG, Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n    Matcher m = p.matcher (content);\n    while (m.find ()) {\n        int start = m.start ();\n        int end = m.end ();\n        String textToMarkup = content.substring (start, end);\n        textToMarkup = textToMarkup.substring (PHOTOS_START_TAG.length (), textToMarkup.length () - PHOTOS_END_TAG.length ());\n        StringBuffer buf = new StringBuffer ();\n        buf.append (\"<div class=\\\"photos\\\">\\n\");\n        try {\n            BufferedReader reader = new BufferedReader (new StringReader (textToMarkup));\n            String line = reader.readLine ();\n            buf.append (\"<div>\\n\");\n            boolean foundPhotos = false;\n            while (line != null) {\n                if (line.trim ().equals (\"\")) {\n                    if (foundPhotos) {\n                        buf.append (\"</div>\\n\");\n                        buf.append (\"<div>\\n\");\n                    }\n                } else {\n                    String [] tokens = line.split (\"\\\\|\");\n                    buf.append (\"<img src=\\\"\");\n                    buf.append (tokens [0]);\n                    buf.append (\"\\\" class=\\\"photo\\\" alt=\\\"\");\n                    if (tokens.length == 2) {\n                        buf.append (tokens [1]);\n                    }\n                    buf.append (\"\\\" />\\n\");\n                    foundPhotos = true;\n                }\n                line = reader.readLine ();\n            }\n            buf.append (\"</div>\\n\");\n        } catch (IOException ioe) {\n            log.warn (ioe);\n        }\n        buf.append (\"</div>\");\n        content = content.substring (0, start) + buf.toString () + content.substring (end, content.length ());\n        m = p.matcher (content);\n    }\n    return content;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 896372, "method2_id": 17477951, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "public static void copy (String inputFile, String outputFile) throws Exception {\n    try {\n        FileReader in = new FileReader (inputFile);\n        FileWriter out = new FileWriter (outputFile);\n        int c;\n        while ((c = in.read ()) != - 1) out.write (c);\n\n        in.close ();\n        out.close ();\n    } catch (Exception e) {\n        throw new Exception (\"Could not copy \" + inputFile + \" into \" + outputFile + \" because:\\n\" + e.getMessage ());\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2324866, "method2_id": 22321272, "code1": "public SpreadSheetFrame (FileManager owner, File file, Delimiter delim) {\n    super (owner, file.getPath ());\n    JPanel pane = new JPanel (new BorderLayout ());\n    super.contentPane.add (pane);\n    this.tableModel = new BigTableModel (file, delim);\n    this.table = new JTable (tableModel);\n    this.table.setAutoResizeMode (JTable.AUTO_RESIZE_OFF);\n    this.tableModel.setTable (this.table);\n    pane.add (new JScrollPane (this.table));\n    addInternalFrameListener (new InternalFrameAdapter () {\n        @Override\n        public void internalFrameClosed (InternalFrameEvent e) {\n            tableModel.close ();\n        }}\n\n    );\n    JMenu menu = new JMenu (\"Tools\");\n    getJMenuBar ().add (menu);\n    menu.add (new AbstractAction (\"NCBI\") {\n        @Override\n        public void actionPerformed (ActionEvent e) {\n            try {\n                Pattern delim = Pattern.compile (\"[ ]\");\n                BufferedReader r = new BufferedReader (new InputStreamReader (new GZIPInputStream (new FileInputStream (\"/home/lindenb/jeter.txt.gz\"))));\n                String line = null;\n                URL url = new URL (\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                URLConnection conn = url.openConnection ();\n                conn.setDoOutput (true);\n                OutputStreamWriter wr = new OutputStreamWriter (conn.getOutputStream ());\n                wr.write (\"db=snp&retmode=xml\");\n                while ((line = r.readLine ()) != null) {\n                    String tokens [] = delim.split (line, 2);\n                    if (! tokens [0].startsWith (\"rs\")) continue;\n\n                    wr.write (\"&id=\" + tokens [0].substring (2).trim ());\n                }\n                wr.flush ();\n                r.close ();\n                InputStream in = conn.getInputStream ();\n                IOUtils.copyTo (in, System.err);\n                in.close ();\n                wr.close ();\n            } catch (IOException err) {\n                err.printStackTrace ();\n            }\n        }}\n\n    );\n}\n", "code2": "public static void copyFile (File from, File to) throws Exception {\n    if (! from.exists ()) return;\n\n    FileInputStream in = new FileInputStream (from);\n    FileOutputStream out = new FileOutputStream (to);\n    byte [] buffer = new byte [BUFFER_SIZE];\n    int bytes_read;\n    while (true) {\n        bytes_read = in.read (buffer);\n        if (bytes_read == - 1) break;\n\n        out.write (buffer, 0, bytes_read);\n    }\n    out.flush ();\n    out.close ();\n    in.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 18030152, "method2_id": 19687455, "code1": "public static boolean copyFile (File from, File tu) {\n    final int BUFFER_SIZE = 4096;\n    byte [] buffer = new byte [BUFFER_SIZE];\n    try {\n        FileInputStream in = new FileInputStream (from);\n        FileOutputStream out = new FileOutputStream (tu);\n        int read;\n        while ((read = in.read (buffer)) != - 1) {\n            out.write (buffer, 0, read);\n        }\n        in.close ();\n        out.close ();\n    } catch (IOException e) {\n        return false;\n    }\n    return true;\n}\n", "code2": "public void testReadPerMemberAllFour () throws IOException {\n    GZIPMembersInputStream gzin = new GZIPMembersInputStream (new ByteArrayInputStream (allfour_gz));\n    gzin.setEofEachMember (true);\n    int count0 = IOUtils.copy (gzin, new NullOutputStream ());\n    assertEquals (\"wrong 1k member count\", 1024, count0);\n    assertEquals (\"wrong member number\", 0, gzin.getMemberNumber ());\n    assertEquals (\"wrong member0 start\", 0, gzin.getCurrentMemberStart ());\n    assertEquals (\"wrong member0 end\", noise1k_gz.length, gzin.getCurrentMemberEnd ());\n    gzin.nextMember ();\n    int count1 = IOUtils.copy (gzin, new NullOutputStream ());\n    assertEquals (\"wrong 32k member count\", (32 * 1024), count1);\n    assertEquals (\"wrong member number\", 1, gzin.getMemberNumber ());\n    assertEquals (\"wrong member1 start\", noise1k_gz.length, gzin.getCurrentMemberStart ());\n    assertEquals (\"wrong member1 end\", noise1k_gz.length + noise32k_gz.length, gzin.getCurrentMemberEnd ());\n    gzin.nextMember ();\n    int count2 = IOUtils.copy (gzin, new NullOutputStream ());\n    assertEquals (\"wrong 1-byte member count\", 1, count2);\n    assertEquals (\"wrong member number\", 2, gzin.getMemberNumber ());\n    assertEquals (\"wrong member2 start\", noise1k_gz.length + noise32k_gz.length, gzin.getCurrentMemberStart ());\n    assertEquals (\"wrong member2 end\", noise1k_gz.length + noise32k_gz.length + a_gz.length, gzin.getCurrentMemberEnd ());\n    gzin.nextMember ();\n    int count3 = IOUtils.copy (gzin, new NullOutputStream ());\n    assertEquals (\"wrong 5-byte member count\", 5, count3);\n    assertEquals (\"wrong member number\", 3, gzin.getMemberNumber ());\n    assertEquals (\"wrong member3 start\", noise1k_gz.length + noise32k_gz.length + a_gz.length, gzin.getCurrentMemberStart ());\n    assertEquals (\"wrong member3 end\", noise1k_gz.length + noise32k_gz.length + a_gz.length + hello_gz.length, gzin.getCurrentMemberEnd ());\n    gzin.nextMember ();\n    int countEnd = IOUtils.copy (gzin, new NullOutputStream ());\n    assertEquals (\"wrong eof count\", 0, countEnd);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3673886, "method2_id": 4477204, "code1": "public static final void copyDirectory (File source, File destination) throws IOException {\n    if (! source.isDirectory ()) {\n        throw new IllegalArgumentException (\"Source (\" + source.getPath () + \") must be a directory.\");\n    }\n    if (! source.exists ()) {\n        throw new IllegalArgumentException (\"Source directory (\" + source.getPath () + \") doesn't exist.\");\n    }\n    if (destination.exists ()) {\n        throw new IllegalArgumentException (\"Destination (\" + destination.getPath () + \") exists.\");\n    }\n    destination.mkdirs ();\n    File [] files = source.listFiles ();\n    for (File file : files) {\n        if (file.isDirectory ()) {\n            copyDirectory (file, new File (destination, file.getName ()));\n        } else {\n            copyFile (file, new File (destination, file.getName ()));\n        }\n    }\n}\n", "code2": "public static void synchronize (File source, File destination, boolean smart, long chunkSize) throws IOException {\n    if (chunkSize <= 0) {\n        log.warn (\"Chunk size must be positive: using default value.\");\n        chunkSize = DEFAULT_COPY_BUFFER_SIZE;\n    }\n    if (source.isDirectory ()) {\n        if (! destination.exists ()) {\n            if (! destination.mkdirs ()) {\n                throw new IOException (\"Could not create path \" + destination);\n            }\n        } else if (! destination.isDirectory ()) {\n            throw new IOException (\"Source and Destination not of the same type:\" + source.getCanonicalPath () + \" , \" + destination.getCanonicalPath ());\n        }\n\n        String [] sources = source.list ();\n        Set < String > srcNames = new HashSet < String > (Arrays.asList (sources));\n        String [] dests = destination.list ();\n        for (String fileName : dests) {\n            if (! srcNames.contains (fileName)) {\n                delete (new File (destination, fileName));\n            }\n        }\n        for (String fileName : sources) {\n            File srcFile = new File (source, fileName);\n            File destFile = new File (destination, fileName);\n            synchronize (srcFile, destFile, smart, chunkSize);\n        }\n    } else {\n        if (destination.exists () && destination.isDirectory ()) {\n            delete (destination);\n        }\n        if (destination.exists ()) {\n            long sts = source.lastModified () / FAT_PRECISION;\n            long dts = destination.lastModified () / FAT_PRECISION;\n            if (! smart || sts == 0 || sts != dts || source.length () != destination.length ()) {\n                copyFile (source, destination, chunkSize);\n            }\n        } else {\n            copyFile (source, destination, chunkSize);\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1831677, "method2_id": 19356328, "code1": "public int delete (BusinessObject o) throws DAOException {\n    int delete = 0;\n    Account acc = (Account) o;\n    try {\n        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery (\"DELETE_ACCOUNT\"));\n        pst.setInt (1, acc.getId ());\n        delete = pst.executeUpdate ();\n        if (delete <= 0) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows <= 0\");\n        } else if (delete > 1) {\n            connection.rollback ();\n            throw new DAOException (\"Number of rows > 1\");\n        }\n\n        connection.commit ();\n    } catch (SQLException e) {\n        Log.write (e.getMessage ());\n        throw new DAOException (\"A SQLException has occured\");\n    } catch (NullPointerException npe) {\n        Log.write (npe.getMessage ());\n        throw new DAOException (\"Connection null\");\n    }\n    return delete;\n}\n", "code2": "private void btnOkActionPerformed (java.awt.event.ActionEvent evt) {\n    try {\n        int id = 0;\n        String sql = \"SELECT MAX(ID) as MAX_ID from CORE_USER_GROUPS\";\n        PreparedStatement pStmt = Database.getMyConnection ().prepareStatement (sql);\n        ResultSet rs = pStmt.executeQuery ();\n        if (rs.next ()) {\n            id = rs.getInt (\"MAX_ID\") + 1;\n        } else {\n            id = 1;\n        }\n        Database.close (pStmt);\n        sql = \"INSERT INTO CORE_USER_GROUPS\" + \" (ID, GRP_NAME, GRP_DESC, DATE_INITIAL, DATE_FINAL, IND_STATUS)\" + \" VALUES (?, ?, ?, ?, ?, ?)\";\n        pStmt = Database.getMyConnection ().prepareStatement (sql);\n        pStmt.setInt (1, id);\n        pStmt.setString (2, txtGrpName.getText ());\n        pStmt.setString (3, txtGrpDesc.getText ());\n        pStmt.setDate (4, Utils.getTodaySql ());\n        pStmt.setDate (5, Date.valueOf (\"9999-12-31\"));\n        pStmt.setString (6, \"A\");\n        pStmt.executeUpdate ();\n        Database.getMyConnection ().commit ();\n        Database.close (pStmt);\n        MessageBox.ok (\"New group added successfully\", this);\n        rs = getGroups ();\n        tblGroups.setModel (new GroupsTableModel (rs));\n        Database.close (rs);\n    } catch (SQLException e) {\n        log.error (\"Failed with update operation \\n\" + e.getMessage ());\n        MessageBox.ok (\"Failed to create the new group in the database\", this);\n        try {\n            Database.getMyConnection ().rollback ();\n        } catch (Exception inner) {\n        }\n    } catch (IllegalArgumentException e) {\n        log.error (\"Illegal argument for the DATE_FINAL \\n\" + e.getMessage ());\n        MessageBox.ok (\"Failed to create the new group in the database\", this);\n        try {\n            Database.getMyConnection ().rollback ();\n        } catch (Exception inner) {\n        }\n    } finally {\n        txtGrpName.setEnabled (false);\n        txtGrpDesc.setEnabled (false);\n        btnOk.setEnabled (false);\n        btnCancel.requestFocus ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2752946, "method2_id": 3115835, "code1": "public void actionPerformed (ActionEvent arg0) {\n    Object [] constructorArgs = {collapsedGraph};\n    Class < ? extends Layout > layoutC = (Class < ? extends Layout >) jcb.getSelectedItem ();\n    try {\n        Constructor < ? extends Layout > constructor = layoutC.getConstructor (new Class [] {Graph.class});\n        Object o = constructor.newInstance (constructorArgs);\n        Layout l = (Layout) o;\n        l.setInitializer (vv.getGraphLayout ());\n        l.setSize (vv.getSize ());\n        layout = l;\n        LayoutTransition lt = new LayoutTransition (vv, vv.getGraphLayout (), l);\n        Animator animator = new Animator (lt);\n        animator.start ();\n        vv.getRenderContext ().getMultiLayerTransformer ().setToIdentity ();\n        vv.repaint ();\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "protected Wizard constructWizard (final WizDefinition definition, final List branchNodes) throws DBException {\n    String wizardClassString = definition.getWizardClass ();\n    Class wizardClass;\n    try {\n        wizardClass = Thread.currentThread ().getContextClassLoader ().loadClass (wizardClassString);\n        if (! BranchingWizard.class.isAssignableFrom (wizardClass)) {\n            throw new IllegalArgumentException (\"If you do not\" + \" implement a wizard\" + \" that derives from SequentialWizard and uses the same \" + \"constructor then you need to implement your own\" + \" Wizard Factory implementation\");\n        }\n        Constructor c = wizardClass.getConstructor (new Class [] {WizardMonitor.class, BranchNode [].class});\n        AbstractWizard emoWizard = (AbstractWizard) c.newInstance (new Object [] {constructMonitor (), (BranchNode []) branchNodes.toArray (new BranchNode [branchNodes.size ()])});\n        emoWizard.setId (new Integer (definition.getId ()));\n        emoWizard.setTitle (definition.getWizName ());\n        emoWizard.setSummary (definition.getSummary ());\n        setWizardForStepsThatNeedIt (emoWizard, branchNodes);\n        return emoWizard;\n    } catch (ClassNotFoundException ex) {\n        throw new IllegalArgumentException (\"Unknown class: \" + wizardClassString + \" edit your wizard definition to solve this problem\");\n    } catch (InvocationTargetException ex) {\n        throw new DBException (\"An Exception was thrown constructing the \" + \"wizard\", ex);\n    } catch (IllegalAccessException ex) {\n        throw new IllegalArgumentException (\"The wizard specified: \" + wizardClassString + \" does not have a public constructor\" + \" like the default.  You may need to implement your own \" + \"wizard factory.\");\n    } catch (InstantiationException ex) {\n        throw new DBException (\"There was an error constructing your \" + \"wizard.\", ex);\n    } catch (NoSuchMethodException ex) {\n        throw new IllegalArgumentException (\"No appropriate constructor\" + \" found:\" + ex.getMessage ());\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 11865905, "method2_id": 18202328, "code1": "@Test\npublic void testRegister () {\n    try {\n        String username = \"muchu\";\n        String password = \"123\";\n        MessageDigest md5 = MessageDigest.getInstance (\"MD5\");\n        md5.update (password.getBytes ());\n        String passwordMd5 = new String (md5.digest ());\n        LogService logServiceMock = EasyMock.createMock (LogService.class);\n        DbService dbServiceMock = EasyMock.createMock (DbService.class);\n        userServ.setDbServ (dbServiceMock);\n        userServ.setLogger (logServiceMock);\n        IFeelerUser user = new FeelerUserImpl ();\n        user.setUsername (username);\n        user.setPassword (passwordMd5);\n        logServiceMock.info (DbUserServiceImpl.class, \">>>rigister \" + username + \"<<<\");\n        EasyMock.expect (dbServiceMock.queryFeelerUser (username)).andReturn (null);\n        dbServiceMock.addFeelerUser (username, passwordMd5);\n        logServiceMock.info (DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n        EasyMock.expect (dbServiceMock.queryFeelerUser (username)).andReturn (user);\n        EasyMock.replay (dbServiceMock, logServiceMock);\n        Assert.assertTrue (userServ.register (username, password));\n        EasyMock.verify (dbServiceMock, logServiceMock);\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public void register (MinecraftSession session, String username, String verificationKey) {\n    if (Configuration.getConfiguration ().isVerifyingNames ()) {\n        long salt = HeartbeatManager.getHeartbeatManager ().getSalt ();\n        String hash = new StringBuilder ().append (String.valueOf (salt)).append (username).toString ();\n        MessageDigest digest;\n        try {\n            digest = MessageDigest.getInstance (\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException (\"No MD5 algorithm!\");\n        }\n        digest.update (hash.getBytes ());\n        if (! verificationKey.equals (new BigInteger (1, digest.digest ()).toString (16))) {\n            session.getActionSender ().sendLoginFailure (\"Illegal name.\");\n            return;\n        }\n    }\n    char [] nameChars = username.toCharArray ();\n    for (char nameChar : nameChars) {\n        if (nameChar < ' ' || nameChar > '\\177') {\n            session.getActionSender ().sendLoginFailure (\"Invalid name!\");\n            return;\n        }\n    }\n    for (Player p : playerList.getPlayers ()) {\n        if (p.getName ().equalsIgnoreCase (username)) {\n            p.getSession ().getActionSender ().sendLoginFailure (\"Logged in from another computer.\");\n            break;\n        }\n    }\n    final Player player = new Player (session, username);\n    if (! playerList.add (player)) {\n        player.getSession ().getActionSender ().sendLoginFailure (\"Too many players online!\");\n        return;\n    }\n    session.setPlayer (player);\n    final Configuration c = Configuration.getConfiguration ();\n    session.getActionSender ().sendLoginResponse (Constants.PROTOCOL_VERSION, c.getName (), c.getMessage (), false);\n    LevelGzipper.getLevelGzipper ().gzipLevel (session);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 14050307, "method2_id": 22328842, "code1": "public int instantiate (int objectId, String description) throws FidoDatabaseException, ObjectNotFoundException, ClassLinkTypeNotFoundException {\n    try {\n        Connection conn = null;\n        Statement stmt = null;\n        ResultSet rs = null;\n        try {\n            String sql = \"insert into Objects (Description) \" + \"values ('\" + description + \"')\";\n            conn = fido.util.FidoDataSource.getConnection ();\n            conn.setAutoCommit (false);\n            stmt = conn.createStatement ();\n            if (contains (stmt, objectId) == false) throw new ObjectNotFoundException (objectId);\n\n            stmt.executeUpdate (sql);\n            int id;\n            sql = \"select currval('objects_objectid_seq')\";\n            rs = stmt.executeQuery (sql);\n            if (rs.next () == false) throw new SQLException (\"No rows returned from select currval() query\");\n            else id = rs.getInt (1);\n\n            ObjectLinkTable objectLinkList = new ObjectLinkTable ();\n            objectLinkList.linkObjects (stmt, id, \"instance\", objectId);\n            conn.commit ();\n            return id;\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback ();\n\n            throw e;\n        } finally {\n            if (rs != null) rs.close ();\n\n            if (stmt != null) stmt.close ();\n\n            if (conn != null) conn.close ();\n\n        }\n    } catch (SQLException e) {\n        throw new FidoDatabaseException (e);\n    }\n}\n", "code2": "protected void doBackupOrganizeType () throws Exception {\n    Connection con = null;\n    PreparedStatement ps = null;\n    ResultSet result = null;\n    String strSelQuery = \"SELECT organize_type_id,organize_type_name,width \" + \"FROM \" + Common.ORGANIZE_TYPE_TABLE;\n    String strInsQuery = \"INSERT INTO \" + Common.ORGANIZE_TYPE_B_TABLE + \" \" + \"(version_no,organize_type_id,organize_type_name,width) \" + \"VALUES (?,?,?,?)\";\n    DBOperation dbo = factory.createDBOperation (POOL_NAME);\n    try {\n        try {\n            con = dbo.getConnection ();\n            con.setAutoCommit (false);\n            ps = con.prepareStatement (strSelQuery);\n            result = ps.executeQuery ();\n            ps = con.prepareStatement (strInsQuery);\n            while (result.next ()) {\n                ps.setInt (1, this.versionNO);\n                ps.setString (2, result.getString (\"organize_type_id\"));\n                ps.setString (3, result.getString (\"organize_type_name\"));\n                ps.setInt (4, result.getInt (\"width\"));\n                int resultCount = ps.executeUpdate ();\n                if (resultCount != 1) {\n                    con.rollback ();\n                    throw new CesSystemException (\"Organize_backup.doBackupOrganizeType(): ERROR Inserting data \" + \"in T_SYS_ORGANIZE_B_TYPE INSERT !! resultCount = \" + resultCount);\n                }\n            }\n            con.commit ();\n        } catch (SQLException se) {\n            con.rollback ();\n            throw new CesSystemException (\"Organize_backup.doBackupOrganizeType(): SQLException:  \" + se);\n        } finally {\n            con.setAutoCommit (true);\n            close (dbo, ps, result);\n        }\n    } catch (SQLException se) {\n        throw new CesSystemException (\"Organize_backup.doBackupOrganizeType(): SQLException while committing or rollback\");\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 523070, "method2_id": 19549489, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public static void copy (File sourceFile, File destinationFile) throws IOException {\n    FileChannel sourceFileChannel = (new FileInputStream (sourceFile)).getChannel ();\n    FileChannel destinationFileChannel = (new FileOutputStream (destinationFile)).getChannel ();\n    sourceFileChannel.transferTo (0, sourceFile.length (), destinationFileChannel);\n    sourceFileChannel.close ();\n    destinationFileChannel.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 567313, "method2_id": 8544627, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "@Override\nprotected void copyContent (String filename) throws IOException {\n    InputStream in = null;\n    try {\n        in = LOADER.getResourceAsStream (RES_PKG + filename);\n        ByteArrayOutputStream out = new ByteArrayOutputStream ();\n        IOUtils.copy (in, out);\n        setResponseData (out.toByteArray ());\n    } finally {\n        if (in != null) {\n            in.close ();\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2711585, "method2_id": 21900384, "code1": "public static void _save (PortletRequest req, PortletResponse res, PortletConfig config, ActionForm form) throws Exception {\n    try {\n        String filePath = getUserManagerConfigPath () + \"user_manager_config.properties\";\n        String tmpFilePath = UtilMethods.getTemporaryDirPath () + \"user_manager_config_properties.tmp\";\n        File from = new java.io.File (tmpFilePath);\n        from.createNewFile ();\n        File to = new java.io.File (filePath);\n        to.createNewFile ();\n        FileChannel srcChannel = new FileInputStream (from).getChannel ();\n        FileChannel dstChannel = new FileOutputStream (to).getChannel ();\n        dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n        srcChannel.close ();\n        dstChannel.close ();\n    } catch (NonWritableChannelException we) {\n    } catch (IOException e) {\n        Logger.error (UserManagerPropertiesFactory.class, \"Property File save Failed \" + e, e);\n    }\n    SessionMessages.add (req, \"message\", \"message.usermanager.display.save\");\n}\n", "code2": "@Override\nprotected ActionForward executeAction (ActionMapping mapping, ActionForm form, User user, HttpServletRequest request, HttpServletResponse response) throws Exception {\n    long resourceId = ServletRequestUtils.getLongParameter (request, \"resourceId\", 0L);\n    String attributeIdentifier = request.getParameter (\"identifier\");\n    if (resourceId != 0L && StringUtils.hasText (attributeIdentifier)) {\n        try {\n            BinaryAttribute binaryAttribute = resourceManager.readAttribute (resourceId, attributeIdentifier, user);\n            response.addHeader (\"Content-Disposition\", \"attachment; filename=\\\"\" + binaryAttribute.getName () + '\"');\n            String contentType = binaryAttribute.getContentType ();\n            if (contentType != null) {\n                if (\"application/x-zip-compressed\".equalsIgnoreCase (contentType)) {\n                    response.setContentType (\"application/octet-stream\");\n                } else {\n                    response.setContentType (contentType);\n                }\n            } else {\n                response.setContentType (\"application/octet-stream\");\n            }\n            IOUtils.copy (binaryAttribute.getInputStream (), response.getOutputStream ());\n            return null;\n        } catch (DataRetrievalFailureException e) {\n            addGlobalError (request, \"errors.notFound\");\n        } catch (Exception e) {\n            addGlobalError (request, e);\n        }\n    }\n    return mapping.getInputForward ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 246146, "method2_id": 524051, "code1": "public void run (ScriptContext sc) {\n    View parent = sc.getView ();\n    XTreeNode node = sc.getNode ();\n    boolean stringArg = false;\n    String arg = \"\";\n    String cleanedCmd = command.substring (1, command.length () - 1).trim ();\n    int bracket = cleanedCmd.indexOf (\"(\");\n    if (bracket == - 1) {\n        XScripter.doError (command, \"\\\"(\\\" expected\");\n        return;\n    }\n    int classEnds = cleanedCmd.lastIndexOf (\".\", bracket);\n    String clazzName = cleanedCmd.substring (0, classEnds);\n    String methodName = cleanedCmd.substring (classEnds + 1, bracket);\n    if (cleanedCmd.charAt (bracket + 1) != ')') {\n        stringArg = true;\n        String _arg = cleanedCmd.substring (bracket + 1, cleanedCmd.length ());\n        if (_arg.startsWith (\"$\")) {\n            arg = XScripter.getSubstituteFor (parent, _arg.substring (1), node);\n        } else {\n            arg = _arg;\n        }\n    }\n    try {\n        Class clazz = Class.forName (clazzName);\n        Method method = null;\n        System.out.println (\"ClassName=\" + clazzName + \"/\" + clazz.getName () + \" methodName=\" + methodName);\n        Object [] args = null;\n        if (stringArg) {\n            method = clazz.getMethod (methodName, new Class [] {String.class});\n            args = new Object [1];\n            args [0] = arg;\n        } else {\n            method = clazz.getMethod (methodName, null);\n        }\n        Object obj = method.invoke (null, args);\n        if (obj == null) {\n            return;\n        } else {\n            InsertTextCommand.insertText (obj.toString (), sc);\n        }\n    } catch (Exception e) {\n        XScripter.doError (command, e);\n    }\n}\n", "code2": "public static void main (final String [] args) throws Exception {\n    System.out.println (\"Calling foo(null) results in a NullPointerException:\");\n    try {\n        foo (null);\n    } catch (Exception e) {\n        e.printStackTrace (System.out);\n    }\n    final String n = Annotations.class.getName ();\n    final ClassWriter cw = new ClassWriter (ClassWriter.COMPUTE_MAXS);\n    ClassReader cr = new ClassReader (n);\n    cr.accept (new ClassAdapter (cw) {\n        public MethodVisitor visitMethod (final int access, final String name, final String desc, final String signature, final String [] exceptions) {\n            final Type [] args = Type.getArgumentTypes (desc);\n            MethodVisitor v = cv.visitMethod (access, name, desc, signature, exceptions);\n            return new MethodAdapter (v) {\n                private final List params = new ArrayList ();\n                public AnnotationVisitor visitParameterAnnotation (final int parameter, final String desc, final boolean visible) {\n                    AnnotationVisitor av;\n                    av = mv.visitParameterAnnotation (parameter, desc, visible);\n                    if (desc.equals (\"LNotNull;\")) {\n                        params.add (new Integer (parameter));\n                    }\n                    return av;\n                } public void visitCode () {\n                    int var = (access & Opcodes.ACC_STATIC) == 0 ? 1 : 0;\n                    for (int p = 0;\n                    p < params.size (); ++ p) {\n                        int param = ((Integer) params.get (p)).intValue ();\n                        for (int i = 0;\n                        i < param; ++ i) {\n                            var += args [i].getSize ();\n                        }\n                        String c = \"java/lang/IllegalArgumentException\";\n                        String d = \"(Ljava/lang/String;)V\";\n                        Label end = new Label ();\n                        mv.visitVarInsn (Opcodes.ALOAD, var);\n                        mv.visitJumpInsn (Opcodes.IFNONNULL, end);\n                        mv.visitTypeInsn (Opcodes.NEW, c);\n                        mv.visitInsn (Opcodes.DUP);\n                        mv.visitLdcInsn (\"Argument \" + param + \" must not be null\");\n                        mv.visitMethodInsn (Opcodes.INVOKESPECIAL, c, \"<init>\", d);\n                        mv.visitInsn (Opcodes.ATHROW);\n                        mv.visitLabel (end);\n                    }\n                }}\n\n            ;\n        }}\n\n    , 0);\n    Class c = new ClassLoader () {\n        public Class loadClass (final String name) throws ClassNotFoundException {\n            if (name.equals (n)) {\n                byte [] b = cw.toByteArray ();\n                return defineClass (name, b, 0, b.length);\n            }\n            return super.loadClass (name);\n        }}\n\n    .loadClass (n);\n    System.out.println ();\n    System.out.println (\"Calling foo(null) on the transformed class results in an IllegalArgumentException:\");\n    Method m = c.getMethod (\"foo\", new Class [] {String.class});\n    try {\n        m.invoke (null, new Object [] {null});\n    } catch (InvocationTargetException e) {\n        e.getCause ().printStackTrace (System.out);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 12626920, "method2_id": 14188181, "code1": "public void xtestFile2 () throws Exception {\n    InputStream inputStream = new FileInputStream (IOTest.FILE);\n    OutputStream outputStream = new FileOutputStream (\"C:/Temp/testFile2.mp4\");\n    IOUtils.copy (inputStream, outputStream);\n    inputStream.close ();\n    outputStream.close ();\n}\n", "code2": "protected void copyFile (String from, String to, String workingDirectory) throws Exception {\n    URL monitorCallShellScriptUrl = Thread.currentThread ().getContextClassLoader ().getResource (from);\n    File f = new File (monitorCallShellScriptUrl.getFile ());\n    String directoryPath = f.getAbsolutePath ();\n    String fileName = from;\n    InputStream in = null;\n    if (directoryPath.indexOf (\".jar!\") > - 1) {\n        URL urlJar = new URL (directoryPath.substring (directoryPath.indexOf (\"file:\"), directoryPath.indexOf ('!')));\n        JarFile jf = new JarFile (urlJar.getFile ());\n        JarEntry je = jf.getJarEntry (from);\n        fileName = je.getName ();\n        in = Thread.currentThread ().getContextClassLoader ().getResourceAsStream (fileName);\n    } else {\n        in = new FileInputStream (f);\n    }\n    File outScriptFile = new File (to);\n    FileOutputStream fos = new FileOutputStream (outScriptFile);\n    int nextChar;\n    while ((nextChar = in.read ()) != - 1) fos.write (nextChar);\n\n    fos.flush ();\n    fos.close ();\n    try {\n        LinuxCommandExecutor cmdExecutor = new LinuxCommandExecutor ();\n        cmdExecutor.setWorkingDirectory (workingDirectory);\n        cmdExecutor.runCommand (\"chmod 777 \" + to);\n    } catch (Exception e) {\n        throw e;\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 280240, "method2_id": 434724, "code1": "private void addAdditional2 (Message response, int section) {\n    Enumeration e = response.getSection (section);\n    while (e.hasMoreElements ()) {\n        Record r = (Record) e.nextElement ();\n        try {\n            Method m = r.getClass ().getMethod (\"getTarget\", null);\n            Name glueName = (Name) m.invoke (r, null);\n            addGlue (response, glueName);\n        } catch (Exception ex) {\n        }\n    }\n}\n", "code2": "public static void main (String [] argv) throws Exception {\n    if (argv.length == 0) {\n        printUsage ();\n        return;\n    }\n    for (int iArg = 0;\n    iArg < argv.length; iArg ++) {\n        String arg = argv [iArg];\n        if (arg.startsWith (\"-h\")) {\n            printUsage ();\n            return;\n        }\n        System.out.println (\"**** START OF EXECUTION of \" + arg + \".\" + methodToRun + \" \" + signatureToPrintOut + \" ****.\");\n        Class klass = Class.forName (arg);\n        Method method = klass.getDeclaredMethod (methodToRun, noparams);\n        Object result = method.invoke (null, (Object []) noparams);\n        System.out.println (\"**** RESULT: \" + result);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 5317659, "method2_id": 7215887, "code1": "public String hash (String clearPassword) {\n    if (osalt == 0) return null;\n\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"SHA1\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new AssertionError (\"Can't find the SHA1 algorithm in the java.security package\");\n    }\n    String saltString = String.valueOf (osalt);\n    md.update (saltString.getBytes ());\n    md.update (clearPassword.getBytes ());\n    byte [] digestBytes = md.digest ();\n    StringBuffer digestSB = new StringBuffer ();\n    for (int i = 0;\n    i < digestBytes.length; i ++) {\n        int lowNibble = digestBytes [i] & 0x0f;\n        int highNibble = (digestBytes [i]>> 4) & 0x0f;\n        digestSB.append (Integer.toHexString (highNibble));\n        digestSB.append (Integer.toHexString (lowNibble));\n    }\n    String digestStr = digestSB.toString ();\n    return digestStr;\n}\n", "code2": "public static String encrypt (String password, Long digestSeed) {\n    try {\n        MessageDigest algorithm = MessageDigest.getInstance (\"MD5\");\n        algorithm.reset ();\n        algorithm.update (password.getBytes (\"UTF-8\"));\n        algorithm.update (digestSeed.toString ().getBytes (\"UTF-8\"));\n        byte [] messageDigest = algorithm.digest ();\n        StringBuffer hexString = new StringBuffer ();\n        for (int i = 0;\n        i < messageDigest.length; i ++) {\n            hexString.append (Integer.toHexString (0xff & messageDigest [i]));\n        }\n        return hexString.toString ();\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException (e);\n    } catch (UnsupportedEncodingException e) {\n        throw new RuntimeException (e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 14636645, "method2_id": 19145296, "code1": "private static void loadQueryProcessorFactories () {\n    qpFactoryMap = new HashMap < String, QueryProcessorFactoryIF > ();\n    Enumeration < URL > resources = null;\n    try {\n        resources = QueryUtils.class.getClassLoader ().getResources (RESOURCE_STRING);\n    } catch (IOException e) {\n        log.error (\"Error while trying to look for \" + \"QueryProcessorFactoryIF implementations.\", e);\n    }\n    while (resources != null && resources.hasMoreElements ()) {\n        URL url = resources.nextElement ();\n        InputStream is = null;\n        try {\n            is = url.openStream ();\n        } catch (IOException e) {\n            log.warn (\"Error opening stream to QueryProcessorFactoryIF service description.\", e);\n        }\n        if (is != null) {\n            BufferedReader rdr = new BufferedReader (new InputStreamReader (is));\n            String line;\n            try {\n                while ((line = rdr.readLine ()) != null) {\n                    try {\n                        ClassLoader classLoader = Thread.currentThread ().getContextClassLoader ();\n                        Class < ? > c = Class.forName (line, true, classLoader);\n                        if (QueryProcessorFactoryIF.class.isAssignableFrom (c)) {\n                            QueryProcessorFactoryIF factory = (QueryProcessorFactoryIF) c.newInstance ();\n                            qpFactoryMap.put (factory.getQueryLanguage ().toUpperCase (), factory);\n                        } else {\n                            log.warn (\"Wrong entry for QueryProcessorFactoryIF service \" + \"description, '\" + line + \"' is not implementing the \" + \"correct interface.\");\n                        }\n                    } catch (Exception e) {\n                        log.warn (\"Could not create an instance for \" + \"QueryProcessorFactoryIF service '\" + line + \"'.\");\n                    }\n                }\n            } catch (IOException e) {\n                log.warn (\"Could not read from QueryProcessorFactoryIF \" + \"service descriptor.\", e);\n            }\n        }\n    }\n    if (! qpFactoryMap.containsKey (DEFAULT_LANGUAGE)) {\n        qpFactoryMap.put (DEFAULT_LANGUAGE, new TologQueryProcessorFactory ());\n    }\n}\n", "code2": "public static double [] [] getCurrency () throws IOException {\n    URL url = new URL (\"http://hk.finance.yahoo.com/currency\");\n    BufferedReader in = new BufferedReader (new InputStreamReader (url.openStream (), \"big5\"));\n    double currency [] [] = new double [11] [11];\n    while (true) {\n        String line = in.readLine ();\n        String reg = \"<td\\\\s((align=\\\"right\\\"\\\\sclass=\\\"yfnc_tabledata1\\\")\" + \"|(class=\\\"yfnc_tabledata1\\\"\\\\salign=\\\"right\\\"))>\" + \"([\\\\d|\\\\.]+)</td>\";\n        Matcher m = Pattern.compile (reg).matcher (line);\n        int i = 0, j = 0;\n        boolean isfound = false;\n        while (m.find ()) {\n            isfound = true;\n            currency [i] [j] = Double.parseDouble (m.group (4));\n            if (j == 10) {\n                j = 0;\n                i ++;\n            } else j ++;\n\n        }\n        if (isfound) break;\n\n    }\n    return currency;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1008324, "method2_id": 12269678, "code1": "public void copyHashAllFilesToDirectory (String baseDirStr, Hashtable newNamesTable, String destDirStr) throws Exception {\n    if (baseDirStr.endsWith (sep)) {\n        baseDirStr = baseDirStr.substring (0, baseDirStr.length () - 1);\n    }\n    if (destDirStr.endsWith (sep)) {\n        destDirStr = destDirStr.substring (0, destDirStr.length () - 1);\n    }\n    FileUtils.getInstance ().createDirectory (baseDirStr);\n    if (null == newNamesTable) {\n        newNamesTable = new Hashtable ();\n    }\n    BufferedInputStream in = null;\n    BufferedOutputStream out = null;\n    byte dataBuff [] = new byte [bufferSize];\n    File baseDir = new File (baseDirStr);\n    baseDir.mkdirs ();\n    if ((baseDir.exists ()) && (baseDir.isDirectory ())) {\n        if (! newNamesTable.isEmpty ()) {\n            Enumeration enumFiles = newNamesTable.keys ();\n            while (enumFiles.hasMoreElements ()) {\n                String newName = (String) enumFiles.nextElement ();\n                String oldPathName = (String) newNamesTable.get (newName);\n                if ((newName != null) && (! \"\".equals (newName)) && (oldPathName != null) && (! \"\".equals (oldPathName))) {\n                    String newPathFileName = destDirStr + sep + newName;\n                    String oldPathFileName = baseDirStr + sep + oldPathName;\n                    if (oldPathName.startsWith (sep)) {\n                        oldPathFileName = baseDirStr + oldPathName;\n                    }\n                    File f = new File (oldPathFileName);\n                    if ((f.exists ()) && (f.isFile ())) {\n                        in = new BufferedInputStream (new FileInputStream (oldPathFileName), bufferSize);\n                        out = new BufferedOutputStream (new FileOutputStream (newPathFileName), bufferSize);\n                        int readLen;\n                        while ((readLen = in.read (dataBuff)) > 0) {\n                            out.write (dataBuff, 0, readLen);\n                        }\n                        out.flush ();\n                        in.close ();\n                        out.close ();\n                    } else {\n                    }\n                }\n            }\n        } else {\n        }\n    } else {\n        throw new Exception (\"Base (baseDirStr) dir not exist !\");\n    }\n}\n", "code2": "private void copyResource (String relResourceName) {\n    String projectName = layout.getRootDir ().getName ();\n    String resourceName = \"/protoj/\" + projectName + \"/\" + relResourceName;\n    InputStream source = getClass ().getResourceAsStream (resourceName);\n    if (source == null) {\n        throw new RuntimeException (\"couldn't find resource \" + resourceName);\n    }\n    File dest = new File (layout.getRootDir (), relResourceName);\n    dest.getParentFile ().mkdirs ();\n    dest.createNewFile ();\n    InputStreamReader in = new InputStreamReader (source);\n    try {\n        FileOutputStream out = new FileOutputStream (dest);\n        try {\n            IOUtils.copy (in, out);\n        } finally {\n            IOUtils.closeQuietly (out);\n        }\n    } finally {\n        IOUtils.closeQuietly (in);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 310182, "method2_id": 19841852, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public static final boolean checkForUpdate (final String currentVersion, final String updateURL, boolean noLock) throws Exception {\n    try {\n        final String parentFDTConfDirName = System.getProperty (\"user.home\") + File.separator + \".fdt\";\n        final String fdtUpdateConfFileName = \"update.properties\";\n        final File confFile = createOrGetRWFile (parentFDTConfDirName, fdtUpdateConfFileName);\n        if (confFile != null) {\n            long lastCheck = 0;\n            Properties updateProperties = new Properties ();\n            FileInputStream fis = null;\n            FileOutputStream fos = null;\n            try {\n                fis = new FileInputStream (confFile);\n                updateProperties.load (fis);\n                final String lastCheckProp = (String) updateProperties.get (\"LastCheck\");\n                lastCheck = 0;\n                if (lastCheckProp != null) {\n                    try {\n                        lastCheck = Long.parseLong (lastCheckProp);\n                    } catch (Throwable t) {\n                        if (logger.isLoggable (Level.FINE)) {\n                            logger.log (Level.FINE, \"Got exception parsing LastCheck param\", t);\n                        }\n                        lastCheck = 0;\n                    }\n                }\n            } catch (Throwable t) {\n                logger.log (Level.WARNING, \"Cannot load update properties file: \" + confFile, t);\n            } finally {\n                closeIgnoringExceptions (fos);\n                closeIgnoringExceptions (fis);\n            }\n            final long now = System.currentTimeMillis ();\n            boolean bHaveUpdates = false;\n            checkAndSetInstanceID (updateProperties);\n            if (lastCheck + FDT.UPDATE_PERIOD < now) {\n                lastCheck = now;\n                try {\n                    logger.log (\"\\n\\nChecking for remote updates ... This may be disabled using -noupdates flag.\");\n                    bHaveUpdates = updateFDT (currentVersion, updateURL, false, noLock);\n                    if (bHaveUpdates) {\n                        logger.log (\"FDT may be updated using: java -jar fdt.jar -update\");\n                    } else {\n                        if (logger.isLoggable (Level.FINE)) {\n                            logger.log (Level.FINE, \"No updates available\");\n                        }\n                    }\n                } catch (Throwable t) {\n                    if (logger.isLoggable (Level.FINE)) {\n                        logger.log (Level.WARNING, \"Got exception\", t);\n                    }\n                }\n                updateProperties.put (\"LastCheck\", \"\" + now);\n                try {\n                    fos = new FileOutputStream (confFile);\n                    updateProperties.store (fos, null);\n                } catch (Throwable t1) {\n                    logger.log (Level.WARNING, \"Cannot store update properties file\", t1);\n                } finally {\n                    closeIgnoringExceptions (fos);\n                }\n                return bHaveUpdates;\n            }\n        } else {\n            if (logger.isLoggable (Level.FINE)) {\n                logger.log (Level.FINE, \" [ checkForUpdate ] Cannot read or write the update conf file: \" + parentFDTConfDirName + File.separator + fdtUpdateConfFileName);\n            }\n            return false;\n        }\n    } catch (Throwable t) {\n        logger.log (Level.WARNING, \"Got exception checking for updates\", t);\n    }\n    return false;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 266990, "method2_id": 841724, "code1": "public static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 16104708, "method2_id": 20856392, "code1": "private void writeToZip (String dirIni, File file, ZipOutputStream zipOut) throws IOException, FileNotFoundException {\n    if (this.getName ().equals (file.getName ())) return;\n\n    if (file.isDirectory ()) {\n        for (File f : file.listFiles ()) {\n            writeToZip (dirIni, f, zipOut);\n        }\n        return;\n    }\n    byte [] fileBytes = getFileBytes (file);\n    dirIni = dirIni.replace (\"\\\\\", \"/\");\n    String fileName = file.getPath ();\n    fileName = fileName.replace (dirIni + \"\\\\\", \"\").replace ('\\\\', '/');\n    fileName = fileName.replace (dirIni + \"/\", \"\");\n    ZipEntry entry = new ZipEntry (fileName);\n    zipOut.putNextEntry (entry);\n    zipOut.write (fileBytes);\n    zipOut.flush ();\n}\n", "code2": "public void run () {\n    try {\n        waitForCompletion ();\n    } catch (FaultType f) {\n        logger.error (f);\n        synchronized (status) {\n            status.notifyAll ();\n        }\n        return;\n    }\n    if (AppServiceImpl.drmaaInUse || ! AppServiceImpl.globusInUse) {\n        done = true;\n        status.setCode (GramJob.STATUS_STAGE_OUT);\n        status.setMessage (\"Writing output metadata\");\n        if (AppServiceImpl.dbInUse) {\n            try {\n                updateStatusInDatabase (jobID, status);\n            } catch (SQLException e) {\n                status.setCode (GramJob.STATUS_FAILED);\n                status.setMessage (\"Cannot update status database after finish - \" + e.getMessage ());\n                logger.error (e);\n                synchronized (status) {\n                    status.notifyAll ();\n                }\n                return;\n            }\n        }\n    }\n    try {\n        if (! AppServiceImpl.drmaaInUse && ! AppServiceImpl.globusInUse) {\n            try {\n                logger.debug (\"Waiting for all outputs to be written out\");\n                stdoutThread.join ();\n                stderrThread.join ();\n                logger.debug (\"All outputs successfully written out\");\n            } catch (InterruptedException ignore) {\n            }\n        }\n        File stdOutFile = new File (workingDir + File.separator + \"stdout.txt\");\n        if (! stdOutFile.exists ()) {\n            throw new IOException (\"Standard output missing for execution\");\n        }\n        File stdErrFile = new File (workingDir + File.separator + \"stderr.txt\");\n        if (! stdErrFile.exists ()) {\n            throw new IOException (\"Standard error missing for execution\");\n        }\n        if (AppServiceImpl.archiveData) {\n            logger.debug (\"Archiving output files\");\n            File f = new File (workingDir);\n            File [] outputFiles = f.listFiles ();\n            ZipOutputStream out = new ZipOutputStream (new FileOutputStream (workingDir + File.separator + jobID + \".zip\"));\n            byte [] buf = new byte [1024];\n            try {\n                for (int i = 0;\n                i < outputFiles.length; i ++) {\n                    FileInputStream in = new FileInputStream (outputFiles [i]);\n                    out.putNextEntry (new ZipEntry (outputFiles [i].getName ()));\n                    int len;\n                    while ((len = in.read (buf)) > 0) {\n                        out.write (buf, 0, len);\n                    }\n                    out.closeEntry ();\n                    in.close ();\n                }\n                out.close ();\n            } catch (IOException e) {\n                logger.error (e);\n                logger.error (\"Error not fatal - moving on\");\n            }\n        }\n        File f = new File (workingDir);\n        File [] outputFiles = f.listFiles ();\n        OutputFileType [] outputFileObj = new OutputFileType [outputFiles.length - 2];\n        int j = 0;\n        for (int i = 0;\n        i < outputFiles.length; i ++) {\n            if (outputFiles [i].getName ().equals (\"stdout.txt\")) {\n                outputs.setStdOut (new URI (AppServiceImpl.tomcatURL + jobID + \"/stdout.txt\"));\n            } else if (outputFiles [i].getName ().equals (\"stderr.txt\")) {\n                outputs.setStdErr (new URI (AppServiceImpl.tomcatURL + jobID + \"/stderr.txt\"));\n            } else {\n                OutputFileType next = new OutputFileType ();\n                next.setName (outputFiles [i].getName ());\n                next.setUrl (new URI (AppServiceImpl.tomcatURL + jobID + \"/\" + outputFiles [i].getName ()));\n                outputFileObj [j ++] = next;\n            }\n\n        }\n        outputs.setOutputFile (outputFileObj);\n    } catch (IOException e) {\n        status.setCode (GramJob.STATUS_FAILED);\n        status.setMessage (\"Cannot retrieve outputs after finish - \" + e.getMessage ());\n        logger.error (e);\n        if (AppServiceImpl.dbInUse) {\n            try {\n                updateStatusInDatabase (jobID, status);\n            } catch (SQLException se) {\n                logger.error (se);\n            }\n        }\n        synchronized (status) {\n            status.notifyAll ();\n        }\n        return;\n    }\n    if (! AppServiceImpl.dbInUse) {\n        AppServiceImpl.outputTable.put (jobID, outputs);\n    } else {\n        Connection conn = null;\n        try {\n            conn = DriverManager.getConnection (AppServiceImpl.dbUrl, AppServiceImpl.dbUser, AppServiceImpl.dbPasswd);\n        } catch (SQLException e) {\n            status.setCode (GramJob.STATUS_FAILED);\n            status.setMessage (\"Cannot connect to database after finish - \" + e.getMessage ());\n            logger.error (e);\n            synchronized (status) {\n                status.notifyAll ();\n            }\n            return;\n        }\n        String sqlStmt = \"insert into job_output(job_id, std_out, std_err) \" + \"values ('\" + jobID + \"', \" + \"'\" + outputs.getStdOut ().toString () + \"', \" + \"'\" + outputs.getStdErr ().toString () + \"');\";\n        Statement stmt = null;\n        try {\n            stmt = conn.createStatement ();\n            stmt.executeUpdate (sqlStmt);\n        } catch (SQLException e) {\n            status.setCode (GramJob.STATUS_FAILED);\n            status.setMessage (\"Cannot update job output database after finish - \" + e.getMessage ());\n            logger.error (e);\n            try {\n                updateStatusInDatabase (jobID, status);\n            } catch (SQLException se) {\n                logger.error (se);\n            }\n            synchronized (status) {\n                status.notifyAll ();\n            }\n            return;\n        }\n        OutputFileType [] outputFile = outputs.getOutputFile ();\n        for (int i = 0;\n        i < outputFile.length; i ++) {\n            sqlStmt = \"insert into output_file(job_id, name, url) \" + \"values ('\" + jobID + \"', \" + \"'\" + outputFile [i].getName () + \"', \" + \"'\" + outputFile [i].getUrl ().toString () + \"');\";\n            try {\n                stmt = conn.createStatement ();\n                stmt.executeUpdate (sqlStmt);\n            } catch (SQLException e) {\n                status.setCode (GramJob.STATUS_FAILED);\n                status.setMessage (\"Cannot update output_file DB after finish - \" + e.getMessage ());\n                logger.error (e);\n                try {\n                    updateStatusInDatabase (jobID, status);\n                } catch (SQLException se) {\n                    logger.error (se);\n                }\n                synchronized (status) {\n                    status.notifyAll ();\n                }\n                return;\n            }\n        }\n    }\n    if (terminatedOK ()) {\n        status.setCode (GramJob.STATUS_DONE);\n        status.setMessage (\"Execution complete - \" + \"check outputs to verify successful execution\");\n    } else {\n        status.setCode (GramJob.STATUS_FAILED);\n        status.setMessage (\"Execution failed\");\n    }\n    if (AppServiceImpl.dbInUse) {\n        try {\n            updateStatusInDatabase (jobID, status);\n        } catch (SQLException e) {\n            status.setCode (GramJob.STATUS_FAILED);\n            status.setMessage (\"Cannot update status database after finish - \" + e.getMessage ());\n            logger.error (e);\n            synchronized (status) {\n                status.notifyAll ();\n            }\n            return;\n        }\n    }\n    AppServiceImpl.jobTable.remove (jobID);\n    synchronized (status) {\n        status.notifyAll ();\n    }\n    logger.info (\"Execution complete for job: \" + jobID);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8570520, "method2_id": 20103762, "code1": "public String doAdd (ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n    if (logger.isDebugEnabled ()) {\n        logger.debug (\"doAdd(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse) - start\");\n    }\n    t_information_EditMap editMap = new t_information_EditMap ();\n    try {\n        t_information_Form vo = null;\n        vo = (t_information_Form) form;\n        vo.setCompany (vo.getCounty ());\n        if (\"\ufffd\ufffd\ufffd\ufffd\".equals (vo.getInfo_type ())) {\n            vo.setInfo_level (null);\n            vo.setAlert_level (null);\n        }\n        String str_postFIX = \"\";\n        int i_p = 0;\n        editMap.add (vo);\n        try {\n            logger.info (\"\ufffd\ufffd\ufffd\u0379\ufffd\u02fe\ufffd\u9c68\ufffd\ufffd\");\n            String [] mobiles = request.getParameterValues (\"mobiles\");\n            vo.setMobiles (mobiles);\n            SMSService.inforAlert (vo);\n        } catch (Exception e) {\n            logger.error (\"doAdd(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)\", e);\n        }\n        String filename = vo.getFile ().getFileName ();\n        if (null != filename && ! \"\".equals (filename)) {\n            FormFile file = vo.getFile ();\n            String realpath = getServlet ().getServletContext ().getRealPath (\"/\");\n            realpath = realpath.replaceAll (\"\\\\\\\\\", \"/\");\n            String inforId = vo.getId ();\n            String rootFilePath = getServlet ().getServletContext ().getRealPath (request.getContextPath ());\n            rootFilePath = (new StringBuilder (String.valueOf (rootFilePath))).append (UploadFileOne.strPath).toString ();\n            String strAppend = (new StringBuilder (String.valueOf (UUIDGenerator.nextHex ()))).append (UploadFileOne.getFileType (file)).toString ();\n            if (file.getFileSize () != 0) {\n                file.getInputStream ();\n                String name = file.getFileName ();\n                i_p = file.getFileName ().lastIndexOf (\".\");\n                str_postFIX = file.getFileName ().substring (i_p, file.getFileName ().length ());\n                String fullPath = realpath + \"attach/\" + strAppend + str_postFIX;\n                t_attach attach = new t_attach ();\n                attach.setAttach_fullname (fullPath);\n                attach.setAttach_name (name);\n                attach.setInfor_id (Integer.parseInt (inforId));\n                attach.setInsert_day (new Date ());\n                attach.setUpdate_day (new Date ());\n                t_attach_EditMap attachEdit = new t_attach_EditMap ();\n                attachEdit.add (attach);\n                File sysfile = new File (fullPath);\n                if (! sysfile.exists ()) {\n                    sysfile.createNewFile ();\n                }\n                java.io.OutputStream out = new FileOutputStream (sysfile);\n                org.apache.commons.io.IOUtils.copy (file.getInputStream (), out);\n                out.close ();\n            }\n        }\n    } catch (HibernateException e) {\n        logger.error (\"doAdd(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)\", e);\n        ActionErrors errors = new ActionErrors ();\n        errors.add (\"org.apache.struts.action.GLOBAL_ERROR\", new ActionError (\"error.database.save\", e.toString ()));\n        saveErrors (request, errors);\n        e.printStackTrace ();\n        request.setAttribute (\"t_information_Form\", form);\n        if (logger.isDebugEnabled ()) {\n            logger.debug (\"doAdd(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse) - end\");\n        }\n        return \"addpage\";\n    }\n    if (logger.isDebugEnabled ()) {\n        logger.debug (\"doAdd(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse) - end\");\n    }\n    return \"aftersave\";\n}\n", "code2": "public boolean backupLastAuditSchema (File lastAuditSchema) {\n    boolean isBkupFileOK = false;\n    String writeTimestamp = DateFormatUtils.format (new java.util.Date (), configFile.getTimestampPattern ());\n    File target = new File (configFile.getAuditSchemaFileDir () + File.separator + configFile.getAuditSchemaFileName () + \".bkup_\" + writeTimestamp);\n    FileChannel sourceChannel = null;\n    FileChannel targetChannel = null;\n    try {\n        sourceChannel = new FileInputStream (lastAuditSchema).getChannel ();\n        targetChannel = new FileOutputStream (target).getChannel ();\n        targetChannel.transferFrom (sourceChannel, 0, sourceChannel.size ());\n    } catch (IOException e) {\n        logger.log (Level.SEVERE, \"IO exception occurred while copying file\", e);\n    } finally {\n        if ((target != null) && (target.exists ()) && (target.length () > 0)) {\n            isBkupFileOK = true;\n        }\n        try {\n            if (sourceChannel != null) {\n                sourceChannel.close ();\n            }\n            if (targetChannel != null) {\n                targetChannel.close ();\n            }\n        } catch (IOException e) {\n            logger.info (\"closing channels failed\");\n        }\n    }\n    return isBkupFileOK;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 310182, "method2_id": 4471000, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 12067823, "method2_id": 20089257, "code1": "public void run () {\n    if (saveAsDialog == null) {\n        saveAsDialog = new FileDialog (window.getShell (), SWT.SAVE);\n        saveAsDialog.setFilterExtensions (saveAsTypes);\n    }\n    String outputFile = saveAsDialog.open ();\n    if (outputFile != null) {\n        Object inputFile = DataSourceSingleton.getInstance ().getContainer ().getWrapped ();\n        InputStream in;\n        try {\n            if (inputFile instanceof URL) in = ((URL) inputFile).openStream ();\n            else in = new FileInputStream ((File) inputFile);\n\n            OutputStream out = new FileOutputStream (outputFile);\n            if (outputFile.endsWith (\"xml\")) {\n                int c;\n                while ((c = in.read ()) != - 1) out.write (c);\n\n            } else {\n                PrintWriter pw = new PrintWriter (out);\n                Element data = DataSourceSingleton.getInstance ().getRawData ();\n                writeTextFile (data, pw, - 1);\n                pw.close ();\n            }\n            in.close ();\n            out.close ();\n        } catch (MalformedURLException e1) {\n        } catch (IOException e) {\n        }\n    }\n}\n", "code2": "public void store (String path, InputStream stream) throws IOException {\n    toIgnore.add (normalizePath (path));\n    ZipEntry entry = new ZipEntry (path);\n    zipOutput.putNextEntry (entry);\n    IOUtils.copy (stream, zipOutput);\n    zipOutput.closeEntry ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 11090449, "method2_id": 16586894, "code1": "public static Drawable fetchCachedDrawable (String url) throws MalformedURLException, IOException {\n    Log.d (LOG_TAG, \"Fetching cached : \" + url);\n    String cacheName = md5 (url);\n    checkAndCreateDirectoryIfNeeded ();\n    File r = new File (CACHELOCATION + cacheName);\n    if (! r.exists ()) {\n        InputStream is = (InputStream) fetch (url);\n        FileOutputStream fos = new FileOutputStream (CACHELOCATION + cacheName);\n        int nextChar;\n        while ((nextChar = is.read ()) != - 1) fos.write ((char) nextChar);\n\n        fos.flush ();\n    }\n    FileInputStream fis = new FileInputStream (CACHELOCATION + cacheName);\n    Drawable d = Drawable.createFromStream (fis, \"src\");\n    return d;\n}\n", "code2": "public void test3 () throws FileNotFoundException, IOException {\n    Decoder decoder1 = new MP3Decoder (new FileInputStream (\"/home/marc/tmp/test1.mp3\"));\n    Decoder decoder2 = new OggDecoder (new FileInputStream (\"/home/marc/tmp/test1.ogg\"));\n    FileOutputStream out = new FileOutputStream (\"/home/marc/tmp/test.pipe\");\n    IOUtils.copy (decoder1, out);\n    IOUtils.copy (decoder2, out);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 662799, "method2_id": 21442625, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private void copyFile (String from, String to) throws Exception {\n    URL monitorCallShellScriptUrl = Thread.currentThread ().getContextClassLoader ().getResource (from);\n    File inScriptFile = null;\n    try {\n        inScriptFile = new File (monitorCallShellScriptUrl.toURI ());\n    } catch (URISyntaxException e) {\n        throw e;\n    }\n    File outScriptFile = new File (to);\n    FileChannel inChannel = new FileInputStream (inScriptFile).getChannel ();\n    FileChannel outChannel = new FileOutputStream (outScriptFile).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n    try {\n        LinuxCommandExecutor cmdExecutor = new LinuxCommandExecutor ();\n        cmdExecutor.setWorkingDirectory (workingDirectory);\n        cmdExecutor.runCommand (\"chmod 777 \" + to);\n    } catch (Exception e) {\n        throw e;\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1760355, "method2_id": 18317329, "code1": "public static int deleteHedgeCustTrade () {\n    Connection conn = null;\n    PreparedStatement psmt = null;\n    StringBuffer SQL = new StringBuffer (200);\n    int deleted = 0;\n    SQL.append (\" DELETE FROM JHF_HEDGE_CUSTTRADE \");\n    try {\n        conn = JdbcConnectionPool.mainConnection ();\n        conn.setAutoCommit (false);\n        conn.setReadOnly (false);\n        psmt = conn.prepareStatement (SQL.toString ());\n        deleted = psmt.executeUpdate ();\n        conn.commit ();\n    } catch (SQLException e) {\n        if (null != conn) {\n            try {\n                conn.rollback ();\n            } catch (SQLException e1) {\n                System.out.println (\" error when roll back !\");\n            }\n        }\n    } finally {\n        try {\n            if (null != psmt) {\n                psmt.close ();\n                psmt = null;\n            }\n            if (null != conn) {\n                conn.close ();\n                conn = null;\n            }\n        } catch (SQLException e) {\n            System.out.println (\" error  when psmt close or conn close .\");\n        }\n    }\n    return deleted;\n}\n", "code2": "private void delete (Connection conn, int itemId) throws SQLException {\n    Statement statement = null;\n    try {\n        conn.setAutoCommit (false);\n        deleteComponents (conn, itemId);\n        statement = conn.createStatement ();\n        StringBuffer sqlBuff = new StringBuffer (\"DELETE FROM \");\n        sqlBuff.append (m_dbItemName);\n        sqlBuff.append (\" WHERE \");\n        sqlBuff.append (m_dbItemIdFieldColName);\n        sqlBuff.append (\" = \");\n        sqlBuff.append (Integer.toString (itemId));\n        String sql = sqlBuff.toString ();\n        statement.executeUpdate (sql);\n        conn.commit ();\n    } catch (SQLException ex) {\n        try {\n            conn.rollback ();\n        } catch (SQLException e) {\n            e.printStackTrace ();\n        }\n        throw ex;\n    } finally {\n        if (statement != null) {\n            statement.close ();\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6249581, "method2_id": 6887177, "code1": "private static void createIndex (JarOutputStream jos, List oldEntries, Map movedMap) throws IOException {\n    StringWriter writer = new StringWriter ();\n    writer.write (VERSION_HEADER);\n    writer.write (\"\\r\\n\");\n    for (int counter = 0;\n    counter < oldEntries.size (); counter ++) {\n        String name = (String) oldEntries.get (counter);\n        writer.write (REMOVE_COMMAND);\n        writer.write (\" \");\n        writeEscapedString (writer, name);\n        writer.write (\"\\r\\n\");\n    }\n    Iterator names = movedMap.keySet ().iterator ();\n    if (names != null) {\n        while (names.hasNext ()) {\n            String newName = (String) names.next ();\n            String oldName = (String) movedMap.get (newName);\n            writer.write (MOVE_COMMAND);\n            writer.write (\" \");\n            writeEscapedString (writer, oldName);\n            writer.write (\" \");\n            writeEscapedString (writer, newName);\n            writer.write (\"\\r\\n\");\n        }\n    }\n    ZipEntry je = new ZipEntry (INDEX_NAME);\n    byte [] bytes = writer.toString ().getBytes (\"UTF-8\");\n    writer.close ();\n    jos.putNextEntry (je);\n    jos.write (bytes, 0, bytes.length);\n}\n", "code2": "protected void add (ExtZipEntry zipEntry, InputStream zipData) throws IOException, UnsupportedEncodingException {\n    zipOS.putNextEntry (zipEntry);\n    byte [] data = new byte [1024];\n    int read = zipData.read (data);\n    while (read != - 1) {\n        zipOS.writeBytes (data, 0, read);\n        read = zipData.read (data);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1391374, "method2_id": 1407914, "code1": "public static AbstractONDEXPlugin getPlugin (String str) {\n    AbstractONDEXPlugin p = null;\n    try {\n        Class < ? > cls = Class.forName (str);\n        p = (AbstractONDEXPlugin) cls.getConstructor (new Class < ? > [] {}).newInstance ();\n    } catch (Exception e) {\n    }\n    return p;\n}\n", "code2": "private void InitEventListener (org.jdom.Element eleEvent) {\n    if (eleEvent == null) return;\n\n    List events = eleEvent.getChildren ();\n    for (Object obj : events) {\n        Element event = (Element) obj;\n        String event_name = event.getName ();\n        String event_key = event.getAttributeValue (\"key\");\n        String event_classname = event.getTextTrim ();\n        if (event_name == null || event_classname == null) continue;\n\n        if (! (event_name.equalsIgnoreCase (\"insert\") || \"update\".equalsIgnoreCase (event_name) || \"delete\".equalsIgnoreCase (event_name) || \"ready\".equalsIgnoreCase (event_name) || \"publish\".equalsIgnoreCase (event_name))) continue;\n\n        Object clazz_obj;\n        try {\n            Class clazz = Config.GetClassLoader ().ReloadClass (event_classname);\n            java.lang.reflect.Constructor clazz_constructor = clazz.getConstructor (new Class [] {});\n            clazz_obj = clazz_constructor.newInstance (new Object [] {});\n        } catch (Exception e) {\n            nps.util.DefaultLog.error_noexception (e);\n            continue;\n        }\n        if (\"insert\".equalsIgnoreCase (event_name)) {\n            if (clazz_obj instanceof InsertEventListener) {\n                EventSubscriber.GetSubscriber ().AddListener ((InsertEventListener) clazz_obj, event_key);\n            }\n        } else if (\"update\".equalsIgnoreCase (event_name)) {\n            if (clazz_obj instanceof UpdateEventListener) {\n                EventSubscriber.GetSubscriber ().AddListener ((UpdateEventListener) clazz_obj, event_key);\n            }\n        } else if (\"delete\".equalsIgnoreCase (event_name)) {\n            if (clazz_obj instanceof DeleteEventListener) {\n                EventSubscriber.GetSubscriber ().AddListener ((DeleteEventListener) clazz_obj, event_key);\n            }\n        } else if (\"ready\".equalsIgnoreCase (event_name)) {\n            if (clazz_obj instanceof Ready2PublishEventListener) {\n                EventSubscriber.GetSubscriber ().AddListener ((Ready2PublishEventListener) clazz_obj, event_key);\n            }\n        } else if (\"publish\".equalsIgnoreCase (event_name)) {\n            if (clazz_obj instanceof PublishEventListener) {\n                EventSubscriber.GetSubscriber ().AddListener ((PublishEventListener) clazz_obj, event_key);\n            }\n        } else if (\"cancel\".equalsIgnoreCase (event_name)) {\n            if (clazz_obj instanceof CancelEventListener) {\n                EventSubscriber.GetSubscriber ().AddListener ((CancelEventListener) clazz_obj, event_key);\n            }\n        }\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 7652062, "method2_id": 18516553, "code1": "public void processChangedLines (int offset, int length) throws BadLocationException {\n    String text = getText (0, getLength ());\n    highlightString (Color.black, 0, getLength (), true, false);\n    Set < String > keyw = keywords.keySet ();\n    for (String keyword : keyw) {\n        Color col = keywords.get (keyword);\n        Pattern p = Pattern.compile (\"\\\\b\" + keyword + \"\\\\b\");\n        Matcher m = p.matcher (text);\n        while (m.find ()) {\n            highlightString (col, m.start (), keyword.length (), true, true);\n        }\n    }\n    Matcher mlcStart = multiLineCommentDelimiterStart.matcher (text);\n    Matcher mlcEnd = multiLineCommentDelimiterEnd.matcher (text);\n    while (mlcStart.find ()) {\n        if (mlcEnd.find (mlcStart.end ())) highlightString (commentColor, mlcStart.start (), (mlcEnd.end () - mlcStart.start ()), true, false);\n        else highlightString (commentColor, mlcStart.start (), getLength (), true, false);\n\n    }\n    Matcher slc = singleLineCommentDelimter.matcher (text);\n    while (slc.find ()) {\n        int line = rootElement.getElementIndex (slc.start ());\n        int endOffset = rootElement.getElement (line).getEndOffset () - 1;\n        highlightString (commentColor, slc.start (), (endOffset - slc.start ()), true, true);\n    }\n}\n", "code2": "private String parseTags (String string) {\n    string = string.replaceAll (\"</(.+?)>\", \"\\\\\\\\textag $0\");\n    Pattern pattern = Pattern.compile (\"(?s)(?i)(<\\\\w.*?)(~(?:.*?))?(/?>)\");\n    Matcher matcher = pattern.matcher (string);\n    String output = \"\";\n    int lastend = 0;\n    while (matcher.find ()) {\n        output += string.substring (lastend, matcher.start (1));\n        output += \"\\\\textag \";\n        output += matcher.group (1);\n        if (matcher.group (2) != null) {\n            output += parseAttribs (matcher.group (2));\n            output += \"\\\\textag \";\n        }\n        output += matcher.group (3);\n        lastend = matcher.end (3);\n    }\n    output += string.substring (lastend);\n    return output;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4726770, "method2_id": 14652853, "code1": "public void execute () throws MojoExecutionException, MojoFailureException {\n    try {\n        this.getLog ().info (\"copy source web.xml - \" + this.getWebXml () + \" to build dir (source web.xml required if mergewebxml execution is enabled)\");\n        File destination = new File (this.getBuildDir (), \"web.xml\");\n        if (! destination.exists ()) {\n            destination.getParentFile ().mkdirs ();\n            destination.createNewFile ();\n        }\n        FileIOUtils.copyFile (this.getWebXml (), destination);\n        for (int i = 0;\n        i < this.getCompileTarget ().length; i ++) {\n            File moduleFile = null;\n            for (Iterator it = this.getProject ().getCompileSourceRoots ().iterator ();\n            it.hasNext () && moduleFile == null;) {\n                File check = new File (it.next ().toString () + \"/\" + this.getCompileTarget () [i].replace ('.', '/') + \".gwt.xml\");\n                getLog ().debug (\"Looking for file: \" + check.getAbsolutePath ());\n                if (check.exists ()) {\n                    moduleFile = check;\n                }\n            }\n            for (Iterator it = this.getProject ().getResources ().iterator ();\n            it.hasNext ();) {\n                Resource r = (Resource) it.next ();\n                File check = new File (r.getDirectory () + \"/\" + this.getCompileTarget () [i].replace ('.', '/') + \".gwt.xml\");\n                getLog ().debug (\"Looking for file: \" + check.getAbsolutePath ());\n                if (check.exists ()) {\n                    moduleFile = check;\n                }\n            }\n            ClassLoader loader = this.fixThreadClasspath ();\n            if (moduleFile == null) {\n                try {\n                    String classpath = \"/\" + this.getCompileTarget () [i].replace ('.', '/') + \".gwt.xml\";\n                    InputStream is = loader.getResourceAsStream (classpath);\n                    System.out.println (\"Looking for classpath: \" + classpath + \"(\" + (is != null) + \")\");\n                    if (is != null) {\n                        File temp = new File (this.getBuildDir (), this.getCompileTarget () [i].concat (\".gwt.xml\"));\n                        FileOutputStream fos = new FileOutputStream (temp);\n                        FileIOUtils.copyStream (is, fos);\n                        moduleFile = temp;\n                    }\n                } catch (IOException e) {\n                    this.getLog ().info (e);\n                }\n            }\n            GwtWebInfProcessor processor = null;\n            try {\n                if (moduleFile != null) {\n                    getLog ().info (\"Module file: \" + moduleFile.getAbsolutePath ());\n                    processor = new GwtWebInfProcessor (this.getCompileTarget () [i], moduleFile, destination.getAbsolutePath (), destination.getAbsolutePath (), this.isWebXmlServletPathAsIs ());\n                    processor.process ();\n                } else {\n                    throw new MojoExecutionException (\"module file null\");\n                }\n            } catch (ExitException e) {\n                this.getLog ().info (e.getMessage ());\n            }\n        }\n    } catch (Exception e) {\n        throw new MojoExecutionException (\"Unable to merge web.xml\", e);\n    }\n}\n", "code2": "public static void main (String args []) {\n    String midletClass = null;\n    File appletInputFile = null;\n    File deviceInputFile = null;\n    File midletInputFile = null;\n    File htmlOutputFile = null;\n    File appletOutputFile = null;\n    File deviceOutputFile = null;\n    File midletOutputFile = null;\n    List params = new ArrayList ();\n    for (int i = 0;\n    i < args.length; i ++) {\n        params.add (args [i]);\n    }\n    Iterator argsIterator = params.iterator ();\n    while (argsIterator.hasNext ()) {\n        String arg = (String) argsIterator.next ();\n        argsIterator.remove ();\n        if ((arg.equals (\"--help\")) || (arg.equals (\"-help\"))) {\n            System.out.println (usage ());\n            System.exit (0);\n        } else if (arg.equals (\"--midletClass\")) {\n            midletClass = (String) argsIterator.next ();\n            argsIterator.remove ();\n        } else if (arg.equals (\"--appletInput\")) {\n            appletInputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        } else if (arg.equals (\"--deviceInput\")) {\n            deviceInputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        } else if (arg.equals (\"--midletInput\")) {\n            midletInputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        } else if (arg.equals (\"--htmlOutput\")) {\n            htmlOutputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        } else if (arg.equals (\"--appletOutput\")) {\n            appletOutputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        } else if (arg.equals (\"--deviceOutput\")) {\n            deviceOutputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        } else if (arg.equals (\"--midletOutput\")) {\n            midletOutputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        }\n\n    }\n    if (midletClass == null || appletInputFile == null || deviceInputFile == null || midletInputFile == null || htmlOutputFile == null || appletOutputFile == null || deviceOutputFile == null || midletOutputFile == null) {\n        System.out.println (usage ());\n        System.exit (0);\n    }\n    try {\n        DeviceImpl device = null;\n        String descriptorLocation = null;\n        JarFile jar = new JarFile (deviceInputFile);\n        for (Enumeration en = jar.entries ();\n        en.hasMoreElements ();) {\n            String entry = ((JarEntry) en.nextElement ()).getName ();\n            if ((entry.toLowerCase ().endsWith (\".xml\") || entry.toLowerCase ().endsWith (\"device.txt\")) && ! entry.toLowerCase ().startsWith (\"meta-inf\")) {\n                descriptorLocation = entry;\n                break;\n            }\n        }\n        if (descriptorLocation != null) {\n            EmulatorContext context = new EmulatorContext () {\n                private DisplayComponent displayComponent = new NoUiDisplayComponent ();\n                private InputMethod inputMethod = new J2SEInputMethod ();\n                private DeviceDisplay deviceDisplay = new J2SEDeviceDisplay (this);\n                private FontManager fontManager = new J2SEFontManager ();\n                private DeviceComponent deviceComponent = new SwingDeviceComponent (true);\n                public DisplayComponent getDisplayComponent () {\n                    return displayComponent;\n                } public InputMethod getDeviceInputMethod () {\n                    return inputMethod;\n                } public DeviceDisplay getDeviceDisplay () {\n                    return deviceDisplay;\n                } public FontManager getDeviceFontManager () {\n                    return fontManager;\n                } public InputStream getResourceAsStream (String name) {\n                    return MIDletBridge.getCurrentMIDlet ().getClass ().getResourceAsStream (name);\n                } public DeviceComponent getDeviceComponent () {\n                    return deviceComponent;\n                }}\n\n            ;\n            URL [] urls = new URL [1];\n            urls [0] = deviceInputFile.toURI ().toURL ();\n            ClassLoader classLoader = new ExtensionsClassLoader (urls, urls.getClass ().getClassLoader ());\n            device = DeviceImpl.create (context, classLoader, descriptorLocation, J2SEDevice.class);\n        }\n        if (device == null) {\n            System.out.println (\"Error parsing device package: \" + descriptorLocation);\n            System.exit (0);\n        }\n        createHtml (htmlOutputFile, device, midletClass, midletOutputFile, appletOutputFile, deviceOutputFile);\n        createMidlet (midletInputFile.toURI ().toURL (), midletOutputFile);\n        IOUtils.copyFile (appletInputFile, appletOutputFile);\n        IOUtils.copyFile (deviceInputFile, deviceOutputFile);\n    } catch (IOException ex) {\n        ex.printStackTrace ();\n    }\n    System.exit (0);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2668853, "method2_id": 4240389, "code1": "public static boolean decodeFileToFile (final String infile, final String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        final byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (final java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (final Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (final Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "private void copyResource (final String resourceName, final File file) throws IOException {\n    assertTrue (resourceName.startsWith (\"/\"));\n    InputStream in = null;\n    boolean suppressExceptionOnClose = true;\n    try {\n        in = this.getClass ().getResourceAsStream (resourceName);\n        assertNotNull (\"Resource '\" + resourceName + \"' not found.\", in);\n        OutputStream out = null;\n        try {\n            out = new FileOutputStream (file);\n            IOUtils.copy (in, out);\n            suppressExceptionOnClose = false;\n        } finally {\n            try {\n                if (out != null) {\n                    out.close ();\n                }\n            } catch (final IOException e) {\n                if (! suppressExceptionOnClose) {\n                    throw e;\n                }\n            }\n        }\n    } finally {\n        try {\n            if (in != null) {\n                in.close ();\n            }\n        } catch (final IOException e) {\n            if (! suppressExceptionOnClose) {\n                throw e;\n            }\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8635034, "method2_id": 23373800, "code1": "private void addFileToArchive (ZipOutputStream reportArchive, String file) throws FileNotFoundException, IOException {\n    FileInputStream asf = new FileInputStream (file);\n    reportArchive.putNextEntry (new ZipEntry (file));\n    byte [] buffer = new byte [18024];\n    int len;\n    while ((len = asf.read (buffer)) > 0) {\n        reportArchive.write (buffer, 0, len);\n    }\n    asf.close ();\n    reportArchive.closeEntry ();\n}\n", "code2": "public NucZipper (File file, NucleiMgr nucleiMgr) {\n    super ();\n    String nucDir = nucleiMgr.getConfig ().iZipNucDir;\n    try {\n        FileOutputStream fos = new FileOutputStream (file);\n        ZipOutputStream zos = new ZipOutputStream (fos);\n        Vector nuclei = (Vector) nucleiMgr.getNucleiRecord ();\n        for (int i = 0;\n        i < nuclei.size (); i ++) {\n            String ename = nucDir + \"t\" + EUtils.makePaddedInt (i + 1) + \"-nuclei\";\n            zos.putNextEntry (new ZipEntry (ename));\n            String s;\n            for (int j = 0;\n            j < ((Vector) nuclei.elementAt (i)).size (); j ++) {\n                Nucleus n = (Nucleus) ((Vector) nuclei.elementAt (i)).elementAt (j);\n                s = formatNucleus (j, n);\n                byte [] b = s.getBytes ();\n                zos.write (b, 0, b.length);\n            }\n            zos.closeEntry ();\n        }\n        addParameters (zos, nucleiMgr);\n        zos.close ();\n    } catch (IOException ioe) {\n        System.out.println (\"NucZipper exception: \" + ioe);\n        new AceTreeHelp (\"/org/rhwlab/help/messages/PermissionError.html\", 200, 200);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10942052, "method2_id": 23613195, "code1": "public static void copy (String from, String to) throws Exception {\n    File inputFile = new File (from);\n    File outputFile = new File (to);\n    FileInputStream in = new FileInputStream (inputFile);\n    FileOutputStream out = new FileOutputStream (outputFile);\n    byte [] buffer = new byte [1024];\n    int len;\n    while ((len = in.read (buffer)) != - 1) out.write (buffer, 0, len);\n\n    in.close ();\n    out.close ();\n}\n", "code2": "public static void copy (File source, File dest) throws IOException {\n    FileChannel in = null, out = null;\n    try {\n        in = new FileInputStream (source).getChannel ();\n        out = new FileOutputStream (dest).getChannel ();\n        long size = in.size ();\n        MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n        out.write (buf);\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 15429599, "method2_id": 20423573, "code1": "public static boolean copyFile (File src, File dest) throws IOException {\n    if (src == null) {\n        throw new IllegalArgumentException (\"src == null\");\n    }\n    if (dest == null) {\n        throw new IllegalArgumentException (\"dest == null\");\n    }\n    if (! src.isFile ()) {\n        return false;\n    }\n    FileChannel in = new FileInputStream (src).getChannel ();\n    FileChannel out = new FileOutputStream (dest).getChannel ();\n    try {\n        in.transferTo (0, in.size (), out);\n        return true;\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (in != null) {\n            in.close ();\n        }\n        if (out != null) {\n            out.close ();\n        }\n    }\n}\n", "code2": "private static String fetchFile (String urlLocation) {\n    try {\n        URL url = new URL (urlLocation);\n        URLConnection conn = url.openConnection ();\n        File tempFile = File.createTempFile (\"marla\", \".jar\");\n        OutputStream os = new FileOutputStream (tempFile);\n        IOUtils.copy (conn.getInputStream (), os);\n        return tempFile.getAbsolutePath ();\n    } catch (IOException ex) {\n        throw new MarlaException (\"Unable to fetch file '\" + urlLocation + \"' from server\", ex);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1217755, "method2_id": 2543784, "code1": "static DaoException createException (Class < ? > clazz, Exception e) throws Exception {\n    Constructor < ? > c = clazz.getConstructor (Exception.class);\n    DaoException ret = (DaoException) c.newInstance (e);\n    return ret;\n}\n", "code2": "@SuppressWarnings(\"unchecked\")\nprotected AbstractEdgeShapeTransformer < Node, Edge > makeEdgeShapeInstance (final Class < ? extends AbstractEdgeShapeTransformer < Node, Edge > > thisEdgeShapeClass) {\n    try {\n        final Constructor < ? extends AbstractEdgeShapeTransformer < Node, Edge > > thisConstructor = thisEdgeShapeClass.getConstructor (new Class [] {});\n        final Object [] theseArgs = {};\n        final Object thisEdgeShapeObject = thisConstructor.newInstance (theseArgs);\n        final AbstractEdgeShapeTransformer < Node, Edge > thisEdgeShapeTransformer = (AbstractEdgeShapeTransformer < Node, Edge >) thisEdgeShapeObject;\n        thisEdgeShapeTransformer.setControlOffsetIncrement (this.theSettings.theEdgeControlOffsetIncrement);\n        if (thisEdgeShapeTransformer instanceof Bracket) {\n            final Bracket < Node, Edge > thisBracket = (Bracket < Node, Edge >) thisEdgeShapeTransformer;\n            thisBracket.setEdgeIndexFunction (this.theBracketEdgeIndexFunction);\n            thisBracket.setEdgeOffsetFunctions (this.theBracketEdgeOffsetFunctions);\n            Bracket.setXOffsetIncrement (this.theSettings.theEdgeXOffsetIncrement);\n            Bracket.setYOffsetIncrement (this.theSettings.theEdgeYOffsetIncrement);\n        }\n        return thisEdgeShapeTransformer;\n    } catch (final SecurityException e) {\n        e.printStackTrace ();\n    } catch (final NoSuchMethodException e) {\n        e.printStackTrace ();\n    } catch (final IllegalArgumentException e) {\n        e.printStackTrace ();\n    } catch (final InstantiationException e) {\n        e.printStackTrace ();\n    } catch (final IllegalAccessException e) {\n        e.printStackTrace ();\n    } catch (final InvocationTargetException e) {\n        e.printStackTrace ();\n    }\n    return null;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6902534, "method2_id": 10062076, "code1": "public void doAction (HttpServletRequest request, HttpServletResponse response) throws Exception {\n    String attachmentName = request.getParameter (\"attachment\");\n    String virtualWiki = getVirtualWiki (request);\n    File uploadPath = getEnvironment ().uploadPath (virtualWiki, attachmentName);\n    response.reset ();\n    response.setHeader (\"Content-Disposition\", getEnvironment ().getStringSetting (Environment.PROPERTY_ATTACHMENT_TYPE) + \";filename=\" + attachmentName + \";\");\n    int dotIndex = attachmentName.indexOf ('.');\n    if (dotIndex >= 0 && dotIndex < attachmentName.length () - 1) {\n        String extension = attachmentName.substring (attachmentName.lastIndexOf ('.') + 1);\n        logger.fine (\"Extension: \" + extension);\n        String mimetype = (String) getMimeByExtension ().get (extension.toLowerCase ());\n        logger.fine (\"MIME: \" + mimetype);\n        if (mimetype != null) {\n            logger.fine (\"Setting content type to: \" + mimetype);\n            response.setContentType (mimetype);\n        }\n    }\n    FileInputStream in = null;\n    ServletOutputStream out = null;\n    try {\n        in = new FileInputStream (uploadPath);\n        out = response.getOutputStream ();\n        IOUtils.copy (in, out);\n        out.flush ();\n    } finally {\n        IOUtils.closeQuietly (in);\n        IOUtils.closeQuietly (out);\n    }\n}\n", "code2": "private long generateNativeInstallExe (File nativeInstallFile, String instTemplate, File instClassFile) throws IOException {\n    InputStream reader = getClass ().getResourceAsStream (\"/\" + instTemplate);\n    ByteArrayOutputStream content = new ByteArrayOutputStream ();\n    String installClassVarStr = \"000000000000\";\n    byte [] buf = new byte [installClassVarStr.length ()];\n    NumberFormat nf = NumberFormat.getInstance (Locale.US);\n    nf.setGroupingUsed (false);\n    nf.setMinimumIntegerDigits (installClassVarStr.length ());\n    int installClassStopPos = 0;\n    long installClassOffset = reader.available ();\n    int position = 0;\n    System.out.println (VAGlobals.i18n (\"VAArchiver_GenerateInstallExe\"));\n    reader.read (buf, 0, buf.length);\n    position = 1;\n    for (int n = 0;\n    n < 3; n ++) {\n        while ((! new String (buf).equals (\"clname_here_\")) && (! new String (buf).equals (\"clstart_here\")) && (! new String (buf).equals (\"clstop_here_\"))) {\n            content.write (buf [0]);\n            int nextb = reader.read ();\n            position ++;\n            shiftArray (buf);\n            buf [buf.length - 1] = (byte) nextb;\n        }\n        if (new String (buf).equals (\"clname_here_\")) {\n            VAGlobals.printDebug (\"  clname_here_ found at \" + (position - 1));\n            StringBuffer clnameBuffer = new StringBuffer (64);\n            clnameBuffer.append (instClassName_);\n            for (int i = clnameBuffer.length () - 1;\n            i < 64; i ++) {\n                clnameBuffer.append ('.');\n            }\n            byte [] clnameBytes = clnameBuffer.toString ().getBytes ();\n            for (int i = 0;\n            i < 64; i ++) {\n                content.write (clnameBytes [i]);\n                position ++;\n            }\n            reader.skip (64 - buf.length);\n            reader.read (buf, 0, buf.length);\n        } else if (new String (buf).equals (\"clstart_here\")) {\n            VAGlobals.printDebug (\"  clstart_here found at \" + (position - 1));\n            buf = nf.format (installClassOffset).getBytes ();\n            for (int i = 0;\n            i < buf.length; i ++) {\n                content.write (buf [i]);\n                position ++;\n            }\n            reader.read (buf, 0, buf.length);\n        } else if (new String (buf).equals (\"clstop_here_\")) {\n            VAGlobals.printDebug (\"  clstop_here_ found at \" + (position - 1));\n            installClassStopPos = position - 1;\n            content.write (buf);\n            position += 12;\n            reader.read (buf, 0, buf.length);\n        }\n\n    }\n    content.write (buf);\n    buf = new byte [2048];\n    int read = reader.read (buf);\n    while (read > 0) {\n        content.write (buf, 0, read);\n        read = reader.read (buf);\n    }\n    reader.close ();\n    FileInputStream classStream = new FileInputStream (instClassFile);\n    read = classStream.read (buf);\n    while (read > 0) {\n        content.write (buf, 0, read);\n        read = classStream.read (buf);\n    }\n    classStream.close ();\n    content.close ();\n    byte [] contentBytes = content.toByteArray ();\n    installClassVarStr = nf.format (contentBytes.length);\n    byte [] installClassVarBytes = installClassVarStr.getBytes ();\n    for (int i = 0;\n    i < installClassVarBytes.length; i ++) {\n        contentBytes [installClassStopPos + i] = installClassVarBytes [i];\n    }\n    FileOutputStream out = new FileOutputStream (nativeInstallFile);\n    out.write (contentBytes);\n    out.close ();\n    return installClassOffset;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9830267, "method2_id": 12678589, "code1": "public void run () {\n    final SimpleMessageListener listener = new SimpleMessageListener () {\n        public final boolean accept (final String from, final String recipient) {\n            return true;\n        } public final void deliver (final String from, final String recipient, final InputStream data) throws TooMuchDataException, IOException {\n            System.out.println (\"FROM: \" + from);\n            System.out.println (\"TO: \" + recipient);\n            final File tmpDir = new File (System.getProperty (\"java.io.tmpdir\"));\n            final File file = new File (tmpDir, recipient);\n            final FileWriter fw = new FileWriter (file);\n            try {\n                IOUtils.copy (data, fw);\n            } finally {\n                fw.close ();\n            }\n        }}\n\n    ;\n    final SMTPServer smtpServer = new SMTPServer (new SimpleMessageListenerAdapter (listener));\n    smtpServer.start ();\n    System.out.println (\"Started SMTP Server\");\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 14053882, "method2_id": 14957786, "code1": "public synchronized String encrypt (String plaintext) throws Exception {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance (\"SHA\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new Exception (e.getMessage ());\n    }\n    try {\n        md.update (plaintext.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        throw new Exception (e.getMessage ());\n    }\n    byte raw [] = md.digest ();\n    String hash = (new BASE64Encoder ()).encode (raw);\n    return hash;\n}\n", "code2": "public void setPassword (String password) {\n    MessageDigest md;\n    try {\n        md = MessageDigest.getInstance (\"SHA-256\");\n        md.update (password.getBytes (\"UTF-8\"));\n        byte [] digest = md.digest ();\n        String encodedPassword = Base64.encode (digest);\n        this.password = encodedPassword;\n    } catch (NoSuchAlgorithmException e) {\n        logger.log (Level.SEVERE, \"Password creation failed\", e);\n        throw new RuntimeException (e);\n    } catch (UnsupportedEncodingException e) {\n        logger.log (Level.SEVERE, \"Password creation failed\", e);\n        throw new RuntimeException (e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6184983, "method2_id": 21575639, "code1": "@Override\npublic boolean copyFile (String srcRootPath, String srcDir, String srcFileName, String destRootPath, String destDir, String destFileName) {\n    File srcPath = new File (srcRootPath + separator () + Database.getDomainName () + separator () + srcDir);\n    if (! srcPath.exists ()) {\n        try {\n            srcPath.mkdirs ();\n        } catch (Exception e) {\n            logger.error (\"Can't create directory...:\" + srcPath);\n            return false;\n        }\n    }\n    File destPath = new File (destRootPath + separator () + Database.getDomainName () + separator () + destDir);\n    if (! destPath.exists ()) {\n        try {\n            destPath.mkdirs ();\n        } catch (Exception e) {\n            logger.error (\"Can't create directory...:\" + destPath);\n            return false;\n        }\n    }\n    File from = new File (srcPath + separator () + srcFileName);\n    File to = new File (destPath + separator () + destFileName);\n    boolean res = true;\n    FileChannel srcChannel = null;\n    FileChannel destChannel = null;\n    try {\n        srcChannel = new FileInputStream (from).getChannel ();\n        destChannel = new FileOutputStream (to).getChannel ();\n        destChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    } catch (Exception ex) {\n        logger.error (\"Exception\", ex);\n        res = false;\n    } finally {\n        if (destChannel != null) {\n            try {\n                destChannel.close ();\n            } catch (IOException ex) {\n                logger.error (\"Exception\", ex);\n                res = false;\n            }\n        }\n        if (srcChannel != null) {\n            try {\n                srcChannel.close ();\n            } catch (IOException ex) {\n                logger.error (\"Exception\", ex);\n                res = false;\n            }\n        }\n    }\n    return res;\n}\n", "code2": "protected byte [] readGZippedBytes (TupleInput in) {\n    final boolean is_compressed = in.readBoolean ();\n    byte array [] = readBytes (in);\n    if (array == null) return null;\n\n    if (! is_compressed) {\n        return array;\n    }\n    try {\n        ByteArrayInputStream bais = new ByteArrayInputStream (array);\n        GZIPInputStream gzin = new GZIPInputStream (bais);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream (array.length);\n        IOUtils.copyTo (gzin, baos);\n        gzin.close ();\n        bais.close ();\n        return baos.toByteArray ();\n    } catch (IOException err) {\n        throw new RuntimeException (err);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9639113, "method2_id": 23013746, "code1": "public static Object cut (Object obj, int size) {\n    int j;\n    if ((j = Array.getLength (obj)) == 1) {\n        return Array.newInstance (obj.getClass ().getComponentType (), 0);\n    }\n    int k;\n    if ((k = j - size - 1) > 0) {\n        System.arraycopy (obj, size + 1, obj, size, k);\n    }\n    j --;\n    Object obj1 = Array.newInstance (obj.getClass ().getComponentType (), j);\n    System.arraycopy (obj, 0, obj1, 0, j);\n    return obj1;\n}\n", "code2": "private static Object extendArray (Object a1) {\n    int n = Array.getLength (a1);\n    Object a2 = Array.newInstance (a1.getClass ().getComponentType (), n + ARRAY_SIZE_INCREMENT);\n    System.arraycopy (a1, 0, a2, 0, n);\n    return a2;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2731393, "method2_id": 2994956, "code1": "public static PositionTransformation loadFieldTransformator () {\n    PositionTransformation result = null;\n    String name = null;\n    if (Configuration.dimensions == 2) {\n        name = Configuration.guiPositionTransformation2D;\n    } else if (Configuration.dimensions == 3) {\n        name = Configuration.guiPositionTransformation3D;\n    } else {\n        Main.fatalError (\"The 'dimensions' field in the configuration file is invalid. Valid values are either '2' for 2D or '3' for 3D. (Cannot create corresponding position transformation instance.)\");\n    }\n\n    try {\n        Class < ? > c = Class.forName (name);\n        Constructor < ? > cons = c.getConstructor ();\n        result = (PositionTransformation) cons.newInstance ();\n    } catch (ClassNotFoundException e) {\n        Main.fatalError (\"Cannot find the class \" + name + \" which contains the implementation for the field transformation. Please check the guiPositionTransformation field in the config file.\");\n    } catch (SecurityException e) {\n        Main.fatalError (\"Cannot generate the field transformation object due to a security exception:\\n\\n\" + e.getMessage ());\n    } catch (NoSuchMethodException e) {\n        Main.fatalError (\"The field transformation \" + name + \" must provide a constructor taking no arguments.\\n\\n\" + e.getMessage ());\n    } catch (IllegalArgumentException e) {\n        Main.fatalError (\"The field transformation \" + name + \" must provide a constructor taking no arguments.\\n\\n\" + e.getMessage ());\n    } catch (InstantiationException e) {\n        Main.fatalError (\"Classes usable as field transformators must be instantiable classes, i.e. no interfaces and not abstract.\\n\\n\" + e.getMessage ());\n    } catch (IllegalAccessException e) {\n        Main.fatalError (\"Cannot generate the field transformator object due to illegal access:\\n\\n\" + e.getMessage ());\n    } catch (InvocationTargetException e) {\n        Main.fatalError (\"Exception while instanciating \" + name + \":\\n\\n\" + e.getCause ().getMessage ());\n    }\n    return result;\n}\n", "code2": "public static < T > T createConstantsInstance (Class < T > constantsClass, Locale locale) {\n    ImplKey key = new ImplKey (constantsClass.getName (), locale);\n    T result = (T) cache.get (key);\n    if (result != null) {\n        return result;\n    }\n    String ifaceName = constantsClass.getName ();\n    final ClassPool classPool = getClassPool ();\n    try {\n        CtClass iface = classPool.get (constantsClass.getName ());\n        CtClass baseConstantsImpl = classPool.get (BaseConstantsImpl.class.getName ());\n        CtClass stringClass = classPool.get (String.class.getName ());\n        CtClass impl = classPool.makeClass (ifaceName + \"Impl_\" + locale.toString (), baseConstantsImpl);\n        impl.addInterface (iface);\n        final CtClass resourceBundle = classPool.get (ResourceBundle.class.getName ());\n        CtField resField = new CtField (resourceBundle, \"res\", impl);\n        impl.addField (resField);\n        KeyGenerator keyGenerator = new MethodNameKeyGenerator ();\n        for (Object ann : iface.getAnnotations ()) {\n            if (ann instanceof GenerateKeys) {\n                String keyGeneratorClassName = ((GenerateKeys) ann).value ();\n                Class < KeyGenerator > keyGeneratorClass;\n                try {\n                    keyGeneratorClass = (Class < KeyGenerator >) Class.forName (keyGeneratorClassName);\n                } catch (ClassNotFoundException cnfe) {\n                    keyGeneratorClass = (Class < KeyGenerator >) Class.forName (KeyGenerator.class.getName () + \".\" + keyGeneratorClassName);\n                }\n                keyGenerator = keyGeneratorClass.newInstance ();\n            }\n        }\n        ResourceBundle resBundle = ResourceBundle.getBundle (ifaceName, locale);\n        for (CtMethod method : iface.getMethods ()) {\n            if ((method.getModifiers () & Modifier.ABSTRACT) == 0) continue;\n\n            String methodKey = null;\n            String meaning = null;\n            Object defaultValue = null;\n            for (Object ann : method.getAnnotations ()) {\n                if (ann instanceof Key) {\n                    methodKey = ((Key) ann).value ();\n                } else if (ann instanceof Meaning) {\n                    meaning = ((Meaning) ann).value ();\n                } else if (ann instanceof DefaultStringValue) {\n                    defaultValue = ((DefaultStringValue) ann).value ();\n                } else if (ann instanceof DefaultBooleanValue) {\n                    defaultValue = ((DefaultBooleanValue) ann).value ();\n                } else if (ann instanceof DefaultDoubleValue) {\n                    defaultValue = ((DefaultDoubleValue) ann).value ();\n                } else if (ann instanceof DefaultIntValue) {\n                    defaultValue = ((DefaultIntValue) ann).value ();\n                } else if (ann instanceof DefaultFloatValue) {\n                    defaultValue = ((DefaultFloatValue) ann).value ();\n                } else if (ann instanceof DefaultMessage) {\n                    defaultValue = ((DefaultMessage) ann).value ();\n                }\n\n            }\n            if (methodKey == null) {\n                methodKey = keyGenerator.generateKey (ifaceName, method.getName (), String.valueOf (defaultValue), meaning);\n            }\n            CtMethod methodImpl = new CtMethod (method, impl, null);\n            CtClass returnType = methodImpl.getReturnType ();\n            Initializer initializer;\n            String valueString;\n            try {\n                valueString = resBundle.getString (methodKey);\n            } catch (MissingResourceException mre) {\n                if (defaultValue != null) valueString = String.valueOf (defaultValue);\n                else throw mre;\n\n            }\n            if (returnType.isPrimitive ()) {\n                if (returnType.getSimpleName ().equals (\"int\")) initializer = CtField.Initializer.constant (Integer.parseInt (valueString));\n                else if (returnType.getSimpleName ().equals (\"float\")) initializer = CtField.Initializer.byExpr (Float.parseFloat (valueString) + \"f\");\n                else if (returnType.getSimpleName ().equals (\"double\")) initializer = CtField.Initializer.constant (Double.parseDouble (valueString));\n                else if (returnType.getSimpleName ().equals (\"boolean\")) initializer = CtField.Initializer.byExpr (String.valueOf (Boolean.parseBoolean (valueString)));\n                else throw new IllegalStateException (returnType + \" is not a supported primitive return type of a constant in \" + iface.getName ());\n\n            } else if (returnType.equals (stringClass)) {\n                initializer = CtField.Initializer.constant (valueString);\n            } else if (returnType.getSimpleName ().equals (\"Map\")) {\n                CtField keyField = new CtField (stringClass, method.getName ().toUpperCase (), impl);\n                keyField.setModifiers (Modifier.FINAL | Modifier.STATIC);\n                impl.addField (keyField, CtField.Initializer.constant (methodKey));\n                initializer = CtField.Initializer.byExpr (\"getMap(\" + keyField.getName () + \")\");\n            } else if (returnType.getSimpleName ().equals (\"String[]\")) {\n                CtField keyField = new CtField (stringClass, method.getName ().toUpperCase (), impl);\n                keyField.setModifiers (Modifier.FINAL | Modifier.STATIC);\n                impl.addField (keyField, CtField.Initializer.constant (methodKey));\n                initializer = CtField.Initializer.byExpr (\"getStringArray(\" + keyField.getName () + \")\");\n                returnType = classPool.get (String [].class.getName ());\n            } else throw new IllegalStateException (returnType + \" is not a supported return type of a constant in \" + iface.getName ());\n\n            CtField valueField = new CtField (returnType, method.getName (), impl);\n            impl.addField (valueField, initializer);\n            methodImpl.setModifiers (Modifier.PUBLIC);\n            methodImpl.setBody (\"return this.\" + valueField.getName () + \";\");\n            impl.addMethod (methodImpl);\n        }\n        CtConstructor ctor = new CtConstructor (new CtClass [] {resourceBundle}, impl);\n        ctor.setModifiers (Modifier.PUBLIC);\n        ctor.setExceptionTypes (new CtClass [] {classPool.get (MissingResourceException.class.getName ())});\n        impl.addConstructor (ctor);\n        ctor.setBody (\"super($1);\");\n        Class < T > implClass = impl.toClass ();\n        T instance = implClass.getConstructor (ResourceBundle.class).newInstance (resBundle);\n        cache.put (key, instance);\n        return instance;\n    } catch (NotFoundException e) {\n        throw new Error (e);\n    } catch (RuntimeException e) {\n        throw new Error (e);\n    } catch (CannotCompileException e) {\n        throw new Error (e);\n    } catch (InvocationTargetException e) {\n        throw new Error (e);\n    } catch (NoSuchMethodException e) {\n        throw new Error (e);\n    } catch (ClassNotFoundException e) {\n        throw new Error (e);\n    } catch (InstantiationException e) {\n        throw new Error (e);\n    } catch (IllegalAccessException e) {\n        throw new Error (e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 7861020, "method2_id": 13433127, "code1": "private void writeToFile (Body b, File mime4jFile) throws FileNotFoundException, IOException {\n    if (b instanceof TextBody) {\n        String charset = CharsetUtil.toJavaCharset (b.getParent ().getCharset ());\n        if (charset == null) {\n            charset = \"ISO8859-1\";\n        }\n        OutputStream out = new FileOutputStream (mime4jFile);\n        IOUtils.copy (((TextBody) b).getReader (), out, charset);\n    } else {\n        OutputStream out = new FileOutputStream (mime4jFile);\n        IOUtils.copy (((BinaryBody) b).getInputStream (), out);\n    }\n}\n", "code2": "public void save (File selectedFile) throws IOException {\n    if (storeEntriesInFiles) {\n        boolean moved = false;\n        for (int i = 0;\n        i < tempFiles.size (); i ++) {\n            File newFile = new File (selectedFile.getAbsolutePath () + \"_\" + Integer.toString (i) + \".zettmp\");\n            moved = tempFiles.get (i).renameTo (newFile);\n            if (! moved) {\n                BufferedReader read = new BufferedReader (new FileReader (tempFiles.get (i)));\n                PrintWriter write = new PrintWriter (newFile);\n                String s;\n                while ((s = read.readLine ()) != null) write.print (s);\n\n                read.close ();\n                write.flush ();\n                write.close ();\n                tempFiles.get (i).delete ();\n            }\n            tempFiles.set (i, newFile);\n        }\n    }\n    GZIPOutputStream output = new GZIPOutputStream (new BufferedOutputStream (new FileOutputStream (selectedFile)));\n    XStream xml_convert = new XStream ();\n    xml_convert.setMode (XStream.ID_REFERENCES);\n    xml_convert.toXML (this, output);\n    output.flush ();\n    output.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 21495886, "method2_id": 23677194, "code1": "private void zipFiles (File cpFile) {\n    int byteCount;\n    final int DATA_BLOCK_SIZE = 2048;\n    FileInputStream cpFileInputStream;\n    if (cpFile.isDirectory ()) {\n        if (cpFile.getName ().equalsIgnoreCase (\".metadata\")) {\n            return;\n        }\n        File [] fList = cpFile.listFiles ();\n        for (int i = 0;\n        i < fList.length; i ++) {\n            zipFiles (fList [i]);\n        }\n    } else {\n        try {\n            if (cpFile.getAbsolutePath ().equalsIgnoreCase (strTarget)) {\n                return;\n            }\n            System.out.println (\"Zipping \" + cpFile);\n            size += cpFile.length ();\n            numOfFiles ++;\n            String strAbsPath = cpFile.getPath ();\n            String strZipEntryName = strAbsPath.substring (strSource.length () + 1, strAbsPath.length ());\n            cpFileInputStream = new FileInputStream (cpFile);\n            ZipEntry cpZipEntry = new ZipEntry (strZipEntryName);\n            cpZipOutputStream.putNextEntry (cpZipEntry);\n            byte [] b = new byte [DATA_BLOCK_SIZE];\n            while ((byteCount = cpFileInputStream.read (b, 0, DATA_BLOCK_SIZE)) != - 1) {\n                cpZipOutputStream.write (b, 0, byteCount);\n            }\n            cpZipOutputStream.closeEntry ();\n        } catch (Exception e) {\n            e.printStackTrace ();\n        }\n    }\n}\n", "code2": "public static void ZipFiles (File zipfile, File [] files) throws IOException {\n    byte [] buffer = new byte [1024];\n    FileOutputStream fos = new FileOutputStream (zipfile);\n    ZipOutputStream zos = new ZipOutputStream (fos);\n    for (int i = 0;\n    i < files.length; i ++) {\n        File src = files [i];\n        FileInputStream fis = new FileInputStream (src);\n        ZipEntry entry = new ZipEntry (src.getName ());\n        zos.putNextEntry (entry);\n        int length;\n        while ((length = fis.read (buffer)) > 0) {\n            zos.write (buffer, 0, length);\n        }\n        zos.closeEntry ();\n        fis.close ();\n    }\n    zos.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 22768445, "method2_id": 23517481, "code1": "public static String hashNative (String password, String algorithm, String prefixKey, boolean useDefaultEncoding) {\n    try {\n        MessageDigest digest = MessageDigest.getInstance (algorithm);\n        if (useDefaultEncoding) {\n            digest.update (password.getBytes ());\n        } else {\n            for (char c : password.toCharArray ()) {\n                digest.update ((byte) (c>> 8));\n                digest.update ((byte) c);\n            }\n        }\n        byte [] digestedPassword = digest.digest ();\n        BASE64Encoder encoder = new BASE64Encoder ();\n        String encodedDigested = encoder.encode (digestedPassword);\n        return prefixKey + encodedDigested;\n    } catch (NoSuchAlgorithmException ne) {\n        return password;\n    }\n}\n", "code2": "private String md5 (String uri) throws ConnoteaRuntimeException {\n    try {\n        MessageDigest messageDigest = MessageDigest.getInstance (\"MD5\");\n        messageDigest.update (uri.getBytes ());\n        byte [] bytes = messageDigest.digest ();\n        StringBuffer stringBuffer = new StringBuffer ();\n        for (byte b : bytes) {\n            String hex = Integer.toHexString (0xff & b);\n            if (hex.length () == 1) {\n                stringBuffer.append ('0');\n            }\n            stringBuffer.append (hex);\n        }\n        return stringBuffer.toString ();\n    } catch (NoSuchAlgorithmException e) {\n        throw new ConnoteaRuntimeException (e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 324781, "method2_id": 570147, "code1": "public void run () {\n    try {\n        if (this.finished == false) {\n            Runtime runner = Runtime.getRuntime ();\n            process = runner.exec (command);\n            new ProcessInputReaderThread (process.getInputStream (), out);\n            new ProcessInputReaderThread (process.getErrorStream (), err);\n            exitCode = new Integer (process.waitFor ());\n        }\n    } catch (Exception e) {\n        err.append (\"Error running command.\\n\");\n        ByteArrayOutputStream ba = new ByteArrayOutputStream ();\n        PrintWriter errData = new PrintWriter (ba);\n        e.printStackTrace (errData);\n        errData.flush ();\n        err.append (ba.toString ());\n        e.printStackTrace ();\n    }\n    this.finished = true;\n}\n", "code2": "public static String executeBulkLoad (String command, String logLines, String timeout) {\n    String ls = System.getProperty (\"line.separator\");\n    long ptimeout = 0;\n    int numLines = 0;\n    try {\n        ptimeout = new Long (timeout).longValue ();\n        numLines = new Integer (logLines).intValue ();\n    } catch (NumberFormatException e) {\n        return \"The second and third parameters( number of lines and timeout ) need to be numbers. \" + ls + e.getMessage ();\n    }\n    if (ptimeout > 0) return executeBulkLoadWithTimeout (command, logLines, ptimeout);\n\n    Runtime rt = Runtime.getRuntime ();\n    long l1 = System.currentTimeMillis ();\n    Process p = null;\n    int retStatus = 0;\n    long millis = 0;\n    long secs = 0;\n    long min = 0;\n    long hours = 0;\n    LinkedList output = new LinkedList ();\n    LinkedList error = new LinkedList ();\n    try {\n        p = rt.exec (command);\n    } catch (IOException e) {\n        return \"Caught IOException while executing the command. Message = \" + ls + e.getMessage () + ls;\n    }\n    InputStream is = p.getInputStream ();\n    BufferedReader bf = new BufferedReader (new InputStreamReader (is));\n    InputStream is2 = p.getErrorStream ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (is2));\n    try {\n        output = getOutput (bf, numLines);\n        error = getError (br, numLines);\n    } catch (IOException e) {\n        return \"Caught IOException. Message = \" + ls + e.getMessage () + ls;\n    }\n    StringBuffer message = new StringBuffer ();\n    if (output.size () > 0) {\n        message.append (ls + \"OUTPUT:\" + ls);\n        for (Iterator iter = output.iterator ();\n        iter.hasNext ();) {\n            message.append ((String) iter.next () + ls);\n        }\n    }\n    if (error.size () > 0) {\n        message.append (\"ERRORS:\" + ls);\n        for (Iterator iter = error.iterator ();\n        iter.hasNext ();) {\n            message.append ((String) iter.next () + ls);\n        }\n    }\n    try {\n        retStatus = p.waitFor ();\n    } catch (InterruptedException e) {\n    }\n    try {\n        is.close ();\n        is2.close ();\n        bf.close ();\n        br.close ();\n    } catch (IOException e) {\n    }\n    long l2 = System.currentTimeMillis ();\n    millis = l2 - l1;\n    System.out.println (\"millis = \" + millis);\n    String time = new org.xaware.shared.util.ElapsedTimeConverter ().convertElapsedTime (millis);\n    message.append (ls + \"TIME TO EXECUTE: \" + time + \" (HH:MM:SS:MS) \" + ls);\n    return message.toString ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 15693314, "method2_id": 17413929, "code1": "private void load () {\n    File backFile = null;\n    ZipFile zipFile = null;\n    Enumeration zippedFiles = null;\n    ZipEntry currEntry = null;\n    ZipEntry entry = null;\n    try {\n        String oldName = archiveFile.toString () + \".bak\";\n        archiveFile.renameTo (new File (oldName));\n        backFile = new File (archiveFile.toString () + \".bak\");\n        zipFile = new ZipFile (backFile.getAbsolutePath ());\n        zippedFiles = zipFile.entries ();\n        out = new ZipOutputStream (new FileOutputStream (archiveFile));\n        long presentTime = Calendar.getInstance ().getTime ().getTime ();\n        out.setMethod (out.DEFLATED);\n        while (zippedFiles.hasMoreElements ()) {\n            currEntry = (ZipEntry) zippedFiles.nextElement ();\n            BufferedInputStream reader = new BufferedInputStream (zipFile.getInputStream (currEntry));\n            int b;\n            out.putNextEntry (new ZipEntry (currEntry.getName ()));\n            while ((b = reader.read ()) != - 1) out.write (b);\n\n            reader.close ();\n            out.flush ();\n            out.closeEntry ();\n        }\n        zipFile.close ();\n    } catch (Exception e) {\n        m_logCat.error (\"Cannot load zip file\", e);\n    }\n}\n", "code2": "private void writeZipFile (File f, ZipOutputStream zos, String hiberarchy) throws IOException {\n    if (f.exists ()) {\n        if (f.isDirectory ()) {\n            hiberarchy += f.getName () + \"/\";\n            File [] fif = f.listFiles ();\n            for (int i = 0;\n            i < fif.length; i ++) {\n                writeZipFile (fif [i], zos, hiberarchy);\n            }\n        } else {\n            FileInputStream fis = null;\n            fis = new FileInputStream (f);\n            ZipEntry ze = new ZipEntry (hiberarchy + f.getName ());\n            zos.putNextEntry (ze);\n            byte [] b = new byte [1024];\n            while (fis.read (b) != - 1) {\n                zos.write (b);\n                b = new byte [1024];\n            }\n            if (fis != null) fis.close ();\n\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4910110, "method2_id": 9449064, "code1": "public void test () throws Exception {\n    TranslationResponseStorage r = new TranslationResponseStorage (mockStorage, \"UTF-8\");\n    MockResponseStateObserver observer = new MockResponseStateObserver ();\n    r.addStateObserver (observer);\n    assertEquals (\"UTF-8\", r.getCharacterEncoding ());\n    assertEquals (- 1L, r.getLastModified ());\n    assertEquals (0, r.getTranslationCount ());\n    r.setTranslationCount (10);\n    assertEquals (10, r.getTranslationCount ());\n    assertNotNull (r.getHeadersStorage ());\n    assertNull (r.getHeaders ());\n    r.setLastModified (100000L);\n    assertEquals (100000L, r.getLastModified ());\n    assertFalse (r.getHeaders ().isEmpty ());\n    {\n        Set < ResponseHeader > set = new TreeSet < ResponseHeader > ();\n        set.add (new ResponseHeaderImpl (\"Last-Modified\", new String [] {DateUtil.formatDate (new Date (200000L))}));\n        r.addHeaders (set);\n    } assertEquals (1, r.getHeaders ().size ());\n    assertEquals (200000L, r.getLastModified ());\n    {\n        Set < ResponseHeader > set = new TreeSet < ResponseHeader > ();\n        set.add (new ResponseHeaderImpl (\"Last-Modified\", new String [] {DateUtil.formatDate (new Date (310000L))}));\n        set.add (new ResponseHeaderImpl (\"User-Agent\", new String [] {\"Pinoccio\"}));\n        r.addHeaders (set);\n    } assertEquals (2, r.getHeaders ().size ());\n    int ii = 0;\n    for (ResponseHeader h : r.getHeaders ()) {\n        ii ++;\n        if (ii == 1) {\n            assertEquals (\"Last-Modified\", h.getName ());\n            assertEquals (Arrays.toString (new String [] {DateUtil.formatDate (new Date (310000L))}), Arrays.toString (h.getValues ()));\n        } else if (ii == 2) {\n            assertEquals (\"User-Agent\", h.getName ());\n            assertEquals (Arrays.toString (new String [] {\"Pinoccio\"}), Arrays.toString (h.getValues ()));\n        }\n\n    }\n    r.addText (\"This is an example\");\n    r.addText (\" and another one.\");\n    assertEquals (\"This is an example and another one.\", mockStorage.getText ());\n    InputStream input = r.getInputStream ();\n    StringWriter writer = new StringWriter ();\n    try {\n        IOUtils.copy (input, writer, \"UTF-8\");\n    } finally {\n        input.close ();\n        writer.close ();\n    }\n    assertEquals (\"This is an example and another one.\", writer.toString ());\n    {\n        OutputStream output = r.getOutputStream ();\n        output.write (\" and another line\".getBytes (\"UTF-8\"));\n        assertEquals (\"This is an example and another one. and another line\", r.getText ());\n    } {\n        Writer output = r.getWriter ();\n        output.write (\" and write some more\");\n        assertEquals (\"This is an example and another one. and another line and write some more\", r.getText ());\n    } assertFalse (r.hasEnded ());\n    assertNull (r.getEndState ());\n    assertEquals (0L, observer.getHits ());\n    r.setEndState (ResponseStateOk.getInstance ());\n    assertEquals (ResponseStateOk.getInstance (), r.getEndState ());\n    assertTrue (r.hasEnded ());\n    assertEquals (1L, observer.getHits ());\n    try {\n        r.getOutputStream ();\n        fail (\"Previous line should throw IOException as result closed.\");\n    } catch (IOException e) {\n    }\n    try {\n        r.getWriter ();\n        fail (\"Previous line should throw IOException as result closed.\");\n    } catch (IOException e) {\n    }\n}\n", "code2": "public static void main (String [] args) {\n    try {\n        boolean readExp = Utils.getFlag ('l', args);\n        final boolean writeExp = Utils.getFlag ('s', args);\n        final String expFile = Utils.getOption ('f', args);\n        if ((readExp || writeExp) && (expFile.length () == 0)) {\n            throw new Exception (\"A filename must be given with the -f option\");\n        }\n        Experiment exp = null;\n        if (readExp) {\n            FileInputStream fi = new FileInputStream (expFile);\n            ObjectInputStream oi = new ObjectInputStream (new BufferedInputStream (fi));\n            exp = (Experiment) oi.readObject ();\n            oi.close ();\n        } else {\n            exp = new Experiment ();\n        }\n        System.err.println (\"Initial Experiment:\\n\" + exp.toString ());\n        final JFrame jf = new JFrame (\"Weka Experiment Setup\");\n        jf.getContentPane ().setLayout (new BorderLayout ());\n        final SetupPanel sp = new SetupPanel ();\n        jf.getContentPane ().add (sp, BorderLayout.CENTER);\n        jf.addWindowListener (new WindowAdapter () {\n            public void windowClosing (WindowEvent e) {\n                System.err.println (\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString ());\n                if (writeExp) {\n                    try {\n                        FileOutputStream fo = new FileOutputStream (expFile);\n                        ObjectOutputStream oo = new ObjectOutputStream (new BufferedOutputStream (fo));\n                        oo.writeObject (sp.m_Exp);\n                        oo.close ();\n                    } catch (Exception ex) {\n                        ex.printStackTrace ();\n                        System.err.println (\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage ());\n                    }\n                }\n                jf.dispose ();\n                System.exit (0);\n            }}\n\n        );\n        jf.pack ();\n        jf.setVisible (true);\n        System.err.println (\"Short nap\");\n        Thread.currentThread ().sleep (3000);\n        System.err.println (\"Done\");\n        sp.setExperiment (exp);\n    } catch (Exception ex) {\n        ex.printStackTrace ();\n        System.err.println (ex.getMessage ());\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 92552, "method2_id": 8070379, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "public RepeatStatus execute (StepContribution contribution, ChunkContext chunkContext) throws Exception {\n    ZipInputStream zis = new ZipInputStream (new BufferedInputStream (inputResource.getInputStream ()));\n    File targetDirectoryAsFile = new File (targetDirectory);\n    if (! targetDirectoryAsFile.exists ()) {\n        FileUtils.forceMkdir (targetDirectoryAsFile);\n    }\n    File target = new File (targetDirectory, targetFile);\n    BufferedOutputStream dest = null;\n    while (zis.getNextEntry () != null) {\n        if (! target.exists ()) {\n            target.createNewFile ();\n        }\n        FileOutputStream fos = new FileOutputStream (target);\n        dest = new BufferedOutputStream (fos);\n        IOUtils.copy (zis, dest);\n        dest.flush ();\n        dest.close ();\n    }\n    zis.close ();\n    if (! target.exists ()) {\n        throw new IllegalStateException (\"Could not decompress anything from the archive!\");\n    }\n    return RepeatStatus.FINISHED;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6501291, "method2_id": 11840745, "code1": "public static void extractFile (String input, String output) throws ZipException, IOException {\n    FileReader reader = new FileReader (input);\n    InputStream in = reader.getInputStream ();\n    OutputStream out = new FileOutputStream (new File (output));\n    byte [] buf = new byte [512];\n    int len;\n    while ((len = in.read (buf)) > 0) out.write (buf, 0, len);\n\n    reader.close ();\n    out.close ();\n}\n", "code2": "public final void close () throws IOException {\n    if (dataStream == null) throw new NullPointerException (\"Write stream is null.\");\n\n    dataStream.flush ();\n    dataStream.close ();\n    dataStream = null;\n    File tmpFile = new File (packPath + \".tmp\");\n    FileOutputStream packStream = new FileOutputStream (packPath);\n    try {\n        String nbFiles = Long.toString (currentNbFiles) + \"\\0\";\n        packStream.write (FLAT_PACK_HEADER.getBytes (Charsets.ISO_8859_1));\n        structBufferWriter.flush ();\n        structBufferWriter.close ();\n        int headerSize = structBuffer.size () + nbFiles.length ();\n        packStream.write (Integer.toString (headerSize).getBytes (Charsets.ISO_8859_1));\n        packStream.write ('\\0');\n        packStream.write (nbFiles.getBytes (Charsets.ISO_8859_1));\n        structBuffer.writeTo (packStream);\n        structBufferWriter = null;\n        structBuffer = null;\n        FileInputStream in = new FileInputStream (tmpFile);\n        try {\n            byte [] buffer = new byte [FILE_COPY_BUFFER_LEN];\n            int read;\n            while ((read = in.read (buffer)) > 0) packStream.write (buffer, 0, read);\n\n            packStream.flush ();\n            packStream.close ();\n        } finally {\n            Utilities.closeStream (in);\n        }\n    } finally {\n        Utilities.closeStream (packStream);\n    }\n    if (tmpFile.isFile ()) Utilities.deleteFile (tmpFile);\n\n    packPath = null;\n    structBuffer = null;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9233950, "method2_id": 16954340, "code1": "public static void copyFile (File src, File dest) throws IOException {\n    if (! src.exists ()) throw new IOException (\"File not found '\" + src.getAbsolutePath () + \"'\");\n\n    BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n    BufferedInputStream in = new BufferedInputStream (new FileInputStream (src));\n    byte [] read = new byte [128];\n    int len = 128;\n    while ((len = in.read (read)) > 0) out.write (read, 0, len);\n\n    out.flush ();\n    out.close ();\n    in.close ();\n}\n", "code2": "public static boolean copyFile (String sourceFileName, String destFileName) {\n    if (sourceFileName == null || destFileName == null) return false;\n\n    if (sourceFileName.equals (destFileName)) return false;\n\n    try {\n        java.io.FileInputStream in = new java.io.FileInputStream (sourceFileName);\n        java.io.FileOutputStream out = new java.io.FileOutputStream (destFileName);\n        try {\n            byte [] buf = new byte [31000];\n            int read = in.read (buf);\n            while (read > - 1) {\n                out.write (buf, 0, read);\n                read = in.read (buf);\n            }\n        } finally {\n            in.close ();\n            out.close ();\n        }\n    } catch (Exception e) {\n        System.out.println (e.toString ());\n        return false;\n    }\n    return true;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8035822, "method2_id": 17551409, "code1": "private File generateZip (Preference preference, File xml, List < Document > documents) {\n    File zfile = new File (preference.getStoreLocation () + File.separator + AppConstants.DMS_ZIPFILE);\n    try {\n        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zfile));\n        FileInputStream in = new FileInputStream (xml);\n        out.putNextEntry (new ZipEntry (xml.getName ()));\n        int len;\n        byte [] buf = new byte [1024];\n        while ((len = in.read (buf)) > 0) {\n            out.write (buf, 0, len);\n        }\n        out.closeEntry ();\n        in.close ();\n        for (Iterator < Document > iter = documents.iterator ();\n        iter.hasNext ();) {\n            Document document = iter.next ();\n            in = new FileInputStream (preference.getStoreLocation () + File.separator + document.getName ());\n            out.putNextEntry (new ZipEntry (document.getName ()));\n            len = 0;\n            while ((len = in.read (buf)) > 0) {\n                out.write (buf, 0, len);\n            }\n            out.closeEntry ();\n            in.close ();\n        }\n        out.close ();\n    } catch (Exception e) {\n        e.printStackTrace ();\n        zfile = null;\n    }\n    return zfile;\n}\n", "code2": "public static void addStringToZip (String text, String entryName, ZipOutputStream zOut) throws IOException {\n    BufferedReader reader = new BufferedReader (new StringReader (text));\n    ZipEntry zipEntry = new ZipEntry (entryName);\n    zOut.putNextEntry (zipEntry);\n    int i;\n    while ((i = reader.read ()) != - 1) {\n        zOut.write (i);\n    }\n    zOut.closeEntry ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 7580227, "method2_id": 15595626, "code1": "public static void main (String args []) {\n    try {\n        DataFrame df = ImportData.importXLS (\"G:/Recerca/EIO_RECERCA/New CoDaPack/Halimba.xls\", true);\n        String [] names = new String [3];\n        names [0] = df.getName (0);\n        names [1] = df.getName (1);\n        names [2] = df.getName (2);\n        double [] [] data = new double [3] [];\n        data [0] = df.getNumericalData (names [0]);\n        data [1] = df.getNumericalData (names [1]);\n        data [2] = df.getNumericalData (names [2]);\n        int size = data [0].length;\n        TernaryPlot2dWindow frame = new TernaryPlot2dWindow (df, new TernaryPlot2dBuilder (names, data).build (), \"TEST\");\n        frame.setSize (600, 600);\n        frame.setVisible (true);\n        double cdata [] [] = new double [3] [size];\n        for (int i = 0;\n        i < size; i ++) {\n            for (int j = 0;\n            j < 3; j ++) {\n                cdata [j] [i] = Math.log (data [j] [i]);\n            }\n        }\n        double mean [] = {0, 0, 0};\n        double cov [] [] = new double [3] [3];\n        for (int j = 0;\n        j < 3; j ++) {\n            for (int k = 0;\n            k < size; k ++) {\n                mean [j] += cdata [j] [k];\n            }\n            mean [j] /= size;\n        }\n        for (int j = 0;\n        j < 3; j ++) {\n            for (int i = j;\n            i < 3; i ++) {\n                cov [i] [j] = 0;\n                for (int k = 0;\n                k < size; k ++) {\n                    cov [i] [j] += (cdata [i] [k] - mean [i]) * (cdata [j] [k] - mean [j]);\n                }\n                cov [i] [j] /= size;\n                cov [j] [i] = cov [i] [j];\n            }\n        }\n        printMatrix (cov);\n        Composition [] new_data = new Composition [SIZE];\n        int windows = 1;\n        for (int w = 0;\n        w < windows; w ++) {\n            for (int i = 0;\n            i < SIZE; i ++) new_data [i] = random.nextGaussianBasis (mean, cov);\n\n            TernaryPlotWindow frame2 = new TernaryPlotWindow (df, new TernaryPlotBuilder (names, new_data).build (), \"TEST\");\n            frame2.setSize (600, 600);\n            frame2.setVisible (true);\n        }\n    } catch (FileNotFoundException ex) {\n        Logger.getLogger (testAdjustNormalDistribution.class.getName ()).log (Level.SEVERE, null, ex);\n    } catch (IOException ex) {\n        Logger.getLogger (testAdjustNormalDistribution.class.getName ()).log (Level.SEVERE, null, ex);\n    } catch (InvalidFormatException ex) {\n        Logger.getLogger (testAdjustNormalDistribution.class.getName ()).log (Level.SEVERE, null, ex);\n    }\n}\n", "code2": "public Matrix Transpose () {\n    float [] [] a = this.matrix;\n    if (INFO) {\n        System.out.println (\"Performing Transpose...\");\n    }\n    float m [] [] = new float [a [0].length] [a.length];\n    for (int i = 0;\n    i < a.length; i ++) for (int j = 0;\n    j < a [i].length; j ++) m [j] [i] = a [i] [j];\n\n    return new Matrix (m);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 647224, "method2_id": 12119068, "code1": "public void uploadFile (File inputFile, String targetFile) throws IOException {\n    System.out.println (\"Uploading \" + inputFile.getName () + \" to \" + targetFile);\n    File outputFile = new File (targetFile);\n    if (targetFile.endsWith (\"/\")) {\n        outputFile = new File (outputFile, inputFile.getName ());\n    } else if (outputFile.getParentFile ().exists () == false) {\n        outputFile.getParentFile ().mkdirs ();\n    }\n\n    if (inputFile.renameTo (outputFile) == false) {\n        InputStream in = new FileInputStream (inputFile);\n        OutputStream out = new FileOutputStream (outputFile);\n        byte [] line = new byte [16384];\n        int bytes = - 1;\n        while ((bytes = in.read (line)) != - 1) out.write (line, 0, bytes);\n\n        in.close ();\n        out.close ();\n    }\n}\n", "code2": "public String drive () {\n    logger.info (\"\\n\");\n    logger.info (\"===========================================================\");\n    logger.info (\"========== Start drive method =============================\");\n    logger.info (\"===========================================================\");\n    logger.entering (cl, \"drive\");\n    xstream = new XStream (new JsonHierarchicalStreamDriver ());\n    xstream.setMode (XStream.NO_REFERENCES);\n    xstream.alias (\"AuditDiffFacade\", AuditDiffFacade.class);\n    File auditSchemaFile = null;\n    File auditSchemaXsdFile = null;\n    try {\n        if (configFile == null) {\n            logger.severe (\"Request Failed: configFile is null\");\n            return null;\n        } else {\n            if (configFile.getAuditSchemaFile () != null) {\n                logger.info (\"auditSchemaFile=\" + configFile.getAuditSchemaFile ());\n                logger.info (\"auditSchemaXsdFile=\" + configFile.getAuditSchemaXsdFile ());\n                logger.info (\"plnXpathFile=\" + configFile.getPlnXpathFile ());\n                logger.info (\"auditSchemaFileDir=\" + configFile.getAuditSchemaFileDir ());\n                logger.info (\"auditReportFile=\" + configFile.getAuditReportFile ());\n                logger.info (\"auditReportXsdFile=\" + configFile.getAuditReportXsdFile ());\n            } else {\n                logger.severe (\"Request Failed: auditSchemaFile is null\");\n                return null;\n            }\n        }\n        File test = new File (configFile.getAuditSchemaFileDir () + File.separator + \"temp.xml\");\n        auditSchemaFile = new File (configFile.getAuditSchemaFile ());\n        if (! auditSchemaFile.exists () || auditSchemaFile.length () == 0L) {\n            logger.severe (\"Request Failed: the audit schema file does not exist or empty\");\n            return null;\n        }\n        auditSchemaXsdFile = null;\n        if (configFile.getAuditSchemaXsdFile () != null) {\n            auditSchemaXsdFile = new File (configFile.getAuditSchemaXsdFile ());\n        } else {\n            logger.severe (\"Request Failed: the audit schema xsd file is null\");\n            return null;\n        }\n        if (! auditSchemaXsdFile.exists () || auditSchemaXsdFile.length () == 0L) {\n            logger.severe (\"Request Failed: the audit schema xsd file does not exist or empty\");\n            return null;\n        }\n        SchemaFactory factory = SchemaFactory.newInstance (XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        Schema schema = factory.newSchema (auditSchemaXsdFile);\n        Validator validator = schema.newValidator ();\n        Source source = new StreamSource (auditSchemaFile);\n        validator.validate (source);\n    } catch (SAXException e) {\n        logger.warning (\"SAXException caught trying to validate input Schema Files: \");\n        e.printStackTrace ();\n    } catch (IOException e) {\n        logger.warning (\"IOException caught trying to read input Schema File: \");\n        e.printStackTrace ();\n    }\n    String xPathFile = null;\n    if (configFile.getPlnXpathFile () != null) {\n        xPathFile = configFile.getPlnXpathFile ();\n        logger.info (\"Attempting to retrieve xpaths from file: '\" + xPathFile + \"'\");\n        XpathUtility.readFile (xPathFile);\n    } else {\n        logger.severe (\"Configuration file does not have a value for the Xpath Filename\");\n        return null;\n    }\n    Properties xpathProps = XpathUtility.getXpathsProps ();\n    if (xpathProps == null) {\n        logger.severe (\"No Xpaths could be extracted from file: '\" + xPathFile + \"' - xpath properties object is null\");\n        return null;\n    }\n    if (xpathProps.isEmpty ()) {\n        logger.severe (\"No Xpaths could be extracted from file: '\" + xPathFile + \"' - xpath properties object is empty\");\n        return null;\n    }\n    logger.info (xpathProps.size () + \" xpaths retrieved.\");\n    for (String key : xpathProps.stringPropertyNames ()) {\n        logger.info (\"Key=\" + key + \"   Value=\" + xpathProps.getProperty (key));\n    }\n    logger.info (\"\\n\");\n    logger.info (\"===========================================================\");\n    logger.info (\"========== Process XML Schema File BEGIN ==================\");\n    logger.info (\"===========================================================\");\n    SchemaSAXReader sax = new SchemaSAXReader ();\n    ArrayList < String > key_matches = new ArrayList < String > (sax.parseDocument (auditSchemaFile, xpathProps));\n    logger.info (\"Check Input xpath hash against xpaths found in Schema.\");\n    Comparison comp_keys = new Comparison ();\n    ArrayList < String > in_xpath_not_in_schema = new ArrayList < String > (comp_keys.keys_not_in_both_hashes (xpathProps, Utility.arraylist_to_map (key_matches, \"key_matches\"), \"xpath Properties\", \"hm_key_matches\"));\n    if (in_xpath_not_in_schema.size () > 0) {\n        logger.severe (\"All XPaths in Input xpath Properties list were not found in Schema.\");\n        logger.severe (\"Xpaths in xpath Properties list missing from schema file:\" + xstream.toXML (in_xpath_not_in_schema));\n        logger.severe (\"Quitting.\");\n        return null;\n    }\n    Map < String, Map > schema_audit_hashbox = sax.get_audit_hashbox ();\n    logger.info (\"schema_audit_hashbox\\n\" + xstream.toXML (schema_audit_hashbox));\n    Map < String, Map > schema_network_hashbox = sax.get_net_hashbox ();\n    logger.info (\"schema_network_hashbox\\n\" + xstream.toXML (schema_network_hashbox));\n    Map < String, Map > schema_host_hashbox = sax.get_host_hashbox ();\n    Map < String, Map > schema_au_hashbox = sax.get_au_hashbox ();\n    logger.info (\"schema_au_hashbox\\n\" + xstream.toXML (schema_au_hashbox));\n    Hasherator hr = new Hasherator ();\n    Set < String > s_host_hb_additions = new HashSet < String > ();\n    s_host_hb_additions.add (\"/SSP/network/@network_id\");\n    schema_host_hashbox = hr.copy_hashbox_entries (schema_network_hashbox, schema_host_hashbox, s_host_hb_additions);\n    logger.info (\"schema_host_hashbox(after adding network name)\\n\" + xstream.toXML (schema_host_hashbox));\n    Map < String, String > transforms_s_au_hb = new HashMap < String, String > ();\n    transforms_s_au_hb.put (\"/SSP/archivalUnits/au/auCapabilities/storageRequired/@max_size\", \"s_gigabytes_to_string_bytes_unformatted()\");\n    schema_au_hashbox = hr.convert_hashbox_vals (schema_au_hashbox, transforms_s_au_hb);\n    Map < String, String > transforms_s_host_hb = new HashMap < String, String > ();\n    transforms_s_host_hb.put (\"/SSP/hosts/host/hostCapabilities/storageAvailable/@max_size\", \"s_gigabytes_to_string_bytes_unformatted()\");\n    schema_host_hashbox = hr.convert_hashbox_vals (schema_host_hashbox, transforms_s_host_hb);\n    logger.info (\"schema_host_hashbox(after transformations)\\n\" + xstream.toXML (schema_host_hashbox));\n    logger.info (\"\\n\");\n    logger.info (\"========== Process Schema  END ============================\");\n    logger.info (\"\\n\");\n    logger.info (\"========== Database Operations ============================\");\n    MYSQLWorkPlnHostSummaryDAO daowphs = new MYSQLWorkPlnHostSummaryDAO ();\n    daowphs.drop ();\n    daowphs.create ();\n    daowphs.updateTimestamp ();\n    CachedRowSet rs_q0_N = daowphs.query_0_N ();\n    double d_space_total = DBUtil.get_single_db_double_value (rs_q0_N, \"net_sum_repo_size\");\n    double d_space_used = DBUtil.get_single_db_double_value (rs_q0_N, \"net_sum_used_space\");\n    double d_space_free = d_space_total - d_space_used;\n    double d_avg_uptime = DBUtil.get_single_db_double_value (rs_q0_N, \"net_avg_uptime\");\n    long space_total = (long) d_space_total;\n    long space_used = (long) d_space_used;\n    long space_free = space_total - space_used;\n    String f_space_total = Utility.l_bytes_to_other_units_formatted (space_total, 3, \"T\");\n    String f_space_used = Utility.l_bytes_to_other_units_formatted (space_used, 3, \"G\");\n    String f_space_free = Utility.l_bytes_to_other_units_formatted (space_free, 3, \"T\");\n    String f_space_free2 = Utility.l_bytes_to_other_units_formatted (space_free, 3, null);\n    logger.info (\"d_space_total: \" + d_space_total + \"\\n\" + \"d_space_used: \" + d_space_used + \"\\n\" + \"space_total: \" + space_total + \"\\n\" + \"space_used: \" + space_used + \"\\n\" + \"space_free: \" + space_free + \"\\n\\n\" + \"Double.toString( d_space_total ): \" + Double.toString (d_space_total) + \"\\n\\n\" + \"f_space_total: \" + f_space_total + \"\\n\" + \"f_space_used: \" + f_space_used + \"\\n\" + \"f_space_free: \" + f_space_free + \"\\n\" + \"f_space_free2: \" + f_space_free2);\n    rprtCnst = new ReportData ();\n    logger.info (\"\\n\");\n    logger.info (\"========== Load Report Constants from Calculations ===========\");\n    rprtCnst.addKV (\"REPORT_HOSTS_TOTAL_DISKSPACE\", f_space_total);\n    rprtCnst.addKV (\"REPORT_HOSTS_TOTAL_DISKSPACE_USED\", f_space_used);\n    rprtCnst.addKV (\"REPORT_HOSTS_TOTAL_DISKSPACE_FREE\", f_space_free);\n    rprtCnst.addKV (\"REPORT_HOSTS_MEAN_UPTIME\", Utility.ms_to_dd_hh_mm_ss_formatted ((long) d_avg_uptime));\n    logger.info (\"r=\\n\" + rprtCnst.toString ());\n    logger.info (\"\\n\");\n    logger.info (\"========== Load Report Constants from ConfigFile =============\");\n    rprtCnst.addKV (\"REPORT_FILENAME_SCHEMA_FILENAME\", configFile.getAuditSchemaFile ());\n    rprtCnst.addKV (\"REPORT_FILENAME_SCHEMA_FILE_XSD_FILENAME\", configFile.getAuditSchemaXsdFile ());\n    rprtCnst.addKV (\"REPORT_FILENAME_XML_DIFF_FILENAME\", configFile.getAuditReportFile ());\n    rprtCnst.addKV (\"REPORT_FILENAME_XML_DIFF_FILE_XSD_FILENAME\", configFile.getAuditReportXsdFile ());\n    logger.info (\"\\n\");\n    logger.info (\"========== Load Report Constants from Hashboxes ==============\");\n    Set auditHBKeySet = hr.getMapKeyset (schema_audit_hashbox, \"schema_audit_hashbox\");\n    String audit_id = hr.singleKeysetEntryToString (auditHBKeySet);\n    logger.info (\"audit_id: \" + audit_id);\n    Set networkHBKeySet = hr.getMapKeyset (schema_network_hashbox, \"schema_network_hashbox\");\n    String network_id = hr.singleKeysetEntryToString (networkHBKeySet);\n    logger.info (\"network_id: \" + network_id);\n    rprtCnst.addKV (\"REPORT_AUDIT_ID\", audit_id);\n    rprtCnst.addKV (\"REPORT_AUDIT_REPORT_EMAIL\", hr.extractSingleValueFromHashbox (schema_audit_hashbox, \"schema_audit_hashbox\", audit_id, \"/SSP/audit/auditReportEmail\"));\n    rprtCnst.addKV (\"REPORT_AUDIT_INTERVAL\", hr.extractSingleValueFromHashbox (schema_audit_hashbox, \"schema_audit_hashbox\", audit_id, \"/SSP/audit/auditReportInterval/@maxDays\"));\n    rprtCnst.addKV (\"REPORT_SCHEMA_VERSION\", hr.extractSingleValueFromHashbox (schema_audit_hashbox, \"schema_audit_hashbox\", audit_id, \"/SSP/audit/schemaVersion\"));\n    rprtCnst.addKV (\"REPORT_CLASSIFICATION_GEOGRAPHIC_SUMMARY_SCHEME\", hr.extractSingleValueFromHashbox (schema_audit_hashbox, \"schema_audit_hashbox\", audit_id, \"/SSP/audit/geographicSummaryScheme\"));\n    rprtCnst.addKV (\"REPORT_CLASSIFICATION_SUBJECT_SUMMARY_SCHEME\", hr.extractSingleValueFromHashbox (schema_audit_hashbox, \"schema_audit_hashbox\", audit_id, \"/SSP/audit/subjectSummaryScheme\"));\n    rprtCnst.addKV (\"REPORT_CLASSIFICATION_OWNER_INSTITUTION_SUMMARY_SCHEME\", hr.extractSingleValueFromHashbox (schema_audit_hashbox, \"schema_audit_hashbox\", audit_id, \"/SSP/audit/ownerInstSummaryScheme\"));\n    rprtCnst.addKV (\"REPORT_NETWORK_ID\", network_id);\n    rprtCnst.addKV (\"REPORT_NETWORK_ADMIN_EMAIL\", hr.extractSingleValueFromHashbox (schema_network_hashbox, \"schema_network_hashbox\", network_id, \"/SSP/network/networkIdentity/accessBase/@adminEmail\"));\n    rprtCnst.addKV (\"REPORT_GEOGRAPHIC_CODING\", hr.extractSingleValueFromHashbox (schema_network_hashbox, \"schema_network_hashbox\", network_id, \"/SSP/network/networkIdentity/geographicCoding\"));\n    logger.info (\"\\n\");\n    logger.info (\"===========================================================\");\n    logger.info (\"========== Process Network Data BEGIN======================\");\n    logger.info (\"===========================================================\");\n    Set < String > tableSet0 = reportAuOverviewFacade.findAllTables ();\n    String reportAuOverviewTable = \"report_au_overview\";\n    int n_tabs = 0;\n    if (tableSet0 != null && ! tableSet0.isEmpty ()) {\n        logger.fine (\"Table List N=\" + tableSet0.size ());\n        for (String tableName : tableSet0) {\n            n_tabs ++;\n            if (tableName.equalsIgnoreCase (reportAuOverviewTable)) {\n                logger.fine (n_tabs + \" \" + tableName + \" <--\");\n            } else {\n                logger.fine (n_tabs + \" \" + tableName);\n            }\n        }\n    } else {\n        logger.fine (\"No tables found in DB.\");\n    }\n    if (! tableSet0.contains (reportAuOverviewTable)) {\n        logger.info (\"Database does not contain table '\" + reportAuOverviewTable + \"'\");\n    }\n    List < ReportAuOverview > repAuOvTabAllData = null;\n    repAuOvTabAllData = reportAuOverviewFacade.findAll ();\n    if (repAuOvTabAllData != null && ! (repAuOvTabAllData.isEmpty ())) {\n        logger.fine (\"\\n\" + reportAuOverviewTable + \" table has \" + repAuOvTabAllData.size () + \" rows.\");\n        int n_rows = 0;\n        for (ReportAuOverview row : repAuOvTabAllData) {\n            n_rows ++;\n            logger.fine (n_rows + \" \" + row.toString ());\n        }\n    } else {\n        logger.fine (reportAuOverviewTable + \" is null, empty, or nonexistent.\");\n    }\n    logger.fine (\"report_au_overview Table xstream Dump:\\n\" + xstream.toXML (repAuOvTabAllData));\n    logger.fine (\"\\n\");\n    logger.fine (\"Iterate over repAuOvTabAllData 2\");\n    Iterator it = repAuOvTabAllData.iterator ();\n    int n_el = 0;\n    while (it.hasNext ()) {\n        ++ n_el;\n        String el = it.next ().toString ();\n        logger.fine (n_el + \". \" + el);\n    }\n    Class aClass = edu.harvard.iq.safe.saasystem.entities.ReportAuOverview.class;\n    String reportAuOverviewTableName = reportAuOverviewFacade.getTableName ();\n    logger.fine (\"\\n\");\n    logger.fine (\"EntityManager Tests\");\n    logger.fine (\"Table: \" + reportAuOverviewTableName);\n    logger.fine (\"\\n\");\n    logger.fine (\"Schema: \" + reportAuOverviewFacade.getSchema ());\n    logger.fine (\"\\n\");\n    Set columnList = reportAuOverviewFacade.getColumnList (reportAuOverviewFacade.getTableName ());\n    logger.fine (\"Columns (fields) in table '\" + reportAuOverviewTableName + \"' (N=\" + columnList.size () + \")\");\n    Set < String > colList = new HashSet ();\n    Iterator colNames = columnList.iterator ();\n    int n_el2 = 0;\n    while (colNames.hasNext ()) {\n        ++ n_el2;\n        String el = colNames.next ().toString ();\n        logger.fine (n_el2 + \". \" + el);\n        colList.add (el);\n    }\n    logger.fine (colList.size () + \" entries in Set 'colList' \");\n    logger.info (\"========== Query 'au_overview_table'=============\");\n    MySQLAuOverviewDAO daoao = new MySQLAuOverviewDAO ();\n    CachedRowSet rs_q1_A = daoao.query_q1_A ();\n    int [] au_table_rc = DBUtil.get_rs_dims (rs_q1_A);\n    logger.info (\"Au Table Query ResultSet has \" + au_table_rc [0] + \" rows and \" + au_table_rc [1] + \" columns.\");\n    rprtCnst.addKV (\"REPORT_N_AUS_IN_NETWORK\", Integer.toString (au_table_rc [0]));\n    logger.info (\"========== Create 'network_au_hashbox' ==========\");\n    Map < String, Map > network_au_hashbox = new TreeMap < String, Map > (DBUtil.rs_to_hashbox (rs_q1_A, null, \"au_id\"));\n    logger.info (\"network_au_hashbox before transformations\\n\" + xstream.toXML (network_au_hashbox));\n    Map < String, String > transforms_n_au_hb = new HashMap < String, String > ();\n    transforms_n_au_hb.put (\"last_s_crawl_end\", \"ms_to_decimal_days_elapsed()\");\n    transforms_n_au_hb.put (\"last_s_poll_end\", \"ms_to_decimal_days_elapsed()\");\n    transforms_n_au_hb.put (\"crawl_duration\", \"ms_to_decimal_days()\");\n    network_au_hashbox = hr.convert_hashbox_vals (network_au_hashbox, transforms_n_au_hb);\n    Map < String, String > auNVerifiedRegions = reportAuOverviewFacade.getAuNVerifiedRegions ();\n    logger.fine (\"auNVerifiedRegions\\n\" + xstream.toXML (auNVerifiedRegions));\n    network_au_hashbox = hr.addNewInnerHashEntriesToHashbox (network_au_hashbox, auNVerifiedRegions, \"au_n_verified_regions\");\n    logger.info (\"network_au_hashbox after Transformations and Addition of 'au_n_verified_regions'\" + xstream.toXML (network_au_hashbox));\n    logger.info (\"========== Compare AUs BEGIN ==============================\");\n    ArrayList < String > al_aus_in_schema_not_in_network = new ArrayList < String > (comp_keys.keys_not_in_both_hashes (schema_au_hashbox, network_au_hashbox, \"schema_aus\", \"network_aus\"));\n    Map < String, String > h_aus_in_schema_not_in_network = hr.get_names_from_id_list (schema_au_hashbox, al_aus_in_schema_not_in_network, \"/SSP/archivalUnits/au/auIdentity/name\");\n    rprtCnst.addKV (\"REPORT_N_AUS_IN_SCHEMA_NOT_IN_NETWORK\", Integer.toString (al_aus_in_schema_not_in_network.size ()));\n    rprtCnst.set_h_aus_in_schema_not_in_network (h_aus_in_schema_not_in_network);\n    MYSQLReportAusInSchemaNotInNetworkDAO daoraisnin = new MYSQLReportAusInSchemaNotInNetworkDAO ();\n    daoraisnin.create ();\n    daoraisnin.update (h_aus_in_schema_not_in_network);\n    ArrayList < String > al_aus_in_network_not_in_schema = new ArrayList < String > (comp_keys.keys_not_in_both_hashes (network_au_hashbox, schema_au_hashbox, \"network_aus\", \"schema_aus\"));\n    Utility.print_arraylist (al_aus_in_network_not_in_schema, \"aus in_network_not_in_schema\");\n    Map < String, String > h_aus_in_network_not_in_schema = hr.get_names_from_id_list (network_au_hashbox, al_aus_in_network_not_in_schema, \"au_name\");\n    rprtCnst.addKV (\"REPORT_N_AUS_IN_NETWORK_NOT_IN_SCHEMA\", Integer.toString (al_aus_in_network_not_in_schema.size ()));\n    rprtCnst.set_h_aus_in_network_not_in_schema (h_aus_in_network_not_in_schema);\n    MYSQLReportAusInNetworkNotInSchemaDAO daorainnis = new MYSQLReportAusInNetworkNotInSchemaDAO ();\n    daorainnis.create ();\n    daorainnis.update (h_aus_in_network_not_in_schema);\n    Comparison comp_au = new Comparison (schema_au_hashbox, \"Schema_AU\", network_au_hashbox, \"Network_AU\", XpathUtility.getXpathToDbColumnMap (), XpathUtility.getXpathToCompOpMap ());\n    comp_au.init ();\n    logger.info (\"Attempting to create DB table 'lockss_audit.audit_results_au'\");\n    MYSQLAuditResultsAuDAO daoara = new MYSQLAuditResultsAuDAO ();\n    daoara.create ();\n    String results_table_au = \"audit_results_au\";\n    String sql_vals_au_schema = comp_au.iterate_hbs_au (daoara, results_table_au, \"au\", h_aus_in_network_not_in_schema);\n    CachedRowSet rs_RA2 = daoara.query_q1_RA ();\n    String n_aus_not_verified = DBUtil.get_single_count_from_rs (rs_RA2);\n    rprtCnst.addKV (\"REPORT_N_AUS_NOT_VERIFIED\", DBUtil.get_single_count_from_rs (rs_RA2));\n    logger.info (\"\\nInstantiating Result Class from main()\");\n    DiffResult result = new DiffResult ();\n    Map au_comp_host = result.get_result_hash (\"au\");\n    logger.info (\"========== Compare AUs END ================================\");\n    logger.info (\"========== Process Network Host Table =====================\");\n    logger.info (\"========== Query 'lockss_box_table' and =========\");\n    logger.info (\"================ 'repository_space_table' =======\\n\");\n    MySQLLockssBoxRepositorySpaceDAO daolbrs = new MySQLLockssBoxRepositorySpaceDAO ();\n    CachedRowSet rs_q1_H = daolbrs.query_q1_H ();\n    int [] host_table_rc = DBUtil.get_rs_dims (rs_q1_H);\n    logger.info (\"Host Table Query ResultSet has \" + host_table_rc [0] + \" rows and \" + host_table_rc [1] + \" columns.\");\n    rprtCnst.addKV (\"REPORT_N_HOSTS_IN_NETWORK\", Integer.toString (host_table_rc [0]));\n    Long numberOfMemberHosts;\n    if (StringUtils.isNotBlank (saasConfigurationRegistry.getSaasConfigProperties ().getProperty (\"saas.ip.fromlockssxml\"))) {\n        numberOfMemberHosts = Long.parseLong (Integer.toString (saasConfigurationRegistry.getSaasConfigProperties ().getProperty (\"saas.ip.fromlockssxml\").split (\",\").length));\n    } else {\n        if (StringUtils.isNotBlank (saasConfigurationRegistry.getSaasAuditConfigProperties ().getProperty (\"saas.targetIp\"))) {\n            numberOfMemberHosts = Long.parseLong (Integer.toString (saasConfigurationRegistry.getSaasAuditConfigProperties ().getProperty (\"saas.targetIp\").split (\",\").length));\n        } else {\n            numberOfMemberHosts = 0L;\n        }\n    }\n    rprtCnst.addKV (\"REPORT_N_HOSTS_IN_NETWORK_2\", Long.toString (numberOfMemberHosts));\n    Long numberOfReachableHosts;\n    numberOfReachableHosts = lockssBoxFacade.getTotalHosts ();\n    rprtCnst.addKV (\"REPORT_N_HOSTS_IN_NETWORK_REACHABLE\", Long.toString (numberOfReachableHosts));\n    Map < String, Map > network_host_hashbox = new TreeMap < String, Map > (DBUtil.rs_to_hashbox (rs_q1_H, null, \"ip_address\"));\n    logger.info (\"network_host_hashbox before transformations\\n\" + xstream.toXML (network_host_hashbox));\n    Map < String, String > transforms_n_host_hb = new HashMap < String, String > ();\n    transforms_n_host_hb.put (\"repo_size\", \"SciToStr2()\");\n    transforms_n_host_hb.put (\"used_space\", \"SciToStr2()\");\n    network_host_hashbox = hr.convert_hashbox_vals (network_host_hashbox, transforms_n_host_hb);\n    logger.info (\"network_host_hashbox(after transformations)\\n\" + xstream.toXML (network_host_hashbox));\n    Map < String, String > network_host_hb_sel_used_space = hr.join_hash_pk_to_inner_hash_value (network_host_hashbox, \"used_space\");\n    Map < String, String > schema_host_hb_sel_size = hr.join_hash_pk_to_inner_hash_value (schema_host_hashbox, \"/SSP/hosts/host/hostCapabilities/storageAvailable/@max_size\");\n    logger.info (\"\\n========== Process Network  END ===========================\");\n    logger.info (\"========== Compare Key Sets (IDs)==========================\");\n    Set < String > sa_hb_keys = hr.gen_hash_keyset (schema_au_hashbox, \"schema_au_hashbox\");\n    hr.set_hash_keyset (sa_hb_keys, \"s_au_hb\");\n    Set < String > sh_hb_keys = hr.gen_hash_keyset (schema_host_hashbox, \"schema_host_hashbox\");\n    hr.set_hash_keyset (sh_hb_keys, \"s_h_hb\");\n    Set < String > na_hb_keys = hr.gen_hash_keyset (network_au_hashbox, \"network_au_hashbox\");\n    hr.set_hash_keyset (na_hb_keys, \"n_au_hb\");\n    Set < String > nh_hb_keys = hr.gen_hash_keyset (network_host_hashbox, \"network_host_hashbox\");\n    hr.set_hash_keyset (nh_hb_keys, \"n_h_hb\");\n    Set < String > aus_in_schema_not_in_network = new TreeSet < String > (hr.get_hash_keyset (\"s_au_hb\"));\n    aus_in_schema_not_in_network.removeAll (hr.get_hash_keyset (\"n_au_hb\"));\n    Set < String > aus_in_network_not_in_schema = new TreeSet < String > (hr.get_hash_keyset (\"n_au_hb\"));\n    aus_in_network_not_in_schema.removeAll (hr.get_hash_keyset (\"s_au_hb\"));\n    Set < String > symmetricDiff = new HashSet < String > (hr.get_hash_keyset (\"s_au_hb\"));\n    symmetricDiff.addAll (hr.get_hash_keyset (\"n_au_hb\"));\n    Set < String > tmp = new HashSet < String > (hr.get_hash_keyset (\"s_au_hb\"));\n    tmp.retainAll (hr.get_hash_keyset (\"n_au_hb\"));\n    symmetricDiff.removeAll (tmp);\n    Set < String > hosts_in_network_not_in_schema = new TreeSet < String > (hr.get_hash_keyset (\"n_h_hb\"));\n    hosts_in_network_not_in_schema.removeAll (hr.get_hash_keyset (\"s_h_hb\"));\n    Set < String > hosts_in_schema_not_in_network = new TreeSet < String > (hr.get_hash_keyset (\"s_h_hb\"));\n    hosts_in_schema_not_in_network.removeAll (hr.get_hash_keyset (\"n_h_hb\"));\n    ArrayList < String > al_hosts_in_schema_not_in_network = new ArrayList < String > (comp_keys.keys_not_in_both_hashes (schema_host_hashbox, network_host_hashbox, \"schema_hosts\", \"network_hosts\"));\n    Map < String, String > h_hosts_in_schema_not_in_network = hr.get_names_from_id_list (schema_host_hashbox, al_hosts_in_schema_not_in_network, \"/SSP/hosts/host/hostIdentity/name\");\n    rprtCnst.addKV (\"REPORT_N_HOSTS_IN_SCHEMA_NOT_IN_NETWORK\", Integer.toString (al_hosts_in_schema_not_in_network.size ()));\n    rprtCnst.set_h_hosts_in_schema_not_in_network (h_hosts_in_schema_not_in_network);\n    MYSQLReportHostsInSchemaNotInNetworkDAO daorhisnin = new MYSQLReportHostsInSchemaNotInNetworkDAO ();\n    daorhisnin.create ();\n    daorhisnin.update (h_hosts_in_schema_not_in_network);\n    ArrayList < String > al_hosts_in_network_not_in_schema = new ArrayList < String > (comp_keys.keys_not_in_both_hashes (network_host_hashbox, schema_host_hashbox, \"network_hosts\", \"schema_hosts\"));\n    Map < String, String > h_hosts_in_network_not_in_schema = hr.get_names_from_id_list (network_host_hashbox, al_hosts_in_network_not_in_schema, \"host_name\");\n    rprtCnst.addKV (\"REPORT_N_HOSTS_IN_NETWORK_NOT_IN_SCHEMA\", Integer.toString (al_hosts_in_network_not_in_schema.size ()));\n    rprtCnst.set_h_hosts_in_network_not_in_schema (h_hosts_in_network_not_in_schema);\n    MYSQLReportHostsInNetworkNotInSchemaDAO rhinnis = new MYSQLReportHostsInNetworkNotInSchemaDAO ();\n    rhinnis.create ();\n    rhinnis.update (h_hosts_in_network_not_in_schema);\n    logger.info (\"========== Compare Hosts BEGIN ============================\");\n    Comparison comp_host = new Comparison (schema_host_hashbox, \"Schema_Host\", network_host_hashbox, \"Network_Host\", XpathUtility.getXpathToDbColumnMap (), XpathUtility.getXpathToCompOpMap ());\n    comp_host.init ();\n    MYSQLAuditResultsHostDAO daoarh = new MYSQLAuditResultsHostDAO ();\n    daoarh.create ();\n    String sql_vals_host_schema = comp_host.iterate_hbs_host (daoarh, \"audit_results_host\", \"host\", h_hosts_in_network_not_in_schema);\n    CachedRowSet rs_RH = daoarh.query_q1_RH ();\n    String n_hosts_not_meeting_storage = DBUtil.get_single_count_from_rs (rs_RH);\n    rprtCnst.addKV (\"REPORT_N_HOSTS_NOT_MEETING_STORAGE\", n_hosts_not_meeting_storage);\n    logger.info (\"Calling result.get_result_hash( \\\"host\\\" ) from main()\");\n    Map host_comp_hash = result.get_result_hash (\"host\");\n    Map au_comp_hash2 = result.get_result_hash (\"au\");\n    logger.info (\"========== Compare Hosts END ==============================\");\n    Map < String, String > map_host_ip_to_host_name = hr.make_id_hash (schema_host_hashbox, \"/SSP/hosts/host/hostIdentity/name\");\n    rprtCnst.addKV (\"REPORT_N_HOSTS_IN_SCHEMA\", Integer.toString (map_host_ip_to_host_name.size ()));\n    String [] host_ip_list = hr.hash_keys_to_array (schema_host_hashbox);\n    String [] [] col2 = Utility.add_column_to_array1 (map_host_ip_to_host_name.values ().toArray (new String [0]), host_ip_list, null);\n    Map < String, String > map_au_key_string_to_au_name = hr.make_id_hash (schema_au_hashbox, \"/SSP/archivalUnits/au/auIdentity/name\");\n    logger.info (\"Length map_au_key_string_to_au_name.values().toArray(new String[0]: \" + map_au_key_string_to_au_name.values ().toArray (new String [0]).length);\n    rprtCnst.addKV (\"REPORT_N_AUS_IN_SCHEMA\", Integer.toString (map_au_key_string_to_au_name.size ()));\n    MySQLLockssBoxArchivalUnitStatusDAO daolbaus = new MySQLLockssBoxArchivalUnitStatusDAO ();\n    int [] rc = daolbaus.getResultSetDimensions ();\n    int n_rs_rows = rc [0];\n    int n_rs_cols = rc [1];\n    logger.info (\"\\n\" + n_rs_rows + \" rows (Host-AU's). \" + n_rs_cols + \" columns.\");\n    rprtCnst.addKV (\"REPORT_N_HOST_AUS_IN_NETWORK\", Integer.toString (n_rs_rows));\n    logger.info (\"================== Query 'audit_results_host' Table ==========\");\n    CachedRowSet NNonCompliantAUsCRS = daoara.getNNonCompliantAUs ();\n    String NNonCompliantAUs = DBUtil.get_single_count_from_rs (NNonCompliantAUsCRS);\n    rprtCnst.addKV (\"REPORT_N_AUS_NONCOMPLIANT\", NNonCompliantAUs);\n    logger.info (\"================== Query 'audit_results_host' Table END ======\");\n    logger.info (\"========== Output Report ==================================\");\n    MYSQLReportConstantsDAO daorc = new MYSQLReportConstantsDAO ();\n    daorc.create ();\n    daorc.update (rprtCnst.getBox ());\n    MYSQLReportHostSummaryDAO daorhs = new MYSQLReportHostSummaryDAO ();\n    daorhs.create ();\n    CachedRowSet crsarh = daoarh.queryAll ();\n    daorhs.update (crsarh);\n    daorhs.update_new_column (\"space_offered\", schema_host_hb_sel_size);\n    daorhs.update_new_column (\"space_used\", network_host_hb_sel_used_space);\n    Map < String, String > computation_cols_in_net_host_summary = new HashMap < String, String > ();\n    computation_cols_in_net_host_summary.put (\"space_total\", \"1\");\n    computation_cols_in_net_host_summary.put (\"space_used\", \"2\");\n    daorhs.update_compute_column (\"space_free\", computation_cols_in_net_host_summary);\n    logger.info (\"========== Audit Report Writer ======================================\");\n    AuditReportXMLWriter arxw = new AuditReportXMLWriter (rprtCnst, configFile.getAuditReportFile ());\n    Set < String > tableSet = tracAuditChecklistDataFacade.findAllTables ();\n    String tracResultTable = \"trac_audit_checklist_data\";\n    List < TracAuditChecklistData > evidenceList = null;\n    if (tableSet.contains (tracResultTable)) {\n        evidenceList = tracAuditChecklistDataFacade.findAll ();\n        logger.info (\"TRAC evidence list is size:\" + evidenceList.size ());\n    } else {\n        logger.info (\"Database does not contain table 'trac_audit_checklist_data'\");\n    }\n    Map < String, String > tracDataMap = new LinkedHashMap < String, String > ();\n    for (TracAuditChecklistData tracdata : evidenceList) {\n        tracDataMap.put (tracdata.getAspectId (), tracdata.getEvidence ());\n    }\n    String writeTimestamp = arxw.write (daoarh, daoara, daorc, tracDataMap);\n    File target = new File (configFile.getAuditReportFileDir () + File.separator + configFile.getAuditSchemaFileName () + \".\" + writeTimestamp);\n    FileChannel sourceChannel = null;\n    FileChannel targetChannel = null;\n    try {\n        sourceChannel = new FileInputStream (auditSchemaFile).getChannel ();\n        targetChannel = new FileOutputStream (target).getChannel ();\n        targetChannel.transferFrom (sourceChannel, 0, sourceChannel.size ());\n    } catch (IOException e) {\n        logger.log (Level.SEVERE, \"IO exception occurred while copying file\", e);\n    } finally {\n        try {\n            if (sourceChannel != null) {\n                sourceChannel.close ();\n            }\n            if (targetChannel != null) {\n                targetChannel.close ();\n            }\n        } catch (IOException e) {\n            logger.info (\"closing channels failed\");\n        }\n    }\n    logger.info (\"\\n========== EXIT drive() ===========================================\");\n    return writeTimestamp;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 12383757, "method2_id": 13994366, "code1": "public void addFile (File file, String objectId) throws DAException {\n    try {\n        String entryString = \"\";\n        FileInputStream in = new FileInputStream (file.getAbsolutePath ());\n        System.out.println (\" Adding: \" + file.getAbsolutePath ());\n        if (objectId != null) {\n            entryString = m_batchNumber + File.separator + OBJECT_DIR_PREFIX + objectId + File.separator + file.getName ();\n        } else {\n            entryString = m_batchNumber + File.separator + file.getName ();\n        }\n        m_zipOutputStream.putNextEntry (new ZipEntry (entryString));\n        byte [] tmpBuf = new byte [1024];\n        int len;\n        while ((len = in.read (tmpBuf)) > 0) {\n            m_zipOutputStream.write (tmpBuf, 0, len);\n        }\n        m_zipOutputStream.closeEntry ();\n        in.close ();\n    } catch (IOException ioEx) {\n        DAException ex = new DAException (DAExceptionCodes.IO_ERROR, new String [] {ioEx.getMessage (), file.getAbsolutePath ()});\n        logger.log (DAExceptionCodes.IO_ERROR, this, \"addFile\", \"Error while adding file to zip\", ex);\n        throw ex;\n    }\n}\n", "code2": "public static boolean exportStandalone (String projectDirectory, String destinyJARPath) {\n    boolean exported = true;\n    try {\n        File destinyJarFile = new File (destinyJARPath);\n        FileOutputStream mergedFile = new FileOutputStream (destinyJarFile);\n        ZipOutputStream os = new ZipOutputStream (mergedFile);\n        String manifest = Writer.defaultManifestFile (\"es.eucm.eadventure.engine.EAdventureStandalone\");\n        ZipEntry manifestEntry = new ZipEntry (\"META-INF/MANIFEST.MF\");\n        os.putNextEntry (manifestEntry);\n        os.write (manifest.getBytes ());\n        os.closeEntry ();\n        os.flush ();\n        File.mergeZipAndDirToJar (\"web/eAdventure_temp.jar\", projectDirectory, os);\n        addNeededLibrariesToJar (os, Controller.getInstance ());\n        os.close ();\n    } catch (FileNotFoundException e) {\n        exported = false;\n        ReportDialog.GenerateErrorReport (e, true, \"UNKNOWNERROR\");\n    } catch (IOException e) {\n        exported = false;\n        ReportDialog.GenerateErrorReport (e, true, \"UNKNOWNERROR\");\n    }\n    return exported;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 15424571, "method2_id": 21266147, "code1": "private File copyFile (File source, File destiny) {\n    try {\n        FileInputStream fileinputstream = new FileInputStream (source);\n        FileOutputStream fileoutputstream = new FileOutputStream (destiny);\n        byte abyte0 [] = new byte [4096];\n        int i;\n        while ((i = fileinputstream.read (abyte0)) != - 1) fileoutputstream.write (abyte0, 0, i);\n\n        fileinputstream.close ();\n        fileoutputstream.close ();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace ();\n        LOGGER.error (e.getMessage ());\n    } catch (IOException e) {\n        e.printStackTrace ();\n        LOGGER.error (e.getMessage ());\n    }\n    return destiny;\n}\n", "code2": "public void execute () {\n    File sourceFile = new File (oarfilePath);\n    File destinationFile = new File (deploymentDirectory + File.separator + sourceFile.getName ());\n    try {\n        FileInputStream fis = new FileInputStream (sourceFile);\n        FileOutputStream fos = new FileOutputStream (destinationFile);\n        byte [] readArray = new byte [2048];\n        while (fis.read (readArray) != - 1) {\n            fos.write (readArray);\n        }\n        fis.close ();\n        fos.flush ();\n        fos.close ();\n    } catch (IOException ioe) {\n        logger.severe (\"failed to copy the file:\" + ioe);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 16737344, "method2_id": 20917396, "code1": "private static void zipFunc (String filePath) {\n    try {\n        FileInputStream fis = new FileInputStream (filePath);\n        BufferedInputStream bis = new BufferedInputStream (fis);\n        ZipEntry fileEntry = new ZipEntry (filePath.substring (Config.getDataDir ().length () + 1));\n        zos.putNextEntry (fileEntry);\n        byte [] data = new byte [1024];\n        int byteCount;\n        while ((byteCount = bis.read (data, 0, 1024)) > - 1) {\n            zos.write (data, 0, byteCount);\n        }\n        bis.close ();\n        fis.close ();\n    } catch (IOException e) {\n    }\n    System.out.println (filePath);\n}\n", "code2": "protected void addFile (String filename, InputStream stream) throws IOException {\n    ZipEntry entry = new ZipEntry (filename);\n    byte [] chunk = new byte [1024];\n    int len;\n    _zip.putNextEntry (entry);\n    while ((len = stream.read (chunk)) > 0) {\n        _zip.write (chunk, 0, len);\n    }\n    _zip.closeEntry ();\n    _zip.flush ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 16825994, "method2_id": 22966750, "code1": "public int run (String [] args) throws Exception {\n    if (args.length < 2) {\n        System.err.println (\"Download dir local\");\n        return 1;\n    }\n    OutputStream out = new FileOutputStream (args [1]);\n    Path srcDir = new Path (args [0]);\n    Configuration conf = new Configuration ();\n    FileSystem srcFS = FileSystem.get (conf);\n    if (! srcFS.getFileStatus (srcDir).isDirectory ()) {\n        System.err.println (args [0] + \" is not a directory.\");\n        return 1;\n    }\n    try {\n        FileStatus contents [] = srcFS.listStatus (srcDir);\n        for (int i = 0;\n        i < contents.length; i ++) {\n            if (contents [i].isFile ()) {\n                System.err.println (contents [i].getPath ());\n                InputStream in = srcFS.open (contents [i].getPath ());\n                try {\n                    IOUtils.copyBytes (in, out, conf, false);\n                } finally {\n                    in.close ();\n                }\n            }\n        }\n    } finally {\n        out.close ();\n    }\n    return 0;\n}\n", "code2": "public static void returnURL (URL url, OutputStream out) throws IOException {\n    IOUtils.copy (url.openStream (), out);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1017586, "method2_id": 4724024, "code1": "public void store (OutputStream out) throws IOException {\n    int u;\n    Iterator i;\n    ZipEntry ze;\n    Map.Entry entry;\n    ZipOutputStream zip;\n    u = 0;\n    zip = new ZipOutputStream (out);\n    synchronized (map_) {\n        for (i = map_.entrySet ().iterator (); i.hasNext ();) {\n            entry = (Map.Entry) i.next ();\n            ze = new ZipEntry ((String) entry.getKey ());\n            zip.putNextEntry (ze);\n            u ++;\n            zip.write ((byte []) entry.getValue ());\n            zip.closeEntry ();\n        }\n    }\n}\n", "code2": "public void compress () throws IOException {\n    ZipOutputStream zipOutputStream = new ZipOutputStream (new FileOutputStream (this.outputFile));\n    ZipEntry zipEntry = new ZipEntry (this.inputFile.getName ());\n    FileInputStream fileInputStream;\n    CRC32 crc = new CRC32 ();\n    byte [] bytes = new byte [1000];\n    int numBytes;\n    zipOutputStream.setMethod (ZipOutputStream.DEFLATED);\n    fileInputStream = new FileInputStream (this.inputFile);\n    while ((numBytes = fileInputStream.read (bytes)) > - 1) {\n        crc.update (bytes, 0, numBytes);\n    }\n    fileInputStream.close ();\n    zipEntry.setSize (this.inputFile.length ());\n    zipEntry.setTime (this.inputFile.lastModified ());\n    zipEntry.setCrc (crc.getValue ());\n    zipEntry.setComment (\"Product File\");\n    zipOutputStream.putNextEntry (zipEntry);\n    fileInputStream = new FileInputStream (this.inputFile);\n    while ((numBytes = fileInputStream.read (bytes)) > - 1) {\n        zipOutputStream.write (bytes, 0, numBytes);\n    }\n    fileInputStream.close ();\n    zipOutputStream.closeEntry ();\n    zipOutputStream.finish ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 964970, "method2_id": 16668856, "code1": "private Drawable fetchImage (String iconUrl, Context ctx) {\n    URL url;\n    HttpClient httpClient = new DefaultHttpClient ();\n    try {\n        if (PreferenceManager.getDefaultSharedPreferences (ctx).getBoolean (\"use.urlimg.com\", true)) {\n            iconUrl = iconUrl.substring (iconUrl.indexOf (\"//\") + 2);\n            iconUrl = \"http://urlimg.com/width/100/\" + iconUrl;\n        }\n        Log.d (ImageCache.class.getName (), \"Loading image from: \" + iconUrl);\n        HttpGet httpGet = new HttpGet (iconUrl);\n        HttpResponse response = httpClient.execute (httpGet);\n        InputStream content = response.getEntity ().getContent ();\n        Drawable d = Drawable.createFromStream (content, \"src\");\n        content.close ();\n        httpGet.abort ();\n        return d;\n    } catch (IOException e) {\n        Log.e (ImageCache.class.getName (), \"IOException while fetching: \" + iconUrl);\n        return TELKA;\n    } finally {\n    }\n}\n", "code2": "public void loadSourceCode () {\n    if (getResourceName () != null) {\n        String filename = getResourceName () + \".java\";\n        sourceCode = new String (\"<html><body bgcolor=\\\"#ffffff\\\"><pre>\");\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer ();\n        URL url;\n        try {\n            url = getClass ().getResource (filename);\n            is = url.openStream ();\n            isr = new InputStreamReader (is);\n            BufferedReader reader = new BufferedReader (isr);\n            String line = reader.readLine ();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight (line) + \" \\n \";\n                line = reader.readLine ();\n            }\n            sourceCode += new String (\"</pre></body></html>\");\n        } catch (Exception ex) {\n            sourceCode = \"Could not load file: \" + filename;\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6085964, "method2_id": 19579830, "code1": "private static String readStreamToString (InputStream is, boolean passInVelocity, String tplName, Map < String, Object > templateVarsMap) throws IOException {\n    StringWriter sw = new StringWriter ();\n    IOUtils.copy (is, sw, \"UTF-8\");\n    if (passInVelocity) {\n        return tpl.formatStr (sw.toString (), templateVarsMap, tplName);\n    }\n    return sw.toString ();\n}\n", "code2": "public static void copy (File toCopy, File dest) throws IOException {\n    FileInputStream src = new FileInputStream (toCopy);\n    FileOutputStream out = new FileOutputStream (dest);\n    try {\n        while (src.available () > 0) {\n            out.write (src.read ());\n        }\n    } finally {\n        src.close ();\n        out.close ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4886971, "method2_id": 20336463, "code1": "private static void copyFile (String srFile, String dtFile) {\n    try {\n        File f1 = new File (srFile);\n        File f2 = new File (dtFile);\n        InputStream in = new FileInputStream (f1);\n        OutputStream out = new FileOutputStream (f2);\n        byte [] buf = new byte [1024];\n        int len;\n        while ((len = in.read (buf)) > 0) out.write (buf, 0, len);\n\n        in.close ();\n        out.close ();\n    } catch (FileNotFoundException ex) {\n        System.out.println (\"Error copying \" + srFile + \" to \" + dtFile);\n        System.out.println (ex.getMessage () + \" in the specified directory.\");\n    } catch (IOException e) {\n        System.out.println (e.getMessage ());\n    }\n}\n", "code2": "private static void prepare () {\n    System.err.println (\"PREPARING-----------------------------------------\");\n    deleteHome ();\n    InputStream configStream = null;\n    FileOutputStream tempStream = null;\n    try {\n        configStream = AllTests.class.getClassLoader ().getResourceAsStream (\"net/sf/archimede/test/resources/repository.xml\");\n        new File (\"temp\").mkdir ();\n        tempStream = new FileOutputStream (new File (\"temp/repository.xml\"));\n        IOUtils.copy (configStream, tempStream);\n    } catch (FileNotFoundException e) {\n        e.printStackTrace ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    } finally {\n        try {\n            if (configStream != null) {\n                configStream.close ();\n            }\n        } catch (IOException e) {\n            e.printStackTrace ();\n        } finally {\n            if (tempStream != null) {\n                try {\n                    tempStream.close ();\n                } catch (IOException e) {\n                    e.printStackTrace ();\n                }\n            }\n        }\n    }\n    String repositoryName = \"jackrabbit.repository\";\n    Properties jndiProperties = new Properties ();\n    jndiProperties.put (\"java.naming.provider.url\", \"http://sf.net/projects/archimede#1\");\n    jndiProperties.put (\"java.naming.factory.initial\", \"org.apache.jackrabbit.core.jndi.provider.DummyInitialContextFactory\");\n    startupUtil = new StartupJcrUtil (REPOSITORY_HOME, \"temp/repository.xml\", repositoryName, jndiProperties);\n    startupUtil.init ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 15480455, "method2_id": 18568751, "code1": "public static void TestDBStore () throws PDException, Exception {\n    StoreDDBB StDB = new StoreDDBB (\"jdbc:derby://localhost:1527/Prodoc\", \"Prodoc\", \"Prodoc\", \"org.apache.derby.jdbc.ClientDriver;STBLOB\");\n    System.out.println (\"Driver[\" + StDB.getDriver () + \"] Tabla  [\" + StDB.getTable () + \"]\");\n    StDB.Connect ();\n    FileInputStream in = new FileInputStream (\"/tmp/readme.htm\");\n    StDB.Insert (\"12345678-1\", \"1.0\", in);\n    int TAMBUFF = 1024 * 64;\n    byte Buffer [] = new byte [TAMBUFF];\n    InputStream Bytes;\n    Bytes = StDB.Retrieve (\"12345678-1\", \"1.0\");\n    FileOutputStream fo = new FileOutputStream (\"/tmp/12345679.htm\");\n    int readed = Bytes.read (Buffer);\n    while (readed != - 1) {\n        fo.write (Buffer, 0, readed);\n        readed = Bytes.read (Buffer);\n    }\n    Bytes.close ();\n    fo.close ();\n    StDB.Delete (\"12345678-1\", \"1.0\");\n    StDB.Disconnect ();\n}\n", "code2": "public static Boolean decompress (File source, File destination) {\n    FileOutputStream outputStream;\n    ZipInputStream inputStream;\n    try {\n        outputStream = null;\n        inputStream = new ZipInputStream (new FileInputStream (source));\n        int read;\n        byte buffer [] = new byte [BUFFER_SIZE];\n        ZipEntry zipEntry;\n        while ((zipEntry = inputStream.getNextEntry ()) != null) {\n            if (zipEntry.isDirectory ()) new File (destination, zipEntry.getName ()).mkdirs ();\n            else {\n                File fileEntry = new File (destination, zipEntry.getName ());\n                fileEntry.getParentFile ().mkdirs ();\n                outputStream = new FileOutputStream (fileEntry);\n                while ((read = inputStream.read (buffer, 0, BUFFER_SIZE)) != - 1) {\n                    outputStream.write (buffer, 0, read);\n                }\n                outputStream.flush ();\n                outputStream.close ();\n            }\n        }\n        inputStream.close ();\n    } catch (Exception oException) {\n        return false;\n    }\n    return true;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 5606566, "method2_id": 11591514, "code1": "public boolean authenticate (String user, String pass) throws IOException {\n    MessageDigest hash = null;\n    try {\n        MessageDigest.getInstance (\"BrokenMD4\");\n    } catch (NoSuchAlgorithmException x) {\n        throw new Error (x);\n    }\n    hash.update (new byte [4], 0, 4);\n    try {\n        hash.update (pass.getBytes (\"US-ASCII\"), 0, pass.length ());\n        hash.update (challenge.getBytes (\"US-ASCII\"), 0, challenge.length ());\n    } catch (java.io.UnsupportedEncodingException shouldNeverHappen) {\n    }\n    String response = Util.base64 (hash.digest ());\n    Util.writeASCII (out, user + \" \" + response + '\\n');\n    String reply = Util.readLine (in);\n    if (reply.startsWith (RSYNCD_OK)) {\n        authReqd = false;\n        return true;\n    }\n    connected = false;\n    error = reply;\n    return false;\n}\n", "code2": "public HashCash (String cash) throws NoSuchAlgorithmException {\n    myToken = cash;\n    String [] parts = cash.split (\":\");\n    myVersion = Integer.parseInt (parts [0]);\n    if (myVersion < 0 || myVersion > 1) throw new IllegalArgumentException (\"Only supported versions are 0 and 1\");\n\n    if ((myVersion == 0 && parts.length != 6) || (myVersion == 1 && parts.length != 7)) throw new IllegalArgumentException (\"Improperly formed HashCash\");\n\n    try {\n        int index = 1;\n        if (myVersion == 1) myValue = Integer.parseInt (parts [index ++]);\n        else myValue = 0;\n\n        SimpleDateFormat dateFormat = new SimpleDateFormat (dateFormatString);\n        Calendar tempCal = Calendar.getInstance (TimeZone.getTimeZone (\"GMT\"));\n        tempCal.setTime (dateFormat.parse (parts [index ++]));\n        myResource = parts [index ++];\n        myExtensions = deserializeExtensions (parts [index ++]);\n        MessageDigest md = MessageDigest.getInstance (\"SHA1\");\n        md.update (cash.getBytes ());\n        byte [] tempBytes = md.digest ();\n        int tempValue = numberOfLeadingZeros (tempBytes);\n        if (myVersion == 0) myValue = tempValue;\n        else if (myVersion == 1) myValue = (tempValue > myValue ? myValue : tempValue);\n\n    } catch (java.text.ParseException ex) {\n        throw new IllegalArgumentException (\"Improperly formed HashCash\", ex);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 5615339, "method2_id": 10656325, "code1": "private void zipContainer (String containerName, ZipOutputStream out) throws NxqdException, IOException {\n    NxqdContainer container = manager.getContainer (containerName);\n    java.util.List contents = container.listDocuments ();\n    if (contents.size () == 0) {\n        out.putNextEntry (new ZipEntry (containerName + '/'));\n        out.closeEntry ();\n    } else {\n        String documentId;\n        byte [] buf;\n        for (int i = 0;\n        i < contents.size (); i ++) {\n            documentId = contents.get (i).toString ();\n            out.putNextEntry (new ZipEntry (containerName + '/' + documentId));\n            String document = container.getDocument (documentId).asString ();\n            buf = document.getBytes ();\n            out.write (buf, 0, buf.length);\n            out.closeEntry ();\n        }\n    }\n    contents = container.listBlobs ();\n    if (contents.size () == 0) {\n        out.putNextEntry (new ZipEntry (containerName + '/'));\n        out.closeEntry ();\n    } else {\n        String documentId;\n        byte [] buf;\n        for (int i = 0;\n        i < contents.size (); i ++) {\n            documentId = contents.get (i).toString ();\n            out.putNextEntry (new ZipEntry (containerName + '/' + documentId + BLOB_SUFFIX));\n            buf = container.getBlob (documentId).getBlob ();\n            out.write (buf, 0, buf.length);\n            out.closeEntry ();\n        }\n    }\n}\n", "code2": "private void addDir (File dirObj, ZipOutputStream out) throws IOException {\n    File [] files = dirObj.listFiles ();\n    byte [] tmpBuf = new byte [1024];\n    for (int i = 0;\n    i < files.length; i ++) {\n        if (files [i].isDirectory ()) {\n            addDir (files [i], out);\n            continue;\n        }\n        String dir = dirObj.toString ();\n        dir = dir.substring (dir.indexOf (File.separator) + 1);\n        FileInputStream in = new FileInputStream (dirObj + File.separator + files [i].getName ());\n        out.putNextEntry (new ZipEntry (dir + File.separator + files [i].getName ()));\n        int len;\n        while ((len = in.read (tmpBuf)) > 0) {\n            out.write (tmpBuf, 0, len);\n        }\n        out.closeEntry ();\n        in.close ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8344806, "method2_id": 19868933, "code1": "public void unpack (File destDirectory, boolean delete) {\n    if (delete) delete (destDirectory);\n\n    if (destDirectory.exists ()) throw new ContentPackageException (\"Destination directory already exists.\");\n\n    this.destDirectory = destDirectory;\n    this.manifestFile = new File (destDirectory, MANIFEST_FILE_NAME);\n    try {\n        if (zipInputStream == null) zipInputStream = new ZipInputStream (new FileInputStream (zipFile));\n\n        ZipEntry zipEntry;\n        while ((zipEntry = zipInputStream.getNextEntry ()) != null) {\n            File destFile = new File (destDirectory, zipEntry.getName ());\n            destFile.getParentFile ().mkdirs ();\n            if (! zipEntry.isDirectory ()) {\n                BufferedOutputStream output = new BufferedOutputStream (new FileOutputStream (destFile), BUFFER_SIZE);\n                byte [] buffer = new byte [BUFFER_SIZE];\n                int length;\n                while ((length = zipInputStream.read (buffer, 0, BUFFER_SIZE)) != - 1) output.write (buffer, 0, length);\n\n                output.close ();\n                zipInputStream.closeEntry ();\n            }\n        }\n        zipInputStream.close ();\n    } catch (IOException ex) {\n        throw new ContentPackageException (ex);\n    }\n}\n", "code2": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 672084, "method2_id": 762814, "code1": "public boolean addMeFile (File f) {\n    try {\n        BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (new File (directory + f.getName ())));\n        BufferedInputStream in = new BufferedInputStream (new FileInputStream (f));\n        byte [] read = new byte [128];\n        int len = 128;\n        while ((len = in.read (read)) > 0) out.write (read, 0, len);\n\n        out.flush ();\n        out.close ();\n        in.close ();\n        if (! PatchManager.mute) System.out.println (\"added : \" + directory + f.getName ());\n\n    } catch (IOException e) {\n        System.out.println (\"copy directory : \" + e);\n        return false;\n    }\n    return true;\n}\n", "code2": "public static void zipFile (String file, String entry) throws IOException {\n    FileInputStream in = new FileInputStream (file);\n    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (file + \".zip\"));\n    out.putNextEntry (new ZipEntry (entry));\n    byte [] buffer = new byte [4096];\n    int bytes_read;\n    while ((bytes_read = in.read (buffer)) != - 1) out.write (buffer, 0, bytes_read);\n\n    in.close ();\n    out.closeEntry ();\n    out.close ();\n    File fin = new File (file);\n    fin.delete ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 16250771, "method2_id": 19395766, "code1": "public static String genDigest (String info) {\n    MessageDigest alga;\n    byte [] digesta = null;\n    try {\n        alga = MessageDigest.getInstance (\"SHA-1\");\n        alga.update (info.getBytes ());\n        digesta = alga.digest ();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace ();\n    }\n    return byte2hex (digesta);\n}\n", "code2": "public static String encodePassword (String password) {\n    try {\n        MessageDigest messageDiegest = MessageDigest.getInstance (\"SHA-1\");\n        messageDiegest.update (password.getBytes (\"UTF-8\"));\n        return Base64.encodeToString (messageDiegest.digest (), false);\n    } catch (NoSuchAlgorithmException e) {\n        log.error (\"Ha habido un error mientras se almacenaba la clave de acceso.\");\n        throw new Error (e);\n    } catch (UnsupportedEncodingException e) {\n        log.error (\"Ha habido un error mientras se almacenaba la clave de acceso.\");\n        throw new Error (e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 845651, "method2_id": 9564133, "code1": "public static void main (String [] args) throws IOException, WrongFormatException, URISyntaxException {\n    System.out.println (new URI (\"google.com.ua.css\").toString ());\n    Scanner scc = new Scanner (System.in);\n    System.err.print (scc.nextLine ().substring (1));\n    ServerSocket s = new ServerSocket (5354);\n    while (true) {\n        Socket client = s.accept ();\n        InputStream iStream = client.getInputStream ();\n        BufferedReader bf = new BufferedReader (new InputStreamReader (iStream));\n        String line = \"\";\n        while (! (line = bf.readLine ()).equals (\"\")) {\n            System.out.println (line);\n        }\n        System.out.println (\"end of request\");\n        new PrintWriter (client.getOutputStream ()).println (\"hi\");\n        bf.close ();\n    }\n}\n", "code2": "public void copy (File aSource, File aDestDir) throws IOException {\n    FileInputStream myInFile = new FileInputStream (aSource);\n    FileOutputStream myOutFile = new FileOutputStream (new File (aDestDir, aSource.getName ()));\n    FileChannel myIn = myInFile.getChannel ();\n    FileChannel myOut = myOutFile.getChannel ();\n    boolean end = false;\n    while (true) {\n        int myBytes = myIn.read (theBuffer);\n        if (myBytes != - 1) {\n            theBuffer.flip ();\n            myOut.write (theBuffer);\n            theBuffer.clear ();\n        } else break;\n\n    }\n    myIn.close ();\n    myOut.close ();\n    myInFile.close ();\n    myOutFile.close ();\n    long myEnd = System.currentTimeMillis ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9996802, "method2_id": 13122191, "code1": "public static int copy (File src, int amount, File dst) {\n    final int BUFFER_SIZE = 1024;\n    int amountToRead = amount;\n    InputStream in = null;\n    OutputStream out = null;\n    try {\n        in = new BufferedInputStream (new FileInputStream (src));\n        out = new BufferedOutputStream (new FileOutputStream (dst));\n        byte [] buf = new byte [BUFFER_SIZE];\n        while (amountToRead > 0) {\n            int read = in.read (buf, 0, Math.min (BUFFER_SIZE, amountToRead));\n            if (read == - 1) break;\n\n            amountToRead -= read;\n            out.write (buf, 0, read);\n        }\n    } catch (IOException e) {\n    } finally {\n        if (in != null) try {\n            in.close ();\n        } catch (IOException e) {\n        }\n\n        if (out != null) {\n            try {\n                out.flush ();\n            } catch (IOException e) {\n            }\n            try {\n                out.close ();\n            } catch (IOException e) {\n            }\n        }\n    }\n    return amount - amountToRead;\n}\n", "code2": "public static void copy (String inputFile, String outputFile) throws EDITSException {\n    try {\n        FileReader in = new FileReader (inputFile);\n        FileWriter out = new FileWriter (outputFile);\n        int c;\n        while ((c = in.read ()) != - 1) out.write (c);\n\n        in.close ();\n        out.close ();\n    } catch (Exception e) {\n        throw new EDITSException (\"Could not copy \" + inputFile + \" into \" + outputFile + \" because:\\n\" + e.getMessage ());\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3230111, "method2_id": 3320586, "code1": "public static Adaptor getAdaptor (String kindTerm, Adaptable adaptable) throws AdaptorException {\n    Class < Adaptor > adaptorClass = getAdaptorClass (kindTerm, adaptable);\n    if (adaptorClass == null) {\n        return null;\n    }\n    Adaptor adaptor = adaptable.getAdaptor (adaptorClass);\n    if (adaptor == null) {\n        Constructor < ? > adaptorConstructor = null;\n        Class < ? > constructorArgClass = adaptable.getClass ();\n        while (constructorArgClass != null) {\n            try {\n                adaptorConstructor = adaptorClass.getConstructor (constructorArgClass);\n                break;\n            } catch (NoSuchMethodException nsme) {\n                constructorArgClass = constructorArgClass.getSuperclass ();\n            }\n        }\n        if (adaptorConstructor == null) {\n            try {\n                adaptorConstructor = adaptorClass.getConstructor ();\n            } catch (NoSuchMethodException nsme) {\n                throw new AdaptorException (\"Unable to construct Adaptor \" + adaptorClass + \" instance for \" + adaptable.getClass ());\n            }\n        }\n        try {\n            if (constructorArgClass == null) {\n                adaptor = (Adaptor) adaptorConstructor.newInstance ();\n            } else {\n                adaptor = (Adaptor) adaptorConstructor.newInstance (adaptable);\n            }\n        } catch (RuntimeException re) {\n            throw re;\n        } catch (Exception e) {\n            throw new AdaptorException (\"Unable to create kind Adaptor\", e);\n        }\n        adaptable.addAdaptor (adaptor);\n    }\n    return adaptor;\n}\n", "code2": "protected Object parseOption (Option opt, String arg) throws BadArgsException {\n    Constructor init;\n    Object [] param;\n    Class [] sig;\n    try {\n        sig = new Class [] {arg.getClass ()};\n        param = new Object [] {arg};\n        init = opt.type_.getConstructor (sig);\n        return init.newInstance (param);\n    } catch (Exception e) {\n        opt.help (System.err);\n        throw new BadArgsException (\"Can't assign \\\"\" + arg + \"\\\" to option \\\"\" + opt.name_ + \"\\\"\");\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2247987, "method2_id": 8430178, "code1": "public static void main (String argv []) {\n    Matrix A, B, C, Z, O, I, R, S, X, SUB, M, T, SQ, DEF, SOL;\n    int errorCount = 0;\n    int warningCount = 0;\n    double tmp, s;\n    double [] columnwise = {1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12.};\n    double [] rowwise = {1., 4., 7., 10., 2., 5., 8., 11., 3., 6., 9., 12.};\n    double [] [] avals = {{1., 4., 7., 10.}, {2., 5., 8., 11.}, {3., 6., 9., 12.}};\n    double [] [] rankdef = avals;\n    double [] [] tvals = {{1., 2., 3.}, {4., 5., 6.}, {7., 8., 9.}, {10., 11., 12.}};\n    double [] [] subavals = {{5., 8., 11.}, {6., 9., 12.}};\n    double [] [] rvals = {{1., 4., 7.}, {2., 5., 8., 11.}, {3., 6., 9., 12.}};\n    double [] [] pvals = {{4., 1., 1.}, {1., 2., 3.}, {1., 3., 6.}};\n    double [] [] ivals = {{1., 0., 0., 0.}, {0., 1., 0., 0.}, {0., 0., 1., 0.}};\n    double [] [] evals = {{0., 1., 0., 0.}, {1., 0., 2.e-7, 0.}, {0., - 2.e-7, 0., 1.}, {0., 0., 1., 0.}};\n    double [] [] square = {{166., 188., 210.}, {188., 214., 240.}, {210., 240., 270.}};\n    double [] [] sqSolution = {{13.}, {15.}};\n    double [] [] condmat = {{1., 3.}, {7., 9.}};\n    int rows = 3, cols = 4;\n    int invalidld = 5;\n    int raggedr = 0;\n    int raggedc = 4;\n    int validld = 3;\n    int nonconformld = 4;\n    int ib = 1, ie = 2, jb = 1, je = 3;\n    int [] rowindexset = {1, 2};\n    int [] badrowindexset = {1, 3};\n    int [] columnindexset = {1, 2, 3};\n    int [] badcolumnindexset = {1, 2, 4};\n    double columnsummax = 33.;\n    double rowsummax = 30.;\n    double sumofdiagonals = 15;\n    double sumofsquares = 650;\n    print (\"\\nTesting constructors and constructor-like methods...\\n\");\n    try {\n        A = new Matrix (columnwise, invalidld);\n        errorCount = try_failure (errorCount, \"Catch invalid length in packed constructor... \", \"exception not thrown for invalid input\");\n    } catch (IllegalArgumentException e) {\n        try_success (\"Catch invalid length in packed constructor... \", e.getMessage ());\n    }\n    try {\n        A = new Matrix (rvals);\n        tmp = A.get (raggedr, raggedc);\n    } catch (IllegalArgumentException e) {\n        try_success (\"Catch ragged input to default constructor... \", e.getMessage ());\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        errorCount = try_failure (errorCount, \"Catch ragged input to constructor... \", \"exception not thrown in construction...ArrayIndexOutOfBoundsException thrown later\");\n    }\n    try {\n        A = Matrix.constructWithCopy (rvals);\n        tmp = A.get (raggedr, raggedc);\n    } catch (IllegalArgumentException e) {\n        try_success (\"Catch ragged input to constructWithCopy... \", e.getMessage ());\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        errorCount = try_failure (errorCount, \"Catch ragged input to constructWithCopy... \", \"exception not thrown in construction...ArrayIndexOutOfBoundsException thrown later\");\n    }\n    A = new Matrix (columnwise, validld);\n    B = new Matrix (avals);\n    tmp = B.get (0, 0);\n    avals [0] [0] = 0.0;\n    C = B.minus (A);\n    avals [0] [0] = tmp;\n    B = Matrix.constructWithCopy (avals);\n    tmp = B.get (0, 0);\n    avals [0] [0] = 0.0;\n    if ((tmp - B.get (0, 0)) != 0.0) {\n        errorCount = try_failure (errorCount, \"constructWithCopy... \", \"copy not effected... data visible outside\");\n    } else {\n        try_success (\"constructWithCopy... \", \"\");\n    }\n    avals [0] [0] = columnwise [0];\n    I = new Matrix (ivals);\n    try {\n        check (I, Matrix.identity (3, 4));\n        try_success (\"identity... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"identity... \", \"identity Matrix not successfully created\");\n    }\n    print (\"\\nTesting access methods...\\n\");\n    B = new Matrix (avals);\n    if (B.getRowDimension () != rows) {\n        errorCount = try_failure (errorCount, \"getRowDimension... \", \"\");\n    } else {\n        try_success (\"getRowDimension... \", \"\");\n    }\n    if (B.getColumnDimension () != cols) {\n        errorCount = try_failure (errorCount, \"getColumnDimension... \", \"\");\n    } else {\n        try_success (\"getColumnDimension... \", \"\");\n    }\n    B = new Matrix (avals);\n    double [] [] barray = B.getArray ();\n    if (barray != avals) {\n        errorCount = try_failure (errorCount, \"getArray... \", \"\");\n    } else {\n        try_success (\"getArray... \", \"\");\n    }\n    barray = B.getArrayCopy ();\n    if (barray == avals) {\n        errorCount = try_failure (errorCount, \"getArrayCopy... \", \"data not (deep) copied\");\n    }\n    try {\n        check (barray, avals);\n        try_success (\"getArrayCopy... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"getArrayCopy... \", \"data not successfully (deep) copied\");\n    }\n    double [] bpacked = B.getColumnPackedCopy ();\n    try {\n        check (bpacked, columnwise);\n        try_success (\"getColumnPackedCopy... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"getColumnPackedCopy... \", \"data not successfully (deep) copied by columns\");\n    }\n    bpacked = B.getRowPackedCopy ();\n    try {\n        check (bpacked, rowwise);\n        try_success (\"getRowPackedCopy... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"getRowPackedCopy... \", \"data not successfully (deep) copied by rows\");\n    }\n    try {\n        tmp = B.get (B.getRowDimension (), B.getColumnDimension () - 1);\n        errorCount = try_failure (errorCount, \"get(int,int)... \", \"OutOfBoundsException expected but not thrown\");\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        try {\n            tmp = B.get (B.getRowDimension () - 1, B.getColumnDimension ());\n            errorCount = try_failure (errorCount, \"get(int,int)... \", \"OutOfBoundsException expected but not thrown\");\n        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n            try_success (\"get(int,int)... OutofBoundsException... \", \"\");\n        }\n    } catch (java.lang.IllegalArgumentException e1) {\n        errorCount = try_failure (errorCount, \"get(int,int)... \", \"OutOfBoundsException expected but not thrown\");\n    }\n    try {\n        if (B.get (B.getRowDimension () - 1, B.getColumnDimension () - 1) != avals [B.getRowDimension () - 1] [B.getColumnDimension () - 1]) {\n            errorCount = try_failure (errorCount, \"get(int,int)... \", \"Matrix entry (i,j) not successfully retreived\");\n        } else {\n            try_success (\"get(int,int)... \", \"\");\n        }\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        errorCount = try_failure (errorCount, \"get(int,int)... \", \"Unexpected ArrayIndexOutOfBoundsException\");\n    }\n    SUB = new Matrix (subavals);\n    try {\n        M = B.getMatrix (ib, ie + B.getRowDimension () + 1, jb, je);\n        errorCount = try_failure (errorCount, \"getMatrix(int,int,int,int)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        try {\n            M = B.getMatrix (ib, ie, jb, je + B.getColumnDimension () + 1);\n            errorCount = try_failure (errorCount, \"getMatrix(int,int,int,int)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n            try_success (\"getMatrix(int,int,int,int)... ArrayIndexOutOfBoundsException... \", \"\");\n        }\n    } catch (java.lang.IllegalArgumentException e1) {\n        errorCount = try_failure (errorCount, \"getMatrix(int,int,int,int)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    }\n    try {\n        M = B.getMatrix (ib, ie, jb, je);\n        try {\n            check (SUB, M);\n            try_success (\"getMatrix(int,int,int,int)... \", \"\");\n        } catch (java.lang.RuntimeException e) {\n            errorCount = try_failure (errorCount, \"getMatrix(int,int,int,int)... \", \"submatrix not successfully retreived\");\n        }\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        errorCount = try_failure (errorCount, \"getMatrix(int,int,int,int)... \", \"Unexpected ArrayIndexOutOfBoundsException\");\n    }\n    try {\n        M = B.getMatrix (ib, ie, badcolumnindexset);\n        errorCount = try_failure (errorCount, \"getMatrix(int,int,int[])... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        try {\n            M = B.getMatrix (ib, ie + B.getRowDimension () + 1, columnindexset);\n            errorCount = try_failure (errorCount, \"getMatrix(int,int,int[])... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n            try_success (\"getMatrix(int,int,int[])... ArrayIndexOutOfBoundsException... \", \"\");\n        }\n    } catch (java.lang.IllegalArgumentException e1) {\n        errorCount = try_failure (errorCount, \"getMatrix(int,int,int[])... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    }\n    try {\n        M = B.getMatrix (ib, ie, columnindexset);\n        try {\n            check (SUB, M);\n            try_success (\"getMatrix(int,int,int[])... \", \"\");\n        } catch (java.lang.RuntimeException e) {\n            errorCount = try_failure (errorCount, \"getMatrix(int,int,int[])... \", \"submatrix not successfully retreived\");\n        }\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        errorCount = try_failure (errorCount, \"getMatrix(int,int,int[])... \", \"Unexpected ArrayIndexOutOfBoundsException\");\n    }\n    try {\n        M = B.getMatrix (badrowindexset, jb, je);\n        errorCount = try_failure (errorCount, \"getMatrix(int[],int,int)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        try {\n            M = B.getMatrix (rowindexset, jb, je + B.getColumnDimension () + 1);\n            errorCount = try_failure (errorCount, \"getMatrix(int[],int,int)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n            try_success (\"getMatrix(int[],int,int)... ArrayIndexOutOfBoundsException... \", \"\");\n        }\n    } catch (java.lang.IllegalArgumentException e1) {\n        errorCount = try_failure (errorCount, \"getMatrix(int[],int,int)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    }\n    try {\n        M = B.getMatrix (rowindexset, jb, je);\n        try {\n            check (SUB, M);\n            try_success (\"getMatrix(int[],int,int)... \", \"\");\n        } catch (java.lang.RuntimeException e) {\n            errorCount = try_failure (errorCount, \"getMatrix(int[],int,int)... \", \"submatrix not successfully retreived\");\n        }\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        errorCount = try_failure (errorCount, \"getMatrix(int[],int,int)... \", \"Unexpected ArrayIndexOutOfBoundsException\");\n    }\n    try {\n        M = B.getMatrix (badrowindexset, columnindexset);\n        errorCount = try_failure (errorCount, \"getMatrix(int[],int[])... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        try {\n            M = B.getMatrix (rowindexset, badcolumnindexset);\n            errorCount = try_failure (errorCount, \"getMatrix(int[],int[])... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n            try_success (\"getMatrix(int[],int[])... ArrayIndexOutOfBoundsException... \", \"\");\n        }\n    } catch (java.lang.IllegalArgumentException e1) {\n        errorCount = try_failure (errorCount, \"getMatrix(int[],int[])... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    }\n    try {\n        M = B.getMatrix (rowindexset, columnindexset);\n        try {\n            check (SUB, M);\n            try_success (\"getMatrix(int[],int[])... \", \"\");\n        } catch (java.lang.RuntimeException e) {\n            errorCount = try_failure (errorCount, \"getMatrix(int[],int[])... \", \"submatrix not successfully retreived\");\n        }\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        errorCount = try_failure (errorCount, \"getMatrix(int[],int[])... \", \"Unexpected ArrayIndexOutOfBoundsException\");\n    }\n    try {\n        B.set (B.getRowDimension (), B.getColumnDimension () - 1, 0.);\n        errorCount = try_failure (errorCount, \"set(int,int,double)... \", \"OutOfBoundsException expected but not thrown\");\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        try {\n            B.set (B.getRowDimension () - 1, B.getColumnDimension (), 0.);\n            errorCount = try_failure (errorCount, \"set(int,int,double)... \", \"OutOfBoundsException expected but not thrown\");\n        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n            try_success (\"set(int,int,double)... OutofBoundsException... \", \"\");\n        }\n    } catch (java.lang.IllegalArgumentException e1) {\n        errorCount = try_failure (errorCount, \"set(int,int,double)... \", \"OutOfBoundsException expected but not thrown\");\n    }\n    try {\n        B.set (ib, jb, 0.);\n        tmp = B.get (ib, jb);\n        try {\n            check (tmp, 0.);\n            try_success (\"set(int,int,double)... \", \"\");\n        } catch (java.lang.RuntimeException e) {\n            errorCount = try_failure (errorCount, \"set(int,int,double)... \", \"Matrix element not successfully set\");\n        }\n    } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n        errorCount = try_failure (errorCount, \"set(int,int,double)... \", \"Unexpected ArrayIndexOutOfBoundsException\");\n    }\n    M = new Matrix (2, 3, 0.);\n    try {\n        B.setMatrix (ib, ie + B.getRowDimension () + 1, jb, je, M);\n        errorCount = try_failure (errorCount, \"setMatrix(int,int,int,int,Matrix)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        try {\n            B.setMatrix (ib, ie, jb, je + B.getColumnDimension () + 1, M);\n            errorCount = try_failure (errorCount, \"setMatrix(int,int,int,int,Matrix)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n            try_success (\"setMatrix(int,int,int,int,Matrix)... ArrayIndexOutOfBoundsException... \", \"\");\n        }\n    } catch (java.lang.IllegalArgumentException e1) {\n        errorCount = try_failure (errorCount, \"setMatrix(int,int,int,int,Matrix)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    }\n    try {\n        B.setMatrix (ib, ie, jb, je, M);\n        try {\n            check (M.minus (B.getMatrix (ib, ie, jb, je)), M);\n            try_success (\"setMatrix(int,int,int,int,Matrix)... \", \"\");\n        } catch (java.lang.RuntimeException e) {\n            errorCount = try_failure (errorCount, \"setMatrix(int,int,int,int,Matrix)... \", \"submatrix not successfully set\");\n        }\n        B.setMatrix (ib, ie, jb, je, SUB);\n    } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n        errorCount = try_failure (errorCount, \"setMatrix(int,int,int,int,Matrix)... \", \"Unexpected ArrayIndexOutOfBoundsException\");\n    }\n    try {\n        B.setMatrix (ib, ie + B.getRowDimension () + 1, columnindexset, M);\n        errorCount = try_failure (errorCount, \"setMatrix(int,int,int[],Matrix)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        try {\n            B.setMatrix (ib, ie, badcolumnindexset, M);\n            errorCount = try_failure (errorCount, \"setMatrix(int,int,int[],Matrix)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n            try_success (\"setMatrix(int,int,int[],Matrix)... ArrayIndexOutOfBoundsException... \", \"\");\n        }\n    } catch (java.lang.IllegalArgumentException e1) {\n        errorCount = try_failure (errorCount, \"setMatrix(int,int,int[],Matrix)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    }\n    try {\n        B.setMatrix (ib, ie, columnindexset, M);\n        try {\n            check (M.minus (B.getMatrix (ib, ie, columnindexset)), M);\n            try_success (\"setMatrix(int,int,int[],Matrix)... \", \"\");\n        } catch (java.lang.RuntimeException e) {\n            errorCount = try_failure (errorCount, \"setMatrix(int,int,int[],Matrix)... \", \"submatrix not successfully set\");\n        }\n        B.setMatrix (ib, ie, jb, je, SUB);\n    } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n        errorCount = try_failure (errorCount, \"setMatrix(int,int,int[],Matrix)... \", \"Unexpected ArrayIndexOutOfBoundsException\");\n    }\n    try {\n        B.setMatrix (rowindexset, jb, je + B.getColumnDimension () + 1, M);\n        errorCount = try_failure (errorCount, \"setMatrix(int[],int,int,Matrix)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        try {\n            B.setMatrix (badrowindexset, jb, je, M);\n            errorCount = try_failure (errorCount, \"setMatrix(int[],int,int,Matrix)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n            try_success (\"setMatrix(int[],int,int,Matrix)... ArrayIndexOutOfBoundsException... \", \"\");\n        }\n    } catch (java.lang.IllegalArgumentException e1) {\n        errorCount = try_failure (errorCount, \"setMatrix(int[],int,int,Matrix)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    }\n    try {\n        B.setMatrix (rowindexset, jb, je, M);\n        try {\n            check (M.minus (B.getMatrix (rowindexset, jb, je)), M);\n            try_success (\"setMatrix(int[],int,int,Matrix)... \", \"\");\n        } catch (java.lang.RuntimeException e) {\n            errorCount = try_failure (errorCount, \"setMatrix(int[],int,int,Matrix)... \", \"submatrix not successfully set\");\n        }\n        B.setMatrix (ib, ie, jb, je, SUB);\n    } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n        errorCount = try_failure (errorCount, \"setMatrix(int[],int,int,Matrix)... \", \"Unexpected ArrayIndexOutOfBoundsException\");\n    }\n    try {\n        B.setMatrix (rowindexset, badcolumnindexset, M);\n        errorCount = try_failure (errorCount, \"setMatrix(int[],int[],Matrix)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n        try {\n            B.setMatrix (badrowindexset, columnindexset, M);\n            errorCount = try_failure (errorCount, \"setMatrix(int[],int[],Matrix)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n        } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n            try_success (\"setMatrix(int[],int[],Matrix)... ArrayIndexOutOfBoundsException... \", \"\");\n        }\n    } catch (java.lang.IllegalArgumentException e1) {\n        errorCount = try_failure (errorCount, \"setMatrix(int[],int[],Matrix)... \", \"ArrayIndexOutOfBoundsException expected but not thrown\");\n    }\n    try {\n        B.setMatrix (rowindexset, columnindexset, M);\n        try {\n            check (M.minus (B.getMatrix (rowindexset, columnindexset)), M);\n            try_success (\"setMatrix(int[],int[],Matrix)... \", \"\");\n        } catch (java.lang.RuntimeException e) {\n            errorCount = try_failure (errorCount, \"setMatrix(int[],int[],Matrix)... \", \"submatrix not successfully set\");\n        }\n    } catch (java.lang.ArrayIndexOutOfBoundsException e1) {\n        errorCount = try_failure (errorCount, \"setMatrix(int[],int[],Matrix)... \", \"Unexpected ArrayIndexOutOfBoundsException\");\n    }\n    print (\"\\nTesting array-like methods...\\n\");\n    S = new Matrix (columnwise, nonconformld);\n    R = Matrix.random (A.getRowDimension (), A.getColumnDimension ());\n    A = R;\n    try {\n        S = A.minus (S);\n        errorCount = try_failure (errorCount, \"minus conformance check... \", \"nonconformance not raised\");\n    } catch (IllegalArgumentException e) {\n        try_success (\"minus conformance check... \", \"\");\n    }\n    if (A.minus (R).norm1 () != 0.) {\n        errorCount = try_failure (errorCount, \"minus... \", \"(difference of identical Matrices is nonzero,\\nSubsequent use of minus should be suspect)\");\n    } else {\n        try_success (\"minus... \", \"\");\n    }\n    A = R.copy ();\n    A.minusEquals (R);\n    Z = new Matrix (A.getRowDimension (), A.getColumnDimension ());\n    try {\n        A.minusEquals (S);\n        errorCount = try_failure (errorCount, \"minusEquals conformance check... \", \"nonconformance not raised\");\n    } catch (IllegalArgumentException e) {\n        try_success (\"minusEquals conformance check... \", \"\");\n    }\n    if (A.minus (Z).norm1 () != 0.) {\n        errorCount = try_failure (errorCount, \"minusEquals... \", \"(difference of identical Matrices is nonzero,\\nSubsequent use of minus should be suspect)\");\n    } else {\n        try_success (\"minusEquals... \", \"\");\n    }\n    A = R.copy ();\n    B = Matrix.random (A.getRowDimension (), A.getColumnDimension ());\n    C = A.minus (B);\n    try {\n        S = A.plus (S);\n        errorCount = try_failure (errorCount, \"plus conformance check... \", \"nonconformance not raised\");\n    } catch (IllegalArgumentException e) {\n        try_success (\"plus conformance check... \", \"\");\n    }\n    try {\n        check (C.plus (B), A);\n        try_success (\"plus... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"plus... \", \"(C = A - B, but C + B != A)\");\n    }\n    C = A.minus (B);\n    C.plusEquals (B);\n    try {\n        A.plusEquals (S);\n        errorCount = try_failure (errorCount, \"plusEquals conformance check... \", \"nonconformance not raised\");\n    } catch (IllegalArgumentException e) {\n        try_success (\"plusEquals conformance check... \", \"\");\n    }\n    try {\n        check (C, A);\n        try_success (\"plusEquals... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"plusEquals... \", \"(C = A - B, but C = C + B != A)\");\n    }\n    A = R.uminus ();\n    try {\n        check (A.plus (R), Z);\n        try_success (\"uminus... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"uminus... \", \"(-A + A != zeros)\");\n    }\n    A = R.copy ();\n    O = new Matrix (A.getRowDimension (), A.getColumnDimension (), 1.0);\n    C = A.arrayLeftDivide (R);\n    try {\n        S = A.arrayLeftDivide (S);\n        errorCount = try_failure (errorCount, \"arrayLeftDivide conformance check... \", \"nonconformance not raised\");\n    } catch (IllegalArgumentException e) {\n        try_success (\"arrayLeftDivide conformance check... \", \"\");\n    }\n    try {\n        check (C, O);\n        try_success (\"arrayLeftDivide... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"arrayLeftDivide... \", \"(M.\\\\M != ones)\");\n    }\n    try {\n        A.arrayLeftDivideEquals (S);\n        errorCount = try_failure (errorCount, \"arrayLeftDivideEquals conformance check... \", \"nonconformance not raised\");\n    } catch (IllegalArgumentException e) {\n        try_success (\"arrayLeftDivideEquals conformance check... \", \"\");\n    }\n    A.arrayLeftDivideEquals (R);\n    try {\n        check (A, O);\n        try_success (\"arrayLeftDivideEquals... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"arrayLeftDivideEquals... \", \"(M.\\\\M != ones)\");\n    }\n    A = R.copy ();\n    try {\n        A.arrayRightDivide (S);\n        errorCount = try_failure (errorCount, \"arrayRightDivide conformance check... \", \"nonconformance not raised\");\n    } catch (IllegalArgumentException e) {\n        try_success (\"arrayRightDivide conformance check... \", \"\");\n    }\n    C = A.arrayRightDivide (R);\n    try {\n        check (C, O);\n        try_success (\"arrayRightDivide... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"arrayRightDivide... \", \"(M./M != ones)\");\n    }\n    try {\n        A.arrayRightDivideEquals (S);\n        errorCount = try_failure (errorCount, \"arrayRightDivideEquals conformance check... \", \"nonconformance not raised\");\n    } catch (IllegalArgumentException e) {\n        try_success (\"arrayRightDivideEquals conformance check... \", \"\");\n    }\n    A.arrayRightDivideEquals (R);\n    try {\n        check (A, O);\n        try_success (\"arrayRightDivideEquals... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"arrayRightDivideEquals... \", \"(M./M != ones)\");\n    }\n    A = R.copy ();\n    B = Matrix.random (A.getRowDimension (), A.getColumnDimension ());\n    try {\n        S = A.arrayTimes (S);\n        errorCount = try_failure (errorCount, \"arrayTimes conformance check... \", \"nonconformance not raised\");\n    } catch (IllegalArgumentException e) {\n        try_success (\"arrayTimes conformance check... \", \"\");\n    }\n    C = A.arrayTimes (B);\n    try {\n        check (C.arrayRightDivideEquals (B), A);\n        try_success (\"arrayTimes... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"arrayTimes... \", \"(A = R, C = A.*B, but C./B != A)\");\n    }\n    try {\n        A.arrayTimesEquals (S);\n        errorCount = try_failure (errorCount, \"arrayTimesEquals conformance check... \", \"nonconformance not raised\");\n    } catch (IllegalArgumentException e) {\n        try_success (\"arrayTimesEquals conformance check... \", \"\");\n    }\n    A.arrayTimesEquals (B);\n    try {\n        check (A.arrayRightDivideEquals (B), R);\n        try_success (\"arrayTimesEquals... \", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"arrayTimesEquals... \", \"(A = R, A = A.*B, but A./B != R)\");\n    }\n    print (\"\\nTesting I/O methods...\\n\");\n    try {\n        DecimalFormat fmt = new DecimalFormat (\"0.0000E00\");\n        fmt.setDecimalFormatSymbols (new DecimalFormatSymbols (Locale.US));\n        PrintWriter FILE = new PrintWriter (new FileOutputStream (\"JamaTestMatrix.out\"));\n        A.print (FILE, fmt, 10);\n        FILE.close ();\n        R = Matrix.read (new BufferedReader (new FileReader (\"JamaTestMatrix.out\")));\n        if (A.minus (R).norm1 () < .001) {\n            try_success (\"print()/read()...\", \"\");\n        } else {\n            errorCount = try_failure (errorCount, \"print()/read()...\", \"Matrix read from file does not match Matrix printed to file\");\n        }\n    } catch (java.io.IOException ioe) {\n        warningCount = try_warning (warningCount, \"print()/read()...\", \"unexpected I/O error, unable to run print/read test;  check write permission in current directory and retry\");\n    } catch (Exception e) {\n        try {\n            e.printStackTrace (System.out);\n            warningCount = try_warning (warningCount, \"print()/read()...\", \"Formatting error... will try JDK1.1 reformulation...\");\n            DecimalFormat fmt = new DecimalFormat (\"0.0000\");\n            PrintWriter FILE = new PrintWriter (new FileOutputStream (\"JamaTestMatrix.out\"));\n            A.print (FILE, fmt, 10);\n            FILE.close ();\n            R = Matrix.read (new BufferedReader (new FileReader (\"JamaTestMatrix.out\")));\n            if (A.minus (R).norm1 () < .001) {\n                try_success (\"print()/read()...\", \"\");\n            } else {\n                errorCount = try_failure (errorCount, \"print()/read() (2nd attempt) ...\", \"Matrix read from file does not match Matrix printed to file\");\n            }\n        } catch (java.io.IOException ioe) {\n            warningCount = try_warning (warningCount, \"print()/read()...\", \"unexpected I/O error, unable to run print/read test;  check write permission in current directory and retry\");\n        }\n    }\n    R = Matrix.random (A.getRowDimension (), A.getColumnDimension ());\n    String tmpname = \"TMPMATRIX.serial\";\n    try {\n        ObjectOutputStream out = new ObjectOutputStream (new FileOutputStream (tmpname));\n        out.writeObject (R);\n        ObjectInputStream sin = new ObjectInputStream (new FileInputStream (tmpname));\n        A = (Matrix) sin.readObject ();\n        try {\n            check (A, R);\n            try_success (\"writeObject(Matrix)/readObject(Matrix)...\", \"\");\n        } catch (java.lang.RuntimeException e) {\n            errorCount = try_failure (errorCount, \"writeObject(Matrix)/readObject(Matrix)...\", \"Matrix not serialized correctly\");\n        }\n    } catch (java.io.IOException ioe) {\n        warningCount = try_warning (warningCount, \"writeObject()/readObject()...\", \"unexpected I/O error, unable to run serialization test;  check write permission in current directory and retry\");\n    } catch (Exception e) {\n        errorCount = try_failure (errorCount, \"writeObject(Matrix)/readObject(Matrix)...\", \"unexpected error in serialization test\");\n    }\n    print (\"\\nTesting linear algebra methods...\\n\");\n    A = new Matrix (columnwise, 3);\n    T = new Matrix (tvals);\n    T = A.transpose ();\n    try {\n        check (A.transpose (), T);\n        try_success (\"transpose...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"transpose()...\", \"transpose unsuccessful\");\n    }\n    A.transpose ();\n    try {\n        check (A.norm1 (), columnsummax);\n        try_success (\"norm1...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"norm1()...\", \"incorrect norm calculation\");\n    }\n    try {\n        check (A.normInf (), rowsummax);\n        try_success (\"normInf()...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"normInf()...\", \"incorrect norm calculation\");\n    }\n    try {\n        check (A.normF (), Math.sqrt (sumofsquares));\n        try_success (\"normF...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"normF()...\", \"incorrect norm calculation\");\n    }\n    try {\n        check (A.trace (), sumofdiagonals);\n        try_success (\"trace()...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"trace()...\", \"incorrect trace calculation\");\n    }\n    try {\n        check (A.getMatrix (0, A.getRowDimension () - 1, 0, A.getRowDimension () - 1).det (), 0.);\n        try_success (\"det()...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"det()...\", \"incorrect determinant calculation\");\n    }\n    SQ = new Matrix (square);\n    try {\n        check (A.times (A.transpose ()), SQ);\n        try_success (\"times(Matrix)...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"times(Matrix)...\", \"incorrect Matrix-Matrix product calculation\");\n    }\n    try {\n        check (A.times (0.), Z);\n        try_success (\"times(double)...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"times(double)...\", \"incorrect Matrix-scalar product calculation\");\n    }\n    A = new Matrix (columnwise, 4);\n    QRDecomposition QR = A.qr ();\n    R = QR.getR ();\n    try {\n        check (A, QR.getQ ().times (R));\n        try_success (\"QRDecomposition...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"QRDecomposition...\", \"incorrect QR decomposition calculation\");\n    }\n    SingularValueDecomposition SVD = A.svd ();\n    try {\n        check (A, SVD.getU ().times (SVD.getS ().times (SVD.getV ().transpose ())));\n        try_success (\"SingularValueDecomposition...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"SingularValueDecomposition...\", \"incorrect singular value decomposition calculation\");\n    }\n    DEF = new Matrix (rankdef);\n    try {\n        check (DEF.rank (), Math.min (DEF.getRowDimension (), DEF.getColumnDimension ()) - 1);\n        try_success (\"rank()...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"rank()...\", \"incorrect rank calculation\");\n    }\n    B = new Matrix (condmat);\n    SVD = B.svd ();\n    double [] singularvalues = SVD.getSingularValues ();\n    try {\n        check (B.cond (), singularvalues [0] / singularvalues [Math.min (B.getRowDimension (), B.getColumnDimension ()) - 1]);\n        try_success (\"cond()...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"cond()...\", \"incorrect condition number calculation\");\n    }\n    int n = A.getColumnDimension ();\n    A = A.getMatrix (0, n - 1, 0, n - 1);\n    A.set (0, 0, 0.);\n    LUDecomposition LU = A.lu ();\n    try {\n        check (A.getMatrix (LU.getPivot (), 0, n - 1), LU.getL ().times (LU.getU ()));\n        try_success (\"LUDecomposition...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"LUDecomposition...\", \"incorrect LU decomposition calculation\");\n    }\n    X = A.inverse ();\n    try {\n        check (A.times (X), Matrix.identity (3, 3));\n        try_success (\"inverse()...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"inverse()...\", \"incorrect inverse calculation\");\n    }\n    O = new Matrix (SUB.getRowDimension (), 1, 1.0);\n    SOL = new Matrix (sqSolution);\n    SQ = SUB.getMatrix (0, SUB.getRowDimension () - 1, 0, SUB.getRowDimension () - 1);\n    try {\n        check (SQ.solve (SOL), O);\n        try_success (\"solve()...\", \"\");\n    } catch (java.lang.IllegalArgumentException e1) {\n        errorCount = try_failure (errorCount, \"solve()...\", e1.getMessage ());\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"solve()...\", e.getMessage ());\n    }\n    A = new Matrix (pvals);\n    CholeskyDecomposition Chol = A.chol ();\n    Matrix L = Chol.getL ();\n    try {\n        check (A, L.times (L.transpose ()));\n        try_success (\"CholeskyDecomposition...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"CholeskyDecomposition...\", \"incorrect Cholesky decomposition calculation\");\n    }\n    X = Chol.solve (Matrix.identity (3, 3));\n    try {\n        check (A.times (X), Matrix.identity (3, 3));\n        try_success (\"CholeskyDecomposition solve()...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"CholeskyDecomposition solve()...\", \"incorrect Choleskydecomposition solve calculation\");\n    }\n    EigenvalueDecomposition Eig = A.eig ();\n    Matrix D = Eig.getD ();\n    Matrix V = Eig.getV ();\n    try {\n        check (A.times (V), V.times (D));\n        try_success (\"EigenvalueDecomposition (symmetric)...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"EigenvalueDecomposition (symmetric)...\", \"incorrect symmetric Eigenvalue decomposition calculation\");\n    }\n    A = new Matrix (evals);\n    Eig = A.eig ();\n    D = Eig.getD ();\n    V = Eig.getV ();\n    try {\n        check (A.times (V), V.times (D));\n        try_success (\"EigenvalueDecomposition (nonsymmetric)...\", \"\");\n    } catch (java.lang.RuntimeException e) {\n        errorCount = try_failure (errorCount, \"EigenvalueDecomposition (nonsymmetric)...\", \"incorrect nonsymmetric Eigenvalue decomposition calculation\");\n    }\n    print (\"\\nTestMatrix completed.\\n\");\n    print (\"Total errors reported: \" + Integer.toString (errorCount) + \"\\n\");\n    print (\"Total warnings reported: \" + Integer.toString (warningCount) + \"\\n\");\n}\n", "code2": "public static void copyFile (String source_name, String dest_name) throws IOException {\n    source_name = Shell.getUtils ().constructPath (source_name);\n    File source_file = new File (source_name);\n    dest_name = Shell.getUtils ().constructPath (dest_name);\n    File destination_file = new File (dest_name);\n    FileInputStream source = null;\n    FileOutputStream destination = null;\n    byte [] buffer;\n    int bytes_read;\n    try {\n        if (! source_file.exists () || ! source_file.isFile ()) throw new FileCopyException (\"cp: no such source file: \" + source_name);\n\n        if (! source_file.canRead ()) throw new FileCopyException (\"cp: source file \" + \"is unreadable: \" + source_name);\n\n        if (destination_file.exists ()) {\n            if (destination_file.isFile ()) {\n                BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n                String response;\n                if (! destination_file.canWrite ()) throw new FileCopyException (\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n\n                System.out.print (\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                System.out.flush ();\n                response = in.readLine ();\n                if (! response.equals (\"Y\") && ! response.equals (\"y\")) throw new FileCopyException (\"cp: copy cancelled.\");\n\n            } else throw new FileCopyException (\"cp: destination \" + \"is not a file: \" + dest_name);\n\n        } else {\n            File parentdir = parent (destination_file);\n            if (! parentdir.exists ()) throw new FileCopyException (\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n\n            if (! parentdir.canWrite ()) throw new FileCopyException (\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n\n        }\n        source = new FileInputStream (source_file);\n        destination = new FileOutputStream (destination_file);\n        buffer = new byte [1024];\n        int size = (new Long ((source_file.length () / 1024) / 50)).intValue ();\n        int c = 1;\n        int written = 0;\n        System.out.print (\"cp: \");\n        while (true) {\n            if (written < 50) {\n                if ((c - 1) == size && size != 0) {\n                    System.out.print (\"#\");\n                    c = 1;\n                    written ++;\n                } else if (size == 0) {\n                    int j = 1;\n                    if (c > 1) j = (50 / c) - 50;\n                    else j = 50 / c;\n\n                    for (int i = 0;\n                    i < j; i ++) System.out.print (\"#\");\n\n                    written += j;\n                }\n\n            }\n            bytes_read = source.read (buffer);\n            if (bytes_read == - 1) break;\n\n            destination.write (buffer, 0, bytes_read);\n            c ++;\n        }\n        System.out.println ();\n    } finally {\n        if (source != null) try {\n            source.close ();\n        } catch (IOException e) {\n        }\n\n        if (destination != null) try {\n            destination.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 15635582, "method2_id": 17729564, "code1": "private static boolean maybeBackupFile (File f, ZipOutputStream zip, Map origFileTimes, Map origFileSizes, Map fileTimes, Map fileSizes) {\n    String name = f.getName ();\n    Long fileTime = new Long (f.lastModified ());\n    Long fileSize = new Long (f.length ());\n    fileTimes.put (name, fileTime);\n    fileSizes.put (name, fileSize);\n    Long prevTime = (Long) origFileTimes.get (name);\n    Long prevSize = (Long) origFileSizes.get (name);\n    if (prevTime != null && prevTime.equals (fileTime) && prevSize != null && prevSize.equals (fileSize)) return false;\n\n    try {\n        ZipEntry e = new ZipEntry (name);\n        e.setTime (fileTime.longValue ());\n        zip.putNextEntry (e);\n        byte [] buffer = new byte [4096];\n        FileInputStream in = new FileInputStream (f);\n        int bytesRead;\n        while ((bytesRead = in.read (buffer)) != - 1) zip.write (buffer, 0, bytesRead);\n\n        in.close ();\n    } catch (IOException ioe) {\n        printError (\"Error while backing up \" + name, ioe);\n    }\n    return true;\n}\n", "code2": "public boolean comprimirFicheros_x_algoritmo (String [] archivoZipear, String rutaArchivoComprimido, String nombreAlgoritmo) {\n    System.out.println (\"**** DENTRO DE 'comprimirFicheros_x_algoritmo' ****\");\n    boolean estado = false;\n    try {\n        Checksum algoritmoCompresor = null;\n        if (nombreAlgoritmo.equalsIgnoreCase (\"Adler32\")) {\n            algoritmoCompresor = new Adler32 ();\n        } else if (nombreAlgoritmo.equalsIgnoreCase (\"CRC32\")) {\n            algoritmoCompresor = new CRC32 ();\n        }\n\n        FileInputStream entradaFile = null;\n        BufferedInputStream entradaBuffer = null;\n        FileOutputStream salidaFile = new FileOutputStream (rutaArchivoComprimido);\n        CheckedOutputStream comprobacion = new CheckedOutputStream (salidaFile, algoritmoCompresor);\n        ZipOutputStream ZIP = new ZipOutputStream (new BufferedOutputStream (comprobacion));\n        System.out.println (\"Algoritmo Compresor: \" + nombreAlgoritmo);\n        byte [] datos = new byte [TAMANO_BUFFER];\n        for (int i = 0;\n        i < archivoZipear.length; i ++) {\n            String nombreArchivo = archivoZipear [i];\n            System.out.println (\"Archivos: \" + nombreArchivo);\n            entradaFile = new FileInputStream (nombreArchivo);\n            entradaBuffer = new BufferedInputStream (entradaFile, TAMANO_BUFFER);\n            ZipEntry entradaZip = new ZipEntry (nombreArchivo);\n            ZIP.putNextEntry (entradaZip);\n            int bytes;\n            while ((bytes = entradaBuffer.read (datos, 0, TAMANO_BUFFER)) != - 1) {\n                ZIP.write (datos, 0, bytes);\n                estado = true;\n            }\n            entradaBuffer.close ();\n        }\n        ZIP.close ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n        estado = false;\n    } catch (Exception e) {\n        e.printStackTrace ();\n        estado = false;\n    }\n    return estado;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 18927261, "method2_id": 20181666, "code1": "public static String remap (String before, String after, String sql) {\n    if (LOG.isTraceEnabled ()) LOG.trace (\"Remapping before: \" + before + \", after: \" + after + \", sql: \" + sql);\n\n    StringBuilder out = new StringBuilder (sql.length () + 128);\n    Pattern pattern = Pattern.compile (\"(^|\\\\W+)(\" + before + \")(\\\\W+|$)\", Pattern.CASE_INSENSITIVE);\n    Matcher matcher = pattern.matcher (sql);\n    int lastIndex = 0;\n    while (matcher.find ()) {\n        if (LOG.isTraceEnabled ()) LOG.trace (\"Found match at index \" + matcher.start (2));\n\n        out.append (sql.substring (lastIndex, matcher.start (2)));\n        out.append (after);\n        lastIndex = matcher.end (2);\n    }\n    out.append (sql.substring (lastIndex));\n    if (LOG.isTraceEnabled ()) LOG.trace (\"Result: \" + out);\n\n    return out.toString ();\n}\n", "code2": "public void run () {\n    centerPanel.removeAll ();\n    GridBagConstraints gbc = new GridBagConstraints ();\n    gbc.weighty = 1.0;\n    gbc.weightx = 1.0;\n    centerPanel.add (progressLabel, gbc);\n    SwingUtilities.invokeLater (new Runnable () {\n        public void run () {\n            progressLabel.updateUI ();\n            thisInstance.setEnabled (false);\n            Map < Object, Object > parameters = searcher.getParameters ();\n            if (parameters == null) parameters = new HashMap < Object, Object > ();\n\n            if (target instanceof LuceneDataStoreImpl) {\n                URL indexLocationURL = (URL) ((LuceneDataStoreImpl) target).getIndexer ().getParameters ().get (Constants.INDEX_LOCATION_URL);\n                String indexLocation = null;\n                try {\n                    indexLocation = new File (indexLocationURL.toURI ()).getAbsolutePath ();\n                } catch (URISyntaxException use) {\n                    indexLocation = new File (indexLocationURL.getFile ()).getAbsolutePath ();\n                }\n                ArrayList < String > indexLocations = new ArrayList < String > ();\n                indexLocations.add (indexLocation);\n                parameters.put (Constants.INDEX_LOCATIONS, indexLocations);\n                String corpus2SearchIn = (corpusToSearchIn.getSelectedItem ().equals (Constants.ENTIRE_DATASTORE)) ? null : (String) corpusIds.get (corpusToSearchIn.getSelectedIndex () - 1);\n                parameters.put (Constants.CORPUS_ID, corpus2SearchIn);\n            }\n            int noOfPatterns = ((Number) numberOfResultsSpinner.getValue ()).intValue ();\n            int contextWindow = ((Number) contextSizeSpinner.getValue ()).intValue ();\n            String query = newQuery.getText ().trim ();\n            java.util.regex.Pattern pattern = java.util.regex.Pattern.compile (\"\\\\{([^\\\\{=]+)==\");\n            Matcher matcher = pattern.matcher (query);\n            int start = 0;\n            while (matcher.find (start)) {\n                start = matcher.end (1);\n                for (int row = 0;\n                row < numShortcuts; row ++) {\n                    if (shortcuts [row] [SHORTCUT].equals (matcher.group (1))) {\n                        query = query.substring (0, matcher.start (1)) + shortcuts [row] [ANNOTATION_TYPE] + \".\" + shortcuts [row] [FEATURE] + query.substring (matcher.end (1));\n                        matcher = pattern.matcher (query);\n                        break;\n                    }\n                }\n            }\n            parameters.put (Constants.CONTEXT_WINDOW, new Integer (contextWindow));\n            if (annotationSetToSearchIn.getSelectedItem ().equals (Constants.ALL_SETS)) {\n                parameters.remove (Constants.ANNOTATION_SET_ID);\n            } else {\n                String annotationSet = (String) annotationSetToSearchIn.getSelectedItem ();\n                parameters.put (Constants.ANNOTATION_SET_ID, annotationSet);\n            }\n            try {\n                if (searcher.search (query, parameters)) {\n                    searcher.next (noOfPatterns);\n                }\n            } catch (Exception e) {\n                e.printStackTrace ();\n                thisInstance.setEnabled (true);\n            }\n            processFinished ();\n            pageOfResults = 1;\n            titleResults.setText (\"Results - Page \" + pageOfResults);\n            thisInstance.setEnabled (true);\n        }}\n\n    );\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1890824, "method2_id": 11731587, "code1": "private void internalTransferComplete (File tmpfile) {\n    System.out.println (\"transferComplete : \" + tmpfile);\n    try {\n        File old = new File (m_destination.toString () + \".old\");\n        old.delete ();\n        File current = m_destination;\n        current.renameTo (old);\n        FileInputStream fis = new FileInputStream (tmpfile);\n        FileOutputStream fos = new FileOutputStream (m_destination);\n        BufferedInputStream in = new BufferedInputStream (fis);\n        BufferedOutputStream out = new BufferedOutputStream (fos);\n        for (int read = in.read ();\n        read != - 1; read = in.read ()) {\n            out.write (read);\n        }\n        out.flush ();\n        in.close ();\n        out.close ();\n        fis.close ();\n        fos.close ();\n        tmpfile.delete ();\n        setVisible (false);\n        transferComplete ();\n    } catch (Exception exc) {\n        exc.printStackTrace ();\n        JOptionPane.showMessageDialog (this, \"An error occurred while downloading!\", \"ACLocator Error\", JOptionPane.ERROR_MESSAGE);\n    }\n}\n", "code2": "public File createFileFromClasspathResource (String resourceUrl) throws IOException {\n    File fichierTest = File.createTempFile (\"xmlFieldTestFile\", \"\");\n    FileOutputStream fos = new FileOutputStream (fichierTest);\n    InputStream is = XmlFieldDomSelectorTest.class.getResourceAsStream (resourceUrl);\n    IOUtils.copy (is, fos);\n    is.close ();\n    fos.close ();\n    return fichierTest;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 949221, "method2_id": 11566433, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "public void write (File file) throws Exception {\n    if (getGEDCOMFile () != null) {\n        size = getGEDCOMFile ().length ();\n        if (! getGEDCOMFile ().renameTo (file)) {\n            BufferedInputStream in = null;\n            BufferedOutputStream out = null;\n            try {\n                in = new BufferedInputStream (new FileInputStream (getGEDCOMFile ()));\n                out = new BufferedOutputStream (new FileOutputStream (file));\n                IOUtils.copy (in, out);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close ();\n                    } catch (IOException e) {\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close ();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n    } else {\n        throw new FileUploadException (\"Cannot write uploaded file to disk!\");\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 750821, "method2_id": 14157859, "code1": "private void displayDiffResults () throws IOException {\n    File outFile = File.createTempFile (\"diff\", \".htm\");\n    outFile.deleteOnExit ();\n    FileOutputStream outStream = new FileOutputStream (outFile);\n    BufferedWriter out = new BufferedWriter (new OutputStreamWriter (outStream));\n    out.write (\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n    if (addedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n        out.write (addedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    if (modifiedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n        out.write (modifiedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    if (deletedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n        out.write (deletedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    out.write (\"<table name=METRICS BORDER>\\n\");\n    if (modifiedTable.length () > 0 || deletedTable.length () > 0) {\n        out.write (\"<tr><td>Base:&nbsp;</td><td>\");\n        out.write (Long.toString (base));\n        out.write (\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n        out.write (Long.toString (deleted));\n        out.write (\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n        out.write (Long.toString (modified));\n        out.write (\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n        out.write (Long.toString (added));\n        out.write (\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n        out.write (Long.toString (added + modified));\n        out.write (\"</td></tr>\\n\");\n    }\n    out.write (\"<tr><td>Total:&nbsp;</td><td>\");\n    out.write (Long.toString (total));\n    out.write (\"</td></tr>\\n</table></div>\");\n    redlinesOut.close ();\n    out.flush ();\n    InputStream redlines = new FileInputStream (redlinesTempFile);\n    byte [] buffer = new byte [4096];\n    int bytesRead;\n    while ((bytesRead = redlines.read (buffer)) != - 1) outStream.write (buffer, 0, bytesRead);\n\n    outStream.write (\"</BODY></HTML>\".getBytes ());\n    outStream.close ();\n    Browser.launch (outFile.toURL ().toString ());\n}\n", "code2": "static void copyFile (File file, File file1) throws IOException {\n    byte abyte0 [] = new byte [512];\n    FileInputStream fileinputstream = new FileInputStream (file);\n    FileOutputStream fileoutputstream = new FileOutputStream (file1);\n    int i;\n    while ((i = fileinputstream.read (abyte0)) > 0) fileoutputstream.write (abyte0, 0, i);\n\n    fileinputstream.close ();\n    fileoutputstream.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3246556, "method2_id": 11228284, "code1": "public static void copyFile (File source, String target) throws FileNotFoundException, IOException {\n    File fout = new File (target);\n    fout.mkdirs ();\n    fout.delete ();\n    fout = new File (target);\n    FileChannel in = new FileInputStream (source).getChannel ();\n    FileChannel out = new FileOutputStream (target).getChannel ();\n    in.transferTo (0, in.size (), out);\n    in.close ();\n    out.close ();\n}\n", "code2": "public static boolean copy (File src, File dest) {\n    boolean result = true;\n    String files [] = null;\n    if (src.isDirectory ()) {\n        files = src.list ();\n        result = dest.mkdir ();\n    } else {\n        files = new String [1];\n        files [0] = \"\";\n    }\n    if (files == null) {\n        files = new String [0];\n    }\n    for (int i = 0;\n    (i < files.length) && result; i ++) {\n        File fileSrc = new File (src, files [i]);\n        File fileDest = new File (dest, files [i]);\n        if (fileSrc.isDirectory ()) {\n            result = copy (fileSrc, fileDest);\n        } else {\n            FileChannel ic = null;\n            FileChannel oc = null;\n            try {\n                ic = (new FileInputStream (fileSrc)).getChannel ();\n                oc = (new FileOutputStream (fileDest)).getChannel ();\n                ic.transferTo (0, ic.size (), oc);\n            } catch (IOException e) {\n                log.error (sm.getString (\"expandWar.copy\", fileSrc, fileDest), e);\n                result = false;\n            } finally {\n                if (ic != null) {\n                    try {\n                        ic.close ();\n                    } catch (IOException e) {\n                    }\n                }\n                if (oc != null) {\n                    try {\n                        oc.close ();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2575374, "method2_id": 6430125, "code1": "public static void copy (File in, File out) throws Exception {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n", "code2": "protected Object openDialogBox (Control cellEditorWindow) {\n    FileDialog dialog = new FileDialog (parent.getShell (), SWT.OPEN);\n    dialog.setFilterExtensions (new String [] {\"*.jpg;*.JPG;*.JPEG;*.gif;*.GIF;*.png;*.PNG\", \"*.jpg;*.JPG;*.JPEG\", \"*.gif;*.GIF\", \"*.png;*.PNG\"});\n    dialog.setFilterNames (new String [] {\"All\", \"Joint Photographic Experts Group (JPEG)\", \"Graphics Interchange Format (GIF)\", \"Portable Network Graphics (PNG)\"});\n    String imagePath = dialog.open ();\n    if (imagePath == null) return null;\n\n    IProject project = ProjectManager.getInstance ().getCurrentProject ();\n    String projectFolderPath = project.getLocation ().toOSString ();\n    File imageFile = new File (imagePath);\n    String fileName = imageFile.getName ();\n    ImageData imageData = null;\n    try {\n        imageData = new ImageData (imagePath);\n    } catch (SWTException e) {\n        UserErrorException error = new UserErrorException (PropertyHandler.getInstance ().getProperty (\"_invalid_image_title\"), PropertyHandler.getInstance ().getProperty (\"_invalid_image_text\"));\n        UserErrorService.INSTANCE.showError (error);\n        return null;\n    }\n    if (imageData == null) {\n        UserErrorException error = new UserErrorException (PropertyHandler.getInstance ().getProperty (\"_invalid_image_title\"), PropertyHandler.getInstance ().getProperty (\"_invalid_image_text\"));\n        UserErrorService.INSTANCE.showError (error);\n        return null;\n    }\n    File copiedImageFile = new File (projectFolderPath + File.separator + imageFolderPath + File.separator + fileName);\n    if (copiedImageFile.exists ()) {\n        Path path = new Path (copiedImageFile.getPath ());\n        copiedImageFile = new File (projectFolderPath + File.separator + imageFolderPath + File.separator + UUID.randomUUID ().toString () + \".\" + path.getFileExtension ());\n    }\n    try {\n        copiedImageFile.createNewFile ();\n    } catch (IOException e1) {\n        ExceptionHandlingService.INSTANCE.handleException (e1);\n        copiedImageFile = null;\n    }\n    if (copiedImageFile == null) {\n        copiedImageFile = new File (projectFolderPath + File.separator + imageFolderPath + File.separator + UUID.randomUUID ().toString ());\n        try {\n            copiedImageFile.createNewFile ();\n        } catch (IOException e) {\n            ExceptionHandlingService.INSTANCE.handleException (e);\n            return \"\";\n        }\n    }\n    FileReader in = null;\n    FileWriter out = null;\n    try {\n        in = new FileReader (imageFile);\n        out = new FileWriter (copiedImageFile);\n        int c;\n        while ((c = in.read ()) != - 1) out.write (c);\n\n        in.close ();\n        out.close ();\n    } catch (FileNotFoundException e) {\n        ExceptionHandlingService.INSTANCE.handleException (e);\n        return \"\";\n    } catch (IOException e) {\n        ExceptionHandlingService.INSTANCE.handleException (e);\n        return \"\";\n    }\n    return imageFolderPath + File.separator + copiedImageFile.getName ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3726610, "method2_id": 3946138, "code1": "private static void processFile (StreamDriver driver, String sourceName) throws Exception {\n    String destName = sourceName + \".xml\";\n    File dest = new File (destName);\n    if (dest.exists ()) {\n        throw new IllegalArgumentException (\"File '\" + destName + \"' already exists!\");\n    }\n    FileChannel sourceChannel = new FileInputStream (sourceName).getChannel ();\n    try {\n        MappedByteBuffer sourceByteBuffer = sourceChannel.map (FileChannel.MapMode.READ_ONLY, 0, sourceChannel.size ());\n        CharsetDecoder decoder = Charset.forName (\"ISO-8859-15\").newDecoder ();\n        CharBuffer sourceBuffer = decoder.decode (sourceByteBuffer);\n        driver.generateXmlDocument (sourceBuffer, new FileOutputStream (dest));\n    } finally {\n        sourceChannel.close ();\n    }\n}\n", "code2": "public static void main (String args []) throws Exception {\n    FileInputStream fin = new FileInputStream (\"D:/work/test.txt\");\n    FileOutputStream fout = new FileOutputStream (\"D:/work/output.txt\");\n    FileChannel inChannel = fin.getChannel ();\n    FileChannel outChannel = fout.getChannel ();\n    ByteBuffer buffer = ByteBuffer.allocate (1024);\n    while (true) {\n        int ret = inChannel.read (buffer);\n        if (ret == - 1) break;\n\n        buffer.flip ();\n        outChannel.write (buffer);\n        buffer.clear ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 19452177, "method2_id": 23250845, "code1": "public static File createTempFile (InputStream contentStream, String ext) throws IOException {\n    ExceptionUtils.throwIfNull (contentStream, \"contentStream\");\n    File file = File.createTempFile (\"test\", ext);\n    FileOutputStream fos = new FileOutputStream (file);\n    try {\n        IOUtils.copy (contentStream, fos, false);\n    } finally {\n        fos.close ();\n    }\n    return file;\n}\n", "code2": "private void unzipResource (final String resourceName, final File targetDirectory) throws IOException {\n    assertTrue (resourceName.startsWith (\"/\"));\n    final URL resource = this.getClass ().getResource (resourceName);\n    assertNotNull (\"Expected '\" + resourceName + \"' not found.\", resource);\n    assertTrue (targetDirectory.isAbsolute ());\n    FileUtils.deleteDirectory (targetDirectory);\n    assertTrue (targetDirectory.mkdirs ());\n    ZipInputStream in = null;\n    boolean suppressExceptionOnClose = true;\n    try {\n        in = new ZipInputStream (resource.openStream ());\n        ZipEntry e;\n        while ((e = in.getNextEntry ()) != null) {\n            if (e.isDirectory ()) {\n                continue;\n            }\n            final File dest = new File (targetDirectory, e.getName ());\n            assertTrue (dest.isAbsolute ());\n            OutputStream out = null;\n            try {\n                out = FileUtils.openOutputStream (dest);\n                IOUtils.copy (in, out);\n                suppressExceptionOnClose = false;\n            } finally {\n                try {\n                    if (out != null) {\n                        out.close ();\n                    }\n                    suppressExceptionOnClose = true;\n                } catch (final IOException ex) {\n                    if (! suppressExceptionOnClose) {\n                        throw ex;\n                    }\n                }\n            }\n            in.closeEntry ();\n        }\n        suppressExceptionOnClose = false;\n    } finally {\n        try {\n            if (in != null) {\n                in.close ();\n            }\n        } catch (final IOException e) {\n            if (! suppressExceptionOnClose) {\n                throw e;\n            }\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 11673911, "method2_id": 21044594, "code1": "private void _save (ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n    List list = (List) req.getAttribute (WebKeys.LANGUAGE_MANAGER_LIST);\n    for (int i = 0;\n    i < list.size (); i ++) {\n        long langId = ((Language) list.get (i)).getId ();\n        try {\n            String filePath = getGlobalVariablesPath () + \"cms_language_\" + langId + \".properties\";\n            String tmpFilePath = getTemporyDirPath () + \"cms_language_\" + langId + \"_properties.tmp\";\n            File from = new java.io.File (tmpFilePath);\n            from.createNewFile ();\n            File to = new java.io.File (filePath);\n            to.createNewFile ();\n            FileChannel srcChannel = new FileInputStream (from).getChannel ();\n            FileChannel dstChannel = new FileOutputStream (to).getChannel ();\n            dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n            srcChannel.close ();\n            dstChannel.close ();\n        } catch (NonWritableChannelException we) {\n        } catch (IOException e) {\n            Logger.error (this, \"Property File save Failed \" + e, e);\n        }\n    }\n    SessionMessages.add (req, \"message\", \"message.languagemanager.save\");\n}\n", "code2": "public void run () {\n    final String basename = FilenameUtils.removeExtension (file.getName ());\n    final File compressed = new File (logDirectory, basename + \".gz\");\n    InputStream in = null;\n    OutputStream out = null;\n    try {\n        in = new FileInputStream (file);\n        out = new GZIPOutputStream (new FileOutputStream (compressed));\n        IOUtils.copy (in, out);\n        in.close ();\n        out.close ();\n    } catch (IOException e) {\n        reportError (\"Error compressing olg log file after file rotation\", e, ErrorManager.GENERIC_FAILURE);\n    } finally {\n        IOUtils.closeQuietly (in);\n        IOUtils.closeQuietly (out);\n    }\n    Collections.replaceAll (files, file, compressed);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4267635, "method2_id": 21369761, "code1": "public static boolean copyFile (final File src, final File dst) throws FileNotFoundException {\n    if (src == null || dst == null || src.equals (dst)) {\n        return false;\n    }\n    boolean result = false;\n    if (src.exists ()) {\n        if (dst.exists () && ! dst.canWrite ()) {\n            return false;\n        }\n        final FileInputStream srcStream = new FileInputStream (src);\n        final FileOutputStream dstStream = new FileOutputStream (dst);\n        final FileChannel srcChannel = srcStream.getChannel ();\n        final FileChannel dstChannel = dstStream.getChannel ();\n        FileLock dstLock = null;\n        FileLock srcLock = null;\n        try {\n            srcLock = srcChannel.tryLock (0, Long.MAX_VALUE, true);\n            dstLock = dstChannel.tryLock ();\n            if (srcLock != null && dstLock != null) {\n                int maxCount = 64 * 1024 * 1024 - 32 * 1024;\n                long size = srcChannel.size ();\n                long position = 0;\n                while (position < size) {\n                    position += srcChannel.transferTo (position, maxCount, dstChannel);\n                }\n            }\n        } catch (IOException ex) {\n            Logger.getLogger (FileUtils.class.getName ()).log (Level.SEVERE, null, ex);\n        } finally {\n            if (srcChannel != null) {\n                try {\n                    if (srcLock != null) {\n                        srcLock.release ();\n                    }\n                    srcChannel.close ();\n                    srcStream.close ();\n                } catch (IOException ex) {\n                    Logger.getLogger (FileUtils.class.getName ()).log (Level.SEVERE, null, ex);\n                }\n            }\n            if (dstChannel != null) {\n                try {\n                    if (dstLock != null) {\n                        dstLock.release ();\n                    }\n                    dstChannel.close ();\n                    dstStream.close ();\n                    result = true;\n                } catch (IOException ex) {\n                    Logger.getLogger (FileUtils.class.getName ()).log (Level.SEVERE, null, ex);\n                }\n            }\n        }\n    }\n    return result;\n}\n", "code2": "protected void copyFile (final File in, final File out) throws IOException {\n    final FileChannel inChannel = new FileInputStream (in).getChannel ();\n    final FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (final IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) {\n            inChannel.close ();\n        }\n        if (outChannel != null) {\n            outChannel.close ();\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2396214, "method2_id": 16116214, "code1": "public static String toMD5Sum (String arg0) {\n    String ret;\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (arg0.getBytes ());\n        ret = toHexString (md.digest ());\n    } catch (Exception e) {\n        ret = arg0;\n    }\n    return ret;\n}\n", "code2": "public static void processString (String text) throws Exception {\n    MessageDigest md5 = MessageDigest.getInstance (MD5_DIGEST);\n    md5.reset ();\n    md5.update (text.getBytes ());\n    displayResult (null, md5.digest ());\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9856200, "method2_id": 23031483, "code1": "public static void copyFile (File srcFile, File destFolder) {\n    try {\n        File destFile = new File (destFolder, srcFile.getName ());\n        if (destFile.exists ()) {\n            throw new BuildException (\"Could not copy \" + srcFile + \" to \" + destFolder + \" as \" + destFile + \" already exists\");\n        }\n        FileChannel srcChannel = null;\n        FileChannel destChannel = null;\n        try {\n            srcChannel = new FileInputStream (srcFile).getChannel ();\n            destChannel = new FileOutputStream (destFile).getChannel ();\n            destChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n        } finally {\n            if (srcChannel != null) {\n                srcChannel.close ();\n            }\n            if (destChannel != null) {\n                destChannel.close ();\n            }\n        }\n        destFile.setLastModified ((srcFile.lastModified ()));\n    } catch (IOException e) {\n        throw new BuildException (\"Could not copy \" + srcFile + \" to \" + destFolder + \": \" + e, e);\n    }\n}\n", "code2": "private static void copy (File source, File target, byte [] buffer) throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream (source);\n    File parent = target.getParentFile ();\n    if (! parent.exists ()) {\n        parent.mkdirs ();\n    }\n    if (target.isDirectory ()) {\n        target = new File (target, source.getName ());\n    }\n    OutputStream out = new FileOutputStream (target);\n    int read;\n    try {\n        while ((read = in.read (buffer)) != - 1) {\n            out.write (buffer, 0, read);\n        }\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        in.close ();\n        out.close ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1896089, "method2_id": 20681844, "code1": "public static void copyFileByNIO (File in, File out) throws IOException {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n", "code2": "public void testGetOldVersion () throws ServiceException, IOException, SAXException, ParserConfigurationException {\n    JCRNodeSource emptySource = loadTestSource ();\n    for (int i = 0;\n    i < 3; i ++) {\n        OutputStream sourceOut = emptySource.getOutputStream ();\n        InputStream contentIn = getClass ().getResourceAsStream (CONTENT_FILE);\n        try {\n            IOUtils.copy (contentIn, sourceOut);\n            sourceOut.flush ();\n        } finally {\n            sourceOut.close ();\n            contentIn.close ();\n        }\n    }\n    String testSourceUri = BASE_URL + \"users/lars.trieloff?revision=1.1\";\n    JCRNodeSource secondSource = (JCRNodeSource) resolveSource (testSourceUri);\n    System.out.println (\"Read again at:\" + secondSource.getSourceRevision ());\n    InputStream expected = emptySource.getInputStream ();\n    InputStream actual = secondSource.getInputStream ();\n    assertTrue (isXmlEqual (expected, actual));\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 608747, "method2_id": 5826730, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "private void copyFromZip (File zipFile) throws GLMRessourceManagerException {\n    if (zipFile == null) throw new GLMRessourceZIPException (1);\n\n    if (! zipFile.exists ()) throw new GLMRessourceZIPException (2);\n\n    int len = 0;\n    byte [] buffer = ContentManager.getDefaultBuffer ();\n    try {\n        ZipInputStream zip_in = new ZipInputStream (new BufferedInputStream (new FileInputStream (zipFile)));\n        ZipEntry zipEntry;\n        File rootDir = null;\n        while ((zipEntry = zip_in.getNextEntry ()) != null) {\n            File destFile = new File (tempDirectory, zipEntry.getName ());\n            if (rootDir == null) rootDir = destFile.getParentFile ();\n\n            if (! zipEntry.isDirectory () && destFile.getParentFile ().equals (rootDir)) {\n                if (! zipEntry.getName ().equals (ContentManager.IMS_MANIFEST_FILENAME)) {\n                    FileOutputStream file_out = new FileOutputStream (new File (tempDirectory, zipEntry.getName ()));\n                    while ((len = zip_in.read (buffer)) > 0) file_out.write (buffer, 0, len);\n\n                    file_out.flush ();\n                    file_out.close ();\n                }\n            }\n        }\n        zip_in.close ();\n    } catch (Exception e) {\n        throw new GLMRessourceZIPException (3);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2532322, "method2_id": 3109015, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "private void copy (File parent) {\n    System.out.println (\"parent---\" + parent.getAbsolutePath ());\n    if (parent.isDirectory () && ! \".svn\".equals (parent.getName ())) {\n        File cases = new File (parent, \"cases\");\n        if (cases.exists ()) {\n            File answers = new File (parent, \"answers\");\n            if (! answers.exists ()) {\n                answers.mkdir ();\n                File answers_linux = new File (parent, \"answers_linux\");\n                for (File file : answers_linux.listFiles ()) {\n                    if (file.isDirectory ()) {\n                        continue;\n                    }\n                    File target = new File (answers, file.getName ());\n                    try {\n                        IOUtils.copy (new FileInputStream (file), new FileOutputStream (target));\n                    } catch (Throwable t) {\n                        t.printStackTrace ();\n                    }\n                }\n            }\n        } else {\n            for (File son : parent.listFiles ()) {\n                System.out.println (\"parent---\" + son.getAbsolutePath ());\n                copySon (son);\n            }\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9766481, "method2_id": 17857284, "code1": "public void copy (final File source, final File target) throws FileSystemException {\n    LogHelper.logMethod (log, toObjectString (), \"copy(), source = \" + source + \", target = \" + target);\n    FileChannel sourceChannel = null;\n    FileChannel targetChannel = null;\n    try {\n        sourceChannel = new FileInputStream (source).getChannel ();\n        targetChannel = new FileOutputStream (target).getChannel ();\n        sourceChannel.transferTo (0L, sourceChannel.size (), targetChannel);\n        log.info (\"Copied \" + source + \" to \" + target);\n    } catch (FileNotFoundException e) {\n        throw new FileSystemException (\"Unexpected FileNotFoundException while copying a file\", e);\n    } catch (IOException e) {\n        throw new FileSystemException (\"Unexpected IOException while copying a file\", e);\n    } finally {\n        if (sourceChannel != null) {\n            try {\n                sourceChannel.close ();\n            } catch (IOException e) {\n                log.error (\"IOException during source channel close after copy\", e);\n            }\n        }\n        if (targetChannel != null) {\n            try {\n                targetChannel.close ();\n            } catch (IOException e) {\n                log.error (\"IOException during target channel close after copy\", e);\n            }\n        }\n    }\n}\n", "code2": "public static void copyFile (File source, File destination) throws IOException {\n    FileChannel srcChannel = new FileInputStream (source).getChannel ();\n    FileChannel dstChannel = new FileOutputStream (destination).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 47756, "method2_id": 22456976, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "private static void copyFile (File in, File out) throws Exception {\n    final FileInputStream input = new FileInputStream (in);\n    try {\n        final FileOutputStream output = new FileOutputStream (out);\n        try {\n            final byte [] buf = new byte [4096];\n            int readBytes = 0;\n            while ((readBytes = input.read (buf)) != - 1) {\n                output.write (buf, 0, readBytes);\n            }\n        } finally {\n            output.close ();\n        }\n    } finally {\n        input.close ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2232619, "method2_id": 20080077, "code1": "public void testStorageStringWriter () throws Exception {\n    TranslationResponseInMemory r = new TranslationResponseInMemory (2048, \"UTF-8\");\n    {\n        Writer w = r.getWriter ();\n        w.write (\"This is an example\");\n        w.write (\" and another one.\");\n        w.flush ();\n        assertEquals (\"This is an example and another one.\", r.getText ());\n    } {\n        InputStream input = r.getInputStream ();\n        StringWriter writer = new StringWriter ();\n        try {\n            IOUtils.copy (input, writer, \"UTF-8\");\n        } finally {\n            input.close ();\n            writer.close ();\n        }\n        assertEquals (\"This is an example and another one.\", writer.toString ());\n    } try {\n        r.getOutputStream ();\n        fail (\"Is not allowed as you already called getWriter().\");\n    } catch (IOException e) {\n    }\n    {\n        Writer output = r.getWriter ();\n        output.write (\" and another line\");\n        output.write (\" and write some more\");\n        assertEquals (\"This is an example and another one. and another line and write some more\", r.getText ());\n    } {\n        r.addText (\" and some more.\");\n        assertEquals (\"This is an example and another one. and another line and write some more and some more.\", r.getText ());\n    } r.setEndState (ResponseStateOk.getInstance ());\n    assertEquals (ResponseStateOk.getInstance (), r.getEndState ());\n    try {\n        r.getWriter ();\n        fail (\"Previous line should throw IOException as result closed.\");\n    } catch (IOException e) {\n    }\n}\n", "code2": "public Writer createWriter (File outfile, String encoding) throws UnsupportedEncodingException, IOException {\n    int k_blockSize = 1024;\n    int byteCount;\n    char [] buf = new char [k_blockSize];\n    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (outfile));\n    zos.setMethod (ZipOutputStream.DEFLATED);\n    OutputStreamWriter osw = new OutputStreamWriter (zos, \"ISO-8859-1\");\n    BufferedWriter bw = new BufferedWriter (osw);\n    ZipEntry zot;\n    ZipInputStream zis = new ZipInputStream (new FileInputStream (infile));\n    InputStreamReader isr = new InputStreamReader (zis, \"ISO-8859-1\");\n    BufferedReader br = new BufferedReader (isr);\n    ZipEntry zit;\n    while ((zit = zis.getNextEntry ()) != null) {\n        if (zit.getName ().equals (\"content.xml\")) {\n            continue;\n        }\n        zot = new ZipEntry (zit.getName ());\n        zos.putNextEntry (zot);\n        while ((byteCount = br.read (buf, 0, k_blockSize)) >= 0) bw.write (buf, 0, byteCount);\n\n        bw.flush ();\n        zos.closeEntry ();\n    }\n    zos.putNextEntry (new ZipEntry (\"content.xml\"));\n    bw.flush ();\n    return new OutputStreamWriter (zos, \"UTF-8\");\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 951388, "method2_id": 3551901, "code1": "public static void zipFile (String file, String entry) throws IOException {\n    FileInputStream in = new FileInputStream (file);\n    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (file + \".zip\"));\n    out.putNextEntry (new ZipEntry (entry));\n    byte [] buffer = new byte [4096];\n    int bytes_read;\n    while ((bytes_read = in.read (buffer)) != - 1) out.write (buffer, 0, bytes_read);\n\n    in.close ();\n    out.closeEntry ();\n    out.close ();\n    File fin = new File (file);\n    fin.delete ();\n}\n", "code2": "public void run () {\n    final ProgressIndicator progressIndicator = ProgressManager.getInstance ().getProgressIndicator ();\n    final String zipFileName = zipFileNameField.getText ();\n    final List < List < String > > rawFilesToZip = QuickZipHelper.getFilesStructureToZip (myProject, mySelectedFragments);\n    int totalFilesAndFolders = 0;\n    for (final List < String > loopData : rawFilesToZip) {\n        totalFilesAndFolders += loopData.size ();\n    }\n    try {\n        final ZipOutputStream outputStream = new ZipOutputStream (new FileOutputStream (zipFileName));\n        outputStream.setMethod (ZipOutputStream.DEFLATED);\n        outputStream.setComment (\"Zip file created by QuickZip\");\n        int filesZipped = 0;\n        for (final List < String > loopData : rawFilesToZip) {\n            boolean firstEntryProcessed = false;\n            int prefixLengthToSkip = 0;\n            for (final String loopFileName : loopData) {\n                progressIndicator.setFraction ((1.0 * filesZipped) / totalFilesAndFolders);\n                progressIndicator.setText2 (QuickZipBundle.message (\"title.quick-zip.zip-message\", loopFileName));\n                if (! firstEntryProcessed) {\n                    prefixLengthToSkip = loopFileName.lastIndexOf (\"/\") + 1;\n                    firstEntryProcessed = true;\n                } else {\n                    final File loopFile = new File (loopFileName);\n                    if (loopFile.isFile ()) {\n                        final String zipEntryPath = loopFileName.substring (prefixLengthToSkip);\n                        final byte [] buf = new byte [1024];\n                        outputStream.putNextEntry (new ZipEntry (zipEntryPath));\n                        final FileInputStream loopInputStream = new FileInputStream (loopFile);\n                        int len;\n                        while ((len = loopInputStream.read (buf)) > 0) {\n                            outputStream.write (buf, 0, len);\n                        }\n                        outputStream.closeEntry ();\n                        loopInputStream.close ();\n                    }\n                }\n                filesZipped ++;\n            }\n        }\n        outputStream.close ();\n    } catch (Exception ex) {\n        Messages.showErrorDialog (myProject, ex.getMessage (), \"Error\");\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1008332, "method2_id": 9845518, "code1": "public void copyFileToFileWithPaths (String sourcePath, String destinPath) throws Exception {\n    BufferedInputStream in = null;\n    BufferedOutputStream out = null;\n    byte dataBuff [] = new byte [bufferSize];\n    File file1 = new File (sourcePath);\n    if (file1.exists () && (file1.isFile ())) {\n        File file2 = new File (destinPath);\n        if (file2.exists ()) {\n            file2.delete ();\n        }\n        FileUtils.getInstance ().createDirectory (file2.getParent ());\n        in = new BufferedInputStream (new FileInputStream (sourcePath), bufferSize);\n        out = new BufferedOutputStream (new FileOutputStream (destinPath), bufferSize);\n        int readLen;\n        while ((readLen = in.read (dataBuff)) > 0) {\n            out.write (dataBuff, 0, readLen);\n        }\n        out.flush ();\n        in.close ();\n        out.close ();\n    } else {\n        throw new Exception (\"Source file not exist ! sourcePath = (\" + sourcePath + \")\");\n    }\n}\n", "code2": "public String convertContent (InputStream inputStream, String encoding) throws IOException {\n    StringWriter writer = new StringWriter ();\n    InputStreamReader in = new InputStreamReader (inputStream, encoding);\n    IOUtils.copy (in, writer);\n    return writer.toString ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9885444, "method2_id": 22144692, "code1": "public static long createCRC32Checksum (InputStream in) throws IOException {\n    byte [] buf = new byte [BUFFER_SIZE];\n    int length = - 1;\n    CRC32 crc = new CRC32 ();\n    while ((length = in.read (buf)) > 0) {\n        crc.update (buf, 0, length);\n    }\n    long checksum = crc.getValue ();\n    return checksum;\n}\n", "code2": "private int crc32Hash (byte [] key) {\n    CRC32 checksum = new CRC32 ();\n    checksum.update (key);\n    long crc = checksum.getValue ();\n    return (int) crc;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10851, "method2_id": 6217449, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private void copyFile (File source) throws IOException {\n    File backup = new File (source.getCanonicalPath () + \".backup\");\n    if (! backup.exists ()) {\n        FileChannel srcChannel = new FileInputStream (source).getChannel ();\n        backup.createNewFile ();\n        FileChannel dstChannel = new FileOutputStream (backup).getChannel ();\n        dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n        srcChannel.close ();\n        dstChannel.close ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8990219, "method2_id": 16000121, "code1": "private boolean getCached (Get g) throws IOException {\n    boolean ret = false;\n    File f = getCachedFile (g);\n    if (f.exists ()) {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream (f);\n            os = new FileOutputStream (getDestFile (g));\n            int read;\n            byte [] buffer = new byte [4096];\n            while ((read = is.read (buffer)) > 0) {\n                os.write (buffer, 0, read);\n            }\n            ret = true;\n        } finally {\n            if (is != null) is.close ();\n\n            if (os != null) os.close ();\n\n            is = null;\n            os = null;\n        }\n    }\n    return ret;\n}\n", "code2": "public void invoke (InputStream is) throws AgentException {\n    try {\n        addHeader (\"Content-Type\", \"application/zip\");\n        addHeader (\"Content-Length\", String.valueOf (is.available ()));\n        connection.setDoOutput (true);\n        connection.connect ();\n        OutputStream os = connection.getOutputStream ();\n        boolean success = false;\n        try {\n            IOUtils.copy (is, os);\n            success = true;\n        } finally {\n            try {\n                os.flush ();\n                os.close ();\n            } catch (IOException x) {\n                if (success) throw x;\n\n            }\n        }\n        connection.disconnect ();\n        if (connection.getResponseCode () != HttpURLConnection.HTTP_OK) {\n            throw new AgentException (\"Failed to execute REST call at \" + connection.getURL () + \": \" + connection.getResponseCode () + \" \" + connection.getResponseMessage ());\n        }\n    } catch (ConnectException e) {\n        throw new AgentException (\"Failed to connect to beehive at \" + connection.getURL ());\n    } catch (IOException e) {\n        throw new AgentException (\"Failed to connect to beehive\", e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 12150042, "method2_id": 23647101, "code1": "private static void encrypt (SecretKey key, InputStream in, OutputStream out) throws AesEncryptionException {\n    byte [] buf = new byte [1024];\n    try {\n        Cipher cipher = Cipher.getInstance (algorithm);\n        cipher.init (Cipher.ENCRYPT_MODE, key);\n        out = new CipherOutputStream (out, cipher);\n        int numRead = 0;\n        while ((numRead = in.read (buf)) >= 0) {\n            out.write (buf, 0, numRead);\n        }\n    } catch (Exception e) {\n        throw new AesEncryptionException (e);\n    }\n}\n", "code2": "public void encodePassword (File fromFile, File toFile, char [] password) {\n    PBEKeySpec pbeKeySpec;\n    PBEParameterSpec pbeParamSpec;\n    SecretKeyFactory keyFac;\n    SecretKey pbeKey;\n    Cipher pbeCipher = null;\n    byte [] salt = {(byte) 0xc7, (byte) 0x73, (byte) 0x21, (byte) 0x8c, (byte) 0x7e, (byte) 0xc8, (byte) 0xee, (byte) 0x99};\n    int count = 20;\n    pbeParamSpec = new PBEParameterSpec (salt, count);\n    pbeKeySpec = new PBEKeySpec (password);\n    try {\n        keyFac = SecretKeyFactory.getInstance (\"PBEWithMD5AndDES\");\n        pbeKey = keyFac.generateSecret (pbeKeySpec);\n        pbeCipher = Cipher.getInstance (\"PBEWithMD5AndDES\");\n        pbeCipher.init (Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);\n    } catch (Exception e) {\n        e.printStackTrace ();\n        return;\n    }\n    InputStream in = null;\n    OutputStream out = null;\n    try {\n        in = new BufferedInputStream (new FileInputStream (fromFile));\n        out = new CipherOutputStream (new BufferedOutputStream (new FileOutputStream (toFile)), pbeCipher);\n        byte [] rbuffer = new byte [2056];\n        int rcount = in.read (rbuffer);\n        while (rcount > 0) {\n            out.write (rbuffer, 0, rcount);\n            rcount = in.read (rbuffer);\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    } finally {\n        if (in != null) {\n            try {\n                in.close ();\n            } catch (IOException ioe) {\n            }\n        }\n        if (out != null) {\n            try {\n                out.close ();\n            } catch (IOException ioe) {\n            }\n        }\n    }\n    System.out.println (\"Success: \" + toFile.getName () + \" generated.\");\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 7954779, "method2_id": 20725036, "code1": "public void filter (File source, File destination, MNamespace mNamespace) throws Exception {\n    BufferedReader reader = new BufferedReader (new FileReader (source));\n    BufferedWriter writer = new BufferedWriter (new FileWriter (destination));\n    int line = 0;\n    int column = 0;\n    Stack parseStateStack = new Stack ();\n    parseStateStack.push (new ParseState (mNamespace));\n    for (Iterator i = codePieces.iterator ();\n    i.hasNext ();) {\n        NamedCodePiece cp = (NamedCodePiece) i.next ();\n        while (line < cp.getStartLine ()) {\n            line ++;\n            column = 0;\n            writer.write (reader.readLine ());\n            writer.newLine ();\n        }\n        while (column < cp.getStartPosition ()) {\n            writer.write (reader.read ());\n            column ++;\n        }\n        cp.write (writer, parseStateStack, column);\n        while (line < cp.getEndLine ()) {\n            line ++;\n            column = 0;\n            reader.readLine ();\n        }\n        while (column < cp.getEndPosition ()) {\n            column ++;\n            reader.read ();\n        }\n    }\n    String data;\n    while ((data = reader.readLine ()) != null) {\n        writer.write (data);\n        writer.newLine ();\n    }\n    reader.close ();\n    writer.close ();\n}\n", "code2": "private static void copyFile (File sourceFile, File destFile) throws IOException {\n    if (! destFile.exists ()) {\n        destFile.createNewFile ();\n    }\n    FileChannel source = null;\n    FileChannel destination = null;\n    try {\n        source = new FileInputStream (sourceFile).getChannel ();\n        destination = new FileOutputStream (destFile).getChannel ();\n        destination.transferFrom (source, 0, source.size ());\n    } finally {\n        if (source != null) {\n            source.close ();\n        }\n        if (destination != null) {\n            destination.close ();\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 13397214, "method2_id": 21858888, "code1": "private static void doZip (ZipOutputStream out, File f, String base, FilenameFilter filter) throws Exception {\n    if (f.isDirectory ()) {\n        File [] fl = f.listFiles (filter);\n        out.putNextEntry (new ZipEntry (base + \"/\"));\n        base = base.length () == 0 ? \"\" : base + \"/\";\n        for (int i = 0;\n        i < fl.length; i ++) {\n            doZip (out, fl [i], base + fl [i].getName (), filter);\n        }\n    } else {\n        out.putNextEntry (new ZipEntry (base));\n        FileInputStream in = new FileInputStream (f);\n        int b;\n        System.out.println (base);\n        while ((b = in.read ()) != - 1) {\n            out.write (b);\n        }\n        in.close ();\n    }\n}\n", "code2": "private static void zipDirectory (String dir2zip, ZipOutputStream zos, String zipPath) throws IOException, IllegalArgumentException {\n    File zipDir = new File (dir2zip);\n    String [] dirList = zipDir.list ();\n    byte [] readBuffer = new byte [2156];\n    int bytesIn = 0;\n    for (int i = 0;\n    i < dirList.length; i ++) {\n        File f = new File (zipDir, dirList [i]);\n        if (f.isDirectory ()) {\n            String filePath = f.getPath ();\n            zipDirectory (filePath, zos, zipPath);\n            continue;\n        }\n        FileInputStream fis = new FileInputStream (f);\n        String path = f.getPath ().substring (zipPath.length ());\n        ZipEntry anEntry = new ZipEntry (path);\n        zos.putNextEntry (anEntry);\n        while ((bytesIn = fis.read (readBuffer)) != - 1) {\n            zos.write (readBuffer, 0, bytesIn);\n        }\n        fis.close ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 7385, "method2_id": 59328, "code1": "private File waehleDatei (String msg) {\n    JFileChooser fc = new JFileChooser ();\n    fc.setApproveButtonText (msg);\n    int returnVal = fc.showOpenDialog (null);\n    if (returnVal == JFileChooser.APPROVE_OPTION) return fc.getSelectedFile ();\n    else return null;\n\n}\n", "code2": "private void openSaveFileActionPerformed (java.awt.event.ActionEvent evt) {\n    if (evt.getSource () == openSaveFile) {\n        int returnVal = fc.showOpenDialog (ParameterSolutions.this);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            File savedFile = fc.getSelectedFile ();\n            log.append (\"Opening: \" + savedFile.getName () + \"\\n\");\n            String name = savedFile.getName ();\n            if (! savedFile.canRead () || ! ((name.substring (name.length () - 4, name.length ()).equals (\".cpm\"))) || ! recoverSavedData (savedFile)) {\n                log.append (\"That is not a valid saved file, please choose\" + \" a file previously saved in this program.\\n\");\n            }\n        } else {\n            log.append (\"Dialog Cancelled by User.\\n\");\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3613198, "method2_id": 10303667, "code1": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n", "code2": "@Override\npublic void copy (final String fileName) throws FileIOException {\n    final long savedCurrentPositionInFile = currentPositionInFile;\n    if (opened) {\n        closeImpl ();\n    }\n    final FileInputStream fis;\n    try {\n        fis = new FileInputStream (file);\n    } catch (FileNotFoundException exception) {\n        throw HELPER_FILE_UTIL.fileIOException (FAILED_OPEN + file, file, exception);\n    }\n    final File destinationFile = new File (fileName);\n    final FileOutputStream fos;\n    try {\n        fos = new FileOutputStream (destinationFile);\n    } catch (FileNotFoundException exception) {\n        throw HELPER_FILE_UTIL.fileIOException (FAILED_OPEN + destinationFile, destinationFile, exception);\n    }\n    try {\n        final byte [] buf = new byte [1024];\n        int readLength = 0;\n        while ((readLength = fis.read (buf)) != - 1) {\n            fos.write (buf, 0, readLength);\n        }\n    } catch (IOException exception) {\n        throw HELPER_FILE_UTIL.fileIOException (\"failed copy from \" + file + \" to \" + destinationFile, null, exception);\n    } finally {\n        try {\n            if (fis != null) {\n                fis.close ();\n            }\n        } catch (Exception exception) {\n        }\n        try {\n            if (fos != null) {\n                fos.close ();\n            }\n        } catch (Exception exception) {\n        }\n    }\n    if (opened) {\n        openImpl ();\n        seek (savedCurrentPositionInFile);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 7052764, "method2_id": 11056082, "code1": "public static void zipFile (String filename, ZipOutputStream zos, String zipname) {\n    try {\n        byte [] readBuffer = new byte [1024];\n        int bytesIn = 0;\n        File f = new File (filename);\n        if (f.isDirectory ()) {\n            return;\n        }\n        FileInputStream fis = new FileInputStream (f);\n        ZipEntry anEntry = new ZipEntry (zipname);\n        zos.putNextEntry (anEntry);\n        while ((bytesIn = fis.read (readBuffer)) != - 1) {\n            zos.write (readBuffer, 0, bytesIn);\n        }\n        fis.close ();\n    } catch (Exception ex) {\n        ex.printStackTrace ();\n    }\n}\n", "code2": "private boolean archiveDirectoryTo (String destination, String pathPrefix) {\n    File destinationFile = prepareDestinationArchive (destination);\n    if (destinationFile == null) {\n        return false;\n    }\n    JarOutputStream outputStream;\n    try {\n        outputStream = new JarOutputStream (new FileOutputStream (destinationFile));\n    } catch (FileNotFoundException e) {\n        Log.error (TAG, \"Could not create JarOutputStream: \" + e.getMessage ());\n        return false;\n    } catch (IOException e) {\n        Log.error (TAG, \"Could not create JarOutputStream: \" + e.getMessage ());\n        return false;\n    }\n    String basePath = getAbsolutePath ();\n    UniversalFile [] filesToArchive = listFilesRecursively ();\n    try {\n        for (UniversalFile fileToArchive : filesToArchive) {\n            String path = fileToArchive.getAbsolutePath ();\n            if (! path.startsWith (basePath)) {\n                Log.error (TAG, \"Internal error: File in directory has wrong path:\");\n                Log.error (TAG, \"Base path: \" + basePath);\n                Log.error (TAG, \"File path: \" + path);\n                return false;\n            }\n            path = path.substring (basePath.length () + 1);\n            String entryPath = (pathPrefix + path).replace ('\\\\', '/');\n            outputStream.putNextEntry (new ZipEntry (entryPath));\n            outputStream.write (fileToArchive.getFileAsBytes ());\n        }\n        outputStream.close ();\n        return true;\n    } catch (IOException e) {\n        Log.error (TAG, \"Could not write to archive: \" + e.getMessage ());\n    }\n    return false;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6288459, "method2_id": 7495800, "code1": "private static void createCompoundData (String dir, String type) {\n    try {\n        Set s = new HashSet ();\n        File nouns = new File (dir + \"index.\" + type);\n        FileInputStream fis = new FileInputStream (nouns);\n        InputStreamReader reader = new InputStreamReader (fis);\n        StringBuffer sb = new StringBuffer ();\n        int chr = reader.read ();\n        while (chr >= 0) {\n            if (chr == '\\n' || chr == '\\r') {\n                String line = sb.toString ();\n                if (line.length () > 0) {\n                    String [] spaceSplit = PerlHelp.split (line);\n                    for (int i = 0;\n                    i < spaceSplit.length; i ++) {\n                        if (spaceSplit [i].indexOf ('_') >= 0) {\n                            s.add (spaceSplit [i].replace ('_', ' '));\n                        }\n                    }\n                }\n                sb.setLength (0);\n            } else {\n                sb.append ((char) chr);\n            }\n            chr = reader.read ();\n        }\n        System.out.println (type + \" size=\" + s.size ());\n        File output = new File (dir + \"compound.\" + type + \"s.gz\");\n        FileOutputStream fos = new FileOutputStream (output);\n        GZIPOutputStream gzos = new GZIPOutputStream (new BufferedOutputStream (fos));\n        PrintWriter writer = new PrintWriter (gzos);\n        writer.println (\"# This file was extracted from WordNet data, the following copyright notice\");\n        writer.println (\"# from WordNet is attached.\");\n        writer.println (\"#\");\n        writer.println (\"#  This software and database is being provided to you, the LICENSEE, by  \");\n        writer.println (\"#  Princeton University under the following license.  By obtaining, using  \");\n        writer.println (\"#  and/or copying this software and database, you agree that you have  \");\n        writer.println (\"#  read, understood, and will comply with these terms and conditions.:  \");\n        writer.println (\"#  \");\n        writer.println (\"#  Permission to use, copy, modify and distribute this software and  \");\n        writer.println (\"#  database and its documentation for any purpose and without fee or  \");\n        writer.println (\"#  royalty is hereby granted, provided that you agree to comply with  \");\n        writer.println (\"#  the following copyright notice and statements, including the disclaimer,  \");\n        writer.println (\"#  and that the same appear on ALL copies of the software, database and  \");\n        writer.println (\"#  documentation, including modifications that you make for internal  \");\n        writer.println (\"#  use or for distribution.  \");\n        writer.println (\"#  \");\n        writer.println (\"#  WordNet 1.7 Copyright 2001 by Princeton University.  All rights reserved. \");\n        writer.println (\"#  \");\n        writer.println (\"#  THIS SOFTWARE AND DATABASE IS PROVIDED \\\"AS IS\\\" AND PRINCETON  \");\n        writer.println (\"#  UNIVERSITY MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR  \");\n        writer.println (\"#  IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PRINCETON  \");\n        writer.println (\"#  UNIVERSITY MAKES NO REPRESENTATIONS OR WARRANTIES OF MERCHANT-  \");\n        writer.println (\"#  ABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE  \");\n        writer.println (\"#  OF THE LICENSED SOFTWARE, DATABASE OR DOCUMENTATION WILL NOT  \");\n        writer.println (\"#  INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR \");\n        writer.println (\"#  OTHER RIGHTS. \");\n        writer.println (\"#  \");\n        writer.println (\"#  The name of Princeton University or Princeton may not be used in\");\n        writer.println (\"#  advertising or publicity pertaining to distribution of the software\");\n        writer.println (\"#  and/or database.  Title to copyright in this software, database and\");\n        writer.println (\"#  any associated documentation shall at all times remain with\");\n        writer.println (\"#  Princeton University and LICENSEE agrees to preserve same.  \");\n        for (Iterator i = s.iterator ();\n        i.hasNext ();) {\n            String mwe = (String) i.next ();\n            writer.println (mwe);\n        }\n        writer.close ();\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static void copyFile (File fromFile, File toFile) throws IOException {\n    FileReader from = new FileReader (fromFile);\n    FileWriter to = new FileWriter (toFile);\n    char [] buffer = new char [4096];\n    int bytes_read;\n    while ((bytes_read = from.read (buffer)) != - 1) {\n        to.write (buffer, 0, bytes_read);\n    }\n    to.flush ();\n    to.close ();\n    from.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 621362, "method2_id": 1189509, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "public void testRoundTrip_1 (String resource) throws Exception {\n    long start1 = System.currentTimeMillis ();\n    File originalFile = File.createTempFile (\"RoundTripTest\", \"testRoundTrip_1\");\n    FileOutputStream fos = new FileOutputStream (originalFile);\n    IOUtils.copy (getClass ().getResourceAsStream (resource), fos);\n    fos.close ();\n    long start2 = System.currentTimeMillis ();\n    IsoFile isoFile = new IsoFile (new FileInputStream (originalFile).getChannel ());\n    long start3 = System.currentTimeMillis ();\n    ByteArrayOutputStream baos = new ByteArrayOutputStream ();\n    WritableByteChannel wbc = Channels.newChannel (baos);\n    long start4 = System.currentTimeMillis ();\n    Walk.through (isoFile);\n    long start5 = System.currentTimeMillis ();\n    isoFile.getBox (wbc);\n    wbc.close ();\n    long start6 = System.currentTimeMillis ();\n    System.err.println (\"Preparing tmp copy took: \" + (start2 - start1) + \"ms\");\n    System.err.println (\"Parsing took           : \" + (start3 - start2) + \"ms\");\n    System.err.println (\"Writing took           : \" + (start6 - start3) + \"ms\");\n    System.err.println (\"Walking took           : \" + (start5 - start4) + \"ms\");\n    byte [] a = IOUtils.toByteArray (getClass ().getResourceAsStream (resource));\n    byte [] b = baos.toByteArray ();\n    Assert.assertArrayEquals (a, b);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9339937, "method2_id": 21308543, "code1": "public FileReader (String filePath, Configuration aConfiguration) throws IOException {\n    file = new File (URLDecoder.decode (filePath, \"UTF-8\")).getCanonicalFile ();\n    readerConf = aConfiguration;\n    if (file.isDirectory ()) {\n        File indexFile = new File (file, \"index.php\");\n        File indexFile_1 = new File (file, \"index.html\");\n        if (indexFile.exists () && ! indexFile.isDirectory ()) {\n            file = indexFile;\n        } else if (indexFile_1.exists () && ! indexFile_1.isDirectory ()) {\n            file = indexFile_1;\n        } else {\n            if (! readerConf.getOption (\"showFolders\").equals (\"Yes\")) {\n                makeErrorPage (503, \"Permision denied\");\n            } else {\n                FileOutputStream out = new FileOutputStream (readerConf.getOption (\"wwwPath\") + \"/temp/temp.php\");\n                File [] files = file.listFiles ();\n                makeHeader (200, - 1, new Date (System.currentTimeMillis ()).toString (), \"text/html\");\n                String title = \"Index of \" + file;\n                out.write ((\"<html><head><title>\" + title + \"</title></head><body><h3>Index of \" + file + \"</h3><p>\\n\").getBytes ());\n                for (int i = 0;\n                i < files.length; i ++) {\n                    file = files [i];\n                    String filename = file.getName ();\n                    String description = \"\";\n                    if (file.isDirectory ()) {\n                        description = \"&lt;DIR&gt;\";\n                    }\n                    out.write ((\"<a href=\\\"\" + file.getPath ().substring (readerConf.getOption (\"wwwPath\").length ()) + \"\\\">\" + filename + \"</a> \" + description + \"<br>\\n\").getBytes ());\n                }\n                out.write ((\"</p><hr><p>yawwwserwer</p></body><html>\").getBytes ());\n                file = new File (URLDecoder.decode (readerConf.getOption (\"wwwPath\") + \"/temp/temp.php\", \"UTF-8\")).getCanonicalFile ();\n            }\n        }\n\n    } else if (! file.exists ()) {\n        makeErrorPage (404, \"File Not Found.\");\n    } else if (getExtension () == \".exe\" || getExtension ().contains (\".py\")) {\n        FileOutputStream out = new FileOutputStream (readerConf.getOption (\"wwwPath\") + \"/temp/temp.php\");\n        out.write ((runCommand (filePath)).getBytes ());\n        file = new File (URLDecoder.decode (readerConf.getOption (\"wwwPath\") + \"/temp/temp.php\", \"UTF-8\")).getCanonicalFile ();\n    } else {\n        System.out.println (getExtension ());\n        makeHeader (200, file.length (), new Date (file.lastModified ()).toString (), TYPES.get (getExtension ()).toString ());\n    }\n\n    System.out.println (file);\n}\n", "code2": "private static void copyFile (String src, String target) throws IOException {\n    FileChannel ic = new FileInputStream (src).getChannel ();\n    FileChannel oc = new FileOutputStream (target).getChannel ();\n    ic.transferTo (0, ic.size (), oc);\n    ic.close ();\n    oc.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 12649112, "method2_id": 22948678, "code1": "private static void dumpUrl (URL url) throws IOException {\n    BufferedReader reader = new BufferedReader (new InputStreamReader (url.openStream ()));\n    String s = reader.readLine ();\n    while (s != null) {\n        System.out.println (s);\n        s = reader.readLine ();\n    }\n    reader.close ();\n}\n", "code2": "public void load () throws ResourceInstantiationException, InvalidFormatException {\n    if (null == url) {\n        throw new ResourceInstantiationException (\"URL not set (null).\");\n    }\n    try {\n        BufferedReader mapReader = new BomStrippingInputStreamReader ((url).openStream (), ENCODING);\n        String line;\n        MappingNode node;\n        while (null != (line = mapReader.readLine ())) {\n            if (0 != line.trim ().length ()) {\n                node = new MappingNode (line);\n                this.add (node);\n            }\n        }\n        mapReader.close ();\n    } catch (InvalidFormatException ife) {\n        throw new InvalidFormatException (url, \"on load\");\n    } catch (IOException ioe) {\n        throw new ResourceInstantiationException (ioe);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8665323, "method2_id": 18998637, "code1": "public String GetMemberName (String id) {\n    String name = null;\n    try {\n        String line;\n        URL url = new URL (intvasmemberDeatails + \"?CID=\" + id);\n        URLConnection connection = url.openConnection ();\n        BufferedReader reader = new BufferedReader (new InputStreamReader (connection.getInputStream ()));\n        while ((line = reader.readLine ()) != null) {\n            name = line;\n        }\n    } catch (MalformedURLException e) {\n        e.printStackTrace ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n    String [] parts = name.split (\" \");\n    rating = parts [2];\n    return parts [0] + \" \" + parts [1];\n}\n", "code2": "public boolean loadResource (String resourcePath) {\n    try {\n        URL url = Thread.currentThread ().getContextClassLoader ().getResource (resourcePath);\n        if (url == null) {\n            logger.error (\"Cannot find the resource named: '\" + resourcePath + \"'. Failed to load the keyword list.\");\n            return false;\n        }\n        InputStreamReader isr = new InputStreamReader (url.openStream ());\n        BufferedReader br = new BufferedReader (isr);\n        String ligne = br.readLine ();\n        while (ligne != null) {\n            if (! contains (ligne.toUpperCase ())) {\n                addLast (ligne.toUpperCase ());\n            }\n            ligne = br.readLine ();\n        }\n        return true;\n    } catch (IOException ioe) {\n        logger.log (Level.ERROR, \"Cannot load default SQL keywords file.\", ioe);\n    }\n    return false;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4716110, "method2_id": 12543783, "code1": "public static void copyFile (File in, File out) throws Exception {\n    FileChannel sourceChannel = new FileInputStream (in).getChannel ();\n    FileChannel destinationChannel = new FileOutputStream (out).getChannel ();\n    sourceChannel.transferTo (0, sourceChannel.size (), destinationChannel);\n    sourceChannel.close ();\n    destinationChannel.close ();\n}\n", "code2": "private boolean copy (File in, File out) {\n    try {\n        FileInputStream fis = new FileInputStream (in);\n        FileOutputStream fos = new FileOutputStream (out);\n        FileChannel readableChannel = fis.getChannel ();\n        FileChannel writableChannel = fos.getChannel ();\n        writableChannel.truncate (0);\n        writableChannel.transferFrom (readableChannel, 0, readableChannel.size ());\n        fis.close ();\n        fos.close ();\n        return true;\n    } catch (IOException ioe) {\n        System.out.println (\"Copy Error: IOException during copy\\r\\n\" + ioe.getMessage ());\n        return false;\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 11548511, "method2_id": 18464490, "code1": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n", "code2": "@Override\npublic void actionPerformed (ActionEvent e) {\n    if (copiedFiles_ != null) {\n        File [] tmpFiles = new File [copiedFiles_.length];\n        File tmpDir = new File (Settings.getPropertyString (ConstantKeys.project_dir), \"tmp/\");\n        tmpDir.mkdirs ();\n        for (int i = copiedFiles_.length - 1;\n        i >= 0; i --) {\n            Frame f = FrameManager.getInstance ().getFrameAtIndex (i);\n            try {\n                File in = f.getFile ();\n                File out = new File (tmpDir, f.getFile ().getName ());\n                FileChannel inChannel = new FileInputStream (in).getChannel ();\n                FileChannel outChannel = new FileOutputStream (out).getChannel ();\n                inChannel.transferTo (0, inChannel.size (), outChannel);\n                if (inChannel != null) inChannel.close ();\n\n                if (outChannel != null) outChannel.close ();\n\n                tmpFiles [i] = out;\n            } catch (IOException e1) {\n                e1.printStackTrace ();\n            }\n        }\n        try {\n            FrameManager.getInstance ().insertFrames (getTable ().getSelectedRow (), FrameManager.INSERT_TYPE.MOVE, tmpFiles);\n        } catch (IOException e1) {\n            e1.printStackTrace ();\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2241900, "method2_id": 21947196, "code1": "public static String hashMD5 (String entrada) {\n    MessageDigest m;\n    try {\n        m = MessageDigest.getInstance (\"MD5\");\n        m.update (entrada.getBytes (), 0, entrada.length ());\n        return new BigInteger (1, m.digest ()).toString (16);\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace ();\n    }\n    return null;\n}\n", "code2": "public synchronized String encrypt (final String pPassword) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    final MessageDigest md = MessageDigest.getInstance (\"SHA\");\n    md.update (pPassword.getBytes (\"UTF-8\"));\n    final byte raw [] = md.digest ();\n    return BASE64Encoder.encodeBuffer (raw);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 37044, "method2_id": 14652853, "code1": "public static void main (String [] args) {\n    String fe = null, fk = null, f1 = null, f2 = null;\n    DecimalFormat df = new DecimalFormat (\"000\");\n    int key = 0;\n    int i = 1;\n    for (;;) {\n        System.out.println (\"===================================================\");\n        System.out.println (\"\\n2009 BME\\tTeam ESC's Compare\\n\");\n        System.out.println (\"===================================================\\n\");\n        System.out.println (\"\t*** Menu ***\\n\");\n        System.out.println (\"1. Fajlok osszehasonlitasa\");\n        System.out.println (\"2. Hasznalati utasitas\");\n        System.out.println (\"3. Kilepes\");\n        System.out.print (\"\\nKivalasztott menu szama: \");\n        BufferedReader reader = new BufferedReader (new InputStreamReader (System.in));\n        try {\n            key = reader.read ();\n            switch (key) {\n                case '3' :\n                    System.exit (0);\n                    break;\n                case '2' :\n                    System.out.println (\"\\n @author Bedo Zotlan - F3VFDE\");\n                    System.out.println (\"Team ESC's Compare\");\n                    System.out.println (\"2009.\");\n                    System.out.println ();\n                    System.out.println (\"(1) A program ket fajl osszahesonlitasat vegzi. A fajloknak a program gyokerkonyvtaraban kell lenniuk!\");\n                    System.out.println (\"(2) A menubol ertelem szeruen valasztunk az opciok kozul, majd a program keresere megadjuk a ket osszehasonlitando \" + \"fajl nevet kiterjesztessel egyutt, kulonben hibat kapunk!\");\n                    System.out.println (\"(3) Miutan elvegeztuk az osszehasonlitasokat a program mindegyiket kimenti a compare_xxx.txt fajlba, azonban ha kilepunk a programbol, \" + \"majd utana ismet elinditjuk es elkezdunk osszehasonlitasokat vegezni, akkor felulirhatja \" + \"az elozo futtatasbol kapott fajlainkat, erre kulonosen figyelni kell!\");\n                    System.out.println (\"(4) A kimeneti compare_xxx.txt fajlon kivul minden egyes osszehasonlitott fajlrol csinal egy <fajl neve>.<fajl kiterjesztese>.numbered \" + \"nevu fajlt, ami annyiban ter el az eredeti fajloktol, hogy soronkent sorszamozva vannak!\");\n                    System.out.println (\"(5) Egy nem ures es egy ures fajl osszehasonlitasa utan azt az eredmenyt kapjuk, hogy \\\"OK, megyezenek!\\\". Ez termeszetesen hibas\" + \" es a kimeneti fajlunk is ures lesz. Ezt szinten keruljuk el, ne hasonlitsunk ures fajlokhoz mas fajlokat!\");\n                    System.out.println (\"(6) A fajlok megtekintesehez Notepad++ 5.0.0 verzioja ajanlott legalabb!\\n\");\n                    break;\n                case '1' :\n                    {\n                        System.out.print (\"\\nAz etalon adatokat tartalmazo fajl neve: \");\n                        try {\n                            int lnNo = 1;\n                            BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n                            String inFileName = br.readLine ();\n                            BufferedReader bin = new BufferedReader (new FileReader (inFileName));\n                            BufferedWriter bout = new BufferedWriter (new FileWriter (inFileName + \".numbered\"));\n                            fe = (inFileName + \".numbered\");\n                            f1 = inFileName;\n                            String aLine;\n                            while ((aLine = bin.readLine ()) != null) bout.write (\"Line \" + df.format (lnNo ++) + \": \" + aLine + \"\\n\");\n\n                            bin.close ();\n                            bout.close ();\n                        } catch (IOException e) {\n                            System.out.println (\"Hibas fajlnev\");\n                        }\n                        System.out.print (\"A kapott adatokat tartalmazo fajl neve: \");\n                        try {\n                            int lnNo = 1;\n                            BufferedReader br = new BufferedReader (new InputStreamReader (System.in));\n                            String inFileName = br.readLine ();\n                            BufferedReader bin = new BufferedReader (new FileReader (inFileName));\n                            BufferedWriter bout = new BufferedWriter (new FileWriter (inFileName + \".numbered\"));\n                            fk = (inFileName + \".numbered\");\n                            f2 = inFileName;\n                            String aLine_k;\n                            while ((aLine_k = bin.readLine ()) != null) bout.write (\"Line \" + df.format (lnNo ++) + \": \" + aLine_k + \"\\n\");\n\n                            bin.close ();\n                            bout.close ();\n                        } catch (IOException e) {\n                            System.out.println (\"Hibas fajlnev\");\n                        }\n                        try {\n                            int lnNo_c = 1;\n                            int mstk = 0;\n                            BufferedReader bin_e = new BufferedReader (new FileReader (fe));\n                            BufferedReader bin_k = new BufferedReader (new FileReader (fk));\n                            BufferedWriter bout = new BufferedWriter (new FileWriter (\"compare_\" + i ++ + \".txt\"));\n                            Calendar actDate = Calendar.getInstance ();\n                            bout.write (\"==================================================\\n\");\n                            bout.write (\"\\n2009 BME\\tTeam ESC's Compare\");\n                            bout.write (\"\\n\" + actDate.get (Calendar.YEAR) + \".\" + (actDate.get (Calendar.MONTH) + 1) + \".\" + actDate.get (Calendar.DATE) + \".\\n\" + actDate.get (Calendar.HOUR) + \":\" + actDate.get (Calendar.MINUTE) + \"\\n\\n\");\n                            bout.write (\"==================================================\\n\");\n                            bout.write (\"Az etalon ertekekkel teli fajl neve: \" + f1 + \"\\n\");\n                            bout.write (\"A kapott ertekekkel teli fajl neve: \" + f2 + \"\\n\\n\");\n                            System.out.println (\"==================================================\\n\");\n                            System.out.println (\"\\n2009 BME\\tTeam ESC's Compare\");\n                            System.out.println (actDate.get (Calendar.YEAR) + \".\" + (actDate.get (Calendar.MONTH) + 1) + \".\" + actDate.get (Calendar.DATE) + \".\\n\" + actDate.get (Calendar.HOUR) + \":\" + actDate.get (Calendar.MINUTE) + \"\\n\");\n                            System.out.println (\"==================================================\\n\");\n                            System.out.println (\"\\nAz etalon ertekekkel teli fajl neve: \" + f1);\n                            System.out.println (\"A kapott ertekekkel teli fajl neve: \" + f2 + \"\\n\");\n                            String aLine_c1 = null, aLine_c2 = null;\n                            File fa = new File (fe);\n                            File fb = new File (fk);\n                            if (fa.length () != fb.length ()) {\n                                bout.write (\"\\nOsszehasonlitas eredmenye: HIBA, nincs egyezes!\\n Kulonbozo meretu fajlok: \" + fa.length () + \" byte illetve \" + fb.length () + \" byte!\\n\");\n                                System.out.println (\"\\nOsszehasonlitas eredmenye: HIBA, nincs egyezes!\\n Kulonbozo meretu fajlok: \" + fa.length () + \" byte illetve \" + fb.length () + \" byte!\\n\");\n                            } else {\n                                while (((aLine_c1 = bin_e.readLine ()) != null) && ((aLine_c2 = bin_k.readLine ()) != null)) if (aLine_c1.equals (aLine_c2)) {\n                                } else {\n                                    mstk ++;\n                                    bout.write (\"#\" + df.format (lnNo_c) + \": HIBA  --> \\t\" + f1 + \" : \" + aLine_c1 + \" \\n\\t\\t\\t\\t\\t\" + f2 + \" : \" + aLine_c2 + \"\\n\");\n                                    System.out.println (\"#\" + df.format (lnNo_c) + \": HIBA  -->\\t \" + f1 + \" : \" + aLine_c1 + \" \\n\\t\\t\\t\" + f2 + \" : \" + aLine_c2 + \"\\n\");\n                                    lnNo_c ++;\n                                }\n\n                                if (mstk != 0) {\n                                    bout.write (\"\\nOsszehasonlitas eredmenye: HIBA, nincs egyezes!\");\n                                    bout.write (\"\\nHibas sorok szama: \" + mstk);\n                                    System.out.println (\"\\nOsszehasonlitas eredmenye: HIBA, nincs egyezes!\");\n                                    System.out.println (\"Hibas sorok szama: \" + mstk);\n                                } else {\n                                    bout.write (\"\\nOsszehasonlitas eredmenye: OK, megegyeznek!\");\n                                    System.out.println (\"\\nOsszehasonlitas eredm\ufffdnye: OK, megegyeznek!\\n\");\n                                }\n                            }\n                            bin_e.close ();\n                            bin_k.close ();\n                            fa.delete ();\n                            fb.delete ();\n                            bout.close ();\n                        } catch (IOException e) {\n                            System.out.println (\"Hibas fajl\");\n                        }\n                        break;\n                    }}\n        } catch (Exception e) {\n            System.out.println (\"A fut\ufffds sor\ufffdn hiba t\ufffdrt\ufffdnt!\");\n        }\n    }\n}\n", "code2": "public static void main (String args []) {\n    String midletClass = null;\n    File appletInputFile = null;\n    File deviceInputFile = null;\n    File midletInputFile = null;\n    File htmlOutputFile = null;\n    File appletOutputFile = null;\n    File deviceOutputFile = null;\n    File midletOutputFile = null;\n    List params = new ArrayList ();\n    for (int i = 0;\n    i < args.length; i ++) {\n        params.add (args [i]);\n    }\n    Iterator argsIterator = params.iterator ();\n    while (argsIterator.hasNext ()) {\n        String arg = (String) argsIterator.next ();\n        argsIterator.remove ();\n        if ((arg.equals (\"--help\")) || (arg.equals (\"-help\"))) {\n            System.out.println (usage ());\n            System.exit (0);\n        } else if (arg.equals (\"--midletClass\")) {\n            midletClass = (String) argsIterator.next ();\n            argsIterator.remove ();\n        } else if (arg.equals (\"--appletInput\")) {\n            appletInputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        } else if (arg.equals (\"--deviceInput\")) {\n            deviceInputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        } else if (arg.equals (\"--midletInput\")) {\n            midletInputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        } else if (arg.equals (\"--htmlOutput\")) {\n            htmlOutputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        } else if (arg.equals (\"--appletOutput\")) {\n            appletOutputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        } else if (arg.equals (\"--deviceOutput\")) {\n            deviceOutputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        } else if (arg.equals (\"--midletOutput\")) {\n            midletOutputFile = new File ((String) argsIterator.next ());\n            argsIterator.remove ();\n        }\n\n    }\n    if (midletClass == null || appletInputFile == null || deviceInputFile == null || midletInputFile == null || htmlOutputFile == null || appletOutputFile == null || deviceOutputFile == null || midletOutputFile == null) {\n        System.out.println (usage ());\n        System.exit (0);\n    }\n    try {\n        DeviceImpl device = null;\n        String descriptorLocation = null;\n        JarFile jar = new JarFile (deviceInputFile);\n        for (Enumeration en = jar.entries ();\n        en.hasMoreElements ();) {\n            String entry = ((JarEntry) en.nextElement ()).getName ();\n            if ((entry.toLowerCase ().endsWith (\".xml\") || entry.toLowerCase ().endsWith (\"device.txt\")) && ! entry.toLowerCase ().startsWith (\"meta-inf\")) {\n                descriptorLocation = entry;\n                break;\n            }\n        }\n        if (descriptorLocation != null) {\n            EmulatorContext context = new EmulatorContext () {\n                private DisplayComponent displayComponent = new NoUiDisplayComponent ();\n                private InputMethod inputMethod = new J2SEInputMethod ();\n                private DeviceDisplay deviceDisplay = new J2SEDeviceDisplay (this);\n                private FontManager fontManager = new J2SEFontManager ();\n                private DeviceComponent deviceComponent = new SwingDeviceComponent (true);\n                public DisplayComponent getDisplayComponent () {\n                    return displayComponent;\n                } public InputMethod getDeviceInputMethod () {\n                    return inputMethod;\n                } public DeviceDisplay getDeviceDisplay () {\n                    return deviceDisplay;\n                } public FontManager getDeviceFontManager () {\n                    return fontManager;\n                } public InputStream getResourceAsStream (String name) {\n                    return MIDletBridge.getCurrentMIDlet ().getClass ().getResourceAsStream (name);\n                } public DeviceComponent getDeviceComponent () {\n                    return deviceComponent;\n                }}\n\n            ;\n            URL [] urls = new URL [1];\n            urls [0] = deviceInputFile.toURI ().toURL ();\n            ClassLoader classLoader = new ExtensionsClassLoader (urls, urls.getClass ().getClassLoader ());\n            device = DeviceImpl.create (context, classLoader, descriptorLocation, J2SEDevice.class);\n        }\n        if (device == null) {\n            System.out.println (\"Error parsing device package: \" + descriptorLocation);\n            System.exit (0);\n        }\n        createHtml (htmlOutputFile, device, midletClass, midletOutputFile, appletOutputFile, deviceOutputFile);\n        createMidlet (midletInputFile.toURI ().toURL (), midletOutputFile);\n        IOUtils.copyFile (appletInputFile, appletOutputFile);\n        IOUtils.copyFile (deviceInputFile, deviceOutputFile);\n    } catch (IOException ex) {\n        ex.printStackTrace ();\n    }\n    System.exit (0);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 19471342, "method2_id": 23247093, "code1": "public static void zipDir (File zipDir, ZipOutputStream zos, File rawdatadir) throws IOException {\n    if (zipDir.isFile ()) {\n        int bytesIn = 0;\n        byte [] readBuffer = new byte [2156];\n        if (! alreadyAttached.contains (zipDir.getPath ())) {\n            FileInputStream fis = new FileInputStream (zipDir);\n            ZipEntry anEntry = new ZipEntry (zipDir.getPath ());\n            alreadyAttached.add (zipDir.getPath ());\n            zos.putNextEntry (anEntry);\n            while ((bytesIn = fis.read (readBuffer)) != - 1) {\n                zos.write (readBuffer, 0, bytesIn);\n            }\n            fis.close ();\n        }\n    } else {\n        String [] dirList = zipDir.list ();\n        byte [] readBuffer = new byte [2156];\n        int bytesIn = 0;\n        for (int i = 0;\n        i < dirList.length; i ++) {\n            File f = new File (zipDir, dirList [i]);\n            if (f.isDirectory ()) {\n                String filePath = f.getPath ();\n                zipDir (new File (filePath), zos, rawdatadir);\n                continue;\n            }\n            if (! alreadyAttached.contains (getRelativePath (rawdatadir, f))) {\n                FileInputStream fis = new FileInputStream (f);\n                ZipEntry anEntry = new ZipEntry (getRelativePath (rawdatadir, f));\n                alreadyAttached.add (getRelativePath (rawdatadir, f));\n                zos.putNextEntry (anEntry);\n                while ((bytesIn = fis.read (readBuffer)) != - 1) {\n                    zos.write (readBuffer, 0, bytesIn);\n                }\n                fis.close ();\n            }\n        }\n    }\n}\n", "code2": "void copyDirectoryToZip (File basedir, ZipOutputStream zos) throws Exception {\n    List list = getFilenames (basedir.getAbsolutePath (), true);\n    ZipEntry entry = new ZipEntry (\"_nanoInstaller_/filelist\");\n    zos.putNextEntry (entry);\n    for (Iterator it = list.iterator ();\n    it.hasNext ();) {\n        String filename = (String) it.next ();\n        byte [] buffer = (filename + \"\\n\").getBytes ();\n        zos.write (buffer, 0, buffer.length);\n    }\n    zos.closeEntry ();\n    System.out.println (\"  Packaging \" + list.size () + \" files...\");\n    for (Iterator it = list.iterator ();\n    it.hasNext ();) {\n        String filename = (String) it.next ();\n        if (verbose) {\n            System.out.println (\"  Adding \" + filename + \" ...\");\n        }\n        copyFileToZip (filename, basedir.getAbsolutePath () + \"/\" + filename, zos);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6644757, "method2_id": 19197300, "code1": "public void excluir (Cliente cliente) throws Exception {\n    Connection connection = criaConexao (false);\n    String sql = \"delete from cliente where cod_cliente = ?\";\n    PreparedStatement stmt = null;\n    try {\n        stmt = connection.prepareStatement (sql);\n        stmt.setLong (1, cliente.getId ());\n        int retorno = stmt.executeUpdate ();\n        if (retorno == 0) {\n            connection.rollback ();\n            throw new SQLException (\"Ocorreu um erro inesperado no momento de remover dados de cliente no banco!\");\n        }\n        connection.commit ();\n    } catch (SQLException e) {\n        connection.rollback ();\n        throw e;\n    } finally {\n        try {\n            stmt.close ();\n            this.fechaConexao ();\n        } catch (SQLException e) {\n            throw e;\n        }\n    }\n}\n", "code2": "private void writeStatsToDatabase (long transferJobAIPCount, long reprocessingJobAIPCount, long transferJobAIPVolume, long reprocessingJobAIPVolume, long overallBinaryAIPCount, Map < String, AIPStatistics > mimeTypeRegister) throws SQLException {\n    int nextAIPStatsID;\n    long nextMimetypeStatsID;\n    Statement select = dbConnection.createStatement ();\n    String aipStatsQuery = \"select max(aip_statistics_id) from aip_statistics\";\n    ResultSet result = select.executeQuery (aipStatsQuery);\n    if (result.next ()) {\n        nextAIPStatsID = result.getInt (1) + 1;\n    } else {\n        throw new SQLException (\"Problem getting maximum AIP Statistics ID\");\n    }\n    String mimetypeStatsQuery = \"select max(mimetype_aip_statistics_id) from mimetype_aip_statistics\";\n    result = select.executeQuery (mimetypeStatsQuery);\n    if (result.next ()) {\n        nextMimetypeStatsID = result.getLong (1) + 1;\n    } else {\n        throw new SQLException (\"Problem getting maximum MIME type AIP Statistics ID\");\n    }\n    String insertAIPStatsEntryQuery = \"insert into aip_statistics \" + \"(aip_statistics_id, tj_aip_count, tj_aip_volume, rj_aip_count, rj_aip_volume, \" + \"collation_date, binary_aip_count) \" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n    PreparedStatement insert = dbConnection.prepareStatement (insertAIPStatsEntryQuery);\n    insert.setInt (1, nextAIPStatsID);\n    insert.setLong (2, transferJobAIPCount);\n    insert.setLong (3, transferJobAIPVolume);\n    insert.setLong (4, reprocessingJobAIPCount);\n    insert.setLong (5, reprocessingJobAIPVolume);\n    insert.setDate (6, new java.sql.Date (System.currentTimeMillis ()));\n    insert.setLong (7, overallBinaryAIPCount);\n    int rowsAdded = insert.executeUpdate ();\n    if (rowsAdded != 1) {\n        dbConnection.rollback ();\n        throw new SQLException (\"Could not insert row into AIP statistics table\");\n    }\n    String insertMimeTypeStatsQuery = \"insert into mimetype_aip_statistics \" + \"(mimetype_aip_statistics_id, aip_statistics_id, mimetype_aip_count, mimetype_aip_volume, mimetype) \" + \"values (?, ?, ?, ?, ?)\";\n    insert = dbConnection.prepareStatement (insertMimeTypeStatsQuery);\n    insert.setInt (2, nextAIPStatsID);\n    for (String mimeType : mimeTypeRegister.keySet ()) {\n        AIPStatistics mimeTypeStats = mimeTypeRegister.get (mimeType);\n        insert.setLong (1, nextMimetypeStatsID);\n        insert.setLong (3, mimeTypeStats.aipCount);\n        insert.setLong (4, mimeTypeStats.aipVolume);\n        insert.setString (5, mimeType);\n        nextMimetypeStatsID ++;\n        rowsAdded = insert.executeUpdate ();\n        if (rowsAdded != 1) {\n            dbConnection.rollback ();\n            throw new SQLException (\"Could not insert row into MIME Type AIP statistics table\");\n        }\n    }\n    dbConnection.commit ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3253028, "method2_id": 14317425, "code1": "public static List < String > unTar (File tarFile, File directory) throws IOException {\n    List < String > result = new ArrayList < String > ();\n    InputStream inputStream = new FileInputStream (tarFile);\n    TarArchiveInputStream in = new TarArchiveInputStream (inputStream);\n    TarArchiveEntry entry = in.getNextTarEntry ();\n    while (entry != null) {\n        OutputStream out = new FileOutputStream (new File (directory, entry.getName ()));\n        IOUtils.copy (in, out);\n        out.close ();\n        result.add (entry.getName ());\n        entry = in.getNextTarEntry ();\n    }\n    in.close ();\n    return result;\n}\n", "code2": "public static boolean encodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.ENCODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 14020152, "method2_id": 17426486, "code1": "private byte [] MD5Digest (String input) throws GeneralSecurityException {\n    MessageDigest md = MessageDigest.getInstance (\"MD5\");\n    md.update (input.getBytes ());\n    return md.digest ();\n}\n", "code2": "public String encrypt (String pwd) {\n    MessageDigest md5 = null;\n    try {\n        md5 = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace ();\n        System.out.println (\"Error\");\n    }\n    try {\n        md5.update (pwd.getBytes (\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace ();\n        JOptionPane.showMessageDialog (null, \"That is not a valid encrpytion type\");\n    }\n    byte raw [] = md5.digest ();\n    String empty = \"\";\n    String hash = \"\";\n    for (byte b : raw) {\n        String tmp = empty + Integer.toHexString (b & 0xff);\n        if (tmp.length () == 1) {\n            tmp = 0 + tmp;\n        }\n        hash += tmp;\n    }\n    return hash;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 11339042, "method2_id": 19886621, "code1": "public void doPost (HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n    PrintWriter out = null;\n    ServletOutputStream outstream = null;\n    try {\n        String action = req.getParameter (\"nmrshiftdbaction\");\n        String relativepath = ServletUtils.expandRelative (this.getServletConfig (), \"/WEB-INF\");\n        TurbineConfig tc = new TurbineConfig (relativepath + \"..\", relativepath + getServletConfig ().getInitParameter (\"properties\"));\n        tc.init ();\n        int spectrumId = - 1;\n        DBSpectrum spectrum = null;\n        Export export = null;\n        String format = req.getParameter (\"format\");\n        if (action.equals (\"test\")) {\n            try {\n                res.setContentType (\"text/plain\");\n                out = res.getWriter ();\n                List l = DBSpectrumPeer.executeQuery (\"select SPECTRUM_ID from SPECTRUM limit 1\");\n                if (l.size () > 0) spectrumId = ((Record) l.get (0)).getValue (1).asInt ();\n\n                out.write (\"success\");\n            } catch (Exception ex) {\n                out.write (\"failure\");\n            }\n        } else if (action.equals (\"rss\")) {\n            int numbertoexport = 10;\n            out = res.getWriter ();\n            if (req.getParameter (\"numbertoexport\") != null) {\n                try {\n                    numbertoexport = Integer.parseInt (req.getParameter (\"numbertoexport\"));\n                    if (numbertoexport < 1 || numbertoexport > 20) throw new NumberFormatException (\"Number to small/large\");\n\n                } catch (NumberFormatException ex) {\n                    out.println (\"The parameter <code>numbertoexport</code>must be an integer from 1 to 20\");\n                }\n            }\n            res.setContentType (\"text/xml\");\n            RssWriter rssWriter = new RssWriter ();\n            rssWriter.setWriter (res.getWriter ());\n            AtomContainerSet soac = new AtomContainerSet ();\n            String query = \"select distinct MOLECULE.MOLECULE_ID from MOLECULE, SPECTRUM where SPECTRUM.MOLECULE_ID = MOLECULE.MOLECULE_ID and SPECTRUM.REVIEW_FLAG =\\\"true\\\" order by MOLECULE.DATE desc;\";\n            List l = NmrshiftdbUserPeer.executeQuery (query);\n            for (int i = 0;\n            i < numbertoexport; i ++) {\n                if (i == l.size ()) break;\n\n                DBMolecule mol = DBMoleculePeer.retrieveByPK (new NumberKey (((Record) l.get (i)).getValue (1).asInt ()));\n                IMolecule cdkmol = mol.getAsCDKMoleculeAsEntered (1);\n                soac.addAtomContainer (cdkmol);\n                rssWriter.getLinkmap ().put (cdkmol, mol.getEasylink (req));\n                rssWriter.getDatemap ().put (cdkmol, mol.getDate ());\n                rssWriter.getTitlemap ().put (cdkmol, mol.getChemicalNamesAsOneStringWithFallback ());\n                rssWriter.getCreatormap ().put (cdkmol, mol.getNmrshiftdbUser ().getUserName ());\n                rssWriter.setCreator (GeneralUtils.getAdminEmail (getServletConfig ()));\n                Vector v = mol.getDBCanonicalNames ();\n                for (int k = 0;\n                k < v.size (); k ++) {\n                    DBCanonicalName canonName = (DBCanonicalName) v.get (k);\n                    if (canonName.getDBCanonicalNameType ().getCanonicalNameType () == \"INChI\") {\n                        rssWriter.getInchimap ().put (cdkmol, canonName.getName ());\n                        break;\n                    }\n                }\n                rssWriter.setTitle (\"NMRShiftDB\");\n                rssWriter.setLink (\"http://www.nmrshiftdb.org\");\n                rssWriter.setDescription (\"NMRShiftDB is an open-source, open-access, open-submission, open-content web database for chemical structures and their nuclear magnetic resonance data\");\n                rssWriter.setPublisher (\"NMRShiftDB.org\");\n                rssWriter.setImagelink (\"http://www.nmrshiftdb.org/images/nmrshift-logo.gif\");\n                rssWriter.setAbout (\"http://www.nmrshiftdb.org/NmrshiftdbServlet?nmrshiftdbaction=rss\");\n                Collection coll = new ArrayList ();\n                Vector spectra = mol.selectSpectra (null);\n                for (int k = 0;\n                k < spectra.size (); k ++) {\n                    Element el = ((DBSpectrum) spectra.get (k)).getCmlSpect ();\n                    Element el2 = el.getChildElements ().get (0);\n                    el.removeChild (el2);\n                    coll.add (el2);\n                }\n                rssWriter.getMultiMap ().put (cdkmol, coll);\n            }\n            rssWriter.write (soac);\n        } else if (action.equals (\"getattachment\")) {\n            res.setContentType (\"application/zip\");\n            outstream = res.getOutputStream ();\n            DBSample sample = DBSamplePeer.retrieveByPK (new NumberKey (req.getParameter (\"sampleid\")));\n            outstream.write (sample.getAttachment ());\n        } else if (action.equals (\"createreport\")) {\n            res.setContentType (\"application/pdf\");\n            outstream = res.getOutputStream ();\n            boolean yearly = req.getParameter (\"style\").equals (\"yearly\");\n            int yearstart = Integer.parseInt (req.getParameter (\"yearstart\"));\n            int yearend = Integer.parseInt (req.getParameter (\"yearend\"));\n            int monthstart = 0;\n            int monthend = 0;\n            if (! yearly) {\n                monthstart = Integer.parseInt (req.getParameter (\"monthstart\"));\n                monthend = Integer.parseInt (req.getParameter (\"monthend\"));\n            }\n            int type = Integer.parseInt (req.getParameter (\"type\"));\n            JasperReport jasperReport = (JasperReport) JRLoader.loadObject (relativepath + \"/reports/\" + (yearly ? \"yearly\" : \"monthly\") + \"_report_\" + type + \".jasper\");\n            Map parameters = new HashMap ();\n            if (yearly) parameters.put (\"HEADER\", \"Report for years \" + yearstart + \" - \" + yearend);\n            else parameters.put (\"HEADER\", \"Report for \" + monthstart + \"/\" + yearstart + \" - \" + monthend + \"/\" + yearend);\n\n            DBConnection dbconn = TurbineDB.getConnection ();\n            Connection conn = dbconn.getConnection ();\n            Statement stmt = conn.createStatement ();\n            ResultSet rs = null;\n            if (type == 1) {\n                rs = stmt.executeQuery (\"select YEAR(DATE) as YEAR, \" + (yearly ? \"\" : \" MONTH(DATE) as MONTH, \") + \"AFFILIATION_1, AFFILIATION_2, MACHINE.NAME as NAME, count(*) as C, sum(WISHED_SPECTRUM like '%13C%' or WISHED_SPECTRUM like '%variable temperature%' or WISHED_SPECTRUM like '%ID sel. NOE%' or WISHED_SPECTRUM like '%solvent suppression%' or WISHED_SPECTRUM like '%standard spectrum%') as 1_D, sum(WISHED_SPECTRUM like '%H,H-COSY%' or WISHED_SPECTRUM like '%NOESY%' or WISHED_SPECTRUM like '%HMQC%' or WISHED_SPECTRUM like '%HMBC%') as 2_D, sum(OTHER_WISHED_SPECTRUM!='') as SPECIAL, sum(OTHER_NUCLEI!='') as HETERO, sum(PROCESS='self') as SELF, sum(PROCESS='robot') as ROBOT, sum(PROCESS='worker') as OPERATOR from (SAMPLE join TURBINE_USER using (USER_ID)) join MACHINE on MACHINE.MACHINE_ID=SAMPLE.MACHINE where YEAR(DATE)>=\" + yearstart + \" and YEAR(DATE)<=\" + yearend + \" and LOGIN_NAME<>'testuser' group by YEAR, \" + (yearly ? \"\" : \"MONTH, \") + \"AFFILIATION_1, AFFILIATION_2, MACHINE.NAME\");\n            } else if (type == 2) {\n                rs = stmt.executeQuery (\"select YEAR(DATE) as YEAR, \" + (yearly ? \"\" : \" MONTH(DATE) as MONTH, \") + \"MACHINE.NAME as NAME, count(*) as C, sum(WISHED_SPECTRUM like '%13C%' or WISHED_SPECTRUM like '%variable temperature%' or WISHED_SPECTRUM like '%ID sel. NOE%' or WISHED_SPECTRUM like '%solvent suppression%' or WISHED_SPECTRUM like '%standard spectrum%') as 1_D, sum(WISHED_SPECTRUM like '%H,H-COSY%' or WISHED_SPECTRUM like '%NOESY%' or WISHED_SPECTRUM like '%HMQC%' or WISHED_SPECTRUM like '%HMBC%') as 2_D, sum(OTHER_WISHED_SPECTRUM!='') as SPECIAL, sum(OTHER_NUCLEI!='') as HETERO, sum(PROCESS='self') as SELF, sum(PROCESS='robot') as ROBOT, sum(PROCESS='worker') as OPERATOR from (SAMPLE join TURBINE_USER using (USER_ID)) join MACHINE on MACHINE.MACHINE_ID=SAMPLE.MACHINE group by YEAR, \" + (yearly ? \"\" : \"MONTH, \") + \"MACHINE.NAME\");\n            }\n\n            JasperPrint jasperPrint = JasperFillManager.fillReport (jasperReport, parameters, new JRResultSetDataSource (rs));\n            JasperExportManager.exportReportToPdfStream (jasperPrint, outstream);\n            dbconn.close ();\n        } else if (action.equals (\"exportcmlbyinchi\")) {\n            res.setContentType (\"text/xml\");\n            out = res.getWriter ();\n            String inchi = req.getParameter (\"inchi\");\n            String spectrumtype = req.getParameter (\"spectrumtype\");\n            Criteria crit = new Criteria ();\n            crit.add (DBCanonicalNamePeer.NAME, inchi);\n            crit.addJoin (DBCanonicalNamePeer.MOLECULE_ID, DBSpectrumPeer.MOLECULE_ID);\n            crit.addJoin (DBSpectrumPeer.SPECTRUM_TYPE_ID, DBSpectrumTypePeer.SPECTRUM_TYPE_ID);\n            crit.add (DBSpectrumTypePeer.NAME, spectrumtype);\n            try {\n                GeneralUtils.logToSql (crit.toString (), null);\n            } catch (Exception ex) {\n            }\n            Vector spectra = DBSpectrumPeer.doSelect (crit);\n            if (spectra.size () == 0) {\n                out.write (\"No such molecule or spectrum\");\n            } else {\n                Element cmlElement = new Element (\"cml\");\n                cmlElement.addAttribute (new Attribute (\"convention\", \"nmrshiftdb-convention\"));\n                cmlElement.setNamespaceURI (\"http://www.xml-cml.org/schema\");\n                Element parent = ((DBSpectrum) spectra.get (0)).getDBMolecule ().getCML (1);\n                nu.xom.Node cmldoc = parent.getChild (0);\n                ((Element) cmldoc).setNamespaceURI (\"http://www.xml-cml.org/schema\");\n                parent.removeChildren ();\n                cmlElement.appendChild (cmldoc);\n                for (int k = 0;\n                k < spectra.size (); k ++) {\n                    Element parentspec = ((DBSpectrum) spectra.get (k)).getCmlSpect ();\n                    Node spectrumel = parentspec.getChild (0);\n                    parentspec.removeChildren ();\n                    cmlElement.appendChild (spectrumel);\n                    ((Element) spectrumel).setNamespaceURI (\"http://www.xml-cml.org/schema\");\n                }\n                out.write (cmlElement.toXML ());\n            }\n        } else if (action.equals (\"namelist\")) {\n            res.setContentType (\"application/zip\");\n            outstream = res.getOutputStream ();\n            ByteArrayOutputStream baos = new ByteArrayOutputStream ();\n            ZipOutputStream zipout = new ZipOutputStream (baos);\n            Criteria crit = new Criteria ();\n            crit.addJoin (DBMoleculePeer.MOLECULE_ID, DBSpectrumPeer.MOLECULE_ID);\n            crit.add (DBSpectrumPeer.REVIEW_FLAG, \"true\");\n            Vector v = DBMoleculePeer.doSelect (crit);\n            for (int i = 0;\n            i < v.size (); i ++) {\n                if (i % 500 == 0) {\n                    if (i != 0) {\n                        zipout.write (new String (\"<p>The list is continued <a href=\\\"nmrshiftdb.names.\" + i + \".html\\\">here</a></p></body></html>\").getBytes ());\n                        zipout.closeEntry ();\n                    }\n                    zipout.putNextEntry (new ZipEntry (\"nmrshiftdb.names.\" + i + \".html\"));\n                    zipout.write (new String (\"<html><body><h1>This is a list of strcutures in <a href=\\\"http://www.nmrshiftdb.org\\\">NMRShiftDB</a>, starting at \" + i + \", Its main purpose is to be found by search engines</h1>\").getBytes ());\n                }\n                DBMolecule mol = (DBMolecule) v.get (i);\n                zipout.write (new String (\"<p><a href=\\\"\" + mol.getEasylink (req) + \"\\\">\").getBytes ());\n                Vector cannames = mol.getDBCanonicalNames ();\n                for (int k = 0;\n                k < cannames.size (); k ++) {\n                    zipout.write (new String (((DBCanonicalName) cannames.get (k)).getName () + \" \").getBytes ());\n                }\n                Vector chemnames = mol.getDBChemicalNames ();\n                for (int k = 0;\n                k < chemnames.size (); k ++) {\n                    zipout.write (new String (((DBChemicalName) chemnames.get (k)).getName () + \" \").getBytes ());\n                }\n                zipout.write (new String (\"</a>. Information we have got: NMR spectra\").getBytes ());\n                Vector spectra = mol.selectSpectra ();\n                for (int k = 0;\n                k < spectra.size (); k ++) {\n                    zipout.write (new String (((DBSpectrum) spectra.get (k)).getDBSpectrumType ().getName () + \", \").getBytes ());\n                }\n                if (mol.hasAny3d ()) zipout.write (new String (\"3D coordinates, \").getBytes ());\n\n                zipout.write (new String (\"File formats: CML, mol, png, jpeg\").getBytes ());\n                zipout.write (new String (\"</p>\").getBytes ());\n            }\n            zipout.write (new String (\"</body></html>\").getBytes ());\n            zipout.closeEntry ();\n            zipout.close ();\n            InputStream is = new ByteArrayInputStream (baos.toByteArray ());\n            byte [] buf = new byte [32 * 1024];\n            int nRead = 0;\n            while ((nRead = is.read (buf)) != - 1) {\n                outstream.write (buf, 0, nRead);\n            }\n        } else if (action.equals (\"predictor\")) {\n            if (req.getParameter (\"symbol\") == null) {\n                res.setContentType (\"text/plain\");\n                out = res.getWriter ();\n                out.write (\"please give the symbol to create the predictor for in the request with symbol=X (e. g. symbol=C\");\n            }\n            res.setContentType (\"application/zip\");\n            outstream = res.getOutputStream ();\n            ByteArrayOutputStream baos = new ByteArrayOutputStream ();\n            ZipOutputStream zipout = new ZipOutputStream (baos);\n            String filename = \"org/openscience/nmrshiftdb/PredictionTool.class\";\n            zipout.putNextEntry (new ZipEntry (filename));\n            JarInputStream jip = new JarInputStream (new FileInputStream (ServletUtils.expandRelative (getServletConfig (), \"/WEB-INF/lib/nmrshiftdb-lib.jar\")));\n            JarEntry entry = jip.getNextJarEntry ();\n            while (entry.getName ().indexOf (\"PredictionTool.class\") == - 1) {\n                entry = jip.getNextJarEntry ();\n            }\n            for (int i = 0;\n            i < entry.getSize (); i ++) {\n                zipout.write (jip.read ());\n            }\n            zipout.closeEntry ();\n            zipout.putNextEntry (new ZipEntry (\"nmrshiftdb.csv\"));\n            int i = 0;\n            org.apache.turbine.util.db.pool.DBConnection conn = TurbineDB.getConnection ();\n            HashMap mapsmap = new HashMap ();\n            while (true) {\n                Statement stmt = conn.createStatement ();\n                ResultSet rs = stmt.executeQuery (\"select HOSE_CODE, VALUE, SYMBOL from HOSE_CODES where CONDITION_TYPE='m' and WITH_RINGS=0 and SYMBOL='\" + req.getParameter (\"symbol\") + \"' limit \" + (i * 1000) + \", 1000\");\n                int m = 0;\n                while (rs.next ()) {\n                    String code = rs.getString (1);\n                    Double value = new Double (rs.getString (2));\n                    String symbol = rs.getString (3);\n                    if (mapsmap.get (symbol) == null) {\n                        mapsmap.put (symbol, new HashMap ());\n                    }\n                    for (int spheres = 6;\n                    spheres > 0; spheres --) {\n                        StringBuffer hoseCodeBuffer = new StringBuffer ();\n                        StringTokenizer st = new StringTokenizer (code, \"()/\");\n                        for (int k = 0;\n                        k < spheres; k ++) {\n                            if (st.hasMoreTokens ()) {\n                                String partcode = st.nextToken ();\n                                hoseCodeBuffer.append (partcode);\n                            }\n                            if (k == 0) {\n                                hoseCodeBuffer.append (\"(\");\n                            } else if (k == 3) {\n                                hoseCodeBuffer.append (\")\");\n                            } else {\n                                hoseCodeBuffer.append (\"/\");\n                            }\n\n                        }\n                        String hoseCode = hoseCodeBuffer.toString ();\n                        if (((HashMap) mapsmap.get (symbol)).get (hoseCode) == null) {\n                            ((HashMap) mapsmap.get (symbol)).put (hoseCode, new ArrayList ());\n                        }\n                        ((ArrayList) ((HashMap) mapsmap.get (symbol)).get (hoseCode)).add (value);\n                    }\n                    m ++;\n                }\n                i ++;\n                stmt.close ();\n                if (m == 0) break;\n\n            }\n            Set keySet = mapsmap.keySet ();\n            Iterator it = keySet.iterator ();\n            while (it.hasNext ()) {\n                String symbol = (String) it.next ();\n                HashMap hosemap = ((HashMap) mapsmap.get (symbol));\n                Set keySet2 = hosemap.keySet ();\n                Iterator it2 = keySet2.iterator ();\n                while (it2.hasNext ()) {\n                    String hoseCode = (String) it2.next ();\n                    ArrayList list = ((ArrayList) hosemap.get (hoseCode));\n                    double [] values = new double [list.size ()];\n                    for (int k = 0;\n                    k < list.size (); k ++) {\n                        values [k] = ((Double) list.get (k)).doubleValue ();\n                    }\n                    zipout.write (new String (symbol + \"|\" + hoseCode + \"|\" + Statistics.minimum (values) + \"|\" + Statistics.average (values) + \"|\" + Statistics.maximum (values) + \"\\r\\n\").getBytes ());\n                }\n            }\n            zipout.closeEntry ();\n            zipout.close ();\n            InputStream is = new ByteArrayInputStream (baos.toByteArray ());\n            byte [] buf = new byte [32 * 1024];\n            int nRead = 0;\n            i = 0;\n            while ((nRead = is.read (buf)) != - 1) {\n                outstream.write (buf, 0, nRead);\n            }\n        } else if (action.equals (\"exportspec\") || action.equals (\"exportmol\")) {\n            if (spectrumId > - 1) spectrum = DBSpectrumPeer.retrieveByPK (new NumberKey (spectrumId));\n            else spectrum = DBSpectrumPeer.retrieveByPK (new NumberKey (req.getParameter (\"spectrumid\")));\n\n            export = new Export (spectrum);\n        } else if (action.equals (\"exportmdl\")) {\n            res.setContentType (\"text/plain\");\n            outstream = res.getOutputStream ();\n            DBMolecule mol = DBMoleculePeer.retrieveByPK (new NumberKey (req.getParameter (\"moleculeid\")));\n            outstream.write (mol.getStructureFile (Integer.parseInt (req.getParameter (\"coordsetid\")), false).getBytes ());\n        } else if (action.equals (\"exportlastinputs\")) {\n            format = action;\n        } else if (action.equals (\"printpredict\")) {\n            res.setContentType (\"text/html\");\n            out = res.getWriter ();\n            HttpSession session = req.getSession ();\n            VelocityContext context = PredictPortlet.getContext (session, true, true, new StringBuffer (), getServletConfig (), req, true);\n            StringWriter w = new StringWriter ();\n            Velocity.mergeTemplate (\"predictprint.vm\", \"ISO-8859-1\", context, w);\n            out.println (w.toString ());\n        } else {\n            res.setContentType (\"text/html\");\n            out = res.getWriter ();\n            out.println (\"No valid action\");\n        }\n\n        if (format == null) format = \"\";\n\n        if (format.equals (\"pdf\") || format.equals (\"rtf\")) {\n            res.setContentType (\"application/\" + format);\n            out = res.getWriter ();\n        }\n        if (format.equals (\"docbook\")) {\n            res.setContentType (\"application/zip\");\n            outstream = res.getOutputStream ();\n        }\n        if (format.equals (\"svg\")) {\n            res.setContentType (\"image/x-svg\");\n            out = res.getWriter ();\n        }\n        if (format.equals (\"tiff\")) {\n            res.setContentType (\"image/tiff\");\n            outstream = res.getOutputStream ();\n        }\n        if (format.equals (\"jpeg\")) {\n            res.setContentType (\"image/jpeg\");\n            outstream = res.getOutputStream ();\n        }\n        if (format.equals (\"png\")) {\n            res.setContentType (\"image/png\");\n            outstream = res.getOutputStream ();\n        }\n        if (format.equals (\"mdl\") || format.equals (\"txt\") || format.equals (\"cml\") || format.equals (\"cmlboth\") || format.indexOf (\"exsection\") == 0) {\n            res.setContentType (\"text/plain\");\n            out = res.getWriter ();\n        }\n        if (format.equals (\"simplehtml\") || format.equals (\"exportlastinputs\")) {\n            res.setContentType (\"text/html\");\n            out = res.getWriter ();\n        }\n        if (action.equals (\"exportlastinputs\")) {\n            int numbertoexport = 4;\n            if (req.getParameter (\"numbertoexport\") != null) {\n                try {\n                    numbertoexport = Integer.parseInt (req.getParameter (\"numbertoexport\"));\n                    if (numbertoexport < 1 || numbertoexport > 20) throw new NumberFormatException (\"Number to small/large\");\n\n                } catch (NumberFormatException ex) {\n                    out.println (\"The parameter <code>numbertoexport</code>must be an integer from 1 to 20\");\n                }\n            }\n            NmrshiftdbUser user = null;\n            try {\n                user = NmrshiftdbUserPeer.getByName (req.getParameter (\"username\"));\n            } catch (NmrshiftdbException ex) {\n                out.println (\"Seems <code>username</code> is not OK: \" + ex.getMessage ());\n            }\n            if (user != null) {\n                List l = NmrshiftdbUserPeer.executeQuery (\"SELECT LAST_DOWNLOAD_DATE FROM TURBINE_USER  where LOGIN_NAME=\\\"\" + user.getUserName () + \"\\\";\");\n                Date lastDownloadDate = ((Record) l.get (0)).getValue (1).asDate ();\n                if (((new Date ().getTime () - lastDownloadDate.getTime ()) / 3600000) < 24) {\n                    out.println (\"Your last download was at \" + lastDownloadDate + \". You may download your last inputs only once a day. Sorry for this, but we need to be carefull with resources. If you want to put your last inputs on your homepage best use some sort of cache (e. g. use wget for downlaod with crond and link to this static resource))!\");\n                } else {\n                    NmrshiftdbUserPeer.executeStatement (\"UPDATE TURBINE_USER SET LAST_DOWNLOAD_DATE=NOW() where LOGIN_NAME=\\\"\" + user.getUserName () + \"\\\";\");\n                    Vector < String > parameters = new Vector < String > ();\n                    String query = \"select distinct MOLECULE.MOLECULE_ID from MOLECULE, SPECTRUM where SPECTRUM.MOLECULE_ID = MOLECULE.MOLECULE_ID and SPECTRUM.REVIEW_FLAG =\\\"true\\\" and SPECTRUM.USER_ID=\" + user.getUserId () + \" order by MOLECULE.DATE desc;\";\n                    l = NmrshiftdbUserPeer.executeQuery (query);\n                    String url = javax.servlet.http.HttpUtils.getRequestURL (req).toString ();\n                    url = url.substring (0, url.length () - 17);\n                    for (int i = 0;\n                    i < numbertoexport; i ++) {\n                        if (i == l.size ()) break;\n\n                        DBMolecule mol = DBMoleculePeer.retrieveByPK (new NumberKey (((Record) l.get (i)).getValue (1).asInt ()));\n                        parameters.add (new String (\"<a href=\\\"\" + url + \"/portal/pane0/Results?nmrshiftdbaction=showDetailsFromHome&molNumber=\" + mol.getMoleculeId () + \"\\\"><img src=\\\"\" + javax.servlet.http.HttpUtils.getRequestURL (req).toString () + \"?nmrshiftdbaction=exportmol&spectrumid=\" + ((DBSpectrum) mol.getDBSpectrums ().get (0)).getSpectrumId () + \"&format=jpeg&size=150x150&backcolor=12632256\\\"></a>\"));\n                    }\n                    VelocityContext context = new VelocityContext ();\n                    context.put (\"results\", parameters);\n                    StringWriter w = new StringWriter ();\n                    Velocity.mergeTemplate (\"lateststructures.vm\", \"ISO-8859-1\", context, w);\n                    out.println (w.toString ());\n                }\n            }\n        }\n        if (action.equals (\"exportspec\")) {\n            if (format.equals (\"txt\")) {\n                String lastsearchtype = req.getParameter (\"lastsearchtype\");\n                if (lastsearchtype.equals (NmrshiftdbConstants.TOTALSPECTRUM) || lastsearchtype.equals (NmrshiftdbConstants.SUBSPECTRUM)) {\n                    List l = ParseUtils.parseSpectrumFromSpecFile (req.getParameter (\"lastsearchvalues\"));\n                    spectrum.initSimilarity (l, lastsearchtype.equals (NmrshiftdbConstants.SUBSPECTRUM));\n                }\n                Vector v = spectrum.getOptions ();\n                DBMolecule mol = spectrum.getDBMolecule ();\n                out.print (mol.getChemicalNamesAsOneString (false) + mol.getMolecularFormula (false) + \"; \" + mol.getMolecularWeight () + \" Dalton\\n\\r\");\n                out.print (\"\\n\\rAtom\\t\");\n                if (spectrum.getDBSpectrumType ().getElementSymbol () == (\"H\")) out.print (\"Mult.\\t\");\n\n                out.print (\"Meas.\");\n                if (lastsearchtype.equals (NmrshiftdbConstants.TOTALSPECTRUM) || lastsearchtype.equals (NmrshiftdbConstants.SUBSPECTRUM)) {\n                    out.print (\"\\tInput\\tDiff\");\n                }\n                out.print (\"\\n\\r\");\n                out.print (\"No.\\t\");\n                if (spectrum.getDBSpectrumType ().getElementSymbol () == (\"H\")) out.print (\"\\t\");\n\n                out.print (\"Shift\");\n                if (lastsearchtype.equals (NmrshiftdbConstants.TOTALSPECTRUM) || lastsearchtype.equals (NmrshiftdbConstants.SUBSPECTRUM)) {\n                    out.print (\"\\tShift\\tM-I\");\n                }\n                out.print (\"\\n\\r\");\n                for (int i = 0;\n                i < v.size (); i ++) {\n                    out.print (((ValuesForVelocityBean) v.get (i)).getDisplayText () + \"\\t\" + ((ValuesForVelocityBean) v.get (i)).getRange ());\n                    if (lastsearchtype.equals (NmrshiftdbConstants.TOTALSPECTRUM) || lastsearchtype.equals (NmrshiftdbConstants.SUBSPECTRUM)) {\n                        out.print (\"\\t\" + ((ValuesForVelocityBean) v.get (i)).getNameForElements () + \"\\t\" + ((ValuesForVelocityBean) v.get (i)).getDelta ());\n                    }\n                    out.print (\"\\n\\r\");\n                }\n            }\n            if (format.equals (\"simplehtml\")) {\n                String i1 = export.getImage (false, \"jpeg\", ServletUtils.expandRelative (this.getServletConfig (), \"/nmrshiftdbhtml\") + \"/tmp/\" + System.currentTimeMillis (), true);\n                export.pictures [0] = new File (i1).getName ();\n                String i2 = export.getImage (true, \"jpeg\", ServletUtils.expandRelative (this.getServletConfig (), \"/nmrshiftdbhtml\") + \"/tmp/\" + System.currentTimeMillis (), true);\n                export.pictures [1] = new File (i2).getName ();\n                String docbook = export.getHtml ();\n                out.print (docbook);\n            }\n            if (format.equals (\"pdf\") || format.equals (\"rtf\")) {\n                String svgSpec = export.getSpecSvg (400, 200);\n                String svgspecfile = relativepath + \"/tmp/\" + System.currentTimeMillis () + \"s.svg\";\n                new FileOutputStream (svgspecfile).write (svgSpec.getBytes ());\n                export.pictures [1] = svgspecfile;\n                String molSvg = export.getMolSvg (true);\n                String svgmolfile = relativepath + \"/tmp/\" + System.currentTimeMillis () + \"m.svg\";\n                new FileOutputStream (svgmolfile).write (molSvg.getBytes ());\n                export.pictures [0] = svgmolfile;\n                String docbook = export.getDocbook (\"pdf\", \"SVG\");\n                TransformerFactory tFactory = TransformerFactory.newInstance ();\n                Transformer transformer = tFactory.newTransformer (new StreamSource (\"file:\" + GeneralUtils.getNmrshiftdbProperty (\"docbookxslpath\", getServletConfig ()) + \"/fo/docbook.xsl\"));\n                ByteArrayOutputStream baos = new ByteArrayOutputStream ();\n                transformer.transform (new StreamSource (new StringReader (docbook)), new StreamResult (baos));\n                FopFactory fopFactory = FopFactory.newInstance ();\n                FOUserAgent foUserAgent = fopFactory.newFOUserAgent ();\n                OutputStream out2 = new ByteArrayOutputStream ();\n                Fop fop = fopFactory.newFop (format.equals (\"rtf\") ? MimeConstants.MIME_RTF : MimeConstants.MIME_PDF, foUserAgent, out2);\n                TransformerFactory factory = TransformerFactory.newInstance ();\n                transformer = factory.newTransformer ();\n                Source src = new StreamSource (new StringReader (baos.toString ()));\n                Result res2 = new SAXResult (fop.getDefaultHandler ());\n                transformer.transform (src, res2);\n                out.print (out2.toString ());\n            }\n            if (format.equals (\"docbook\")) {\n                String i1 = relativepath + \"/tmp/\" + System.currentTimeMillis () + \".svg\";\n                new FileOutputStream (i1).write (export.getSpecSvg (300, 200).getBytes ());\n                export.pictures [0] = new File (i1).getName ();\n                String i2 = relativepath + \"/tmp/\" + System.currentTimeMillis () + \".svg\";\n                new FileOutputStream (i2).write (export.getMolSvg (true).getBytes ());\n                export.pictures [1] = new File (i2).getName ();\n                String docbook = export.getDocbook (\"pdf\", \"SVG\");\n                String docbookfile = relativepath + \"/tmp/\" + System.currentTimeMillis () + \".xml\";\n                new FileOutputStream (docbookfile).write (docbook.getBytes ());\n                ByteArrayOutputStream baos = export.makeZip (new String [] {docbookfile, i1, i2});\n                outstream.write (baos.toByteArray ());\n            }\n            if (format.equals (\"svg\")) {\n                out.print (export.getSpecSvg (400, 200));\n            }\n            if (format.equals (\"tiff\") || format.equals (\"jpeg\") || format.equals (\"png\")) {\n                InputStream is = new FileInputStream (export.getImage (false, format, relativepath + \"/tmp/\" + System.currentTimeMillis (), true));\n                byte [] buf = new byte [32 * 1024];\n                int nRead = 0;\n                while ((nRead = is.read (buf)) != - 1) {\n                    outstream.write (buf, 0, nRead);\n                }\n            }\n            if (format.equals (\"cml\")) {\n                out.print (spectrum.getCmlSpect ().toXML ());\n            }\n            if (format.equals (\"cmlboth\")) {\n                Element cmlElement = new Element (\"cml\");\n                cmlElement.addAttribute (new Attribute (\"convention\", \"nmrshiftdb-convention\"));\n                cmlElement.setNamespaceURI (\"http://www.xml-cml.org/schema\");\n                Element parent = spectrum.getDBMolecule ().getCML (1, spectrum.getDBSpectrumType ().getName ().equals (\"1H\"));\n                nu.xom.Node cmldoc = parent.getChild (0);\n                ((Element) cmldoc).setNamespaceURI (\"http://www.xml-cml.org/schema\");\n                parent.removeChildren ();\n                cmlElement.appendChild (cmldoc);\n                Element parentspec = spectrum.getCmlSpect ();\n                Node spectrumel = parentspec.getChild (0);\n                parentspec.removeChildren ();\n                cmlElement.appendChild (spectrumel);\n                ((Element) spectrumel).setNamespaceURI (\"http://www.xml-cml.org/schema\");\n                out.write (cmlElement.toXML ());\n            }\n            if (format.indexOf (\"exsection\") == 0) {\n                StringTokenizer st = new StringTokenizer (format, \"-\");\n                st.nextToken ();\n                String template = st.nextToken ();\n                Criteria crit = new Criteria ();\n                crit.add (DBSpectrumPeer.USER_ID, spectrum.getUserId ());\n                Vector v = spectrum.getDBMolecule ().getDBSpectrums (crit);\n                VelocityContext context = new VelocityContext ();\n                context.put (\"spectra\", v);\n                context.put (\"molecule\", spectrum.getDBMolecule ());\n                StringWriter w = new StringWriter ();\n                Velocity.mergeTemplate (\"exporttemplates/\" + template, \"ISO-8859-1\", context, w);\n                out.write (w.toString ());\n            }\n        }\n        if (action.equals (\"exportmol\")) {\n            int width = - 1;\n            int height = - 1;\n            if (req.getParameter (\"size\") != null) {\n                StringTokenizer st = new StringTokenizer (req.getParameter (\"size\"), \"x\");\n                width = Integer.parseInt (st.nextToken ());\n                height = Integer.parseInt (st.nextToken ());\n            }\n            boolean shownumbers = true;\n            if (req.getParameter (\"shownumbers\") != null && req.getParameter (\"shownumbers\").equals (\"false\")) {\n                shownumbers = false;\n            }\n            if (req.getParameter (\"backcolor\") != null) {\n                export.backColor = new Color (Integer.parseInt (req.getParameter (\"backcolor\")));\n            }\n            if (req.getParameter (\"markatom\") != null) {\n                export.selected = Integer.parseInt (req.getParameter (\"markatom\")) - 1;\n            }\n            if (format.equals (\"svg\")) {\n                out.print (export.getMolSvg (true));\n            }\n            if (format.equals (\"tiff\") || format.equals (\"jpeg\") || format.equals (\"png\")) {\n                InputStream is = new FileInputStream (export.getImage (true, format, relativepath + \"/tmp/\" + System.currentTimeMillis (), width, height, shownumbers, null));\n                byte [] buf = new byte [32 * 1024];\n                int nRead = 0;\n                while ((nRead = is.read (buf)) != - 1) {\n                    outstream.write (buf, 0, nRead);\n                }\n            }\n            if (format.equals (\"mdl\")) {\n                out.println (spectrum.getDBMolecule ().getStructureFile (1, false));\n            }\n            if (format.equals (\"cml\")) {\n                out.println (spectrum.getDBMolecule ().getCMLString (1));\n            }\n        }\n        if (out != null) out.flush ();\n        else outstream.flush ();\n\n    } catch (Exception ex) {\n        ex.printStackTrace ();\n        out.print (GeneralUtils.logError (ex, \"NmrshiftdbServlet\", null, true));\n        out.flush ();\n    }\n}\n", "code2": "private void doPOST (HttpURLConnection connection, InputStream inputXML) throws MessageServiceException {\n    try {\n        OutputStream requestStream = new BufferedOutputStream (connection.getOutputStream ());\n        IOUtils.copyAndClose (inputXML, requestStream);\n        connection.connect ();\n    } catch (IOException e) {\n        throw new MessageServiceException (e.getMessage (), e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 14885371, "method2_id": 23422445, "code1": "public void copyFile (FileInputStream fis, File out) throws IOException {\n    FileChannel inChannel = fis.getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    copyChannel (inChannel, outChannel);\n}\n", "code2": "@Override\nprotected void copy (Reader reader, OutputStream outputs) throws IOException {\n    IOUtils.copy (reader, outputs);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10062076, "method2_id": 20080077, "code1": "private long generateNativeInstallExe (File nativeInstallFile, String instTemplate, File instClassFile) throws IOException {\n    InputStream reader = getClass ().getResourceAsStream (\"/\" + instTemplate);\n    ByteArrayOutputStream content = new ByteArrayOutputStream ();\n    String installClassVarStr = \"000000000000\";\n    byte [] buf = new byte [installClassVarStr.length ()];\n    NumberFormat nf = NumberFormat.getInstance (Locale.US);\n    nf.setGroupingUsed (false);\n    nf.setMinimumIntegerDigits (installClassVarStr.length ());\n    int installClassStopPos = 0;\n    long installClassOffset = reader.available ();\n    int position = 0;\n    System.out.println (VAGlobals.i18n (\"VAArchiver_GenerateInstallExe\"));\n    reader.read (buf, 0, buf.length);\n    position = 1;\n    for (int n = 0;\n    n < 3; n ++) {\n        while ((! new String (buf).equals (\"clname_here_\")) && (! new String (buf).equals (\"clstart_here\")) && (! new String (buf).equals (\"clstop_here_\"))) {\n            content.write (buf [0]);\n            int nextb = reader.read ();\n            position ++;\n            shiftArray (buf);\n            buf [buf.length - 1] = (byte) nextb;\n        }\n        if (new String (buf).equals (\"clname_here_\")) {\n            VAGlobals.printDebug (\"  clname_here_ found at \" + (position - 1));\n            StringBuffer clnameBuffer = new StringBuffer (64);\n            clnameBuffer.append (instClassName_);\n            for (int i = clnameBuffer.length () - 1;\n            i < 64; i ++) {\n                clnameBuffer.append ('.');\n            }\n            byte [] clnameBytes = clnameBuffer.toString ().getBytes ();\n            for (int i = 0;\n            i < 64; i ++) {\n                content.write (clnameBytes [i]);\n                position ++;\n            }\n            reader.skip (64 - buf.length);\n            reader.read (buf, 0, buf.length);\n        } else if (new String (buf).equals (\"clstart_here\")) {\n            VAGlobals.printDebug (\"  clstart_here found at \" + (position - 1));\n            buf = nf.format (installClassOffset).getBytes ();\n            for (int i = 0;\n            i < buf.length; i ++) {\n                content.write (buf [i]);\n                position ++;\n            }\n            reader.read (buf, 0, buf.length);\n        } else if (new String (buf).equals (\"clstop_here_\")) {\n            VAGlobals.printDebug (\"  clstop_here_ found at \" + (position - 1));\n            installClassStopPos = position - 1;\n            content.write (buf);\n            position += 12;\n            reader.read (buf, 0, buf.length);\n        }\n\n    }\n    content.write (buf);\n    buf = new byte [2048];\n    int read = reader.read (buf);\n    while (read > 0) {\n        content.write (buf, 0, read);\n        read = reader.read (buf);\n    }\n    reader.close ();\n    FileInputStream classStream = new FileInputStream (instClassFile);\n    read = classStream.read (buf);\n    while (read > 0) {\n        content.write (buf, 0, read);\n        read = classStream.read (buf);\n    }\n    classStream.close ();\n    content.close ();\n    byte [] contentBytes = content.toByteArray ();\n    installClassVarStr = nf.format (contentBytes.length);\n    byte [] installClassVarBytes = installClassVarStr.getBytes ();\n    for (int i = 0;\n    i < installClassVarBytes.length; i ++) {\n        contentBytes [installClassStopPos + i] = installClassVarBytes [i];\n    }\n    FileOutputStream out = new FileOutputStream (nativeInstallFile);\n    out.write (contentBytes);\n    out.close ();\n    return installClassOffset;\n}\n", "code2": "public Writer createWriter (File outfile, String encoding) throws UnsupportedEncodingException, IOException {\n    int k_blockSize = 1024;\n    int byteCount;\n    char [] buf = new char [k_blockSize];\n    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (outfile));\n    zos.setMethod (ZipOutputStream.DEFLATED);\n    OutputStreamWriter osw = new OutputStreamWriter (zos, \"ISO-8859-1\");\n    BufferedWriter bw = new BufferedWriter (osw);\n    ZipEntry zot;\n    ZipInputStream zis = new ZipInputStream (new FileInputStream (infile));\n    InputStreamReader isr = new InputStreamReader (zis, \"ISO-8859-1\");\n    BufferedReader br = new BufferedReader (isr);\n    ZipEntry zit;\n    while ((zit = zis.getNextEntry ()) != null) {\n        if (zit.getName ().equals (\"content.xml\")) {\n            continue;\n        }\n        zot = new ZipEntry (zit.getName ());\n        zos.putNextEntry (zot);\n        while ((byteCount = br.read (buf, 0, k_blockSize)) >= 0) bw.write (buf, 0, byteCount);\n\n        bw.flush ();\n        zos.closeEntry ();\n    }\n    zos.putNextEntry (new ZipEntry (\"content.xml\"));\n    bw.flush ();\n    return new OutputStreamWriter (zos, \"UTF-8\");\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 18488108, "method2_id": 20644477, "code1": "public static void saveZipComponents (ZipComponents zipComponents, File zipFile) throws FileNotFoundException, IOException, Exception {\n    ZipOutputStream zipOutStream = new ZipOutputStream (new FileOutputStream (zipFile));\n    for (ZipComponent comp : zipComponents.getComponents ()) {\n        ZipEntry newEntry = new ZipEntry (comp.getName ());\n        zipOutStream.putNextEntry (newEntry);\n        if (comp.isDirectory ()) {\n        } else {\n            if (comp.getName ().endsWith (\"document.xml\") || comp.getName ().endsWith (\"document.xml.rels\")) {\n            }\n            InputStream inputStream = comp.getInputStream ();\n            IOUtils.copy (inputStream, zipOutStream);\n            inputStream.close ();\n        }\n    }\n    zipOutStream.close ();\n}\n", "code2": "private static void saveSettings (String destinationFileName, byte [] content) throws IOException {\n    final FileOutputStream fileOutputStream = new FileOutputStream (destinationFileName);\n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream (content);\n    IOUtils.copy (byteArrayInputStream, fileOutputStream);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 5709034, "method2_id": 7763535, "code1": "public static NrpePacket receivePacket (InputStream i, int padding) throws NrpeException, IOException {\n    NrpePacket p = new NrpePacket ();\n    byte [] packet = new byte [PACKET_SIZE + padding];\n    int j, k;\n    for (k = 0; (j = i.read ()) != - 1; k ++) {\n        packet [k] = (byte) j;\n    }\n    if (k < PACKET_SIZE) {\n        throw new NrpeException (\"Received packet is too small.  \" + \"Received \" + k + \", expected at least \" + PACKET_SIZE);\n    }\n    p.m_version = (short) ((positive (packet [0]) << 8) + positive (packet [1]));\n    p.m_type = (short) ((positive (packet [2]) << 8) + positive (packet [3]));\n    long crc_l = ((long) positive (packet [4]) << 24) + ((long) positive (packet [5]) << 16) + ((long) positive (packet [6]) << 8) + ((long) positive (packet [7]));\n    p.m_resultCode = (short) ((positive (packet [8]) << 8) + positive (packet [9]));\n    packet [4] = 0;\n    packet [5] = 0;\n    packet [6] = 0;\n    packet [7] = 0;\n    CRC32 crc = new CRC32 ();\n    crc.update (packet);\n    long crc_calc = crc.getValue ();\n    if (crc_calc != crc_l) {\n        throw new NrpeException (\"CRC mismatch: \" + crc_calc + \" vs. \" + crc_l);\n    }\n    byte [] buffer = new byte [MAX_PACKETBUFFER_LENGTH];\n    System.arraycopy (packet, 10, buffer, 0, buffer.length);\n    p.m_buffer = new String (buffer);\n    if ((j = p.m_buffer.indexOf (0)) > 0) {\n        p.m_buffer = p.m_buffer.substring (0, j);\n    }\n    return p;\n}\n", "code2": "private static long newCompatHashingAlg (String key) {\n    CRC32 checksum = new CRC32 ();\n    checksum.update (key.getBytes ());\n    long crc = checksum.getValue ();\n    return (crc>> 16) & 0x7fff;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1455792, "method2_id": 3462669, "code1": "public void generate (String rootDir, RootModel root) throws Exception {\n    IOUtils.copyStream (HTMLGenerator.class.getResourceAsStream (\"stylesheet.css\"), new FileOutputStream (new File (rootDir, \"stylesheet.css\")));\n    Velocity.init ();\n    VelocityContext context = new VelocityContext ();\n    context.put (\"model\", root);\n    context.put (\"util\", new VelocityUtils ());\n    context.put (\"msg\", messages);\n    processTemplate (\"index.html\", new File (rootDir, \"index.html\"), context);\n    processTemplate (\"list.html\", new File (rootDir, \"list.html\"), context);\n    processTemplate (\"summary.html\", new File (rootDir, \"summary.html\"), context);\n    File imageDir = new File (rootDir, \"images\");\n    imageDir.mkdir ();\n    IOUtils.copyStream (HTMLGenerator.class.getResourceAsStream (\"primarykey.gif\"), new FileOutputStream (new File (imageDir, \"primarykey.gif\")));\n    File tableDir = new File (rootDir, \"tables\");\n    tableDir.mkdir ();\n    for (TableModel table : root.getTables ()) {\n        context.put (\"table\", table);\n        processTemplate (\"table.html\", new File (tableDir, table.getTableName () + \".html\"), context);\n    }\n}\n", "code2": "private void fileCopy (final File src, final File dest) throws IOException {\n    final FileChannel srcChannel = new FileInputStream (src).getChannel ();\n    final FileChannel dstChannel = new FileOutputStream (dest).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 15854368, "method2_id": 19335986, "code1": "public static void copyURLToFile (URL source, File destination) throws IOException {\n    InputStream input = source.openStream ();\n    try {\n        FileOutputStream output = openOutputStream (destination);\n        try {\n            IOUtils.copy (input, output);\n        } finally {\n            IOUtils.close (output);\n        }\n    } finally {\n        IOUtils.close (input);\n    }\n}\n", "code2": "public void uncaughtException (final Thread t, final Throwable e) {\n    final Display display = Display.getCurrent ();\n    final Shell shell = new Shell (display);\n    final MessageBox message = new MessageBox (shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n    message.setText (\"Hawkscope Error\");\n    message.setMessage (e.getMessage () + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n    log.error (\"Uncaught exception\", e);\n    if (message.open () == SWT.OK) {\n        IOUtils.copyToClipboard (Version.getBugReport (e));\n        try {\n            Program.launch (Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode (\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n        } catch (final Exception e1) {\n            Program.launch (Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n        }\n    }\n    shell.dispose ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 123750, "method2_id": 1391374, "code1": "public CGDemoModule loadDemo (String resourceName) {\n    CGTutorial tutorial = getTutorial ();\n    CGDemoModule demo = null;\n    try {\n        String demoName = tutorial.getString (resourceName + \".class\");\n        Class demoClass = Class.forName (demoName);\n        Constructor demoConstructor = demoClass.getConstructor (new Class [] {tutorial.getClass ()});\n        Object [] args = new Object [] {tutorial};\n        demo = (CGDemoModule) demoConstructor.newInstance (args);\n    } catch (Exception ex) {\n        ex.printStackTrace ();\n        tutorial.setStatus (\"Cannot load demo: \" + ex);\n        System.err.println (\"Hint: check if each line in manifest ends with a space, and that computational.jar is updated!\");\n    }\n    return demo;\n}\n", "code2": "public static AbstractONDEXPlugin getPlugin (String str) {\n    AbstractONDEXPlugin p = null;\n    try {\n        Class < ? > cls = Class.forName (str);\n        p = (AbstractONDEXPlugin) cls.getConstructor (new Class < ? > [] {}).newInstance ();\n    } catch (Exception e) {\n    }\n    return p;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 5252413, "method2_id": 18395127, "code1": "public void inScan (File file, DirectoryScanner scanner) throws Exception {\n    int i;\n    FileInputStream in;\n    byte [] buffer = new byte [BLOCK_SIZE];\n    sink_.putNextEntry (new ZipEntry (scanner.path_.toString ().replace (File.separatorChar, '/')));\n    in = new FileInputStream (file);\n    try {\n        while ((i = in.read (buffer)) > 0) sink_.write (buffer, 0, i);\n\n    } catch (Exception e) {\n    }\n    in.close ();\n    sink_.closeEntry ();\n}\n", "code2": "public void closeContents () throws IOException {\n    ZipEntry entry = new ZipEntry (mkRelative (currentPath) + \"/__contents__.xml\");\n    out.putNextEntry (entry);\n    out.write (contents.toString ().getBytes (\"UTF-8\"));\n    out.closeEntry ();\n    dataWritten = true;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4303376, "method2_id": 18568751, "code1": "protected void doGet (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    String [] path = StringUtils.split (request.getRequestURI (), \"/\");\n    String file = path [path.length - 1];\n    File f = new File (pathToImages + \"/\" + file);\n    response.setContentType (getServletContext ().getMimeType (f.getName ()));\n    FileInputStream fis = new FileInputStream (f);\n    IOUtils.copy (fis, response.getOutputStream ());\n    fis.close ();\n}\n", "code2": "public static Boolean decompress (File source, File destination) {\n    FileOutputStream outputStream;\n    ZipInputStream inputStream;\n    try {\n        outputStream = null;\n        inputStream = new ZipInputStream (new FileInputStream (source));\n        int read;\n        byte buffer [] = new byte [BUFFER_SIZE];\n        ZipEntry zipEntry;\n        while ((zipEntry = inputStream.getNextEntry ()) != null) {\n            if (zipEntry.isDirectory ()) new File (destination, zipEntry.getName ()).mkdirs ();\n            else {\n                File fileEntry = new File (destination, zipEntry.getName ());\n                fileEntry.getParentFile ().mkdirs ();\n                outputStream = new FileOutputStream (fileEntry);\n                while ((read = inputStream.read (buffer, 0, BUFFER_SIZE)) != - 1) {\n                    outputStream.write (buffer, 0, read);\n                }\n                outputStream.flush ();\n                outputStream.close ();\n            }\n        }\n        inputStream.close ();\n    } catch (Exception oException) {\n        return false;\n    }\n    return true;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 11158190, "method2_id": 16464790, "code1": "public static void copyFile (String fromPath, String toPath) {\n    try {\n        File inputFile = new File (fromPath);\n        String dirImg = (new File (toPath)).getParent ();\n        File tmp = new File (dirImg);\n        if (! tmp.exists ()) {\n            tmp.mkdir ();\n        }\n        File outputFile = new File (toPath);\n        if (! inputFile.getCanonicalPath ().equals (outputFile.getCanonicalPath ())) {\n            FileInputStream in = new FileInputStream (inputFile);\n            FileOutputStream out = new FileOutputStream (outputFile);\n            int c;\n            while ((c = in.read ()) != - 1) out.write (c);\n\n            in.close ();\n            out.close ();\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace ();\n        LogHandler.log (ex.getMessage (), Level.INFO, \"LOG_MSG\", isLoggingEnabled ());\n    }\n}\n", "code2": "private void fileCopy (final File src, final File dest) throws IOException {\n    final FileChannel srcChannel = new FileInputStream (src).getChannel ();\n    final FileChannel dstChannel = new FileOutputStream (dest).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 529639, "method2_id": 3800349, "code1": "private void displayDiffResults () throws IOException {\n    File outFile = File.createTempFile (\"diff\", \".htm\");\n    outFile.deleteOnExit ();\n    FileOutputStream outStream = new FileOutputStream (outFile);\n    BufferedWriter out = new BufferedWriter (new OutputStreamWriter (outStream));\n    out.write (\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n    if (addedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n        out.write (addedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    if (modifiedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n        out.write (modifiedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    if (deletedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n        out.write (deletedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    out.write (\"<table name=METRICS BORDER>\\n\");\n    if (modifiedTable.length () > 0 || deletedTable.length () > 0) {\n        out.write (\"<tr><td>Base:&nbsp;</td><td>\");\n        out.write (Long.toString (base));\n        out.write (\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n        out.write (Long.toString (deleted));\n        out.write (\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n        out.write (Long.toString (modified));\n        out.write (\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n        out.write (Long.toString (added));\n        out.write (\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n        out.write (Long.toString (added + modified));\n        out.write (\"</td></tr>\\n\");\n    }\n    out.write (\"<tr><td>Total:&nbsp;</td><td>\");\n    out.write (Long.toString (total));\n    out.write (\"</td></tr>\\n</table></div>\");\n    redlinesOut.close ();\n    out.flush ();\n    InputStream redlines = new FileInputStream (redlinesTempFile);\n    byte [] buffer = new byte [4096];\n    int bytesRead;\n    while ((bytesRead = redlines.read (buffer)) != - 1) outStream.write (buffer, 0, bytesRead);\n\n    outStream.write (\"</BODY></HTML>\".getBytes ());\n    outStream.close ();\n    Browser.launch (outFile.toURL ().toString ());\n}\n", "code2": "private boolean _copyPath (String source, String destination, Object handler) {\n    try {\n        FileInputStream fis = new FileInputStream (_fullPathForPath (source));\n        FileOutputStream fos = new FileOutputStream (_fullPathForPath (destination));\n        byte [] buffer = new byte [fis.available ()];\n        int read;\n        for (read = fis.read (buffer); read >= 0; read = fis.read (buffer)) {\n            fos.write (buffer, 0, read);\n        }\n        fis.close ();\n        fos.close ();\n        return true;\n    } catch (IOException ioe) {\n        ioe.printStackTrace ();\n        return false;\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9430039, "method2_id": 21919199, "code1": "private void CopyTo (File dest) throws IOException {\n    FileReader in = null;\n    FileWriter out = null;\n    int c;\n    try {\n        in = new FileReader (image);\n        out = new FileWriter (dest);\n        while ((c = in.read ()) != - 1) out.write (c);\n\n    } finally {\n        if (in != null) try {\n            in.close ();\n        } catch (Exception e) {\n        }\n\n        if (out != null) try {\n            out.close ();\n        } catch (Exception e) {\n        }\n\n    }\n}\n", "code2": "private Datastream addManagedDatastreamVersion (Entry entry) throws StreamIOException, ObjectIntegrityException {\n    Datastream ds = new DatastreamManagedContent ();\n    setDSCommonProperties (ds, entry);\n    ds.DSLocationType = \"INTERNAL_ID\";\n    ds.DSMIME = getDSMimeType (entry);\n    IRI contentLocation = entry.getContentSrc ();\n    if (contentLocation != null) {\n        if (m_obj.isNew ()) {\n            ValidationUtility.validateURL (contentLocation.toString (), ds.DSControlGrp);\n        }\n        if (m_format.equals (ATOM_ZIP1_1)) {\n            if (! contentLocation.isAbsolute () && ! contentLocation.isPathAbsolute ()) {\n                File f = getContentSrcAsFile (contentLocation);\n                contentLocation = new IRI (DatastreamManagedContent.TEMP_SCHEME + f.getAbsolutePath ());\n            }\n        }\n        ds.DSLocation = contentLocation.toString ();\n        ds.DSLocation = (DOTranslationUtility.normalizeDSLocationURLs (m_obj.getPid (), ds, m_transContext)).DSLocation;\n        return ds;\n    }\n    try {\n        File temp = File.createTempFile (\"binary-datastream\", null);\n        OutputStream out = new FileOutputStream (temp);\n        if (MimeTypeHelper.isText (ds.DSMIME) || MimeTypeHelper.isXml (ds.DSMIME)) {\n            IOUtils.copy (new StringReader (entry.getContent ()), out, m_encoding);\n        } else {\n            IOUtils.copy (entry.getContentStream (), out);\n        }\n        ds.DSLocation = DatastreamManagedContent.TEMP_SCHEME + temp.getAbsolutePath ();\n    } catch (IOException e) {\n        throw new StreamIOException (e.getMessage (), e);\n    }\n    return ds;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 18513921, "method2_id": 19643373, "code1": "public static void copy (File src, File dst) {\n    try {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new BufferedInputStream (new FileInputStream (src), BUFFER_SIZE);\n            os = new BufferedOutputStream (new FileOutputStream (dst), BUFFER_SIZE);\n            byte [] buffer = new byte [BUFFER_SIZE];\n            int len = 0;\n            while ((len = is.read (buffer)) > 0) os.write (buffer, 0, len);\n\n        } finally {\n            if (null != is) is.close ();\n\n            if (null != os) os.close ();\n\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        logger.error (Logger.SECURITY_FAILURE, \"Problem decoding file to file\", exc);\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10797051, "method2_id": 18665067, "code1": "private static void copy (File in, File out) throws IOException {\n    if (! out.getParentFile ().isDirectory ()) out.getParentFile ().mkdirs ();\n\n    FileChannel ic = new FileInputStream (in).getChannel ();\n    FileChannel oc = new FileOutputStream (out).getChannel ();\n    ic.transferTo (0, ic.size (), oc);\n    ic.close ();\n    oc.close ();\n}\n", "code2": "public void actionPerformed (ActionEvent e) {\n    if (path.compareTo (\"\") != 0) {\n        imageName = (path.substring (path.lastIndexOf (imageFile.separator) + 1, path.length ()));\n        File imageFile = new File (path);\n        directoryPath = \"Images\" + imageFile.separator + imageName.substring (0, 1).toUpperCase ();\n        File directory = new File (directoryPath);\n        directory.mkdirs ();\n        imagePath = \".\" + imageFile.separator + \"Images\" + imageFile.separator + imageName.substring (0, 1).toUpperCase () + imageFile.separator + imageName;\n        File newFile = new File (imagePath);\n        int i = 1;\n        while (newFile.exists ()) {\n            imagePath = \".\" + imageFile.separator + \"Images\" + imageFile.separator + imageName.substring (0, imageName.lastIndexOf ('.')) + \"_\" + i + imageName.substring (imageName.lastIndexOf ('.'), imageName.length ());\n            newFile = new File (imagePath);\n            i ++;\n        }\n        imagePathThumb = (imagePath.substring (0, imagePath.lastIndexOf (\".\"))).concat (\"_th.jpg\");\n        dataBase.insertDB (theConcepts, imageName, imageName.substring (0, imageName.lastIndexOf ('.')));\n        try {\n            FileChannel srcChannel = new FileInputStream (path).getChannel ();\n            FileChannel dstChannel = new FileOutputStream (imagePath).getChannel ();\n            dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n            srcChannel.close ();\n            dstChannel.close ();\n        } catch (IOException exc) {\n            System.out.println (exc.getMessage ());\n            System.out.println (exc.toString ());\n        }\n        image = null;\n        if (imageFile != null) {\n            if (TFileUtils.isJAIRequired (imageFile)) {\n                RenderedOp src = JAI.create (\"fileload\", imageFile.getAbsolutePath ());\n                BufferedImage bufferedImage = src.getAsBufferedImage ();\n                image = new ImageIcon (bufferedImage);\n            } else {\n                image = new ImageIcon (imageFile.getAbsolutePath ());\n            }\n            if (image.getImageLoadStatus () == MediaTracker.ERRORED) {\n                int choosenOption = JOptionPane.NO_OPTION;\n                choosenOption = JOptionPane.showConfirmDialog (null, TLanguage.getString (\"TIGInsertImageAction.MESSAGE\"), TLanguage.getString (\"TIGInsertImageAction.NAME\"), JOptionPane.CLOSED_OPTION, JOptionPane.ERROR_MESSAGE);\n            } else {\n                try {\n                    int thumbWidth = PREVIEW_WIDTH;\n                    int thumbHeight = PREVIEW_HEIGHT;\n                    double thumbRatio = (double) thumbWidth / (double) thumbHeight;\n                    int imageWidth = image.getIconWidth ();\n                    int imageHeight = image.getIconHeight ();\n                    double imageRatio = (double) imageWidth / (double) imageHeight;\n                    if (thumbRatio < imageRatio) {\n                        thumbHeight = (int) (thumbWidth / imageRatio);\n                    } else {\n                        thumbWidth = (int) (thumbHeight * imageRatio);\n                    }\n                    BufferedImage thumbImage = new BufferedImage (thumbWidth, thumbHeight, BufferedImage.TYPE_INT_RGB);\n                    Graphics2D graphics2D = thumbImage.createGraphics ();\n                    graphics2D.setRenderingHint (RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);\n                    graphics2D.drawImage (image.getImage (), 0, 0, thumbWidth, thumbHeight, null);\n                    BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (imagePathThumb));\n                    JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder (out);\n                    JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam (thumbImage);\n                    int quality = 100;\n                    quality = Math.max (0, Math.min (quality, 100));\n                    param.setQuality ((float) quality / 100.0f, false);\n                    encoder.setJPEGEncodeParam (param);\n                    encoder.encode (thumbImage);\n                    out.close ();\n                } catch (Exception ex) {\n                    System.out.println (ex.getMessage ());\n                    System.out.println (ex.toString ());\n                }\n            }\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10695599, "method2_id": 18098898, "code1": "public static String stringOfUrl (String addr) throws IOException {\n    ByteArrayOutputStream output = new ByteArrayOutputStream ();\n    URL url = new URL (addr);\n    IOUtils.copy (url.openStream (), output);\n    return output.toString ();\n}\n", "code2": "public static final void copy (InputStream is, OutputStream os) throws IOException {\n    try {\n        IOUtils.copy (is, os);\n    } finally {\n        IOUtils.closeQuietly (is);\n        IOUtils.closeQuietly (os);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 15909533, "method2_id": 21754657, "code1": "public ModelAndView handleRequest (HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpClientInfo clientInfo = HttpUtil.parseClientInfo ((HttpServletRequest) request);\n    if (request.getParameter (\"_debug_\") != null) {\n        StringBuffer buffer = new StringBuffer ();\n        Enumeration iter = request.getHeaderNames ();\n        while (iter.hasMoreElements ()) {\n            String name = (String) iter.nextElement ();\n            buffer.append (name + \"=\" + request.getHeader (name)).append (\"\\n\");\n        }\n        buffer.append (\"\\n\");\n        iter = request.getParameterNames ();\n        while (iter.hasMoreElements ()) {\n            String name = (String) iter.nextElement ();\n            String value = request.getParameter (name);\n            if (! \"ISO-8859-1\".equalsIgnoreCase (clientInfo.getPreferCharset ())) value = new String (value.getBytes (\"ISO-8859-1\"), clientInfo.getPreferCharset ());\n\n            buffer.append (name).append (\"=\").append (value).append (\"\\n\");\n        }\n        response.setContentType (\"text/plain; charset=UTF-8\");\n        response.setCharacterEncoding (\"UTF-8\");\n        response.getWriter ().write (buffer.toString ());\n        return null;\n    }\n    Object resultObj = handleRequest (request);\n    if (resultObj == null) {\n        String requestException = (String) request.getAttribute (\"XSMP.handleRequest.Exception\");\n        if (requestException != null) response.sendError (500, requestException);\n        else response.setContentLength (0);\n\n    } else {\n        if (resultObj instanceof DataHandler) {\n            response.setContentType (((DataHandler) resultObj).getContentType ());\n            response.setContentLength (((DataHandler) resultObj).getInputStream ().available ());\n            IOUtils.copy (((DataHandler) resultObj).getInputStream (), response.getOutputStream ());\n        } else {\n            String temp = resultObj.toString ();\n            if (temp.startsWith (\"<\") && temp.endsWith (\">\")) response.setContentType (\"text/html; charset=\" + clientInfo.getPreferCharset ());\n            else response.setContentType (\"text/plain; charset=\" + clientInfo.getPreferCharset ());\n\n            byte [] buffer = temp.getBytes (clientInfo.getPreferCharset ());\n            response.setContentLength (buffer.length);\n            response.getOutputStream ().write (buffer);\n        }\n    }\n    return null;\n}\n", "code2": "private JButton getButtonImagen () {\n    if (buttonImagen == null) {\n        buttonImagen = new JButton ();\n        buttonImagen.setText (Messages.getString (\"gui.AdministracionResorces.6\"));\n        buttonImagen.setIcon (new ImageIcon (getClass ().getResource (\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n        buttonImagen.addActionListener (new java.awt.event.ActionListener () {\n            public void actionPerformed (java.awt.event.ActionEvent e) {\n                JFileChooser fc = new JFileChooser ();\n                fc.addChoosableFileFilter (new ImageFilter ());\n                fc.setAccessory (new ImagePreview (fc));\n                int returnVal = fc.showDialog (AdministracionResorces.this, Messages.getString (\"gui.AdministracionResorces.8\"));\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = fc.getSelectedFile ();\n                    String rutaGlobal = System.getProperty (\"user.dir\") + \"/\" + rutaDatos + \"imagenes/\" + file.getName ();\n                    String rutaRelativa = rutaDatos + \"imagenes/\" + file.getName ();\n                    try {\n                        FileInputStream fis = new FileInputStream (file);\n                        FileOutputStream fos = new FileOutputStream (rutaGlobal, true);\n                        FileChannel canalFuente = fis.getChannel ();\n                        FileChannel canalDestino = fos.getChannel ();\n                        canalFuente.transferTo (0, canalFuente.size (), canalDestino);\n                        fis.close ();\n                        fos.close ();\n                        imagen.setImagenURL (rutaRelativa);\n                        gui.getEntrenamientoIzquierdaLabel ().setIcon (gui.getProcesadorDatos ().escalaImageIcon (((Imagen) gui.getComboBoxImagenesIzquierda ().getSelectedItem ()).getImagenURL ()));\n                        gui.getEntrenamientoDerechaLabel ().setIcon (gui.getProcesadorDatos ().escalaImageIcon (((Imagen) gui.getComboBoxImagenesDerecha ().getSelectedItem ()).getImagenURL ()));\n                        buttonImagen.setIcon (new ImageIcon (getClass ().getResource (\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                        labelImagenPreview.setIcon (gui.getProcesadorDatos ().escalaImageIcon (imagen.getImagenURL ()));\n                    } catch (IOException ex) {\n                        ex.printStackTrace ();\n                    }\n                } else {\n                }\n            }}\n\n        );\n    }\n    return buttonImagen;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9913454, "method2_id": 20983672, "code1": "private void createScript (File scriptsLocation, String relativePath, String scriptContent) {\n    Writer fileWriter = null;\n    try {\n        File scriptFile = new File (scriptsLocation.getAbsolutePath () + \"/\" + relativePath);\n        scriptFile.getParentFile ().mkdirs ();\n        fileWriter = new FileWriter (scriptFile);\n        IOUtils.copy (new StringReader (scriptContent), fileWriter);\n    } catch (IOException e) {\n        throw new UnitilsException (e);\n    } finally {\n        IOUtils.closeQuietly (fileWriter);\n    }\n}\n", "code2": "public void sendResponse (DjdocRequest req, HttpServletResponse res) throws IOException {\n    File file = (File) req.getResult ();\n    InputStream in = null;\n    try {\n        in = new FileInputStream (file);\n        IOUtils.copy (in, res.getOutputStream ());\n    } finally {\n        if (in != null) {\n            in.close ();\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 777609, "method2_id": 2326683, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "public static void encrypt (File plain, File symKey, File ciphered, String algorithm) throws IOException, ClassNotFoundException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n    Key key = null;\n    try {\n        ObjectInputStream in = new ObjectInputStream (new FileInputStream (symKey));\n        key = (Key) in.readObject ();\n    } catch (IOException ioe) {\n        KeyGenerator generator = KeyGenerator.getInstance (algorithm);\n        key = generator.generateKey ();\n        ObjectOutputStream out = new ObjectOutputStream (new java.io.FileOutputStream (symKey));\n        out.writeObject (key);\n        out.close ();\n    }\n    Cipher cipher = Cipher.getInstance (algorithm);\n    cipher.init (Cipher.ENCRYPT_MODE, new SecretKeySpec (key.getEncoded (), algorithm));\n    FileInputStream in = new FileInputStream (plain);\n    CipherOutputStream out = new CipherOutputStream (new FileOutputStream (ciphered), cipher);\n    byte [] buffer = new byte [4096];\n    for (int read = in.read (buffer);\n    read > - 1; read = in.read (buffer)) {\n        out.write (buffer, 0, read);\n    }\n    out.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8121403, "method2_id": 18034373, "code1": "public static void copyAssetFile (Context ctx, String srcFileName, String targetFilePath) {\n    AssetManager assetManager = ctx.getAssets ();\n    try {\n        InputStream is = assetManager.open (srcFileName);\n        File out = new File (targetFilePath);\n        if (! out.exists ()) {\n            out.getParentFile ().mkdirs ();\n            out.createNewFile ();\n        }\n        OutputStream os = new FileOutputStream (out);\n        IOUtils.copy (is, os);\n        is.close ();\n        os.close ();\n    } catch (IOException e) {\n        AIOUtils.log (\"error when copyAssetFile\", e);\n    }\n}\n", "code2": "public static void copyFile (File src, File dest) throws IOException, IllegalArgumentException {\n    if (src.isDirectory ()) throw new IllegalArgumentException (\"Source file is a directory\");\n\n    if (dest.isDirectory ()) throw new IllegalArgumentException (\"Destination file is a directory\");\n\n    int bufferSize = 4 * 1024;\n    InputStream in = new FileInputStream (src);\n    OutputStream out = new FileOutputStream (dest);\n    byte [] buffer = new byte [bufferSize];\n    int bytesRead;\n    while ((bytesRead = in.read (buffer)) >= 0) out.write (buffer, 0, bytesRead);\n\n    out.close ();\n    in.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2410264, "method2_id": 13203935, "code1": "@Override\npublic void mousePressed (MouseEvent e) {\n    Figure f = getFigureAt (e.getX (), e.getY ());\n    if (f == null) return;\n\n    if (! (e.isPopupTrigger () || e.isControlDown ())) return;\n\n    JPopupMenu popup = new JPopupMenu ();\n    JMenuItem menu = new JMenuItem (new ObjectAction < Page > (f.page, \"Open \" + f.page) {\n        private static final long serialVersionUID = 1L;\n        @Override\n        public void actionPerformed (ActionEvent e) {\n            String uri = Wikipedia.BASE + \"/wiki/\" + getObject ().getQNameEncoded ();\n            try {\n                if (RevisionVisualization.this.appletContext == null) {\n                    Desktop d = Desktop.getDesktop ();\n                    d.browse (new URI (uri));\n                } else {\n                    RevisionVisualization.this.appletContext.getAppletContext ().showDocument (new URL (uri), \"_\" + System.currentTimeMillis ());\n                }\n            } catch (Exception err) {\n                ThrowablePane.show (RevisionVisualization.this, err);\n            }\n        }}\n\n    );\n    menu.setEnabled (RevisionVisualization.this.appletContext == null && Desktop.isDesktopSupported ());\n    popup.add (menu);\n    popup.show (drawingArea, e.getX (), e.getY ());\n}\n", "code2": "public static void openInBrowser (String string) {\n    if (java.awt.Desktop.isDesktopSupported ()) {\n        try {\n            java.awt.Desktop.getDesktop ().browse (new URI (string));\n        } catch (IOException ex) {\n        } catch (URISyntaxException ex) {\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 604392, "method2_id": 14763206, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "public static void copyFromFileToFileUsingNIO (File inputFile, File outputFile) throws FileNotFoundException, IOException {\n    FileChannel inputChannel = new FileInputStream (inputFile).getChannel ();\n    FileChannel outputChannel = new FileOutputStream (outputFile).getChannel ();\n    try {\n        inputChannel.transferTo (0, inputChannel.size (), outputChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inputChannel != null) inputChannel.close ();\n\n        if (outputChannel != null) outputChannel.close ();\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 20012017, "method2_id": 21781575, "code1": "public void writeTo (OutputStream output) throws IOException {\n    IOUtils.copyAndClose (stream, output);\n}\n", "code2": "private String loadSchemas () {\n    StringWriter writer = new StringWriter ();\n    try {\n        IOUtils.copy (CoreOdfValidator.class.getResourceAsStream (\"schema_list.properties\"), writer);\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n    return writer.toString ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 14164924, "method2_id": 18696387, "code1": "@Override\npublic void copy (File source, File dest) throws IOException {\n    FileChannel in = null;\n    FileChannel out = null;\n    try {\n        in = (new FileInputStream (source)).getChannel ();\n        out = (new FileOutputStream (dest)).getChannel ();\n        in.transferTo (0, source.length (), out);\n    } catch (FileNotFoundException e) {\n        throw new IOException (\"Wrong source or destination path for backup operation!\");\n    } finally {\n        if (out != null) {\n            out.close ();\n        }\n        if (in != null) {\n            in.close ();\n        }\n    }\n}\n", "code2": "public Converter (String input, String output) {\n    try {\n        FileInputStream fis = new FileInputStream (new File (input));\n        BufferedReader in = new BufferedReader (new InputStreamReader (fis, \"SJIS\"));\n        FileOutputStream fos = new FileOutputStream (new File (output));\n        BufferedWriter out = new BufferedWriter (new OutputStreamWriter (fos, \"UTF8\"));\n        int len = 80;\n        char buf [] = new char [len];\n        int numRead;\n        while ((numRead = in.read (buf, 0, len)) != - 1) out.write (buf, 0, numRead);\n\n        out.close ();\n        in.close ();\n    } catch (IOException e) {\n        System.out.println (\"An I/O Exception Occurred: \" + e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 11787058, "method2_id": 15570948, "code1": "protected int authenticate (long companyId, String login, String password, String authType, Map headerMap, Map parameterMap) throws PortalException, SystemException {\n    login = login.trim ().toLowerCase ();\n    long userId = GetterUtil.getLong (login);\n    if (authType.equals (CompanyImpl.AUTH_TYPE_EA)) {\n        if (! Validator.isEmailAddress (login)) {\n            throw new UserEmailAddressException ();\n        }\n    } else if (authType.equals (CompanyImpl.AUTH_TYPE_SN)) {\n        if (Validator.isNull (login)) {\n            throw new UserScreenNameException ();\n        }\n    } else if (authType.equals (CompanyImpl.AUTH_TYPE_ID)) {\n        if (Validator.isNull (login)) {\n            throw new UserIdException ();\n        }\n    }\n\n    if (Validator.isNull (password)) {\n        throw new UserPasswordException (UserPasswordException.PASSWORD_INVALID);\n    }\n    int authResult = Authenticator.FAILURE;\n    String [] authPipelinePre = PropsUtil.getArray (PropsUtil.AUTH_PIPELINE_PRE);\n    if (authType.equals (CompanyImpl.AUTH_TYPE_EA)) {\n        authResult = AuthPipeline.authenticateByEmailAddress (authPipelinePre, companyId, login, password, headerMap, parameterMap);\n    } else if (authType.equals (CompanyImpl.AUTH_TYPE_SN)) {\n        authResult = AuthPipeline.authenticateByScreenName (authPipelinePre, companyId, login, password, headerMap, parameterMap);\n    } else if (authType.equals (CompanyImpl.AUTH_TYPE_ID)) {\n        authResult = AuthPipeline.authenticateByUserId (authPipelinePre, companyId, userId, password, headerMap, parameterMap);\n    }\n\n    User user = null;\n    try {\n        if (authType.equals (CompanyImpl.AUTH_TYPE_EA)) {\n            user = UserUtil.findByC_EA (companyId, login);\n        } else if (authType.equals (CompanyImpl.AUTH_TYPE_SN)) {\n            user = UserUtil.findByC_SN (companyId, login);\n        } else if (authType.equals (CompanyImpl.AUTH_TYPE_ID)) {\n            user = UserUtil.findByC_U (companyId, GetterUtil.getLong (login));\n        }\n\n    } catch (NoSuchUserException nsue) {\n        return Authenticator.DNE;\n    }\n    if (user.isDefaultUser ()) {\n        _log.error (\"The default user should never be allowed to authenticate\");\n        return Authenticator.DNE;\n    }\n    if (! user.isPasswordEncrypted ()) {\n        user.setPassword (PwdEncryptor.encrypt (user.getPassword ()));\n        user.setPasswordEncrypted (true);\n        UserUtil.update (user);\n    }\n    checkLockout (user);\n    checkPasswordExpired (user);\n    if (authResult == Authenticator.SUCCESS) {\n        if (GetterUtil.getBoolean (PropsUtil.get (PropsUtil.AUTH_PIPELINE_ENABLE_LIFERAY_CHECK))) {\n            String encPwd = PwdEncryptor.encrypt (password, user.getPassword ());\n            if (user.getPassword ().equals (encPwd)) {\n                authResult = Authenticator.SUCCESS;\n            } else if (GetterUtil.getBoolean (PropsUtil.get (PropsUtil.AUTH_MAC_ALLOW))) {\n                try {\n                    MessageDigest digester = MessageDigest.getInstance (PropsUtil.get (PropsUtil.AUTH_MAC_ALGORITHM));\n                    digester.update (login.getBytes (\"UTF8\"));\n                    String shardKey = PropsUtil.get (PropsUtil.AUTH_MAC_SHARED_KEY);\n                    encPwd = Base64.encode (digester.digest (shardKey.getBytes (\"UTF8\")));\n                    if (password.equals (encPwd)) {\n                        authResult = Authenticator.SUCCESS;\n                    } else {\n                        authResult = Authenticator.FAILURE;\n                    }\n                } catch (NoSuchAlgorithmException nsae) {\n                    throw new SystemException (nsae);\n                } catch (UnsupportedEncodingException uee) {\n                    throw new SystemException (uee);\n                }\n            } else {\n                authResult = Authenticator.FAILURE;\n            }\n\n        }\n    }\n    if (authResult == Authenticator.SUCCESS) {\n        String [] authPipelinePost = PropsUtil.getArray (PropsUtil.AUTH_PIPELINE_POST);\n        if (authType.equals (CompanyImpl.AUTH_TYPE_EA)) {\n            authResult = AuthPipeline.authenticateByEmailAddress (authPipelinePost, companyId, login, password, headerMap, parameterMap);\n        } else if (authType.equals (CompanyImpl.AUTH_TYPE_SN)) {\n            authResult = AuthPipeline.authenticateByScreenName (authPipelinePost, companyId, login, password, headerMap, parameterMap);\n        } else if (authType.equals (CompanyImpl.AUTH_TYPE_ID)) {\n            authResult = AuthPipeline.authenticateByUserId (authPipelinePost, companyId, userId, password, headerMap, parameterMap);\n        }\n\n    }\n    if (authResult == Authenticator.FAILURE) {\n        try {\n            String [] authFailure = PropsUtil.getArray (PropsUtil.AUTH_FAILURE);\n            if (authType.equals (CompanyImpl.AUTH_TYPE_EA)) {\n                AuthPipeline.onFailureByEmailAddress (authFailure, companyId, login, headerMap, parameterMap);\n            } else if (authType.equals (CompanyImpl.AUTH_TYPE_SN)) {\n                AuthPipeline.onFailureByScreenName (authFailure, companyId, login, headerMap, parameterMap);\n            } else if (authType.equals (CompanyImpl.AUTH_TYPE_ID)) {\n                AuthPipeline.onFailureByUserId (authFailure, companyId, userId, headerMap, parameterMap);\n            }\n\n            if (! PortalLDAPUtil.isPasswordPolicyEnabled (user.getCompanyId ())) {\n                PasswordPolicy passwordPolicy = user.getPasswordPolicy ();\n                int failedLoginAttempts = user.getFailedLoginAttempts ();\n                int maxFailures = passwordPolicy.getMaxFailure ();\n                if ((failedLoginAttempts >= maxFailures) && (maxFailures != 0)) {\n                    String [] authMaxFailures = PropsUtil.getArray (PropsUtil.AUTH_MAX_FAILURES);\n                    if (authType.equals (CompanyImpl.AUTH_TYPE_EA)) {\n                        AuthPipeline.onMaxFailuresByEmailAddress (authMaxFailures, companyId, login, headerMap, parameterMap);\n                    } else if (authType.equals (CompanyImpl.AUTH_TYPE_SN)) {\n                        AuthPipeline.onMaxFailuresByScreenName (authMaxFailures, companyId, login, headerMap, parameterMap);\n                    } else if (authType.equals (CompanyImpl.AUTH_TYPE_ID)) {\n                        AuthPipeline.onMaxFailuresByUserId (authMaxFailures, companyId, userId, headerMap, parameterMap);\n                    }\n\n                }\n            }\n        } catch (Exception e) {\n            _log.error (e, e);\n        }\n    }\n    return authResult;\n}\n", "code2": "private String generate (String value) throws Exception {\n    String resStr = null;\n    try {\n        MessageDigest md = MessageDigest.getInstance (\"MD5\");\n        md.update (value.getBytes (\"utf-8\"), 0, value.length ());\n        byte [] result = md.digest ();\n        resStr = FTGenerate.convertToHex (result);\n        md.reset ();\n    } catch (NoSuchAlgorithmException nae) {\n        this.getLog ().severe (\"Hash no funcionando\");\n        nae.printStackTrace ();\n        throw new Exception (\"Hash no funcionando\");\n    } catch (UnsupportedEncodingException ee) {\n        this.getLog ().severe (\"Encoding no funcionando\");\n        ee.printStackTrace ();\n        throw new Exception (\"Encoding no funcionando\");\n    }\n    return resStr;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1456846, "method2_id": 2726819, "code1": "public static boolean clearFiles (File srcDir, Boolean isHidden) {\n    if (null == srcDir || ! srcDir.exists () || ! srcDir.isDirectory ()) {\n        log.error (\"srcDir(\" + srcDir + \") is invalid !\");\n        return false;\n    }\n    for (File f : listFiles (srcDir, isHidden)) {\n        if (! f.delete ()) {\n            log.error (\"Failed in deteting file(\" + f + \") !\");\n            return false;\n        }\n        if (DEBUG) {\n            log.debug (\"Succeeded in deteting file(\" + f + \") !\");\n        }\n    }\n    if (DEBUG) {\n        log.debug (\"succeeded: dir=\" + srcDir + \"; isHidden=\" + isHidden);\n    }\n    return true;\n}\n", "code2": "public static void removeFilesUnderDir (final File dir) {\n    if (! dir.exists ()) {\n        return;\n    }\n    File [] files = dir.listFiles ();\n    File file;\n    for (int i = 0, len = files.length;\n    i < len; i ++) {\n        file = files [i];\n        if (file.isDirectory ()) {\n            removeFilesUnderDir (file);\n            file.delete ();\n        } else {\n            file.delete ();\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4235407, "method2_id": 9304937, "code1": "protected static String hashPassword (String password, String salt) throws NoSuchAlgorithmException {\n    String s = salt + password;\n    MessageDigest md = MessageDigest.getInstance (\"MD5\");\n    md.update (s.getBytes ());\n    byte bs [] = md.digest ();\n    String s1 = BASE64Encoder.encode (bs);\n    return new StringBuffer (salt).append (':').append (s1).toString ();\n}\n", "code2": "public static String encrypt (String passPhrase, String password) {\n    String algorithm = \"PBEWithMD5AndDES\";\n    byte [] salt = new byte [8];\n    int iterations = 20;\n    byte [] output = new byte [128];\n    if (passPhrase == null || \"\".equals (passPhrase) || password == null || \"\".equals (password)) {\n        throw new GeneralException (PassPhraseCrypto.class, \"encrypt\", \"Required parameter missing\");\n    }\n    try {\n        Security.addProvider (new com.sun.crypto.provider.SunJCE ());\n        KeySpec keySpec = new PBEKeySpec (passPhrase.toCharArray ());\n        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance (algorithm);\n        SecretKey secretKey = secretKeyFactory.generateSecret (keySpec);\n        MessageDigest messageDigest = MessageDigest.getInstance (\"MD5\");\n        messageDigest.update (passPhrase.getBytes ());\n        byte [] input = new byte [password.length ()];\n        input = password.getBytes ();\n        messageDigest.update (input);\n        byte [] digest = messageDigest.digest ();\n        System.arraycopy (digest, 0, salt, 0, 8);\n        AlgorithmParameterSpec algorithmParameterSpec = new PBEParameterSpec (salt, iterations);\n        Cipher cipher = Cipher.getInstance (algorithm);\n        int mode = Cipher.ENCRYPT_MODE;\n        cipher.init (mode, secretKey, algorithmParameterSpec);\n        output = cipher.doFinal (input);\n    } catch (NoSuchAlgorithmException e) {\n        throw new GeneralException (PassPhraseCrypto.class, \"encrypt\", \"Algorithm not found\", e);\n    } catch (InvalidAlgorithmParameterException e) {\n        throw new GeneralException (PassPhraseCrypto.class, \"encrypt\", \"nvalidAlgorithmParameter\", e);\n    } catch (InvalidKeySpecException e) {\n        throw new GeneralException (PassPhraseCrypto.class, \"encrypt\", \"InvalidKeySpec\", e);\n    } catch (InvalidKeyException e) {\n        throw new GeneralException (PassPhraseCrypto.class, \"encrypt\", \"InvalidKey\", e);\n    } catch (NoSuchPaddingException e) {\n        throw new GeneralException (PassPhraseCrypto.class, \"encrypt\", \"NoSuchPadding\", e);\n    } catch (BadPaddingException e) {\n        throw new GeneralException (PassPhraseCrypto.class, \"encrypt\", \"BadPadding\", e);\n    } catch (IllegalBlockSizeException e) {\n        throw new GeneralException (PassPhraseCrypto.class, \"encrypt\", \"IllegalBlockSize\", e);\n    }\n    StringBuffer result = new StringBuffer ();\n    for (int i = 0;\n    i < output.length; i ++) {\n        result.append (Byte.toString (output [i]));\n    }\n    return result.toString ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4118412, "method2_id": 5977352, "code1": "private void compress (String outputFile, ArrayList < String > inputFiles, PrintWriter log, boolean compress) throws Exception {\n    String absPath = getAppConfig ().getPathConfig ().getAbsoluteServerPath ();\n    log.println (\"Concat files into: \" + outputFile);\n    OutputStream out = new FileOutputStream (absPath + outputFile);\n    byte [] buffer = new byte [4096];\n    int readBytes;\n    for (String file : inputFiles) {\n        log.println (\" Read: \" + file);\n        InputStream in = new FileInputStream (absPath + file);\n        while ((readBytes = in.read (buffer)) != - 1) {\n            out.write (buffer, 0, readBytes);\n        }\n        in.close ();\n    }\n    out.close ();\n    if (compress) {\n        long normalSize = new File (absPath + outputFile).length ();\n        ProcessBuilder builder = new ProcessBuilder (\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n        builder.directory (new File (absPath));\n        Process process = builder.start ();\n        process.waitFor ();\n        long minSize = new File (absPath + outputFile).length ();\n        long diff = normalSize - minSize;\n        double percentage = Math.floor ((double) diff / normalSize * 1000.0) / 10.0;\n        double diffSize = (Math.floor (diff / 1024.0 * 10.0) / 10.0);\n        log.println (\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n    }\n}\n", "code2": "public static void copyFile (File src, File dest, int bufSize, boolean force) throws IOException {\n    if (dest.exists ()) if (force) dest.delete ();\n    else throw new IOException (\"Cannot overwrite existing file: \" + dest.getName ());\n\n    byte [] buffer = new byte [bufSize];\n    int read = 0;\n    InputStream in = null;\n    OutputStream out = null;\n    try {\n        in = new FileInputStream (src);\n        out = new FileOutputStream (dest);\n        while (true) {\n            read = in.read (buffer);\n            if (read == - 1) break;\n\n            out.write (buffer, 0, read);\n        }\n    } finally {\n        if (in != null) try {\n            in.close ();\n        } finally {\n            if (out != null) out.close ();\n\n        }\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 7286523, "method2_id": 21044707, "code1": "public boolean install (InstallMonitor moni) throws AbortInstallException {\n    installedName = Info.getSystemActions ().getTargetName (location, target);\n    backupFile (moni, installedName);\n    OutputStream os = Info.getSystemActions ().openOutputFile (location, target);\n    if (os == null) return false;\n\n    long bytes_written = 0;\n    try {\n        InputStream is = getClass ().getResourceAsStream (\"/Uninstall.class\");\n        if (is != null) {\n            byte [] buffer = new byte [4096];\n            int bytes = 0;\n            while ((bytes = is.read (buffer)) >= 0) {\n                os.write (buffer, 0, bytes);\n                bytes_written += bytes;\n            }\n        }\n    } catch (Exception e) {\n        System.err.println (\"can not write installer zip : \" + e);\n        System.err.println (\"last file was Uninstall.class\");\n        e.printStackTrace ();\n        return false;\n    }\n    ZipOutputStream zips = new ZipOutputStream (os, bytes_written);\n    zips.setLevel (9);\n    InstallableFile insf = null;\n    long count = 0;\n    try {\n        Enumeration instEn = container.getAllInstallables ();\n        while (instEn.hasMoreElements ()) {\n            Installable inst = (Installable) (instEn.nextElement ());\n            if (! (inst instanceof InstallableFile)) continue;\n\n            insf = (InstallableFile) inst;\n            if (! insf.getPackage ().equals (\"installer\")) continue;\n\n            InputStream is = Info.getInstallationSource ().getFile (insf.getName (), insf.getLocation ());\n            if (is == null) {\n                System.err.println (\"can not get installer component \" + insf.getName ());\n                return false;\n            }\n            ZipEntry ze = new ZipEntry (insf.getName ());\n            zips.putNextEntry (ze);\n            byte [] buffer = new byte [4096];\n            int bytes = 0;\n            count = 0;\n            try {\n                while ((bytes = is.read (buffer)) >= 0) {\n                    count += bytes;\n                    zips.write (buffer, 0, bytes);\n                }\n            } catch (EOFException e) {\n            }\n            is.close ();\n        }\n        wasInstalled = true;\n        ZipEntry ze = new ZipEntry (\"uninstall.dat\");\n        zips.putNextEntry (ze);\n        Info.saveState (zips);\n        zips.finish ();\n    } catch (Exception e) {\n        System.err.println (\"can not write installer zip : \" + e);\n        System.err.println (\"last file was \" + insf);\n        System.err.println (\"got \" + count + \" bytes from that file\\n\");\n        e.printStackTrace ();\n        return false;\n    }\n    return true;\n}\n", "code2": "public static boolean ZipFiles (String [] files, String zipname, boolean type) throws Exception {\n    FileOutputStream os = new FileOutputStream (zipname);\n    ZipOutputStream zip = new ZipOutputStream (os);\n    for (int i = 0;\n    i < files.length; i ++) {\n        File file = new File (files [i]);\n        if (file.exists ()) {\n            byte [] buf = new byte [1024];\n            int len;\n            ZipEntry zipEntry = new ZipEntry (type ? file.getName () : file.getPath ());\n            try {\n                FileInputStream fin = new FileInputStream (file);\n                BufferedInputStream in = new BufferedInputStream (fin);\n                zip.putNextEntry (zipEntry);\n                while ((len = in.read (buf)) >= 0) {\n                    zip.write (buf, 0, len);\n                }\n                in.close ();\n                zip.closeEntry ();\n            } catch (FileNotFoundException e) {\n            } catch (IOException e) {\n            }\n        }\n    }\n    zip.close ();\n    os.close ();\n    return true;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 17468430, "method2_id": 23087894, "code1": "private String mkSid () {\n    String temp = toString ();\n    MessageDigest messagedigest = null;\n    try {\n        messagedigest = MessageDigest.getInstance (\"SHA\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace ();\n        return null;\n    }\n    messagedigest.update (temp.getBytes ());\n    byte digest [] = messagedigest.digest ();\n    String chk = \"\";\n    for (int i = 0;\n    i < digest.length; i ++) {\n        String s = Integer.toHexString (digest [i] & 0xFF);\n        chk += ((s.length () == 1) ? \"0\" + s : s);\n    }\n    return chk.toString ();\n}\n", "code2": "public static String digest (String str) {\n    StringBuffer sb = new StringBuffer ();\n    try {\n        MessageDigest md5 = MessageDigest.getInstance (\"md5\");\n        md5.update (str.getBytes (\"ISO8859-1\"));\n        byte [] array = md5.digest ();\n        for (int x = 0;\n        x < 16; x ++) {\n            if ((array [x] & 0xff) < 0x10) sb.append (\"0\");\n\n            sb.append (Long.toString (array [x] & 0xff, 16));\n        }\n    } catch (Exception e) {\n        System.out.println (e);\n    }\n    return sb.toString ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 576772, "method2_id": 8107001, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "@Override\npublic void onCreate (Bundle savedInstanceState) {\n    super.onCreate (savedInstanceState);\n    setContentView (R.layout.listview);\n    HttpGet request = new HttpGet (SERVICE_URI + \"/json/getroutes/1\");\n    request.setHeader (\"Accept\", \"application/json\");\n    request.setHeader (\"Content-type\", \"application/json\");\n    DefaultHttpClient httpClient = new DefaultHttpClient ();\n    String theString = new String (\"\");\n    try {\n        HttpResponse response = httpClient.execute (request);\n        HttpEntity responseEntity = response.getEntity ();\n        InputStream stream = responseEntity.getContent ();\n        BufferedReader reader = new BufferedReader (new InputStreamReader (stream));\n        Vector < String > vectorOfStrings = new Vector < String > ();\n        String tempString = new String ();\n        String tempStringAgent = new String ();\n        String tempStringClient = new String ();\n        String tempStringRoute = new String ();\n        String tempStringZone = new String ();\n        StringBuilder builder = new StringBuilder ();\n        String line;\n        while ((line = reader.readLine ()) != null) {\n            builder.append (line);\n        }\n        stream.close ();\n        theString = builder.toString ();\n        JSONObject json = new JSONObject (theString);\n        Log.i (\"_GetClient_\", \"<jsonobject>\\n\" + json.toString () + \"\\n</jsonobject>\");\n        this.dm = new DataManipulator (this);\n        JSONArray nameArray = json.getJSONArray (\"GetRoutesByAgentResult\");\n        for (int i = 0;\n        i < nameArray.length (); i ++) {\n            tempStringAgent = nameArray.getJSONObject (i).getString (\"Agent\");\n            tempStringClient = nameArray.getJSONObject (i).getString (\"Client\");\n            tempStringRoute = nameArray.getJSONObject (i).getString (\"Route\");\n            tempStringZone = nameArray.getJSONObject (i).getString (\"Zone\");\n            Log.i (\"_GetClient_\", \"<Agent\" + i + \">\" + tempStringAgent + \"</Agent\" + i + \">\\n\");\n            Log.i (\"_GetClient_\", \"<Client\" + i + \">\" + tempStringClient + \"</Client\" + i + \">\\n\");\n            Log.i (\"_GetClient_\", \"<Route\" + i + \">\" + tempStringRoute + \"</Route\" + i + \">\\n\");\n            Log.i (\"_GetClient_\", \"<Zone\" + i + \">\" + tempStringZone + \"</Zone\" + i + \">\\n\");\n            tempString = nameArray.getJSONObject (i).getString (\"Client\") + \"\\n\" + nameArray.getJSONObject (i).getString (\"Route\") + \"\\n\" + nameArray.getJSONObject (i).getString (\"Zone\");\n            vectorOfStrings.add (new String (tempString));\n        }\n        int orderCount = vectorOfStrings.size ();\n        String [] orderTimeStamps = new String [orderCount];\n        vectorOfStrings.copyInto (orderTimeStamps);\n        setListAdapter (new ArrayAdapter < String > (this, android.R.layout.simple_list_item_1, orderTimeStamps));\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 7569985, "method2_id": 10101208, "code1": "public static void save (MainWindow mw, String filename) {\n    if (filename != null) {\n        try {\n            BufferedInputStream origin = null;\n            FileOutputStream dest;\n            if (filename.endsWith (\".cecco\")) dest = new FileOutputStream (filename);\n            else dest = new FileOutputStream (filename + \".cecco\");\n\n            System.out.println (\"Saving : \" + filename);\n            ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));\n            byte data [] = new byte [BUFFER];\n            File [] files = new File [3];\n            files [0] = FileContener.getOnto ();\n            files [1] = FileContener.getCurrentContr ();\n            files [2] = FileContener.getCurrentCacog ();\n            for (int i = 0;\n            i < files.length; i ++) {\n                System.out.println (\"Adding: \" + files [i]);\n                FileInputStream fi = new FileInputStream (files [i]);\n                origin = new BufferedInputStream (fi, BUFFER);\n                ZipEntry entry = new ZipEntry (files [i].getName ());\n                out.putNextEntry (entry);\n                int count;\n                while ((count = origin.read (data, 0, BUFFER)) != - 1) {\n                    out.write (data, 0, count);\n                }\n                origin.close ();\n            }\n            out.close ();\n        } catch (Exception e) {\n            e.printStackTrace ();\n        }\n    }\n}\n", "code2": "public static void createZipFile (final String zipFileName, final String pathDirectoryToZip, final String pathZipFile) throws Exception {\n    if (zipFileName == null || zipFileName.length () == 0) {\n        throw new IllegalArgumentException (\"zipFileName shouldn't be null\");\n    }\n    if (pathDirectoryToZip == null || pathDirectoryToZip.length () == 0) {\n        throw new IllegalArgumentException (\"pathDirectoryToZip shouldn't be null\");\n    }\n    final File di = new File (pathDirectoryToZip);\n    final File [] files1 = di.listFiles ();\n    final FileOutputStream dest = new FileOutputStream (pathZipFile + ZIP_FILE_SEP + zipFileName);\n    final CheckedOutputStream checksum = new CheckedOutputStream (dest, new Adler32 ());\n    final BufferedOutputStream buff = new BufferedOutputStream (checksum);\n    final ZipOutputStream out = new ZipOutputStream (buff);\n    out.setMethod (ZipOutputStream.DEFLATED);\n    out.setLevel (Deflater.BEST_COMPRESSION);\n    final byte [] data = new byte [NB_BITE];\n    for (final File f : files1) {\n        if (f.isDirectory ()) {\n            zipDir (f, \"\", out);\n        } else {\n            final FileInputStream fi = new FileInputStream (pathDirectoryToZip + ZIP_FILE_SEP + f.getName ());\n            final BufferedInputStream buffi = new BufferedInputStream (fi, NB_BITE);\n            final ZipEntry entry = new ZipEntry (f.getName ());\n            out.putNextEntry (entry);\n            int count;\n            while ((count = buffi.read (data, 0, NB_BITE)) != - 1) {\n                out.write (data, 0, count);\n            }\n            out.closeEntry ();\n            buffi.close ();\n        }\n    }\n    out.close ();\n    buff.close ();\n    checksum.close ();\n    dest.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4656580, "method2_id": 17698952, "code1": "public void addKmlFile (byte [] doc) throws IOException {\n    ZipEntry zKml = new ZipEntry (\"data.kml\");\n    kmz.putNextEntry (zKml);\n    kmz.write (doc);\n    kmz.closeEntry ();\n}\n", "code2": "protected static void createZipFile (String zipName, List < File > files) {\n    byte [] buf = new byte [1024];\n    try {\n        if (files.size () > 0) {\n            ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipName));\n            int len;\n            for (File file : files) {\n                FileInputStream in = new FileInputStream (file);\n                ZipEntry entry = new ZipEntry (file.getPath ());\n                out.putNextEntry (entry);\n                while ((len = in.read (buf)) != - 1) {\n                    out.write (buf, 0, len);\n                }\n                out.closeEntry ();\n                in.close ();\n            }\n            out.close ();\n        }\n    } catch (IOException e) {\n        throw new RuntimeException (e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3958807, "method2_id": 21682040, "code1": "private void loadBinaryStream (String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n    resp.setContentType (getContentType (req, streamName));\n    resp.setHeader (\"Content-Disposition\", \"inline;filename=\" + streamName);\n    resp.setContentLength ((int) sz);\n    OutputStream out = resp.getOutputStream ();\n    BufferedOutputStream bos = new BufferedOutputStream (out, 2048);\n    try {\n        IOUtils.copy (streamToLoad, bos);\n    } finally {\n        IOUtils.closeQuietly (streamToLoad);\n        IOUtils.closeQuietly (bos);\n    }\n    getCargo ().put (GWT_ENTRY_POINT_PAGE_PARAM, null);\n}\n", "code2": "public void extractFrinika () throws Exception {\n    FileInputStream fis = new FileInputStream (frinikaFile);\n    progressBar.setIndeterminate (true);\n    ZipInputStream zis = new ZipInputStream (fis);\n    ZipEntry ze = zis.getNextEntry ();\n    while (ze != null) {\n        showMessage (\"Extracting: \" + ze.getName ());\n        File file = new File (installDirName + \"/\" + ze.getName ());\n        if (ze.isDirectory ()) file.mkdir ();\n        else {\n            FileOutputStream fos = new FileOutputStream (file);\n            byte [] b = new byte [BUFSIZE];\n            int c;\n            while ((c = zis.read (b)) != - 1) fos.write (b, 0, c);\n\n            fos.close ();\n        }\n        ze = zis.getNextEntry ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 716792, "method2_id": 11082670, "code1": "public static void doVersionCheck (View view) {\n    view.showWaitCursor ();\n    try {\n        URL url = new URL (jEdit.getProperty (\"version-check.url\"));\n        InputStream in = url.openStream ();\n        BufferedReader bin = new BufferedReader (new InputStreamReader (in));\n        String line;\n        String develBuild = null;\n        String stableBuild = null;\n        while ((line = bin.readLine ()) != null) {\n            if (line.startsWith (\".build\")) develBuild = line.substring (6).trim ();\n            else if (line.startsWith (\".stablebuild\")) stableBuild = line.substring (12).trim ();\n\n        }\n        bin.close ();\n        if (develBuild != null && stableBuild != null) {\n            doVersionCheck (view, stableBuild, develBuild);\n        }\n    } catch (IOException e) {\n        String [] args = {jEdit.getProperty (\"version-check.url\"), e.toString ()};\n        GUIUtilities.error (view, \"read-error\", args);\n    }\n    view.hideWaitCursor ();\n}\n", "code2": "@SuppressWarnings(\"unchecked\")\npublic List < Event > lookupFutureEvents (String groupIdentifier) throws GtugsException {\n    StringBuilder json = new StringBuilder ();\n    String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n    try {\n        URL url = new URL (requestUrl.toString ());\n        BufferedReader in = new BufferedReader (new InputStreamReader (url.openStream ()));\n        String inputLine;\n        while ((inputLine = in.readLine ()) != null) {\n            json.append (inputLine);\n        }\n        in.close ();\n    } catch (IOException e) {\n        throw new GtugsException (e);\n    }\n    List < Event > events = new ArrayList < Event > ();\n    JSONObject jsonObj = (JSONObject) JSONValue.parse (json.toString ());\n    JSONArray results = (JSONArray) jsonObj.get (\"results\");\n    for (int i = 0;\n    i < results.size (); i ++) {\n        JSONObject result = (JSONObject) results.get (i);\n        Event e = new Event ();\n        e.setAttendeeCount (Integer.parseInt ((String) result.get (\"rsvpcount\")));\n        e.setCity ((String) result.get (\"venue_city\"));\n        e.setDescription ((String) result.get (\"description\"));\n        e.setLatitude (Double.parseDouble ((String) result.get (\"venue_lat\")));\n        e.setLongitude (Double.parseDouble ((String) result.get (\"venue_lon\")));\n        e.setName ((String) result.get (\"name\"));\n        Date myDate = null;\n        String time = (String) result.get (\"time\");\n        try {\n            myDate = meetupDateFormat.parse (time);\n            e.setStartTime (timeDateFormat.format (myDate));\n            e.setEndTime (timeDateFormat.format (myDate));\n            e.setStartDate (myDate);\n            e.setEndDate (myDate);\n            String tz = tzDateFormat.format (myDate);\n            if (tz != null && tz.startsWith (\"+\")) {\n                tz = tz.substring (1);\n            }\n            e.setTimeZone (Integer.toString (Integer.parseInt (tz) / 100));\n        } catch (ParseException ex) {\n            ex.printStackTrace ();\n            continue;\n        }\n        e.setState ((String) result.get (\"venue_state\"));\n        StringBuilder addressBuilder = new StringBuilder ();\n        if (result.get (\"venue_address1\") != null) {\n            addressBuilder.append ((String) result.get (\"venue_address1\") + \" \");\n        }\n        if (result.get (\"venue_address2\") != null) {\n            addressBuilder.append ((String) result.get (\"venue_address2\") + \" \");\n        }\n        if (result.get (\"venue_address3\") != null) {\n            addressBuilder.append ((String) result.get (\"venue_address3\") + \" \");\n        }\n        if (result.get (\"venue_address4\") != null) {\n            addressBuilder.append ((String) result.get (\"venue_address4\"));\n        }\n        e.setStreetAddress (addressBuilder.toString ().trim ());\n        e.setZipCode ((String) result.get (\"venue_zip\"));\n        e.setUrl ((String) result.get (\"event_url\"));\n        events.add (e);\n    }\n    return events;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 392357, "method2_id": 6185786, "code1": "private void displayDiffResults () throws IOException {\n    File outFile = File.createTempFile (\"diff\", \".htm\");\n    outFile.deleteOnExit ();\n    FileOutputStream outStream = new FileOutputStream (outFile);\n    BufferedWriter out = new BufferedWriter (new OutputStreamWriter (outStream));\n    out.write (\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n    if (addedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n        out.write (addedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    if (modifiedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n        out.write (modifiedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    if (deletedTable.length () > 0) {\n        out.write (\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n        out.write (deletedTable.toString ());\n        out.write (\"</table><br><br>\");\n    }\n    out.write (\"<table name=METRICS BORDER>\\n\");\n    if (modifiedTable.length () > 0 || deletedTable.length () > 0) {\n        out.write (\"<tr><td>Base:&nbsp;</td><td>\");\n        out.write (Long.toString (base));\n        out.write (\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n        out.write (Long.toString (deleted));\n        out.write (\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n        out.write (Long.toString (modified));\n        out.write (\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n        out.write (Long.toString (added));\n        out.write (\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n        out.write (Long.toString (added + modified));\n        out.write (\"</td></tr>\\n\");\n    }\n    out.write (\"<tr><td>Total:&nbsp;</td><td>\");\n    out.write (Long.toString (total));\n    out.write (\"</td></tr>\\n</table></div>\");\n    redlinesOut.close ();\n    out.flush ();\n    InputStream redlines = new FileInputStream (redlinesTempFile);\n    byte [] buffer = new byte [4096];\n    int bytesRead;\n    while ((bytesRead = redlines.read (buffer)) != - 1) outStream.write (buffer, 0, bytesRead);\n\n    outStream.write (\"</BODY></HTML>\".getBytes ());\n    outStream.close ();\n    Browser.launch (outFile.toURL ().toString ());\n}\n", "code2": "protected void copyFile (File from, File to) throws IOException {\n    to.getParentFile ().mkdirs ();\n    InputStream in = new FileInputStream (from);\n    try {\n        OutputStream out = new FileOutputStream (to);\n        try {\n            byte [] buf = new byte [1024];\n            int readLength;\n            while ((readLength = in.read (buf)) > 0) {\n                out.write (buf, 0, readLength);\n            }\n        } finally {\n            out.close ();\n        }\n    } finally {\n        in.close ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 13312539, "method2_id": 19436818, "code1": "private void executeScript (SQLiteDatabase sqlDatabase, InputStream input) {\n    StringWriter writer = new StringWriter ();\n    try {\n        IOUtils.copy (input, writer);\n    } catch (IOException e) {\n        throw new ComixException (\"Could not read the database script\", e);\n    }\n    String multipleSql = writer.toString ();\n    String [] split = multipleSql.split (\"-- SCRIPT_SPLIT --\");\n    for (String sql : split) {\n        if (! sql.trim ().equals (\"\")) {\n            sqlDatabase.execSQL (sql);\n        }\n    }\n}\n", "code2": "private void collectImageFile (@NotNull\nfinal Progress progress,@NotNull\nfinal File collectedDirectory) throws IOException {\n    final File file = new File (collectedDirectory, ActionBuilderUtils.getString (ACTION_BUILDER, \"configSource.image.name\"));\n    final FileOutputStream fos = new FileOutputStream (file);\n    try {\n        final FileChannel outChannel = fos.getChannel ();\n        try {\n            final int numOfFaceObjects = faceObjects.size ();\n            progress.setLabel (ActionBuilderUtils.getString (ACTION_BUILDER, \"archCollectImages\"), numOfFaceObjects);\n            final ByteBuffer byteBuffer = ByteBuffer.allocate (1024);\n            final Charset charset = Charset.forName (\"ISO-8859-1\");\n            int i = 0;\n            for (final FaceObject faceObject : faceObjects) {\n                final String face = faceObject.getFaceName ();\n                final String path = archFaceProvider.getFilename (face);\n                try {\n                    final FileInputStream fin = new FileInputStream (path);\n                    try {\n                        final FileChannel inChannel = fin.getChannel ();\n                        final long imageSize = inChannel.size ();\n                        byteBuffer.clear ();\n                        byteBuffer.put ((\"IMAGE \" + (faceObjects.isIncludeFaceNumbers () ? i + \" \" : \"\") + imageSize + \" \" + face + \"\\n\").getBytes (charset));\n                        byteBuffer.flip ();\n                        outChannel.write (byteBuffer);\n                        inChannel.transferTo (0L, imageSize, outChannel);\n                    } finally {\n                        fin.close ();\n                    }\n                } catch (final FileNotFoundException ignored) {\n                    ACTION_BUILDER.showMessageDialog (progress.getParentComponent (), \"archCollectErrorFileNotFound\", path);\n                    return;\n                } catch (final IOException e) {\n                    ACTION_BUILDER.showMessageDialog (progress.getParentComponent (), \"archCollectErrorIOException\", path, e);\n                    return;\n                }\n                if (i ++ % 100 == 0) {\n                    progress.setValue (i);\n                }\n            }\n            progress.setValue (faceObjects.size ());\n        } finally {\n            outChannel.close ();\n        }\n    } finally {\n        fos.close ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4960420, "method2_id": 22246375, "code1": "public static boolean writeFileB2C (InputStream pIs, File pFile, boolean pAppend) {\n    boolean flag = false;\n    try {\n        FileWriter fw = new FileWriter (pFile, pAppend);\n        IOUtils.copy (pIs, fw);\n        fw.flush ();\n        fw.close ();\n        pIs.close ();\n        flag = true;\n    } catch (Exception e) {\n        LOG.error (\"\u5c06\u5b57\u8282\u6d41\u5199\u5165\ufffd?\" + pFile.getName () + \"\u51fa\u73b0\u5f02\u5e38\ufffd?\", e);\n    }\n    return flag;\n}\n", "code2": "public static boolean decodeFileToFile (String infile, String outfile) {\n    boolean success = false;\n    java.io.InputStream in = null;\n    java.io.OutputStream out = null;\n    try {\n        in = new Base64.InputStream (new java.io.BufferedInputStream (new java.io.FileInputStream (infile)), Base64.DECODE);\n        out = new java.io.BufferedOutputStream (new java.io.FileOutputStream (outfile));\n        byte [] buffer = new byte [65536];\n        int read = - 1;\n        while ((read = in.read (buffer)) >= 0) {\n            out.write (buffer, 0, read);\n        }\n        success = true;\n    } catch (java.io.IOException exc) {\n        exc.printStackTrace ();\n    } finally {\n        try {\n            in.close ();\n        } catch (Exception exc) {\n        }\n        try {\n            out.close ();\n        } catch (Exception exc) {\n        }\n    }\n    return success;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 13221212, "method2_id": 17713680, "code1": "public static void generate (final InputStream input, String format, Point dimension, IPath outputLocation) throws CoreException {\n    MultiStatus status = new MultiStatus (GraphVizActivator.ID, 0, \"Errors occurred while running Graphviz\", null);\n    File dotInput = null, dotOutput = outputLocation.toFile ();\n    ByteArrayOutputStream dotContents = new ByteArrayOutputStream ();\n    try {\n        dotInput = File.createTempFile (TMP_FILE_PREFIX, DOT_EXTENSION);\n        FileOutputStream tmpDotOutputStream = null;\n        try {\n            IOUtils.copy (input, dotContents);\n            tmpDotOutputStream = new FileOutputStream (dotInput);\n            IOUtils.copy (new ByteArrayInputStream (dotContents.toByteArray ()), tmpDotOutputStream);\n        } finally {\n            IOUtils.closeQuietly (tmpDotOutputStream);\n        }\n        IStatus result = runDot (format, dimension, dotInput, dotOutput);\n        if (dotOutput.isFile ()) {\n            if (! result.isOK () && Platform.inDebugMode ()) LogUtils.log (status);\n\n            return;\n        }\n    } catch (IOException e) {\n        status.add (new Status (IStatus.ERROR, GraphVizActivator.ID, \"\", e));\n    } finally {\n        dotInput.delete ();\n        IOUtils.closeQuietly (input);\n    }\n    throw new CoreException (status);\n}\n", "code2": "public static void main (String [] args) {\n    if (args.length != 3) {\n        System.out.println (\"Usage: HexStrToBin enc/dec <infileName> <outfilename>\");\n        System.exit (1);\n    }\n    try {\n        ByteArrayOutputStream os = new ByteArrayOutputStream ();\n        InputStream in = new FileInputStream (args [1]);\n        int len = 0;\n        byte buf [] = new byte [1024];\n        while ((len = in.read (buf)) > 0) os.write (buf, 0, len);\n\n        in.close ();\n        os.close ();\n        byte [] data = null;\n        if (args [0].equals (\"dec\")) data = decode (os.toString ());\n        else {\n            String strData = encode (os.toByteArray ());\n            data = strData.getBytes ();\n        }\n        FileOutputStream fos = new FileOutputStream (args [2]);\n        fos.write (data);\n        fos.close ();\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 292856, "method2_id": 950903, "code1": "public static void main (String [] argv) throws Exception {\n    ByteArrayOutputStream bos = new ByteArrayOutputStream ();\n    XmlPullParser xp = new KXmlParser ();\n    xp.setInput (new FileInputStream (argv [0]), null);\n    XmlSerializer xs = new WbxmlSerializer ();\n    xs.setOutput (bos, null);\n    new Roundtrip (xp, xs).roundTrip ();\n    byte [] wbxml = bos.toByteArray ();\n    System.out.println (\"********* WBXML size: \" + wbxml.length + \" ***********\");\n    for (int i = 0;\n    i < wbxml.length; i += 16) {\n        for (int j = i;\n        j < Math.min (i + 16, wbxml.length); j ++) {\n            int b = ((int) wbxml [j]) & 0x0ff;\n            System.out.print (Integer.toHexString (b / 16));\n            System.out.print (Integer.toHexString (b % 16));\n            System.out.print (' ');\n        }\n        for (int j = i;\n        j < Math.min (i + 16, wbxml.length); j ++) {\n            int b = wbxml [j];\n            System.out.print (b >= 32 && b <= 127 ? (char) b : '?');\n        }\n        System.out.println ();\n    }\n    ByteArrayInputStream bis = new ByteArrayInputStream (wbxml);\n    xp = new WbxmlParser ();\n    xp.setInput (bis, null);\n    xs = new KXmlSerializer ();\n    xs.setOutput (System.out, null);\n    new Roundtrip (xp, xs).roundTrip ();\n}\n", "code2": "public static void main (String args []) throws Exception {\n    int device = 0;\n    byte [] writeArray = null;\n    String dumpPrefix = null;\n    OSIDataLinkDevice [] devices = OSIDataLinkDevice.getDevices ();\n    try {\n        for (int ii = 0;\n        ii < args.length; ++ ii) {\n            if (\"-dev\".equals (args [ii])) {\n                String devStr = args [++ ii];\n                try {\n                    device = Integer.parseInt (devStr);\n                } catch (NumberFormatException nfe) {\n                    FileInputStream fis = new FileInputStream (devStr);\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream ();\n                    int ch;\n                    while ((ch = fis.read ()) != - 1) baos.write (ch);\n\n                    device = OSIDataLinkDevice.findBestMatch (devices, new String (baos.toByteArray ()));\n                }\n            } else if (\"-l\".equals (args [ii])) {\n                listDev = true;\n            } else if (\"-xml\".equals (args [ii])) {\n                showXML = true;\n            } else if (\"-ip\".equals (args [ii])) {\n                addIp = true;\n                String [] fromTo = new String [2];\n                ii = extractFromTo (args, ii + 1, fromTo);\n                if (fromTo [0] != null || fromTo [1] != null) {\n                    InetAddress fromIP = null, toIP = null;\n                    if (fromTo [0] != null) fromIP = InetAddress.getByName (fromTo [0]);\n\n                    if (fromTo [1] != null) toIP = InetAddress.getByName (fromTo [1]);\n\n                    ipFilters.add (new IPFromToFilter (fromIP, toIP));\n                }\n            } else if (\"-udp\".equals (args [ii])) {\n                addIp = addUdp = true;\n                String [] fromTo = new String [2];\n                ii = extractFromTo (args, ii + 1, fromTo);\n                if (fromTo [0] != null || fromTo [1] != null) {\n                    udpFilters.add (new UDPPortFilter (fromTo [0] != null ? Short.parseShort (fromTo [0]) : UDPPortFilter.UNSPECIFIED_PORT, fromTo [1] != null ? Short.parseShort (fromTo [1]) : UDPPortFilter.UNSPECIFIED_PORT));\n                }\n            } else if (\"-tcp\".equals (args [ii])) {\n                addIp = addTcp = true;\n                String [] fromTo = new String [2];\n                ii = extractFromTo (args, ii + 1, fromTo);\n                if (fromTo [0] != null || fromTo [1] != null) {\n                    tcpFilters.add (new TCPPortFilter (fromTo [0] != null ? Short.parseShort (fromTo [0]) : TCPPortFilter.UNSPECIFIED_PORT, fromTo [1] != null ? Short.parseShort (fromTo [1]) : TCPPortFilter.UNSPECIFIED_PORT));\n                }\n            } else if (\"-icmp\".equals (args [ii])) {\n                addIp = addIcmp = true;\n            } else if (\"-arp\".equals (args [ii])) {\n                addArp = true;\n            } else if (\"-raw\".equals (args [ii])) {\n                showRaw = true;\n            } else if (\"-dump\".equals (args [ii])) {\n                dumpPrefix = args [++ ii];\n            } else if (\"-write\".equals (args [ii])) {\n                FileInputStream fis = new FileInputStream (args [++ ii]);\n                ByteArrayOutputStream baos = new ByteArrayOutputStream ();\n                int ch;\n                while ((ch = fis.read ()) != - 1) baos.write (ch);\n\n                writeArray = baos.toByteArray ();\n            } else if (\"-n\".equals (args [ii])) {\n                byteLimit = Integer.parseInt (args [++ ii]);\n            } else {\n                showHelp ();\n                return;\n            }\n\n        }\n    } catch (ArrayIndexOutOfBoundsException aie) {\n        aie.printStackTrace ();\n        System.err.println (\"Invalid arguments.\");\n        showHelp ();\n        return;\n    }\n    if (listDev) {\n        listDevices (devices);\n        return;\n    }\n    OSIDataLinkDevice osld = devices [device];\n    devices = null;\n    System.out.println (osld);\n    if (showXML) System.out.println (osld.getXMLDescription ());\n\n    if (addIp) {\n        if (ipFilters.size () == 0) {\n            IPHandler iph = new IPHandler (osld);\n            addHandlers (iph, \"IP Packet\");\n        } else for (Iterator iter = ipFilters.iterator ();\n        iter.hasNext ();) {\n            IPHandler iph = new IPHandler (osld);\n            IPFilter f = (IPFilter) iter.next ();\n            iph.addFilter (f);\n            addHandlers (iph, f.toString ());\n        }\n\n    } else if (addArp) {\n        ARPHandler arph = new ARPHandler (osld);\n        arph.addPacketListener (new MyPacketListener (\"ARP Packet\"));\n    } else showRaw = true;\n\n    if (showRaw) osld.addPacketListener (new MyPacketListener (\"Raw\"));\n\n    if (dumpPrefix != null) osld.addPacketListener (new DumpPacketListener (dumpPrefix));\n\n    osld.startCapture ();\n    if (writeArray != null) osld.sendPacket (writeArray);\n\n    while (System.in.read () != '\\n');\n\n    osld.stopCapture ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 16292791, "method2_id": 20375440, "code1": "public void doCompress (File [] files, File out, List < String > excludedKeys) {\n    Map < String, File > map = new HashMap < String, File > ();\n    String parent = FilenameUtils.getBaseName (out.getName ());\n    for (File f : files) {\n        CompressionUtil.list (f, parent, map, excludedKeys);\n    }\n    if (! map.isEmpty ()) {\n        FileOutputStream fos = null;\n        ArchiveOutputStream aos = null;\n        InputStream is = null;\n        try {\n            fos = new FileOutputStream (out);\n            aos = getArchiveOutputStream (fos);\n            for (Map.Entry < String, File > entry : map.entrySet ()) {\n                File file = entry.getValue ();\n                ArchiveEntry ae = getArchiveEntry (file, entry.getKey ());\n                aos.putArchiveEntry (ae);\n                if (file.isFile ()) {\n                    IOUtils.copy (is = new FileInputStream (file), aos);\n                    IOUtils.closeQuietly (is);\n                    is = null;\n                }\n                aos.closeArchiveEntry ();\n            }\n            aos.finish ();\n        } catch (IOException ex) {\n            ex.printStackTrace ();\n        } finally {\n            IOUtils.closeQuietly (is);\n            IOUtils.closeQuietly (aos);\n            IOUtils.closeQuietly (fos);\n        }\n    }\n}\n", "code2": "public static void copyFile (File srcFile, File destFile) throws IOException {\n    InputStream src = new FileInputStream (srcFile);\n    OutputStream dest = new FileOutputStream (destFile);\n    byte buffer [] = new byte [1024];\n    int read = 1;\n    while (read > 0) {\n        read = src.read (buffer);\n        if (read > 0) {\n            dest.write (buffer, 0, read);\n        }\n    }\n    src.close ();\n    dest.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6719721, "method2_id": 6719728, "code1": "public void testBoundaryMatches () {\n    Pattern p = null;\n    Matcher m = null;\n    p = Pattern.compile (\"^Hello\\\\w*\", Pattern.CASE_INSENSITIVE);\n    m = p.matcher (\"Hello how are you doing\");\n    boolean _found = false;\n    while (m.find ()) {\n        System.out.println (\" : Boundary-Search \\\"\" + m.group () + \"\\\" start :  \" + m.start () + \" end : \" + m.end () + \".\");\n        _found = true;\n    }\n    assertTrue (_found);\n    m = p.matcher (\"Helloksjkld how are you doing\");\n    _found = false;\n    while (m.find ()) {\n        System.out.println (\" : Boundary-Search \\\"\" + m.group () + \"\\\" start :  \" + m.start () + \" end : \" + m.end () + \".\");\n        _found = true;\n    }\n    assertTrue (_found);\n    p = Pattern.compile (\"\\\\bHello\\\\B\", Pattern.CASE_INSENSITIVE);\n    m = p.matcher (\"This is not fun Hello ksjkldhow are you doing\");\n    _found = false;\n    while (m.find ()) {\n        System.out.println (\" : New-Search \\\"\" + m.group () + \"\\\" start :  \" + m.start () + \" end : \" + m.end () + \".\");\n        _found = true;\n    }\n    assertFalse (_found);\n    p = Pattern.compile (\"\\\\bHello\\\\b\", Pattern.CASE_INSENSITIVE);\n    m = p.matcher (\"This is not fun Hello ksjkldhow are you doing\");\n    _found = false;\n    while (m.find ()) {\n        System.out.println (\" : New-Search \\\"\" + m.group () + \"\\\" start :  \" + m.start () + \" end : \" + m.end () + \".\");\n        _found = true;\n    }\n    assertTrue (_found);\n}\n", "code2": "public void testExtractFront () {\n    String cmd = \"sendmsg hello this is fun\";\n    Pattern p = null;\n    Matcher m = null;\n    p = Pattern.compile (\"\\\\s\", Pattern.CASE_INSENSITIVE);\n    m = p.matcher (cmd);\n    String results [] = p.split (cmd);\n    boolean _found = false;\n    int str = - 1;\n    int end = - 1;\n    while (m.find ()) {\n        str = m.start ();\n        end = m.end ();\n        _found = true;\n        break;\n    }\n    BotLogger.log (\"--+\" + results [0] + \" :\" + cmd.substring (end, cmd.length ()).trim ());\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1158842, "method2_id": 15236847, "code1": "public static int unzipFile (File file_input, File dir_output) {\n    ZipInputStream zip_in_stream;\n    try {\n        FileInputStream in = new FileInputStream (file_input);\n        BufferedInputStream source = new BufferedInputStream (in);\n        zip_in_stream = new ZipInputStream (source);\n    } catch (IOException e) {\n        return STATUS_IN_FAIL;\n    }\n    byte [] input_buffer = new byte [BUF_SIZE];\n    int len = 0;\n    do {\n        try {\n            ZipEntry zip_entry = zip_in_stream.getNextEntry ();\n            if (zip_entry == null) break;\n\n            File output_file = new File (dir_output, zip_entry.getName ());\n            FileOutputStream out = new FileOutputStream (output_file);\n            BufferedOutputStream destination = new BufferedOutputStream (out, BUF_SIZE);\n            while ((len = zip_in_stream.read (input_buffer, 0, BUF_SIZE)) != - 1) destination.write (input_buffer, 0, len);\n\n            destination.flush ();\n            out.close ();\n        } catch (IOException e) {\n            return STATUS_GUNZIP_FAIL;\n        }\n    } while (true);\n    try {\n        zip_in_stream.close ();\n    } catch (IOException e) {\n    }\n    return STATUS_OK;\n}\n", "code2": "private static MapEntry < String, Properties > loadFpmConf () throws ConfigurationReadException {\n    MapEntry < String, Properties > ret = null;\n    Scanner sc = new Scanner (CONF_PATHS).useDelimiter (SEP_P);\n    String prev = \"\";\n    while (sc.hasNext () && ! hasLoaded) {\n        Properties fpmConf = null;\n        boolean relative = false;\n        String path = sc.next ();\n        if (path.startsWith (PREV_P)) {\n            path = path.replace (PREV_P, prev.substring (0, prev.length () - 1));\n        } else if (path.startsWith (REL_P)) {\n            path = path.replace (REL_P + FS, \"\");\n            relative = true;\n        } else if (path.contains (HOME_P)) {\n            path = path.replace (HOME_P, USER_HOME);\n        }\n\n        prev = path;\n        path = path.concat (MAIN_CONF_FILE);\n        try {\n            InputStream is = null;\n            if (relative) {\n                is = ClassLoader.getSystemResourceAsStream (path);\n                path = getSystemConfDir ();\n                Strings.getOne ().createPath (path);\n                path += MAIN_CONF_FILE;\n                FileOutputStream os = new FileOutputStream (path);\n                IOUtils.copy (is, os);\n                os.flush ();\n                os.close ();\n                os = null;\n            } else {\n                is = new FileInputStream (path);\n            }\n            fpmConf = new Properties ();\n            fpmConf.load (is);\n            if (fpmConf.isEmpty ()) {\n                throw new ConfigurationReadException ();\n            }\n            ret = new MapEntry < String, Properties > (path, fpmConf);\n            hasLoaded = true;\n        } catch (FileNotFoundException e) {\n            fpmConf = null;\n            singleton = null;\n            hasLoaded = false;\n        } catch (IOException e) {\n            throw new ConfigurationReadException ();\n        }\n    }\n    return ret;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 16005066, "method2_id": 22921765, "code1": "private void setManagedContent (Entry entry, Datastream vds) throws StreamIOException {\n    if (m_transContext == DOTranslationUtility.SERIALIZE_EXPORT_ARCHIVE && ! m_format.equals (ATOM_ZIP1_1)) {\n        String mimeType = vds.DSMIME;\n        if (MimeTypeHelper.isText (mimeType) || MimeTypeHelper.isXml (mimeType)) {\n            try {\n                entry.setContent (IOUtils.toString (vds.getContentStream (), m_encoding), mimeType);\n            } catch (IOException e) {\n                throw new StreamIOException (e.getMessage (), e);\n            }\n        } else {\n            entry.setContent (vds.getContentStream (), mimeType);\n        }\n    } else {\n        String dsLocation;\n        IRI iri;\n        if (m_format.equals (ATOM_ZIP1_1) && m_transContext != DOTranslationUtility.AS_IS) {\n            dsLocation = vds.DSVersionID + \".\" + MimeTypeUtils.fileExtensionForMIMEType (vds.DSMIME);\n            try {\n                m_zout.putNextEntry (new ZipEntry (dsLocation));\n                IOUtils.copy (vds.getContentStream (), m_zout);\n                m_zout.closeEntry ();\n            } catch (IOException e) {\n                throw new StreamIOException (e.getMessage (), e);\n            }\n        } else {\n            dsLocation = StreamUtility.enc (DOTranslationUtility.normalizeDSLocationURLs (m_obj.getPid (), vds, m_transContext).DSLocation);\n        }\n        iri = new IRI (dsLocation);\n        entry.setSummary (vds.DSVersionID);\n        entry.setContent (iri, vds.DSMIME);\n    }\n}\n", "code2": "public static void copy (InputStream input, OutputStream output) throws IOException {\n    IOUtils.copy (input, output, true);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2326683, "method2_id": 12543783, "code1": "public static void encrypt (File plain, File symKey, File ciphered, String algorithm) throws IOException, ClassNotFoundException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n    Key key = null;\n    try {\n        ObjectInputStream in = new ObjectInputStream (new FileInputStream (symKey));\n        key = (Key) in.readObject ();\n    } catch (IOException ioe) {\n        KeyGenerator generator = KeyGenerator.getInstance (algorithm);\n        key = generator.generateKey ();\n        ObjectOutputStream out = new ObjectOutputStream (new java.io.FileOutputStream (symKey));\n        out.writeObject (key);\n        out.close ();\n    }\n    Cipher cipher = Cipher.getInstance (algorithm);\n    cipher.init (Cipher.ENCRYPT_MODE, new SecretKeySpec (key.getEncoded (), algorithm));\n    FileInputStream in = new FileInputStream (plain);\n    CipherOutputStream out = new CipherOutputStream (new FileOutputStream (ciphered), cipher);\n    byte [] buffer = new byte [4096];\n    for (int read = in.read (buffer);\n    read > - 1; read = in.read (buffer)) {\n        out.write (buffer, 0, read);\n    }\n    out.close ();\n}\n", "code2": "private boolean copy (File in, File out) {\n    try {\n        FileInputStream fis = new FileInputStream (in);\n        FileOutputStream fos = new FileOutputStream (out);\n        FileChannel readableChannel = fis.getChannel ();\n        FileChannel writableChannel = fos.getChannel ();\n        writableChannel.truncate (0);\n        writableChannel.transferFrom (readableChannel, 0, readableChannel.size ());\n        fis.close ();\n        fos.close ();\n        return true;\n    } catch (IOException ioe) {\n        System.out.println (\"Copy Error: IOException during copy\\r\\n\" + ioe.getMessage ());\n        return false;\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3791822, "method2_id": 16865047, "code1": "public Void doInBackground () {\n    setProgress (0);\n    for (int i = 0;\n    i < uploadFiles.size (); i ++) {\n        String filePath = uploadFiles.elementAt (i).getFilePath ();\n        String fileName = uploadFiles.elementAt (i).getFileName ();\n        String fileMsg = \"Uploading file \" + (i + 1) + \"/\" + uploadFiles.size () + \"\\n\";\n        this.publish (fileMsg);\n        try {\n            File inFile = new File (filePath);\n            FileInputStream in = new FileInputStream (inFile);\n            byte [] inBytes = new byte [(int) chunkSize];\n            int count = 1;\n            int maxCount = (int) (inFile.length () / chunkSize);\n            if (inFile.length () % chunkSize > 0) {\n                maxCount ++;\n            }\n            int readCount = 0;\n            readCount = in.read (inBytes);\n            while (readCount > 0) {\n                File splitFile = File.createTempFile (\"upl\", null, null);\n                String splitName = splitFile.getPath ();\n                FileOutputStream out = new FileOutputStream (splitFile);\n                out.write (inBytes, 0, readCount);\n                out.close ();\n                boolean chunkFinal = (count == maxCount);\n                fileMsg = \" - Sending chunk \" + count + \"/\" + maxCount + \": \";\n                this.publish (fileMsg);\n                boolean uploadSuccess = false;\n                int uploadTries = 0;\n                while (! uploadSuccess && uploadTries <= 5) {\n                    uploadTries ++;\n                    boolean uploadStatus = upload (splitName, fileName, count, chunkFinal);\n                    if (uploadStatus) {\n                        fileMsg = \"OK\\n\";\n                        this.publish (fileMsg);\n                        uploadSuccess = true;\n                    } else {\n                        fileMsg = \"ERROR\\n\";\n                        this.publish (fileMsg);\n                        uploadSuccess = false;\n                    }\n                }\n                if (! uploadSuccess) {\n                    fileMsg = \"There was an error uploading your files. Please let the pipeline administrator know about this problem. Cut and paste the messages in this box, and supply them.\\n\";\n                    this.publish (fileMsg);\n                    errorFlag = true;\n                    return null;\n                }\n                float thisProgress = (count * 100) / (maxCount);\n                float completeProgress = (i * (100 / uploadFiles.size ()));\n                float totalProgress = completeProgress + (thisProgress / uploadFiles.size ());\n                setProgress ((int) totalProgress);\n                splitFile.delete ();\n                readCount = in.read (inBytes);\n                count ++;\n            }\n        } catch (Exception e) {\n            this.publish (e.toString ());\n        }\n    }\n    return null;\n}\n", "code2": "public void serviceDocument (final TranslationRequest request, final TranslationResponse response, final Document document) throws Exception {\n    response.addHeaders (document.getResponseHeaders ());\n    try {\n        IOUtils.copy (document.getInputStream (), response.getOutputStream ());\n        response.setEndState (ResponseStateOk.getInstance ());\n    } catch (Exception e) {\n        response.setEndState (new ResponseStateException (e));\n        log.warn (\"Error parsing XML of \" + document, e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6680023, "method2_id": 22998998, "code1": "public ResourceMigrator getCompletedResourceMigrator () {\n    return new ResourceMigrator () {\n        public void migrate (InputMetadata meta, InputStream inputStream, OutputCreator outputCreator) throws IOException, ResourceMigrationException {\n            OutputStream outputStream = outputCreator.createOutputStream ();\n            IOUtils.copy (inputStream, outputStream);\n        }}\n\n    ;\n}\n", "code2": "public static void copyFile (File sourceFile, File destFile) throws IOException {\n    FileChannel inputFileChannel = new FileInputStream (sourceFile).getChannel ();\n    FileChannel outputFileChannel = new FileOutputStream (destFile).getChannel ();\n    long offset = 0L;\n    long length = inputFileChannel.size ();\n    final long MAXTRANSFERBUFFERLENGTH = 1024 * 1024;\n    try {\n        for (; offset < length;) {\n            offset += inputFileChannel.transferTo (offset, MAXTRANSFERBUFFERLENGTH, outputFileChannel);\n            inputFileChannel.position (offset);\n        }\n    } finally {\n        try {\n            outputFileChannel.close ();\n        } catch (Exception ignore) {\n        }\n        try {\n            inputFileChannel.close ();\n        } catch (IOException ignore) {\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 567476, "method2_id": 20310134, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "public static void copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    try {\n        inChannel.transferTo (0, inChannel.size (), outChannel);\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        if (inChannel != null) inChannel.close ();\n\n        if (outChannel != null) outChannel.close ();\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 7902699, "method2_id": 21822159, "code1": "public static List < String > getLevelIndex (URL fetchUrl) {\n    List < String > levelNames = new ArrayList < String > ();\n    BufferedReader bufferedreader;\n    try {\n        URLConnection urlconnection = fetchUrl.openConnection ();\n        urlconnection.setConnectTimeout (30000);\n        if (urlconnection.getContentEncoding () != null) {\n            bufferedreader = new BufferedReader (new InputStreamReader (urlconnection.getInputStream (), urlconnection.getContentEncoding ()));\n        } else {\n            bufferedreader = new BufferedReader (new InputStreamReader (urlconnection.getInputStream (), \"utf-8\"));\n        }\n    } catch (IOException _ex) {\n        System.err.println (\"HexTD::readFile:: Can't read from \" + fetchUrl);\n        return levelNames;\n    }\n    String sLine1;\n    try {\n        while ((sLine1 = bufferedreader.readLine ()) != null) {\n            if (sLine1.trim ().length () != 0) {\n                levelNames.add (sLine1);\n            }\n        }\n    } catch (IOException ex) {\n        Logger.getLogger (MapLoaderClient.class.getName ()).log (Level.SEVERE, null, ex);\n    }\n    return levelNames;\n}\n", "code2": "private void loadMtlFile (URL url) throws IOException {\n    InputStream is = url.openStream ();\n    BufferedReader br = new BufferedReader (new InputStreamReader (is));\n    int linecounter = 0;\n    String [] params = null;\n    try {\n        String line;\n        Material mtl = null;\n        while (((line = br.readLine ()) != null)) {\n            linecounter ++;\n            line = line.trim ();\n            if ((line.length () == 0) || (line.startsWith (\"#\"))) continue;\n\n            params = line.split (\"\\\\s+\");\n            if (params [0].equals (\"newmtl\")) {\n                mtl = new Material ();\n                mtl.name = params [1];\n                materials.put (mtl.name, mtl);\n            } else if (params [0].equals (\"map_Kd\")) {\n                mtl.map_Kd = params [1];\n            } else if (params [0].equals (\"Ka\")) {\n                Arrays.fill (mtl.Ka, 0.0f);\n                for (int i = 1;\n                i < params.length; i ++) {\n                    mtl.Ka [i - 1] = Float.valueOf (params [i]).floatValue ();\n                }\n            } else if (params [0].equals (\"Kd\")) {\n                Arrays.fill (mtl.Kd, 0.0f);\n                for (int i = 1;\n                i < params.length; i ++) {\n                    mtl.Kd [i - 1] = Float.valueOf (params [i]).floatValue ();\n                }\n            } else if (params [0].equals (\"Ks\")) {\n                Arrays.fill (mtl.Ks, 0.0f);\n                for (int i = 1;\n                i < params.length; i ++) {\n                    mtl.Ks [i - 1] = Float.valueOf (params [i]).floatValue ();\n                }\n            } else if (params [0].equals (\"d\")) {\n                mtl.d = Float.valueOf (params [1]).floatValue ();\n            } else if (params [0].equals (\"Ns\")) {\n                mtl.Ns = Float.valueOf (params [1]).floatValue ();\n            } else if (params [0].equals (\"illum\")) {\n                mtl.illum = Integer.valueOf (params [1]).intValue ();\n            }\n\n        }\n    } catch (IOException e) {\n        System.out.println (\"Failed to read file: \" + br.toString ());\n    } catch (NumberFormatException e) {\n        System.out.println (\"Malformed MTL (on line \" + linecounter + \"): \" + br.toString () + \"\\r \\r\" + e.getMessage ());\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 5236784, "method2_id": 11024681, "code1": "public static double [] [] calcTranspose (double [] [] mat) {\n    double [] [] transpose = new double [mat [0].length] [mat.length];\n    for (int a = 0;\n    a < transpose.length; a ++) {\n        for (int b = 0;\n        b < transpose [0].length; b ++) {\n            transpose [a] [b] = mat [b] [a];\n        }\n    }\n    return transpose;\n}\n", "code2": "protected void setupNodeDistanceSprings () {\n    if (layoutPass != 0) {\n        return;\n    }\n    nodeDistanceSpringRestLengths = new double [vertexCount] [vertexCount];\n    nodeDistanceSpringStrengths = new double [vertexCount] [vertexCount];\n    if (nodeDistanceSpringScalars [layoutPass] == 0.0) {\n        return;\n    }\n    NodeDistances ind = new NodeDistances (pGraph.getVertexList (), null, pGraph);\n    int [] [] node_distances = (int [] []) ind.calculate ();\n    if (node_distances == null) {\n        return;\n    }\n    double node_distance_strength_constant = nodeDistanceStrengthConstant;\n    double node_distance_rest_length_constant = nodeDistanceRestLengthConstant;\n    for (int node_i = 0;\n    node_i < vertexCount; node_i ++) {\n        for (int node_j = (node_i + 1);\n        node_j < vertexCount; node_j ++) {\n            if (node_distances [node_i] [node_j] == Integer.MAX_VALUE) {\n                nodeDistanceSpringRestLengths [node_i] [node_j] = disconnectedNodeDistanceSpringRestLength;\n            } else {\n                nodeDistanceSpringRestLengths [node_i] [node_j] = (node_distance_rest_length_constant * node_distances [node_i] [node_j]);\n            }\n            nodeDistanceSpringRestLengths [node_j] [node_i] = nodeDistanceSpringRestLengths [node_i] [node_j];\n            if (node_distances [node_i] [node_j] == Integer.MAX_VALUE) {\n                nodeDistanceSpringStrengths [node_i] [node_j] = disconnectedNodeDistanceSpringStrength;\n            } else {\n                nodeDistanceSpringStrengths [node_i] [node_j] = (node_distance_strength_constant / (node_distances [node_i] [node_j] * node_distances [node_i] [node_j]));\n            }\n            nodeDistanceSpringStrengths [node_j] [node_i] = nodeDistanceSpringStrengths [node_i] [node_j];\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1102939, "method2_id": 18956017, "code1": "public static long writeInputStreamToOutputStream (final InputStream in, final OutputStream out) {\n    long size = 0;\n    try {\n        size = IOUtils.copyLarge (in, out);\n    } catch (IOException e1) {\n        e1.printStackTrace ();\n    }\n    return size;\n}\n", "code2": "public void writeFile (OutputStream outputStream) throws IOException {\n    InputStream inputStream = null;\n    if (file != null) {\n        try {\n            inputStream = new FileInputStream (file);\n            IOUtils.copy (inputStream, outputStream);\n        } finally {\n            if (inputStream != null) {\n                IOUtils.closeQuietly (inputStream);\n            }\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8801744, "method2_id": 18457132, "code1": "public static void copyFile (File src, File dest, boolean force) throws IOException {\n    if (dest.exists ()) {\n        if (force) {\n            dest.delete ();\n        } else {\n            throw new IOException (\"Cannot overwrite existing file: \" + dest);\n        }\n    }\n    byte [] buffer = new byte [1];\n    int read = 0;\n    InputStream in = null;\n    OutputStream out = null;\n    try {\n        in = new FileInputStream (src);\n        out = new FileOutputStream (dest);\n        while (true) {\n            read = in.read (buffer);\n            if (read == - 1) {\n                break;\n            }\n            out.write (buffer, 0, read);\n        }\n    } finally {\n        if (in != null) {\n            try {\n                in.close ();\n            } finally {\n                if (out != null) {\n                    out.close ();\n                }\n            }\n        }\n    }\n}\n", "code2": "private static void copyFile (File src, File dst) throws IOException {\n    FileChannel in = new FileInputStream (src).getChannel ();\n    FileChannel out = new FileOutputStream (dst).getChannel ();\n    in.transferTo (0, in.size (), out);\n    in.close ();\n    out.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 12909291, "method2_id": 18731843, "code1": "public void render (Map model, HttpServletRequest request, HttpServletResponse response) throws Exception {\n    response.setContentType (s_contentType);\n    response.setHeader (\"Cache-control\", \"no-cache\");\n    InputStream graphStream = getGraphStream (request);\n    OutputStream out = getOutputStream (response);\n    IOUtils.copy (graphStream, out);\n    out.flush ();\n}\n", "code2": "public void doBody (JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n    BufferedInputStream bis = null;\n    BufferedOutputStream bos = null;\n    try {\n        bis = new BufferedInputStream (new FileInputStream (this.loadData (req)));\n        bos = new BufferedOutputStream (resp.getOutputStream ());\n        IOUtils.copy (bis, bos);\n        bos.flush ();\n    } catch (Exception e) {\n        _cat.warn (\"Write data failed!\", e);\n    } finally {\n        IOUtils.closeQuietly (bis);\n        IOUtils.closeQuietly (bos);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 672082, "method2_id": 7395775, "code1": "public boolean copyOneOfMyFile (File f, String dest) {\n    if (! ownsThisFile (f.getName ())) return false;\n\n    if (! dest.endsWith (File.separator)) dest = dest.concat (File.separator);\n\n    try {\n        BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (new File (dest + f.getName ())));\n        BufferedInputStream in = new BufferedInputStream (new FileInputStream (f));\n        int len = 1024;\n        byte [] read = new byte [len];\n        while ((len = in.read (read)) > 0) out.write (read, 0, len);\n\n        out.flush ();\n        out.close ();\n        in.close ();\n        if (! PatchManager.mute) System.out.println (\"file created : \" + dest + f.getName ());\n\n    } catch (IOException e) {\n        System.out.println (\"copy directory : \" + e);\n        return false;\n    }\n    return true;\n}\n", "code2": "private void copyReportFile (ServletRequest req, String reportName, Report report) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException, ClassNotFoundException, FileNotFoundException, IOException {\n    String reportFileName = (String) Class.forName (\"org.eclipse.birt.report.utility.ParameterAccessor\").getMethod (\"getReport\", new Class [] {HttpServletRequest.class, String.class}).invoke (null, new Object [] {req, reportName});\n    ByteArrayInputStream bais = new ByteArrayInputStream (report.getReportContent ());\n    FileOutputStream fos = new FileOutputStream (new File (reportFileName));\n    IOUtils.copy (bais, fos);\n    bais.close ();\n    fos.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 21161120, "method2_id": 22303544, "code1": "public static void main (String [] args) {\n    String host;\n    int port;\n    char [] passphrase;\n    System.out.println (\"InstallCert - Install CA certificate to Java Keystore\");\n    System.out.println (\"=====================================================\");\n    final BufferedReader reader = new BufferedReader (new InputStreamReader (System.in));\n    try {\n        if ((args.length == 1) || (args.length == 2)) {\n            String [] c = args [0].split (\":\");\n            host = c [0];\n            port = (c.length == 1) ? 443 : Integer.parseInt (c [1]);\n            String p = (args.length == 1) ? \"changeit\" : args [1];\n            passphrase = p.toCharArray ();\n        } else {\n            String tmpStr;\n            do {\n                System.out.print (\"Enter hostname or IP address: \");\n                tmpStr = StringUtils.defaultIfEmpty (reader.readLine (), null);\n            } while (tmpStr == null);\n            host = tmpStr;\n            System.out.print (\"Enter port number [443]: \");\n            tmpStr = StringUtils.defaultIfEmpty (reader.readLine (), null);\n            port = tmpStr == null ? 443 : Integer.parseInt (tmpStr);\n            System.out.print (\"Enter keystore password [changeit]: \");\n            tmpStr = reader.readLine ();\n            String p = \"\".equals (tmpStr) ? \"changeit\" : tmpStr;\n            passphrase = p.toCharArray ();\n        }\n        char SEP = File.separatorChar;\n        final File dir = new File (System.getProperty (\"java.home\") + SEP + \"lib\" + SEP + \"security\");\n        final File file = new File (dir, \"cacerts\");\n        System.out.println (\"Loading KeyStore \" + file + \"...\");\n        InputStream in = new FileInputStream (file);\n        KeyStore ks = KeyStore.getInstance (KeyStore.getDefaultType ());\n        ks.load (in, passphrase);\n        in.close ();\n        SSLContext context = SSLContext.getInstance (\"TLS\");\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance (TrustManagerFactory.getDefaultAlgorithm ());\n        tmf.init (ks);\n        X509TrustManager defaultTrustManager = (X509TrustManager) tmf.getTrustManagers () [0];\n        SavingTrustManager tm = new SavingTrustManager (defaultTrustManager);\n        context.init (null, new TrustManager [] {tm}, null);\n        SSLSocketFactory factory = context.getSocketFactory ();\n        System.out.println (\"Opening connection to \" + host + \":\" + port + \"...\");\n        SSLSocket socket = (SSLSocket) factory.createSocket (host, port);\n        socket.setSoTimeout (10000);\n        try {\n            System.out.println (\"Starting SSL handshake...\");\n            socket.startHandshake ();\n            socket.close ();\n            System.out.println ();\n            System.out.println (\"No errors, certificate is already trusted\");\n        } catch (SSLException e) {\n            System.out.println ();\n            e.printStackTrace (System.out);\n        }\n        X509Certificate [] chain = tm.chain;\n        if (chain == null) {\n            System.out.println (\"Could not obtain server certificate chain\");\n            return;\n        }\n        System.out.println ();\n        System.out.println (\"Server sent \" + chain.length + \" certificate(s):\");\n        System.out.println ();\n        MessageDigest sha1 = MessageDigest.getInstance (\"SHA1\");\n        MessageDigest md5 = MessageDigest.getInstance (\"MD5\");\n        for (int i = 0;\n        i < chain.length; i ++) {\n            X509Certificate cert = chain [i];\n            System.out.println (\" \" + (i + 1) + \" Subject \" + cert.getSubjectDN ());\n            System.out.println (\"   Issuer  \" + cert.getIssuerDN ());\n            sha1.update (cert.getEncoded ());\n            System.out.println (\"   sha1    \" + toHexString (sha1.digest ()));\n            md5.update (cert.getEncoded ());\n            System.out.println (\"   md5     \" + toHexString (md5.digest ()));\n            System.out.println ();\n        }\n        System.out.print (\"Enter certificate to add to trusted keystore or 'q' to quit [1]: \");\n        String line = reader.readLine ().trim ();\n        int k = - 1;\n        try {\n            k = (line.length () == 0) ? 0 : Integer.parseInt (line) - 1;\n        } catch (NumberFormatException e) {\n        }\n        if (k < 0 || k >= chain.length) {\n            System.out.println (\"KeyStore not changed\");\n        } else {\n            try {\n                System.out.println (\"Creating keystore backup\");\n                final SimpleDateFormat dateFormat = new SimpleDateFormat (\"yyyyMMddHHmmss\");\n                final File backupFile = new File (dir, CACERTS_KEYSTORE + \".\" + dateFormat.format (new java.util.Date ()));\n                final FileInputStream fis = new FileInputStream (file);\n                final FileOutputStream fos = new FileOutputStream (backupFile);\n                IOUtils.copy (fis, fos);\n                fis.close ();\n                fos.close ();\n            } catch (Exception e) {\n                e.printStackTrace ();\n            }\n            System.out.println (\"Installing certificate...\");\n            X509Certificate cert = chain [k];\n            String alias = host + \"-\" + (k + 1);\n            ks.setCertificateEntry (alias, cert);\n            OutputStream out = new FileOutputStream (file);\n            ks.store (out, passphrase);\n            out.close ();\n            System.out.println ();\n            System.out.println (cert);\n            System.out.println ();\n            System.out.println (\"Added certificate to keystore '\" + file + \"' using alias '\" + alias + \"'\");\n        }\n    } catch (Exception e) {\n        System.out.println ();\n        System.out.println (\"----------------------------------------------\");\n        System.out.println (\"Problem occured during installing certificate:\");\n        e.printStackTrace ();\n        System.out.println (\"----------------------------------------------\");\n    }\n    System.out.println (\"Press Enter to finish...\");\n    try {\n        reader.readLine ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "@Test\npublic void testWriteAndRead () throws Exception {\n    JCFSFileServer server = new JCFSFileServer (defaultTcpPort, defaultTcpAddress, defaultUdpPort, defaultUdpAddress, dir, 0, 0);\n    JCFS.configureDiscovery (defaultUdpAddress, defaultUdpPort);\n    try {\n        server.start ();\n        RFile file = new RFile (\"testreadwrite.txt\");\n        RFileOutputStream out = new RFileOutputStream (file);\n        out.write (\"test\".getBytes (\"utf-8\"));\n        out.close ();\n        RFileInputStream in = new RFileInputStream (file);\n        byte [] buffer = new byte [4];\n        int readCount = in.read (buffer);\n        in.close ();\n        assertEquals (4, readCount);\n        String resultRead = new String (buffer, \"utf-8\");\n        assertEquals (\"test\", resultRead);\n    } finally {\n        server.stop ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 13212350, "method2_id": 22456976, "code1": "public static void copyFile (File source, File dest) {\n    try {\n        FileChannel in = new FileInputStream (source).getChannel ();\n        if (! dest.getParentFile ().exists ()) dest.getParentFile ().mkdirs ();\n\n        FileChannel out = new FileOutputStream (dest).getChannel ();\n        in.transferTo (0, in.size (), out);\n        in.close ();\n        out.close ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "private static void copyFile (File in, File out) throws Exception {\n    final FileInputStream input = new FileInputStream (in);\n    try {\n        final FileOutputStream output = new FileOutputStream (out);\n        try {\n            final byte [] buf = new byte [4096];\n            int readBytes = 0;\n            while ((readBytes = input.read (buf)) != - 1) {\n                output.write (buf, 0, readBytes);\n            }\n        } finally {\n            output.close ();\n        }\n    } finally {\n        input.close ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 150048, "method2_id": 13681010, "code1": "public static void main (String [] args) {\n    Console console = System.console ();\n    if (console == null) {\n        System.err.println (\"No console.\");\n        System.exit (1);\n    }\n    while (true) {\n        String regex = console.readLine (\"%nEnter your regex: \");\n        Pattern pattern = Pattern.compile (regex);\n        String input = console.readLine (\"Enter input string to search: \");\n        Matcher matcher = pattern.matcher (input);\n        boolean found = false;\n        while (matcher.find ()) {\n            console.format (\"I found the text \\\"%s\\\" starting at \" + \"index %d and ending at index %d.%n\", matcher.group (), matcher.start (), matcher.end ());\n            found = true;\n        }\n        if (! found) {\n            console.format (\"No match found.%n\");\n        }\n        String [] arr = input.split (regex);\n        for (int i = 0;\n        i < arr.length; i ++) {\n            console.format (\"a[%d]='%s' \\n\", i, arr [i]);\n        }\n    }\n}\n", "code2": "public ArrayList < ODIE_IndexFinderAnnotation > process (String phrase) {\n    Pattern tokeniserPattern = Pattern.compile (\"\\\\S+\");\n    Matcher matcher = tokeniserPattern.matcher (phrase);\n    ArrayList < ODIE_IndexFinderAnnotation > odieAnnots = new ArrayList < ODIE_IndexFinderAnnotation > ();\n    int annotationId = 0;\n    while (matcher.find ()) {\n        int spos = matcher.start ();\n        int epos = matcher.end ();\n        ODIE_IndexFinderNode sNode = new ODIE_IndexFinderNode ();\n        sNode.setOffset (new Long (spos));\n        ODIE_IndexFinderNode eNode = new ODIE_IndexFinderNode ();\n        eNode.setOffset (new Long (epos));\n        String token = matcher.group (0);\n        ODIE_IndexFinderAnnotation annot = new ODIE_IndexFinderAnnotation ();\n        annot.setStartNode (sNode);\n        annot.setEndNode (eNode);\n        annot.setAnnotationId (annotationId ++);\n        annot.setAnnotationSetName (\"\");\n        annot.setAnnotationTypeName (\"Token\");\n        annot.setFeatures (new HashMap < String, Object > ());\n        annot.getFeatures ().put (\"string\", token);\n        if (this.stemmer != null) {\n            this.stemmer.add (token);\n            this.stemmer.stem ();\n            String normalizedForm = this.stemmer.getResultString ();\n            annot.getFeatures ().put (\"normalizedForm\", normalizedForm);\n        }\n        odieAnnots.add (annot);\n    }\n    this.strategyEngine.setSortedTokens (odieAnnots);\n    this.strategyEngine.execute ();\n    return this.strategyEngine.getResultingConcepts ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 88047, "method2_id": 4981909, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "public static File enregistrerFichier (String fileName, File file, String path, String fileMime) throws Exception {\n    if (file != null) {\n        try {\n            HttpServletRequest request = ServletActionContext.getRequest ();\n            HttpSession session = request.getSession ();\n            String pathFile = session.getServletContext ().getRealPath (path) + File.separator + fileName;\n            File outfile = new File (pathFile);\n            String [] nomPhotoTab = fileName.split (\"\\\\.\");\n            String extension = nomPhotoTab [nomPhotoTab.length - 1];\n            StringBuffer pathResBuff = new StringBuffer (nomPhotoTab [0]);\n            for (int i = 1;\n            i < nomPhotoTab.length - 1; i ++) {\n                pathResBuff.append (\".\").append (nomPhotoTab [i]);\n            }\n            String pathRes = pathResBuff.toString ();\n            String nomPhoto = fileName;\n            for (int i = 0;\n            ! outfile.createNewFile (); i ++) {\n                nomPhoto = pathRes + \"_\" + + i + \".\" + extension;\n                pathFile = session.getServletContext ().getRealPath (path) + File.separator + nomPhoto;\n                outfile = new File (pathFile);\n            }\n            logger.debug (\" enregistrerFichier - Enregistrement du fichier : \" + pathFile);\n            FileChannel in = null;\n            FileChannel out = null;\n            try {\n                in = new FileInputStream (file).getChannel ();\n                out = new FileOutputStream (outfile).getChannel ();\n                in.transferTo (0, in.size (), out);\n            } catch (Exception e) {\n                e.printStackTrace ();\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close ();\n                    } catch (IOException e) {\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close ();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n            return outfile;\n        } catch (IOException e) {\n            logger.error (\"Erreur lors de l'enregistrement de l'image \", e);\n            throw new Exception (\"Erreur lors de l'enregistrement de l'image \");\n        }\n    }\n    return null;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10062078, "method2_id": 12269678, "code1": "private void copy (File fin, File fout) throws IOException {\n    FileOutputStream out = null;\n    FileInputStream in = null;\n    try {\n        out = new FileOutputStream (fout);\n        in = new FileInputStream (fin);\n        byte [] buf = new byte [2048];\n        int read = in.read (buf);\n        while (read > 0) {\n            out.write (buf, 0, read);\n            read = in.read (buf);\n        }\n    } catch (IOException _e) {\n        throw _e;\n    } finally {\n        if (in != null) in.close ();\n\n        if (out != null) out.close ();\n\n    }\n}\n", "code2": "private void copyResource (String relResourceName) {\n    String projectName = layout.getRootDir ().getName ();\n    String resourceName = \"/protoj/\" + projectName + \"/\" + relResourceName;\n    InputStream source = getClass ().getResourceAsStream (resourceName);\n    if (source == null) {\n        throw new RuntimeException (\"couldn't find resource \" + resourceName);\n    }\n    File dest = new File (layout.getRootDir (), relResourceName);\n    dest.getParentFile ().mkdirs ();\n    dest.createNewFile ();\n    InputStreamReader in = new InputStreamReader (source);\n    try {\n        FileOutputStream out = new FileOutputStream (dest);\n        try {\n            IOUtils.copy (in, out);\n        } finally {\n            IOUtils.closeQuietly (out);\n        }\n    } finally {\n        IOUtils.closeQuietly (in);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8317691, "method2_id": 8931241, "code1": "protected void copyFile (File src, File dest) throws Exception {\n    FileChannel srcChannel = new FileInputStream (src).getChannel ();\n    FileChannel destChannel = new FileOutputStream (dest).getChannel ();\n    long transferred = destChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    if (transferred != srcChannel.size ()) throw new Exception (\"Could not transfer entire file\");\n\n    srcChannel.close ();\n    destChannel.close ();\n}\n", "code2": "public static void copy (File from, File to, CopyMode mode) throws IOException {\n    if (! from.exists ()) {\n        IllegalArgumentException e = new IllegalArgumentException (\"Source doesn't exist: \" + from.getCanonicalFile ());\n        log.throwing (\"IOUtils\", \"copy\", e);\n        throw e;\n    }\n    if (from.isFile ()) {\n        if (! to.canWrite ()) {\n            IllegalArgumentException e = new IllegalArgumentException (\"Cannot write to target location: \" + to.getCanonicalFile ());\n            log.throwing (\"IOUtils\", \"copy\", e);\n            throw e;\n        }\n    }\n    if (to.exists ()) {\n        if ((mode.val & CopyMode.OverwriteFile.val) != CopyMode.OverwriteFile.val) {\n            IllegalArgumentException e = new IllegalArgumentException (\"Target already exists: \" + to.getCanonicalFile ());\n            log.throwing (\"IOUtils\", \"copy\", e);\n            throw e;\n        }\n        if (to.isDirectory ()) {\n            if ((mode.val & CopyMode.OverwriteFolder.val) != CopyMode.OverwriteFolder.val) {\n                IllegalArgumentException e = new IllegalArgumentException (\"Target is a folder: \" + to.getCanonicalFile ());\n                log.throwing (\"IOUtils\", \"copy\", e);\n                throw e;\n            } else to.delete ();\n\n        }\n    }\n    if (from.isFile ()) {\n        FileChannel in = new FileInputStream (from).getChannel ();\n        FileLock inLock = in.lock ();\n        FileChannel out = new FileOutputStream (to).getChannel ();\n        FileLock outLock = out.lock ();\n        try {\n            in.transferTo (0, (int) in.size (), out);\n        } finally {\n            inLock.release ();\n            outLock.release ();\n            in.close ();\n            out.close ();\n        }\n    } else {\n        to.mkdirs ();\n        File [] contents = to.listFiles ();\n        for (File file : contents) {\n            File newTo = new File (to.getCanonicalPath () + \"/\" + file.getName ());\n            copy (file, newTo, mode);\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2432558, "method2_id": 11339042, "code1": "public void createZips (Collection < String > filesToZip, Project project, String backupFileName) {\n    try {\n        for (Destination destination : project.getDestinations ()) {\n            String backupFilePath = destination.getPath ();\n            if (! backupFilePath.endsWith (File.separator) && ! backupFilePath.endsWith (\"/\")) {\n                backupFilePath = backupFilePath + \"/\";\n            }\n            backupFilePath = backupFilePath + backupFileName;\n            Destination backupDestination = new Destination (destination);\n            backupDestination.setPath (backupFilePath);\n            OutputStream outputStream = backupDestination.getFileObject ().getContent ().getOutputStream ();\n            byte [] buffer = new byte [18024];\n            ZipOutputStream out = new ZipOutputStream (outputStream);\n            out.setLevel (Deflater.DEFAULT_COMPRESSION);\n            for (String filePath : filesToZip) {\n                FileInputStream in = new FileInputStream (filePath);\n                try {\n                    out.putNextEntry (new ZipEntry (filePath));\n                    int len;\n                    while ((len = in.read (buffer)) > 0) {\n                        out.write (buffer, 0, len);\n                    }\n                } catch (ZipException ze) {\n                    ze.printStackTrace ();\n                    logger.error (ze);\n                }\n                out.closeEntry ();\n                in.close ();\n            }\n            out.close ();\n            sendEmail (project, EmailTrigger.SUCCESS, project.getName () + \" backup successful\");\n        }\n    } catch (IllegalArgumentException iae) {\n        iae.printStackTrace ();\n        sendEmail (project, EmailTrigger.FAILURE, project.getName () + \" backup failed\\n\" + iae.getMessage ());\n    } catch (FileNotFoundException fnfe) {\n        fnfe.printStackTrace ();\n        sendEmail (project, EmailTrigger.FAILURE, project.getName () + \" backup failed\\n\" + fnfe.getMessage ());\n    } catch (IOException ioe) {\n        ioe.printStackTrace ();\n        sendEmail (project, EmailTrigger.FAILURE, project.getName () + \" backup failed\\n\" + ioe.getMessage ());\n    }\n}\n", "code2": "public void doPost (HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n    PrintWriter out = null;\n    ServletOutputStream outstream = null;\n    try {\n        String action = req.getParameter (\"nmrshiftdbaction\");\n        String relativepath = ServletUtils.expandRelative (this.getServletConfig (), \"/WEB-INF\");\n        TurbineConfig tc = new TurbineConfig (relativepath + \"..\", relativepath + getServletConfig ().getInitParameter (\"properties\"));\n        tc.init ();\n        int spectrumId = - 1;\n        DBSpectrum spectrum = null;\n        Export export = null;\n        String format = req.getParameter (\"format\");\n        if (action.equals (\"test\")) {\n            try {\n                res.setContentType (\"text/plain\");\n                out = res.getWriter ();\n                List l = DBSpectrumPeer.executeQuery (\"select SPECTRUM_ID from SPECTRUM limit 1\");\n                if (l.size () > 0) spectrumId = ((Record) l.get (0)).getValue (1).asInt ();\n\n                out.write (\"success\");\n            } catch (Exception ex) {\n                out.write (\"failure\");\n            }\n        } else if (action.equals (\"rss\")) {\n            int numbertoexport = 10;\n            out = res.getWriter ();\n            if (req.getParameter (\"numbertoexport\") != null) {\n                try {\n                    numbertoexport = Integer.parseInt (req.getParameter (\"numbertoexport\"));\n                    if (numbertoexport < 1 || numbertoexport > 20) throw new NumberFormatException (\"Number to small/large\");\n\n                } catch (NumberFormatException ex) {\n                    out.println (\"The parameter <code>numbertoexport</code>must be an integer from 1 to 20\");\n                }\n            }\n            res.setContentType (\"text/xml\");\n            RssWriter rssWriter = new RssWriter ();\n            rssWriter.setWriter (res.getWriter ());\n            AtomContainerSet soac = new AtomContainerSet ();\n            String query = \"select distinct MOLECULE.MOLECULE_ID from MOLECULE, SPECTRUM where SPECTRUM.MOLECULE_ID = MOLECULE.MOLECULE_ID and SPECTRUM.REVIEW_FLAG =\\\"true\\\" order by MOLECULE.DATE desc;\";\n            List l = NmrshiftdbUserPeer.executeQuery (query);\n            for (int i = 0;\n            i < numbertoexport; i ++) {\n                if (i == l.size ()) break;\n\n                DBMolecule mol = DBMoleculePeer.retrieveByPK (new NumberKey (((Record) l.get (i)).getValue (1).asInt ()));\n                IMolecule cdkmol = mol.getAsCDKMoleculeAsEntered (1);\n                soac.addAtomContainer (cdkmol);\n                rssWriter.getLinkmap ().put (cdkmol, mol.getEasylink (req));\n                rssWriter.getDatemap ().put (cdkmol, mol.getDate ());\n                rssWriter.getTitlemap ().put (cdkmol, mol.getChemicalNamesAsOneStringWithFallback ());\n                rssWriter.getCreatormap ().put (cdkmol, mol.getNmrshiftdbUser ().getUserName ());\n                rssWriter.setCreator (GeneralUtils.getAdminEmail (getServletConfig ()));\n                Vector v = mol.getDBCanonicalNames ();\n                for (int k = 0;\n                k < v.size (); k ++) {\n                    DBCanonicalName canonName = (DBCanonicalName) v.get (k);\n                    if (canonName.getDBCanonicalNameType ().getCanonicalNameType () == \"INChI\") {\n                        rssWriter.getInchimap ().put (cdkmol, canonName.getName ());\n                        break;\n                    }\n                }\n                rssWriter.setTitle (\"NMRShiftDB\");\n                rssWriter.setLink (\"http://www.nmrshiftdb.org\");\n                rssWriter.setDescription (\"NMRShiftDB is an open-source, open-access, open-submission, open-content web database for chemical structures and their nuclear magnetic resonance data\");\n                rssWriter.setPublisher (\"NMRShiftDB.org\");\n                rssWriter.setImagelink (\"http://www.nmrshiftdb.org/images/nmrshift-logo.gif\");\n                rssWriter.setAbout (\"http://www.nmrshiftdb.org/NmrshiftdbServlet?nmrshiftdbaction=rss\");\n                Collection coll = new ArrayList ();\n                Vector spectra = mol.selectSpectra (null);\n                for (int k = 0;\n                k < spectra.size (); k ++) {\n                    Element el = ((DBSpectrum) spectra.get (k)).getCmlSpect ();\n                    Element el2 = el.getChildElements ().get (0);\n                    el.removeChild (el2);\n                    coll.add (el2);\n                }\n                rssWriter.getMultiMap ().put (cdkmol, coll);\n            }\n            rssWriter.write (soac);\n        } else if (action.equals (\"getattachment\")) {\n            res.setContentType (\"application/zip\");\n            outstream = res.getOutputStream ();\n            DBSample sample = DBSamplePeer.retrieveByPK (new NumberKey (req.getParameter (\"sampleid\")));\n            outstream.write (sample.getAttachment ());\n        } else if (action.equals (\"createreport\")) {\n            res.setContentType (\"application/pdf\");\n            outstream = res.getOutputStream ();\n            boolean yearly = req.getParameter (\"style\").equals (\"yearly\");\n            int yearstart = Integer.parseInt (req.getParameter (\"yearstart\"));\n            int yearend = Integer.parseInt (req.getParameter (\"yearend\"));\n            int monthstart = 0;\n            int monthend = 0;\n            if (! yearly) {\n                monthstart = Integer.parseInt (req.getParameter (\"monthstart\"));\n                monthend = Integer.parseInt (req.getParameter (\"monthend\"));\n            }\n            int type = Integer.parseInt (req.getParameter (\"type\"));\n            JasperReport jasperReport = (JasperReport) JRLoader.loadObject (relativepath + \"/reports/\" + (yearly ? \"yearly\" : \"monthly\") + \"_report_\" + type + \".jasper\");\n            Map parameters = new HashMap ();\n            if (yearly) parameters.put (\"HEADER\", \"Report for years \" + yearstart + \" - \" + yearend);\n            else parameters.put (\"HEADER\", \"Report for \" + monthstart + \"/\" + yearstart + \" - \" + monthend + \"/\" + yearend);\n\n            DBConnection dbconn = TurbineDB.getConnection ();\n            Connection conn = dbconn.getConnection ();\n            Statement stmt = conn.createStatement ();\n            ResultSet rs = null;\n            if (type == 1) {\n                rs = stmt.executeQuery (\"select YEAR(DATE) as YEAR, \" + (yearly ? \"\" : \" MONTH(DATE) as MONTH, \") + \"AFFILIATION_1, AFFILIATION_2, MACHINE.NAME as NAME, count(*) as C, sum(WISHED_SPECTRUM like '%13C%' or WISHED_SPECTRUM like '%variable temperature%' or WISHED_SPECTRUM like '%ID sel. NOE%' or WISHED_SPECTRUM like '%solvent suppression%' or WISHED_SPECTRUM like '%standard spectrum%') as 1_D, sum(WISHED_SPECTRUM like '%H,H-COSY%' or WISHED_SPECTRUM like '%NOESY%' or WISHED_SPECTRUM like '%HMQC%' or WISHED_SPECTRUM like '%HMBC%') as 2_D, sum(OTHER_WISHED_SPECTRUM!='') as SPECIAL, sum(OTHER_NUCLEI!='') as HETERO, sum(PROCESS='self') as SELF, sum(PROCESS='robot') as ROBOT, sum(PROCESS='worker') as OPERATOR from (SAMPLE join TURBINE_USER using (USER_ID)) join MACHINE on MACHINE.MACHINE_ID=SAMPLE.MACHINE where YEAR(DATE)>=\" + yearstart + \" and YEAR(DATE)<=\" + yearend + \" and LOGIN_NAME<>'testuser' group by YEAR, \" + (yearly ? \"\" : \"MONTH, \") + \"AFFILIATION_1, AFFILIATION_2, MACHINE.NAME\");\n            } else if (type == 2) {\n                rs = stmt.executeQuery (\"select YEAR(DATE) as YEAR, \" + (yearly ? \"\" : \" MONTH(DATE) as MONTH, \") + \"MACHINE.NAME as NAME, count(*) as C, sum(WISHED_SPECTRUM like '%13C%' or WISHED_SPECTRUM like '%variable temperature%' or WISHED_SPECTRUM like '%ID sel. NOE%' or WISHED_SPECTRUM like '%solvent suppression%' or WISHED_SPECTRUM like '%standard spectrum%') as 1_D, sum(WISHED_SPECTRUM like '%H,H-COSY%' or WISHED_SPECTRUM like '%NOESY%' or WISHED_SPECTRUM like '%HMQC%' or WISHED_SPECTRUM like '%HMBC%') as 2_D, sum(OTHER_WISHED_SPECTRUM!='') as SPECIAL, sum(OTHER_NUCLEI!='') as HETERO, sum(PROCESS='self') as SELF, sum(PROCESS='robot') as ROBOT, sum(PROCESS='worker') as OPERATOR from (SAMPLE join TURBINE_USER using (USER_ID)) join MACHINE on MACHINE.MACHINE_ID=SAMPLE.MACHINE group by YEAR, \" + (yearly ? \"\" : \"MONTH, \") + \"MACHINE.NAME\");\n            }\n\n            JasperPrint jasperPrint = JasperFillManager.fillReport (jasperReport, parameters, new JRResultSetDataSource (rs));\n            JasperExportManager.exportReportToPdfStream (jasperPrint, outstream);\n            dbconn.close ();\n        } else if (action.equals (\"exportcmlbyinchi\")) {\n            res.setContentType (\"text/xml\");\n            out = res.getWriter ();\n            String inchi = req.getParameter (\"inchi\");\n            String spectrumtype = req.getParameter (\"spectrumtype\");\n            Criteria crit = new Criteria ();\n            crit.add (DBCanonicalNamePeer.NAME, inchi);\n            crit.addJoin (DBCanonicalNamePeer.MOLECULE_ID, DBSpectrumPeer.MOLECULE_ID);\n            crit.addJoin (DBSpectrumPeer.SPECTRUM_TYPE_ID, DBSpectrumTypePeer.SPECTRUM_TYPE_ID);\n            crit.add (DBSpectrumTypePeer.NAME, spectrumtype);\n            try {\n                GeneralUtils.logToSql (crit.toString (), null);\n            } catch (Exception ex) {\n            }\n            Vector spectra = DBSpectrumPeer.doSelect (crit);\n            if (spectra.size () == 0) {\n                out.write (\"No such molecule or spectrum\");\n            } else {\n                Element cmlElement = new Element (\"cml\");\n                cmlElement.addAttribute (new Attribute (\"convention\", \"nmrshiftdb-convention\"));\n                cmlElement.setNamespaceURI (\"http://www.xml-cml.org/schema\");\n                Element parent = ((DBSpectrum) spectra.get (0)).getDBMolecule ().getCML (1);\n                nu.xom.Node cmldoc = parent.getChild (0);\n                ((Element) cmldoc).setNamespaceURI (\"http://www.xml-cml.org/schema\");\n                parent.removeChildren ();\n                cmlElement.appendChild (cmldoc);\n                for (int k = 0;\n                k < spectra.size (); k ++) {\n                    Element parentspec = ((DBSpectrum) spectra.get (k)).getCmlSpect ();\n                    Node spectrumel = parentspec.getChild (0);\n                    parentspec.removeChildren ();\n                    cmlElement.appendChild (spectrumel);\n                    ((Element) spectrumel).setNamespaceURI (\"http://www.xml-cml.org/schema\");\n                }\n                out.write (cmlElement.toXML ());\n            }\n        } else if (action.equals (\"namelist\")) {\n            res.setContentType (\"application/zip\");\n            outstream = res.getOutputStream ();\n            ByteArrayOutputStream baos = new ByteArrayOutputStream ();\n            ZipOutputStream zipout = new ZipOutputStream (baos);\n            Criteria crit = new Criteria ();\n            crit.addJoin (DBMoleculePeer.MOLECULE_ID, DBSpectrumPeer.MOLECULE_ID);\n            crit.add (DBSpectrumPeer.REVIEW_FLAG, \"true\");\n            Vector v = DBMoleculePeer.doSelect (crit);\n            for (int i = 0;\n            i < v.size (); i ++) {\n                if (i % 500 == 0) {\n                    if (i != 0) {\n                        zipout.write (new String (\"<p>The list is continued <a href=\\\"nmrshiftdb.names.\" + i + \".html\\\">here</a></p></body></html>\").getBytes ());\n                        zipout.closeEntry ();\n                    }\n                    zipout.putNextEntry (new ZipEntry (\"nmrshiftdb.names.\" + i + \".html\"));\n                    zipout.write (new String (\"<html><body><h1>This is a list of strcutures in <a href=\\\"http://www.nmrshiftdb.org\\\">NMRShiftDB</a>, starting at \" + i + \", Its main purpose is to be found by search engines</h1>\").getBytes ());\n                }\n                DBMolecule mol = (DBMolecule) v.get (i);\n                zipout.write (new String (\"<p><a href=\\\"\" + mol.getEasylink (req) + \"\\\">\").getBytes ());\n                Vector cannames = mol.getDBCanonicalNames ();\n                for (int k = 0;\n                k < cannames.size (); k ++) {\n                    zipout.write (new String (((DBCanonicalName) cannames.get (k)).getName () + \" \").getBytes ());\n                }\n                Vector chemnames = mol.getDBChemicalNames ();\n                for (int k = 0;\n                k < chemnames.size (); k ++) {\n                    zipout.write (new String (((DBChemicalName) chemnames.get (k)).getName () + \" \").getBytes ());\n                }\n                zipout.write (new String (\"</a>. Information we have got: NMR spectra\").getBytes ());\n                Vector spectra = mol.selectSpectra ();\n                for (int k = 0;\n                k < spectra.size (); k ++) {\n                    zipout.write (new String (((DBSpectrum) spectra.get (k)).getDBSpectrumType ().getName () + \", \").getBytes ());\n                }\n                if (mol.hasAny3d ()) zipout.write (new String (\"3D coordinates, \").getBytes ());\n\n                zipout.write (new String (\"File formats: CML, mol, png, jpeg\").getBytes ());\n                zipout.write (new String (\"</p>\").getBytes ());\n            }\n            zipout.write (new String (\"</body></html>\").getBytes ());\n            zipout.closeEntry ();\n            zipout.close ();\n            InputStream is = new ByteArrayInputStream (baos.toByteArray ());\n            byte [] buf = new byte [32 * 1024];\n            int nRead = 0;\n            while ((nRead = is.read (buf)) != - 1) {\n                outstream.write (buf, 0, nRead);\n            }\n        } else if (action.equals (\"predictor\")) {\n            if (req.getParameter (\"symbol\") == null) {\n                res.setContentType (\"text/plain\");\n                out = res.getWriter ();\n                out.write (\"please give the symbol to create the predictor for in the request with symbol=X (e. g. symbol=C\");\n            }\n            res.setContentType (\"application/zip\");\n            outstream = res.getOutputStream ();\n            ByteArrayOutputStream baos = new ByteArrayOutputStream ();\n            ZipOutputStream zipout = new ZipOutputStream (baos);\n            String filename = \"org/openscience/nmrshiftdb/PredictionTool.class\";\n            zipout.putNextEntry (new ZipEntry (filename));\n            JarInputStream jip = new JarInputStream (new FileInputStream (ServletUtils.expandRelative (getServletConfig (), \"/WEB-INF/lib/nmrshiftdb-lib.jar\")));\n            JarEntry entry = jip.getNextJarEntry ();\n            while (entry.getName ().indexOf (\"PredictionTool.class\") == - 1) {\n                entry = jip.getNextJarEntry ();\n            }\n            for (int i = 0;\n            i < entry.getSize (); i ++) {\n                zipout.write (jip.read ());\n            }\n            zipout.closeEntry ();\n            zipout.putNextEntry (new ZipEntry (\"nmrshiftdb.csv\"));\n            int i = 0;\n            org.apache.turbine.util.db.pool.DBConnection conn = TurbineDB.getConnection ();\n            HashMap mapsmap = new HashMap ();\n            while (true) {\n                Statement stmt = conn.createStatement ();\n                ResultSet rs = stmt.executeQuery (\"select HOSE_CODE, VALUE, SYMBOL from HOSE_CODES where CONDITION_TYPE='m' and WITH_RINGS=0 and SYMBOL='\" + req.getParameter (\"symbol\") + \"' limit \" + (i * 1000) + \", 1000\");\n                int m = 0;\n                while (rs.next ()) {\n                    String code = rs.getString (1);\n                    Double value = new Double (rs.getString (2));\n                    String symbol = rs.getString (3);\n                    if (mapsmap.get (symbol) == null) {\n                        mapsmap.put (symbol, new HashMap ());\n                    }\n                    for (int spheres = 6;\n                    spheres > 0; spheres --) {\n                        StringBuffer hoseCodeBuffer = new StringBuffer ();\n                        StringTokenizer st = new StringTokenizer (code, \"()/\");\n                        for (int k = 0;\n                        k < spheres; k ++) {\n                            if (st.hasMoreTokens ()) {\n                                String partcode = st.nextToken ();\n                                hoseCodeBuffer.append (partcode);\n                            }\n                            if (k == 0) {\n                                hoseCodeBuffer.append (\"(\");\n                            } else if (k == 3) {\n                                hoseCodeBuffer.append (\")\");\n                            } else {\n                                hoseCodeBuffer.append (\"/\");\n                            }\n\n                        }\n                        String hoseCode = hoseCodeBuffer.toString ();\n                        if (((HashMap) mapsmap.get (symbol)).get (hoseCode) == null) {\n                            ((HashMap) mapsmap.get (symbol)).put (hoseCode, new ArrayList ());\n                        }\n                        ((ArrayList) ((HashMap) mapsmap.get (symbol)).get (hoseCode)).add (value);\n                    }\n                    m ++;\n                }\n                i ++;\n                stmt.close ();\n                if (m == 0) break;\n\n            }\n            Set keySet = mapsmap.keySet ();\n            Iterator it = keySet.iterator ();\n            while (it.hasNext ()) {\n                String symbol = (String) it.next ();\n                HashMap hosemap = ((HashMap) mapsmap.get (symbol));\n                Set keySet2 = hosemap.keySet ();\n                Iterator it2 = keySet2.iterator ();\n                while (it2.hasNext ()) {\n                    String hoseCode = (String) it2.next ();\n                    ArrayList list = ((ArrayList) hosemap.get (hoseCode));\n                    double [] values = new double [list.size ()];\n                    for (int k = 0;\n                    k < list.size (); k ++) {\n                        values [k] = ((Double) list.get (k)).doubleValue ();\n                    }\n                    zipout.write (new String (symbol + \"|\" + hoseCode + \"|\" + Statistics.minimum (values) + \"|\" + Statistics.average (values) + \"|\" + Statistics.maximum (values) + \"\\r\\n\").getBytes ());\n                }\n            }\n            zipout.closeEntry ();\n            zipout.close ();\n            InputStream is = new ByteArrayInputStream (baos.toByteArray ());\n            byte [] buf = new byte [32 * 1024];\n            int nRead = 0;\n            i = 0;\n            while ((nRead = is.read (buf)) != - 1) {\n                outstream.write (buf, 0, nRead);\n            }\n        } else if (action.equals (\"exportspec\") || action.equals (\"exportmol\")) {\n            if (spectrumId > - 1) spectrum = DBSpectrumPeer.retrieveByPK (new NumberKey (spectrumId));\n            else spectrum = DBSpectrumPeer.retrieveByPK (new NumberKey (req.getParameter (\"spectrumid\")));\n\n            export = new Export (spectrum);\n        } else if (action.equals (\"exportmdl\")) {\n            res.setContentType (\"text/plain\");\n            outstream = res.getOutputStream ();\n            DBMolecule mol = DBMoleculePeer.retrieveByPK (new NumberKey (req.getParameter (\"moleculeid\")));\n            outstream.write (mol.getStructureFile (Integer.parseInt (req.getParameter (\"coordsetid\")), false).getBytes ());\n        } else if (action.equals (\"exportlastinputs\")) {\n            format = action;\n        } else if (action.equals (\"printpredict\")) {\n            res.setContentType (\"text/html\");\n            out = res.getWriter ();\n            HttpSession session = req.getSession ();\n            VelocityContext context = PredictPortlet.getContext (session, true, true, new StringBuffer (), getServletConfig (), req, true);\n            StringWriter w = new StringWriter ();\n            Velocity.mergeTemplate (\"predictprint.vm\", \"ISO-8859-1\", context, w);\n            out.println (w.toString ());\n        } else {\n            res.setContentType (\"text/html\");\n            out = res.getWriter ();\n            out.println (\"No valid action\");\n        }\n\n        if (format == null) format = \"\";\n\n        if (format.equals (\"pdf\") || format.equals (\"rtf\")) {\n            res.setContentType (\"application/\" + format);\n            out = res.getWriter ();\n        }\n        if (format.equals (\"docbook\")) {\n            res.setContentType (\"application/zip\");\n            outstream = res.getOutputStream ();\n        }\n        if (format.equals (\"svg\")) {\n            res.setContentType (\"image/x-svg\");\n            out = res.getWriter ();\n        }\n        if (format.equals (\"tiff\")) {\n            res.setContentType (\"image/tiff\");\n            outstream = res.getOutputStream ();\n        }\n        if (format.equals (\"jpeg\")) {\n            res.setContentType (\"image/jpeg\");\n            outstream = res.getOutputStream ();\n        }\n        if (format.equals (\"png\")) {\n            res.setContentType (\"image/png\");\n            outstream = res.getOutputStream ();\n        }\n        if (format.equals (\"mdl\") || format.equals (\"txt\") || format.equals (\"cml\") || format.equals (\"cmlboth\") || format.indexOf (\"exsection\") == 0) {\n            res.setContentType (\"text/plain\");\n            out = res.getWriter ();\n        }\n        if (format.equals (\"simplehtml\") || format.equals (\"exportlastinputs\")) {\n            res.setContentType (\"text/html\");\n            out = res.getWriter ();\n        }\n        if (action.equals (\"exportlastinputs\")) {\n            int numbertoexport = 4;\n            if (req.getParameter (\"numbertoexport\") != null) {\n                try {\n                    numbertoexport = Integer.parseInt (req.getParameter (\"numbertoexport\"));\n                    if (numbertoexport < 1 || numbertoexport > 20) throw new NumberFormatException (\"Number to small/large\");\n\n                } catch (NumberFormatException ex) {\n                    out.println (\"The parameter <code>numbertoexport</code>must be an integer from 1 to 20\");\n                }\n            }\n            NmrshiftdbUser user = null;\n            try {\n                user = NmrshiftdbUserPeer.getByName (req.getParameter (\"username\"));\n            } catch (NmrshiftdbException ex) {\n                out.println (\"Seems <code>username</code> is not OK: \" + ex.getMessage ());\n            }\n            if (user != null) {\n                List l = NmrshiftdbUserPeer.executeQuery (\"SELECT LAST_DOWNLOAD_DATE FROM TURBINE_USER  where LOGIN_NAME=\\\"\" + user.getUserName () + \"\\\";\");\n                Date lastDownloadDate = ((Record) l.get (0)).getValue (1).asDate ();\n                if (((new Date ().getTime () - lastDownloadDate.getTime ()) / 3600000) < 24) {\n                    out.println (\"Your last download was at \" + lastDownloadDate + \". You may download your last inputs only once a day. Sorry for this, but we need to be carefull with resources. If you want to put your last inputs on your homepage best use some sort of cache (e. g. use wget for downlaod with crond and link to this static resource))!\");\n                } else {\n                    NmrshiftdbUserPeer.executeStatement (\"UPDATE TURBINE_USER SET LAST_DOWNLOAD_DATE=NOW() where LOGIN_NAME=\\\"\" + user.getUserName () + \"\\\";\");\n                    Vector < String > parameters = new Vector < String > ();\n                    String query = \"select distinct MOLECULE.MOLECULE_ID from MOLECULE, SPECTRUM where SPECTRUM.MOLECULE_ID = MOLECULE.MOLECULE_ID and SPECTRUM.REVIEW_FLAG =\\\"true\\\" and SPECTRUM.USER_ID=\" + user.getUserId () + \" order by MOLECULE.DATE desc;\";\n                    l = NmrshiftdbUserPeer.executeQuery (query);\n                    String url = javax.servlet.http.HttpUtils.getRequestURL (req).toString ();\n                    url = url.substring (0, url.length () - 17);\n                    for (int i = 0;\n                    i < numbertoexport; i ++) {\n                        if (i == l.size ()) break;\n\n                        DBMolecule mol = DBMoleculePeer.retrieveByPK (new NumberKey (((Record) l.get (i)).getValue (1).asInt ()));\n                        parameters.add (new String (\"<a href=\\\"\" + url + \"/portal/pane0/Results?nmrshiftdbaction=showDetailsFromHome&molNumber=\" + mol.getMoleculeId () + \"\\\"><img src=\\\"\" + javax.servlet.http.HttpUtils.getRequestURL (req).toString () + \"?nmrshiftdbaction=exportmol&spectrumid=\" + ((DBSpectrum) mol.getDBSpectrums ().get (0)).getSpectrumId () + \"&format=jpeg&size=150x150&backcolor=12632256\\\"></a>\"));\n                    }\n                    VelocityContext context = new VelocityContext ();\n                    context.put (\"results\", parameters);\n                    StringWriter w = new StringWriter ();\n                    Velocity.mergeTemplate (\"lateststructures.vm\", \"ISO-8859-1\", context, w);\n                    out.println (w.toString ());\n                }\n            }\n        }\n        if (action.equals (\"exportspec\")) {\n            if (format.equals (\"txt\")) {\n                String lastsearchtype = req.getParameter (\"lastsearchtype\");\n                if (lastsearchtype.equals (NmrshiftdbConstants.TOTALSPECTRUM) || lastsearchtype.equals (NmrshiftdbConstants.SUBSPECTRUM)) {\n                    List l = ParseUtils.parseSpectrumFromSpecFile (req.getParameter (\"lastsearchvalues\"));\n                    spectrum.initSimilarity (l, lastsearchtype.equals (NmrshiftdbConstants.SUBSPECTRUM));\n                }\n                Vector v = spectrum.getOptions ();\n                DBMolecule mol = spectrum.getDBMolecule ();\n                out.print (mol.getChemicalNamesAsOneString (false) + mol.getMolecularFormula (false) + \"; \" + mol.getMolecularWeight () + \" Dalton\\n\\r\");\n                out.print (\"\\n\\rAtom\\t\");\n                if (spectrum.getDBSpectrumType ().getElementSymbol () == (\"H\")) out.print (\"Mult.\\t\");\n\n                out.print (\"Meas.\");\n                if (lastsearchtype.equals (NmrshiftdbConstants.TOTALSPECTRUM) || lastsearchtype.equals (NmrshiftdbConstants.SUBSPECTRUM)) {\n                    out.print (\"\\tInput\\tDiff\");\n                }\n                out.print (\"\\n\\r\");\n                out.print (\"No.\\t\");\n                if (spectrum.getDBSpectrumType ().getElementSymbol () == (\"H\")) out.print (\"\\t\");\n\n                out.print (\"Shift\");\n                if (lastsearchtype.equals (NmrshiftdbConstants.TOTALSPECTRUM) || lastsearchtype.equals (NmrshiftdbConstants.SUBSPECTRUM)) {\n                    out.print (\"\\tShift\\tM-I\");\n                }\n                out.print (\"\\n\\r\");\n                for (int i = 0;\n                i < v.size (); i ++) {\n                    out.print (((ValuesForVelocityBean) v.get (i)).getDisplayText () + \"\\t\" + ((ValuesForVelocityBean) v.get (i)).getRange ());\n                    if (lastsearchtype.equals (NmrshiftdbConstants.TOTALSPECTRUM) || lastsearchtype.equals (NmrshiftdbConstants.SUBSPECTRUM)) {\n                        out.print (\"\\t\" + ((ValuesForVelocityBean) v.get (i)).getNameForElements () + \"\\t\" + ((ValuesForVelocityBean) v.get (i)).getDelta ());\n                    }\n                    out.print (\"\\n\\r\");\n                }\n            }\n            if (format.equals (\"simplehtml\")) {\n                String i1 = export.getImage (false, \"jpeg\", ServletUtils.expandRelative (this.getServletConfig (), \"/nmrshiftdbhtml\") + \"/tmp/\" + System.currentTimeMillis (), true);\n                export.pictures [0] = new File (i1).getName ();\n                String i2 = export.getImage (true, \"jpeg\", ServletUtils.expandRelative (this.getServletConfig (), \"/nmrshiftdbhtml\") + \"/tmp/\" + System.currentTimeMillis (), true);\n                export.pictures [1] = new File (i2).getName ();\n                String docbook = export.getHtml ();\n                out.print (docbook);\n            }\n            if (format.equals (\"pdf\") || format.equals (\"rtf\")) {\n                String svgSpec = export.getSpecSvg (400, 200);\n                String svgspecfile = relativepath + \"/tmp/\" + System.currentTimeMillis () + \"s.svg\";\n                new FileOutputStream (svgspecfile).write (svgSpec.getBytes ());\n                export.pictures [1] = svgspecfile;\n                String molSvg = export.getMolSvg (true);\n                String svgmolfile = relativepath + \"/tmp/\" + System.currentTimeMillis () + \"m.svg\";\n                new FileOutputStream (svgmolfile).write (molSvg.getBytes ());\n                export.pictures [0] = svgmolfile;\n                String docbook = export.getDocbook (\"pdf\", \"SVG\");\n                TransformerFactory tFactory = TransformerFactory.newInstance ();\n                Transformer transformer = tFactory.newTransformer (new StreamSource (\"file:\" + GeneralUtils.getNmrshiftdbProperty (\"docbookxslpath\", getServletConfig ()) + \"/fo/docbook.xsl\"));\n                ByteArrayOutputStream baos = new ByteArrayOutputStream ();\n                transformer.transform (new StreamSource (new StringReader (docbook)), new StreamResult (baos));\n                FopFactory fopFactory = FopFactory.newInstance ();\n                FOUserAgent foUserAgent = fopFactory.newFOUserAgent ();\n                OutputStream out2 = new ByteArrayOutputStream ();\n                Fop fop = fopFactory.newFop (format.equals (\"rtf\") ? MimeConstants.MIME_RTF : MimeConstants.MIME_PDF, foUserAgent, out2);\n                TransformerFactory factory = TransformerFactory.newInstance ();\n                transformer = factory.newTransformer ();\n                Source src = new StreamSource (new StringReader (baos.toString ()));\n                Result res2 = new SAXResult (fop.getDefaultHandler ());\n                transformer.transform (src, res2);\n                out.print (out2.toString ());\n            }\n            if (format.equals (\"docbook\")) {\n                String i1 = relativepath + \"/tmp/\" + System.currentTimeMillis () + \".svg\";\n                new FileOutputStream (i1).write (export.getSpecSvg (300, 200).getBytes ());\n                export.pictures [0] = new File (i1).getName ();\n                String i2 = relativepath + \"/tmp/\" + System.currentTimeMillis () + \".svg\";\n                new FileOutputStream (i2).write (export.getMolSvg (true).getBytes ());\n                export.pictures [1] = new File (i2).getName ();\n                String docbook = export.getDocbook (\"pdf\", \"SVG\");\n                String docbookfile = relativepath + \"/tmp/\" + System.currentTimeMillis () + \".xml\";\n                new FileOutputStream (docbookfile).write (docbook.getBytes ());\n                ByteArrayOutputStream baos = export.makeZip (new String [] {docbookfile, i1, i2});\n                outstream.write (baos.toByteArray ());\n            }\n            if (format.equals (\"svg\")) {\n                out.print (export.getSpecSvg (400, 200));\n            }\n            if (format.equals (\"tiff\") || format.equals (\"jpeg\") || format.equals (\"png\")) {\n                InputStream is = new FileInputStream (export.getImage (false, format, relativepath + \"/tmp/\" + System.currentTimeMillis (), true));\n                byte [] buf = new byte [32 * 1024];\n                int nRead = 0;\n                while ((nRead = is.read (buf)) != - 1) {\n                    outstream.write (buf, 0, nRead);\n                }\n            }\n            if (format.equals (\"cml\")) {\n                out.print (spectrum.getCmlSpect ().toXML ());\n            }\n            if (format.equals (\"cmlboth\")) {\n                Element cmlElement = new Element (\"cml\");\n                cmlElement.addAttribute (new Attribute (\"convention\", \"nmrshiftdb-convention\"));\n                cmlElement.setNamespaceURI (\"http://www.xml-cml.org/schema\");\n                Element parent = spectrum.getDBMolecule ().getCML (1, spectrum.getDBSpectrumType ().getName ().equals (\"1H\"));\n                nu.xom.Node cmldoc = parent.getChild (0);\n                ((Element) cmldoc).setNamespaceURI (\"http://www.xml-cml.org/schema\");\n                parent.removeChildren ();\n                cmlElement.appendChild (cmldoc);\n                Element parentspec = spectrum.getCmlSpect ();\n                Node spectrumel = parentspec.getChild (0);\n                parentspec.removeChildren ();\n                cmlElement.appendChild (spectrumel);\n                ((Element) spectrumel).setNamespaceURI (\"http://www.xml-cml.org/schema\");\n                out.write (cmlElement.toXML ());\n            }\n            if (format.indexOf (\"exsection\") == 0) {\n                StringTokenizer st = new StringTokenizer (format, \"-\");\n                st.nextToken ();\n                String template = st.nextToken ();\n                Criteria crit = new Criteria ();\n                crit.add (DBSpectrumPeer.USER_ID, spectrum.getUserId ());\n                Vector v = spectrum.getDBMolecule ().getDBSpectrums (crit);\n                VelocityContext context = new VelocityContext ();\n                context.put (\"spectra\", v);\n                context.put (\"molecule\", spectrum.getDBMolecule ());\n                StringWriter w = new StringWriter ();\n                Velocity.mergeTemplate (\"exporttemplates/\" + template, \"ISO-8859-1\", context, w);\n                out.write (w.toString ());\n            }\n        }\n        if (action.equals (\"exportmol\")) {\n            int width = - 1;\n            int height = - 1;\n            if (req.getParameter (\"size\") != null) {\n                StringTokenizer st = new StringTokenizer (req.getParameter (\"size\"), \"x\");\n                width = Integer.parseInt (st.nextToken ());\n                height = Integer.parseInt (st.nextToken ());\n            }\n            boolean shownumbers = true;\n            if (req.getParameter (\"shownumbers\") != null && req.getParameter (\"shownumbers\").equals (\"false\")) {\n                shownumbers = false;\n            }\n            if (req.getParameter (\"backcolor\") != null) {\n                export.backColor = new Color (Integer.parseInt (req.getParameter (\"backcolor\")));\n            }\n            if (req.getParameter (\"markatom\") != null) {\n                export.selected = Integer.parseInt (req.getParameter (\"markatom\")) - 1;\n            }\n            if (format.equals (\"svg\")) {\n                out.print (export.getMolSvg (true));\n            }\n            if (format.equals (\"tiff\") || format.equals (\"jpeg\") || format.equals (\"png\")) {\n                InputStream is = new FileInputStream (export.getImage (true, format, relativepath + \"/tmp/\" + System.currentTimeMillis (), width, height, shownumbers, null));\n                byte [] buf = new byte [32 * 1024];\n                int nRead = 0;\n                while ((nRead = is.read (buf)) != - 1) {\n                    outstream.write (buf, 0, nRead);\n                }\n            }\n            if (format.equals (\"mdl\")) {\n                out.println (spectrum.getDBMolecule ().getStructureFile (1, false));\n            }\n            if (format.equals (\"cml\")) {\n                out.println (spectrum.getDBMolecule ().getCMLString (1));\n            }\n        }\n        if (out != null) out.flush ();\n        else outstream.flush ();\n\n    } catch (Exception ex) {\n        ex.printStackTrace ();\n        out.print (GeneralUtils.logError (ex, \"NmrshiftdbServlet\", null, true));\n        out.flush ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4591684, "method2_id": 16749958, "code1": "public static void copyDirs (File sourceDir, File destDir) throws IOException {\n    if (! destDir.exists ()) destDir.mkdirs ();\n\n    for (File file : sourceDir.listFiles ()) {\n        if (file.isDirectory ()) {\n            copyDirs (file, new File (destDir, file.getName ()));\n        } else {\n            FileChannel srcChannel = new FileInputStream (file).getChannel ();\n            File out = new File (destDir, file.getName ());\n            out.createNewFile ();\n            FileChannel dstChannel = new FileOutputStream (out).getChannel ();\n            dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n            srcChannel.close ();\n            dstChannel.close ();\n        }\n    }\n}\n", "code2": "public byte process (ProcessorContext < PublishRequest > context) throws InterruptedException, ProcessorException {\n    logger.info (\"MapTileChacheTask:process\");\n    PublishRequest req = context.getItem ().getEntity ();\n    if (StringUtils.isEmpty (req.getBackMap ())) return TaskState.STATE_TILE_CACHED;\n\n    final PublicMapPost post;\n    final GenericDAO < PublicMapPost > postDao = DAOFactory.createDAO (PublicMapPost.class);\n    try {\n        ReadOnlyTransaction.beginTransaction ();\n    } catch (DatabaseException e) {\n        logger.error (\"error\", e);\n        throw new ProcessorException (e);\n    }\n    int numCachedTiles = 0;\n    try {\n        List < MapTile > backTiles = new ArrayList < MapTile > ();\n        post = postDao.findUniqueByCriteria (Expression.eq (\"guid\", req.getPostGuid ()));\n        final LatLngRectangle bounds = new LatLngRectangle (new LatLngPoint (post.getSWLat (), post.getSWLon ()), new LatLngPoint (post.getNELat (), post.getNELon ()));\n        final String backMapGuid = \"gst\";\n        final XFile dstDir = new XFile (new XFile (Configuration.getInstance ().getPublicMapStorage ().toString ()), backMapGuid);\n        dstDir.mkdir ();\n        for (int z = Math.min (Tile.getOptimalZoom (bounds, 768), 9);\n        z <= 17; z ++) {\n            final Tile tileStart = new Tile (bounds.getSouthWest ().getLat (), bounds.getSouthWest ().getLng (), z);\n            final Tile tileEnd = new Tile (bounds.getNorthEast ().getLat (), bounds.getNorthEast ().getLng (), z);\n            for (double y = tileEnd.getTileCoord ().getY ();\n            y <= tileStart.getTileCoord ().getY (); y ++) for (double x = tileStart.getTileCoord ().getX ();\n            x <= tileEnd.getTileCoord ().getX (); x ++) {\n                NASAMapTile tile = new NASAMapTile ((int) x, (int) y, z);\n                XFile file = new XFile (dstDir, tile.toKeyString ());\n                if (file.exists () && file.isFile ()) continue;\n\n                backTiles.add (tile);\n            }\n\n        }\n        try {\n            for (MapTile tile : backTiles) {\n                InputStream in = null;\n                OutputStream out = null;\n                final URL url = new URL (tile.getPath ());\n                try {\n                    final XFile outFile = new XFile (dstDir, tile.toKeyString ());\n                    final URLConnection conn = url.openConnection ();\n                    if (conn == null || ! conn.getContentType ().startsWith (\"image\")) throw new IllegalAccessException (\"onearth.jpl.nasa.gov service returns non-image file, \" + \"content-type='\" + conn.getContentType () + \"'\");\n\n                    in = conn.getInputStream ();\n                    if (in != null) {\n                        out = new XFileOutputStream (outFile);\n                        IOUtils.copy (in, out);\n                    } else throw new IllegalStateException (\"opened stream is null\");\n\n                } finally {\n                    if (out != null) {\n                        out.flush ();\n                        out.close ();\n                    }\n                    if (in != null) in.close ();\n\n                }\n                if (++ numCachedTiles % 100 == 0) {\n                    logger.info (numCachedTiles + \" tiles cached\");\n                }\n            }\n        } catch (Throwable e) {\n            logger.error (\"map tile caching has failed: \", e);\n            throw new ProcessorException (e);\n        }\n    } catch (ProcessorException e) {\n        logger.error (\"map tile caching has failed: \", e);\n        throw e;\n    } catch (Throwable e) {\n        logger.error (\"map tile caching has failed: \", e);\n        throw new ProcessorException (e);\n    } finally {\n        ReadOnlyTransaction.closeTransaction ();\n        logger.info (numCachedTiles + \" tiles cached\");\n    }\n    return TaskState.STATE_TILE_CACHED;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 40044, "method2_id": 17511631, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private static void extract (final ZipFile zf, final ZipEntry zipEntry, final String desDir, final int...startDirLevel) throws IOException {\n    File desf = new File (desDir);\n    if (! desf.exists ()) {\n        desf.mkdirs ();\n    }\n    int start = 1;\n    if (null != startDirLevel && startDirLevel.length > 0) {\n        start = startDirLevel [0];\n        if (start < 1) {\n            start = 1;\n        }\n    }\n    String startDir = \"\";\n    String zeName = zipEntry.getName ();\n    String folder = zeName;\n    boolean isDir = zipEntry.isDirectory ();\n    if (null != folder) {\n        String [] folders = folder.split (\"\\\\/\");\n        if (null != folders && folders.length > 0) {\n            int len = folders.length;\n            if (start == 1) {\n                startDir = zeName;\n            } else {\n                if (start > len) {\n                } else {\n                    for (int i = start - 1;\n                    i < len; i ++) {\n                        startDir += \"/\" + folders [i];\n                    }\n                    if (null != startDir) {\n                        startDir = startDir.substring (1);\n                    }\n                }\n            }\n        }\n    }\n    startDir = StringUtils.trim (startDir);\n    if (StringUtils.isNotEmpty (startDir)) {\n        StringBuilder desFileName = new StringBuilder (desDir);\n        if (! desDir.endsWith (\"/\") && ! startDir.startsWith (\"/\")) {\n            desFileName.append (\"/\");\n        }\n        desFileName.append (startDir);\n        File destFile = new File (desFileName.toString ());\n        if (isDir) {\n            if (! destFile.exists ()) {\n                destFile.mkdirs ();\n            }\n        } else {\n            File parentDir = new File (destFile.getParentFile ().getPath ());\n            if (! parentDir.exists ()) {\n                parentDir.mkdirs ();\n            }\n            InputStream is = zf.getInputStream (zipEntry);\n            OutputStream os = new FileOutputStream (destFile);\n            IOUtils.copy (is, os);\n            if (null != is) {\n                is.close ();\n            }\n            if (null != os) {\n                os.close ();\n            }\n        }\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6393820, "method2_id": 10471630, "code1": "public MultiArray copyout (int [] origin, int [] shape) {\n    if (origin.length != lengths.length || shape.length != lengths.length) throw new IllegalArgumentException (\"Rank Mismatch\");\n\n    int ji = lengths.length - 1;\n    for (; ji >= 0; ji --) {\n        if (origin [ji] != 0 || shape [ji] != lengths [ji]) break;\n\n    }\n    if (ji < 0) {\n        return (MultiArrayImpl) this.clone ();\n    }\n    final int [] shp = (int []) shape.clone ();\n    final int [] pducts = new int [shp.length];\n    final int product = numberOfElements (shp, pducts);\n    final Object dst = Array.newInstance (getComponentType (), product);\n    int src_pos = indexMap (origin);\n    if (ji == 0) {\n        System.arraycopy (storage, src_pos, dst, 0, product);\n    } else {\n        ji --;\n        final int step = products [ji];\n        final int contig = pducts [ji];\n        for (int dst_pos = 0;\n        dst_pos < product; dst_pos += contig) {\n            System.arraycopy (storage, src_pos, dst, dst_pos, contig);\n            src_pos += step;\n        }\n    }\n    return new MultiArrayImpl (shp, pducts, dst);\n}\n", "code2": "private static Object setIndexInList (Object bean, int idx, Object child) {\n    if (bean instanceof List) {\n        List l = (List) bean;\n        while (l.size () <= idx) {\n            l.add (null);\n        }\n        l.set (idx, child);\n        return l;\n    } else if (bean.getClass ().isArray ()) {\n        int length = Array.getLength (bean);\n        if (length <= idx) {\n            Object newArray = Array.newInstance (bean.getClass ().getComponentType (), idx + 1);\n            System.arraycopy (bean, 0, newArray, 0, length);\n            bean = newArray;\n        }\n        Array.set (bean, idx, child);\n        return bean;\n    } else {\n        return null;\n    }\n\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 12202663, "method2_id": 16367499, "code1": "private static byte [] finalizeStringHash (String loginHash) throws NoSuchAlgorithmException {\n    MessageDigest md5Hasher;\n    md5Hasher = MessageDigest.getInstance (\"MD5\");\n    md5Hasher.update (loginHash.getBytes ());\n    md5Hasher.update (LOGIN_FINAL_SALT);\n    return md5Hasher.digest ();\n}\n", "code2": "public static String md5 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"MD5\");\n    byte [] md5hash;\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    md5hash = md.digest ();\n    return convertToHex (md5hash);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2026331, "method2_id": 9647800, "code1": "private static void addZipEntry (ZipOutputStream zipOut, File zipIn, File root) throws IOException {\n    BufferedInputStream inStream = new BufferedInputStream (new FileInputStream (zipIn));\n    byte buffer [] = new byte [1024];\n    int length;\n    String zipEntryName = replaceSeparator (zipIn.getPath ().substring (root.getPath ().length () + 1));\n    zipOut.putNextEntry (new ZipEntry (zipEntryName));\n    try {\n        length = inStream.read (buffer);\n        while (length != - 1) {\n            zipOut.write (buffer, 0, length);\n            length = inStream.read (buffer);\n        }\n    } finally {\n        zipOut.closeEntry ();\n        inStream.close ();\n    }\n}\n", "code2": "public File createArchive (String filename) throws ArchiveFailedException {\n    File f = new File (filename);\n    try {\n        if (f.exists ()) {\n            f.delete ();\n        }\n        f.createNewFile ();\n        ZipOutputStream zout = new ZipOutputStream (new FileOutputStream (f));\n        zout.putNextEntry (new ZipEntry (COURSE_DESCRIPTOR));\n        zout.write (getXML ().getBytes ());\n        zout.closeEntry ();\n        for (ExportedFile ef : getFiles ()) {\n            zout.putNextEntry (new ZipEntry (ef.getFilename ()));\n            zout.write (ef.getContent ());\n            zout.closeEntry ();\n        }\n        zout.close ();\n    } catch (Exception e) {\n        throw new ArchiveFailedException (e);\n    }\n    return f;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 769146, "method2_id": 920501, "code1": "private String [] execSingleLineOutputCmd (String cmdWithParams) {\n    String result = \"\";\n    try {\n        Process p = Runtime.getRuntime ().exec (cmdWithParams.split (\" \"));\n        BufferedReader sin = new BufferedReader (new InputStreamReader (p.getInputStream ()));\n        result = sin.readLine ();\n        sin.close ();\n        return result.split (\" \");\n    } catch (Exception ex) {\n        System.out.println (\"ERROR: \" + ex.getMessage ());\n        return null;\n    }\n}\n", "code2": "public String [] action (String command, OutputStream logStream) throws java.io.IOException {\n    String logString = \"\\tHeartBeatAction.action:acknowledged by FIBS\\n\";\n    synchronized (logStream) {\n        logStream.write (logString.getBytes (), 0, logString.length ());\n        logStream.flush ();\n    }\n    try {\n        Process p = (Runtime.getRuntime ()).exec (\"fortune\");\n        BufferedReader in = new BufferedReader ((Reader) new InputStreamReader (p.getInputStream ()));\n        fortuneString = \"\";\n    } catch (IOException ioe) {\n    }\n    ret [0] = \"back\";\n    if (fortuneString != null) ret [1] = fortuneString;\n    else {\n        ret [1] = \"tell repbot thump\";\n    }\n    return (ret);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3024983, "method2_id": 11103449, "code1": "@Test\npublic void testCopy_inputStreamToWriter_Encoding_nullEncoding () throws Exception {\n    InputStream in = new ByteArrayInputStream (inData);\n    in = new YellOnCloseInputStreamTest (in);\n    ByteArrayOutputStream baout = new ByteArrayOutputStream ();\n    YellOnFlushAndCloseOutputStreamTest out = new YellOnFlushAndCloseOutputStreamTest (baout, true, true);\n    Writer writer = new OutputStreamWriter (baout, \"US-ASCII\");\n    IOUtils.copy (in, writer, null);\n    out.off ();\n    writer.flush ();\n    assertTrue (\"Not all bytes were read\", in.available () == 0);\n    assertEquals (\"Sizes differ\", inData.length, baout.size ());\n    assertTrue (\"Content differs\", Arrays.equals (inData, baout.toByteArray ()));\n}\n", "code2": "@Override\npublic void run () {\n    try {\n        IOUtils.copy (_is, processOutStr);\n    } catch (final IOException ioe) {\n        proc.destroy ();\n    } finally {\n        IOUtils.closeQuietly (_is);\n        IOUtils.closeQuietly (processOutStr);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 6614947, "method2_id": 22627884, "code1": "public static String getPageSource (String url) throws ClientProtocolException, IOException {\n    HttpClient client = new DefaultHttpClient ();\n    HttpGet request = new HttpGet (url);\n    HttpResponse response = client.execute (request);\n    InputStream in = response.getEntity ().getContent ();\n    BufferedReader reader = new BufferedReader (new InputStreamReader (in));\n    StringBuilder source = new StringBuilder ();\n    String line = null;\n    while ((line = reader.readLine ()) != null) source.append (line);\n\n    in.close ();\n    return source.toString ();\n}\n", "code2": "private < T > Collection < T > loadProviders (final Class < T > providerClass) throws ModelException {\n    try {\n        final String providerNamePrefix = providerClass.getName () + \".\";\n        final Map < String, T > providers = new TreeMap < String, T > (new Comparator < String > () {\n            public int compare (final String key1, final String key2) {\n                return key1.compareTo (key2);\n            }}\n\n        );\n        final File platformProviders = new File (this.getPlatformProviderLocation ());\n        if (platformProviders.exists ()) {\n            if (this.isLoggable (Level.FINEST)) {\n                this.log (Level.FINEST, getMessage (\"processing\", platformProviders.getAbsolutePath ()), null);\n            }\n            InputStream in = null;\n            boolean suppressExceptionOnClose = true;\n            final java.util.Properties p = new java.util.Properties ();\n            try {\n                in = new FileInputStream (platformProviders);\n                p.load (in);\n                suppressExceptionOnClose = false;\n            } finally {\n                try {\n                    if (in != null) {\n                        in.close ();\n                    }\n                } catch (final IOException e) {\n                    if (suppressExceptionOnClose) {\n                        this.log (Level.SEVERE, getMessage (e), e);\n                    } else {\n                        throw e;\n                    }\n                }\n            }\n            for (Map.Entry < Object, Object > e : p.entrySet ()) {\n                if (e.getKey ().toString ().startsWith (providerNamePrefix)) {\n                    final String configuration = e.getValue ().toString ();\n                    if (this.isLoggable (Level.FINEST)) {\n                        this.log (Level.FINEST, getMessage (\"providerInfo\", platformProviders.getAbsolutePath (), providerClass.getName (), configuration), null);\n                    }\n                    providers.put (e.getKey ().toString (), this.createProviderObject (providerClass, configuration, platformProviders.toURI ().toURL ()));\n                }\n            }\n        }\n        final Enumeration < URL > classpathProviders = this.findResources (this.getProviderLocation () + '/' + providerClass.getName ());\n        int count = 0;\n        final long t0 = System.currentTimeMillis ();\n        while (classpathProviders.hasMoreElements ()) {\n            count ++;\n            final URL url = classpathProviders.nextElement ();\n            if (this.isLoggable (Level.FINEST)) {\n                this.log (Level.FINEST, getMessage (\"processing\", url.toExternalForm ()), null);\n            }\n            BufferedReader reader = null;\n            boolean suppressExceptionOnClose = true;\n            try {\n                reader = new BufferedReader (new InputStreamReader (url.openStream (), \"UTF-8\"));\n                String line = null;\n                while ((line = reader.readLine ()) != null) {\n                    if (line.contains (\"#\")) {\n                        continue;\n                    }\n                    if (this.isLoggable (Level.FINEST)) {\n                        this.log (Level.FINEST, getMessage (\"providerInfo\", url.toExternalForm (), providerClass.getName (), line), null);\n                    }\n                    providers.put (providerNamePrefix + providers.size (), this.createProviderObject (providerClass, line, url));\n                }\n                suppressExceptionOnClose = false;\n            } finally {\n                try {\n                    if (reader != null) {\n                        reader.close ();\n                    }\n                } catch (final IOException e) {\n                    if (suppressExceptionOnClose) {\n                        this.log (Level.SEVERE, getMessage (e), e);\n                    } else {\n                        throw new ModelException (getMessage (e), e);\n                    }\n                }\n            }\n        }\n        if (this.isLoggable (Level.FINE)) {\n            this.log (Level.FINE, getMessage (\"contextReport\", count, this.getProviderLocation () + '/' + providerClass.getName (), Long.valueOf (System.currentTimeMillis () - t0)), null);\n        }\n        return providers.values ();\n    } catch (final IOException e) {\n        throw new ModelException (getMessage (e), e);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 100791, "method2_id": 810724, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 44823, "method2_id": 14924022, "code1": "public void convert (File src, File dest) throws IOException {\n    InputStream in = new BufferedInputStream (new FileInputStream (src));\n    DcmParser p = pfact.newDcmParser (in);\n    Dataset ds = fact.newDataset ();\n    p.setDcmHandler (ds.getDcmHandler ());\n    try {\n        FileFormat format = p.detectFileFormat ();\n        if (format != FileFormat.ACRNEMA_STREAM) {\n            System.out.println (\"\\n\" + src + \": not an ACRNEMA stream!\");\n            return;\n        }\n        p.parseDcmFile (format, Tags.PixelData);\n        if (ds.contains (Tags.StudyInstanceUID) || ds.contains (Tags.SeriesInstanceUID) || ds.contains (Tags.SOPInstanceUID) || ds.contains (Tags.SOPClassUID)) {\n            System.out.println (\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n            return;\n        }\n        boolean hasPixelData = p.getReadTag () == Tags.PixelData;\n        boolean inflate = hasPixelData && ds.getInt (Tags.BitsAllocated, 0) == 12;\n        int pxlen = p.getReadLength ();\n        if (hasPixelData) {\n            if (inflate) {\n                ds.putUS (Tags.BitsAllocated, 16);\n                pxlen = pxlen * 4 / 3;\n            }\n            if (pxlen != (ds.getInt (Tags.BitsAllocated, 0)>>> 3) * ds.getInt (Tags.Rows, 0) * ds.getInt (Tags.Columns, 0) * ds.getInt (Tags.NumberOfFrames, 1) * ds.getInt (Tags.NumberOfSamples, 1)) {\n                System.out.println (\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                return;\n            }\n        }\n        ds.putUI (Tags.StudyInstanceUID, uid (studyUID));\n        ds.putUI (Tags.SeriesInstanceUID, uid (seriesUID));\n        ds.putUI (Tags.SOPInstanceUID, uid (instUID));\n        ds.putUI (Tags.SOPClassUID, classUID);\n        if (! ds.contains (Tags.NumberOfSamples)) {\n            ds.putUS (Tags.NumberOfSamples, 1);\n        }\n        if (! ds.contains (Tags.PhotometricInterpretation)) {\n            ds.putCS (Tags.PhotometricInterpretation, \"MONOCHROME2\");\n        }\n        if (fmi) {\n            ds.setFileMetaInfo (fact.newFileMetaInfo (ds, UIDs.ImplicitVRLittleEndian));\n        }\n        OutputStream out = new BufferedOutputStream (new FileOutputStream (dest));\n        try {\n        } finally {\n            ds.writeFile (out, encodeParam ());\n            if (hasPixelData) {\n                if (! skipGroupLen) {\n                    out.write (PXDATA_GROUPLEN);\n                    int grlen = pxlen + 8;\n                    out.write ((byte) grlen);\n                    out.write ((byte) (grlen>> 8));\n                    out.write ((byte) (grlen>> 16));\n                    out.write ((byte) (grlen>> 24));\n                }\n                out.write (PXDATA_TAG);\n                out.write ((byte) pxlen);\n                out.write ((byte) (pxlen>> 8));\n                out.write ((byte) (pxlen>> 16));\n                out.write ((byte) (pxlen>> 24));\n            }\n            if (inflate) {\n                int b2, b3;\n                for (; pxlen > 0; pxlen -= 3) {\n                    out.write (in.read ());\n                    b2 = in.read ();\n                    b3 = in.read ();\n                    out.write (b2 & 0x0f);\n                    out.write (b2>> 4 | ((b3 & 0x0f) << 4));\n                    out.write (b3>> 4);\n                }\n            } else {\n                for (; pxlen > 0; -- pxlen) {\n                    out.write (in.read ());\n                }\n            }\n            out.close ();\n        }\n        System.out.print ('.');\n    } finally {\n        in.close ();\n    }\n}\n", "code2": "private boolean saveDocumentXml (String repository, String tempRepo) {\n    boolean result = true;\n    try {\n        XPath xpath = XPathFactory.newInstance ().newXPath ();\n        String expression = \"documents/document\";\n        InputSource insource = new InputSource (new FileInputStream (tempRepo + File.separator + AppConstants.DMS_XML));\n        NodeList nodeList = (NodeList) xpath.evaluate (expression, insource, XPathConstants.NODESET);\n        for (int i = 0;\n        i < nodeList.getLength (); i ++) {\n            Node node = nodeList.item (i);\n            System.out.println (node.getNodeName ());\n            DocumentModel document = new DocumentModel ();\n            NodeList childs = node.getChildNodes ();\n            for (int j = 0;\n            j < childs.getLength (); j ++) {\n                Node child = childs.item (j);\n                if (child.getNodeType () == Node.ELEMENT_NODE) {\n                    if (child.getNodeName () != null && child.getFirstChild () != null && child.getFirstChild ().getNodeValue () != null) {\n                        System.out.println (child.getNodeName () + \"::\" + child.getFirstChild ().getNodeValue ());\n                    }\n                    if (Document.FLD_ID.equals (child.getNodeName ())) {\n                        if (child.getFirstChild () != null) {\n                            String szId = child.getFirstChild ().getNodeValue ();\n                            if (szId != null && szId.length () > 0) {\n                                try {\n                                    document.setId (new Long (szId));\n                                } catch (Exception e) {\n                                    e.printStackTrace ();\n                                }\n                            }\n                        }\n                    } else if (document.FLD_NAME.equals (child.getNodeName ())) {\n                        document.setName (child.getFirstChild ().getNodeValue ());\n                        document.setTitle (document.getName ());\n                        document.setDescr (document.getName ());\n                        document.setExt (getExtension (document.getName ()));\n                    } else if (document.FLD_LOCATION.equals (child.getNodeName ())) {\n                        document.setLocation (child.getFirstChild ().getNodeValue ());\n                    } else if (document.FLD_OWNER.equals (child.getNodeName ())) {\n                        Long id = new Long (child.getFirstChild ().getNodeValue ());\n                        User user = new UserModel ();\n                        user.setId (id);\n                        user = (User) userService.find (user);\n                        if (user != null && user.getId () != null) {\n                            document.setOwner (user);\n                        }\n                    }\n\n                }\n            }\n            boolean isSave = docService.save (document);\n            if (isSave) {\n                String repo = preference.getRepository ();\n                Calendar calendar = Calendar.getInstance ();\n                StringBuffer sbRepo = new StringBuffer (repo);\n                sbRepo.append (File.separator);\n                StringBuffer sbFolder = new StringBuffer (sdf.format (calendar.getTime ()));\n                sbFolder.append (File.separator).append (calendar.get (Calendar.HOUR_OF_DAY));\n                File fileFolder = new File (sbRepo.append (sbFolder).toString ());\n                if (! fileFolder.exists ()) {\n                    fileFolder.mkdirs ();\n                }\n                FileChannel fcSource = null, fcDest = null;\n                try {\n                    StringBuffer sbFile = new StringBuffer (fileFolder.getAbsolutePath ());\n                    StringBuffer fname = new StringBuffer (document.getId ().toString ());\n                    fname.append (\".\").append (document.getExt ());\n                    sbFile.append (File.separator).append (fname);\n                    fcSource = new FileInputStream (tempRepo + File.separator + document.getName ()).getChannel ();\n                    fcDest = new FileOutputStream (sbFile.toString ()).getChannel ();\n                    fcDest.transferFrom (fcSource, 0, fcSource.size ());\n                    document.setLocation (sbFolder.toString ());\n                    document.setSize (fcSource.size ());\n                    log.info (\"Batch upload file \" + document.getName () + \" into [\" + document.getLocation () + \"] as \" + document.getName () + \".\" + document.getExt ());\n                    folder.setId (DEFAULT_FOLDER);\n                    folder = (Folder) folderService.find (folder);\n                    if (folder != null && folder.getId () != null) {\n                        document.setFolder (folder);\n                    }\n                    workspace.setId (DEFAULT_WORKSPACE);\n                    workspace = (Workspace) workspaceService.find (workspace);\n                    if (workspace != null && workspace.getId () != null) {\n                        document.setWorkspace (workspace);\n                    }\n                    user.setId (DEFAULT_USER);\n                    user = (User) userService.find (user);\n                    if (user != null && user.getId () != null) {\n                        document.setCrtby (user.getId ());\n                    }\n                    document.setCrtdate (new Date ());\n                    document = (DocumentModel) docService.resetDuplicateDocName (document);\n                    docService.save (document);\n                    DocumentIndexer.indexDocument (preference, document);\n                } catch (FileNotFoundException notFoundEx) {\n                    log.error (\"saveFile file not found: \" + document.getName (), notFoundEx);\n                } catch (IOException ioEx) {\n                    log.error (\"saveFile IOException: \" + document.getName (), ioEx);\n                } finally {\n                    try {\n                        if (fcSource != null) {\n                            fcSource.close ();\n                        }\n                        if (fcDest != null) {\n                            fcDest.close ();\n                        }\n                    } catch (Exception e) {\n                        log.error (e.getMessage (), e);\n                    }\n                }\n            }\n        }\n    } catch (Exception e) {\n        result = false;\n        e.printStackTrace ();\n    }\n    return result;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9905886, "method2_id": 12098748, "code1": "public void export () {\n    try {\n        class MyFilter implements FileFilter {\n            public boolean accept (File file) {\n                return (file.getName ().startsWith (graphName) && file.getName ().endsWith (\"display\"));\n            }}\n\n        cat.debug (\"graphFile: \" + graphFile);\n        File parentDir = graphFile.getParentFile ();\n        if (parentDir == null) parentDir = new File (\".\");\n\n        File [] displayFiles = parentDir.listFiles (new MyFilter ());\n        Graph graph = (new GraphWriter ()).readXML (new GraphImp (GraphImp.EMPTY_GRAPH), new FileInputStream (graphFile));\n        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outputFile));\n        for (int i = 0;\n        i < displayFiles.length; i ++) {\n            File file = displayFiles [i];\n            out.putNextEntry (new ZipEntry (file.getName ()));\n            byte [] arr = new byte [(int) file.length ()];\n            (new FileInputStream (file)).read (arr, 0, (int) file.length ());\n            out.write (arr, 0, (int) file.length ());\n            out.closeEntry ();\n        }\n        out.putNextEntry (new ZipEntry (graphName + \".files/\"));\n        relativateFiles (graphName, graph, out);\n        out.putNextEntry (new ZipEntry (graphName + \".xml\"));\n        (new GraphWriter ()).writeXML (graph, out);\n        out.closeEntry ();\n        out.flush ();\n        out.close ();\n    } catch (IOException exc) {\n        exc.printStackTrace (System.err);\n    }\n}\n", "code2": "private void packageFile (ZipOutputStream zos, String filename) throws IOException {\n    String filepath = environment.toProjectFile (projectName, filename);\n    File file = new File (filepath);\n    byte [] data = new byte [(int) file.length ()];\n    FileInputStream fis = new FileInputStream (file);\n    BufferedInputStream bis = new BufferedInputStream (fis);\n    int bytesRead = 0;\n    while (bytesRead < data.length) {\n        int n = bis.read (data, bytesRead, data.length - bytesRead);\n        bytesRead += n;\n    }\n    zos.putNextEntry (new ZipEntry (filename));\n    zos.write (data, 0, data.length);\n    zos.closeEntry ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 12660384, "method2_id": 14885369, "code1": "public static void main (String [] args) {\n    final String filePath1 = \"e:\\\\mysite\\\\data\\\\up\\\\itsite\";\n    final String filePath2 = \"d:\\\\works\\\\itsite\\\\itsite\";\n    IOUtils.listAllFilesNoRs (new File (filePath2), new FileFilter () {\n        @Override\n        public boolean accept (File file) {\n            if (file.getName ().equals (\".svn\")) {\n                return false;\n            }\n            final long modify = file.lastModified ();\n            final long time = DateUtils.toDate (\"2012-03-21 17:43\", \"yyyy-MM-dd HH:mm\").getTime ();\n            if (modify >= time) {\n                if (file.isFile ()) {\n                    File f = new File (StringsUtils.replace (file.getAbsolutePath (), filePath2, filePath1));\n                    f.getParentFile ().mkdirs ();\n                    try {\n                        IOUtils.copyFile (file, f);\n                    } catch (IOException e) {\n                        e.printStackTrace ();\n                    }\n                    System.out.println (f.getName ());\n                }\n            }\n            return true;\n        }}\n\n    );\n}\n", "code2": "public File copyFile (File in, File out) throws IOException {\n    FileChannel inChannel = new FileInputStream (in).getChannel ();\n    FileChannel outChannel = new FileOutputStream (out).getChannel ();\n    copyChannel (inChannel, outChannel);\n    return out;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3357568, "method2_id": 7317602, "code1": "public static String md5 (String text) {\n    MessageDigest msgDigest = null;\n    try {\n        msgDigest = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new IllegalStateException (\"System doesn't support MD5 algorithm.\");\n    }\n    try {\n        msgDigest.update (text.getBytes (AlipayConfig.input_charset));\n    } catch (UnsupportedEncodingException e) {\n        throw new IllegalStateException (\"System doesn't support your  EncodingException.\");\n    }\n    byte [] bytes = msgDigest.digest ();\n    String md5Str = new String (encodeHex (bytes));\n    return md5Str;\n}\n", "code2": "public static String SHA1 (String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"SHA-1\");\n    byte [] sha1hash = new byte [40];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    sha1hash = md.digest ();\n    return convertToHex (sha1hash);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 581819, "method2_id": 14144378, "code1": "private void exportAllSettings (HTTPurl urlData, OutputStream outStream) throws Exception {\n    CaptureDeviceList devList = CaptureDeviceList.getInstance ();\n    if (devList.getActiveDeviceCount () > 0) {\n        PageTemplate template = new PageTemplate (store.getProperty (\"path.template\") + File.separator + \"SettingsLoad.html\");\n        StringBuffer buff = new StringBuffer ();\n        buff.append (\"<tr><td><img border=0 src='/images/stop.png' align='absmiddle' width='24' height='24'></td><td>Can not save settings while a capture is in progress.</td></tr>\");\n        template.replaceAll (\"$result\", buff.toString ());\n        outStream.write (template.getPageBytes ());\n        return;\n    }\n    boolean matchList = \"true\".equalsIgnoreCase (urlData.getParameter (\"MatchList\"));\n    boolean autoAdd = \"true\".equalsIgnoreCase (urlData.getParameter (\"AutoAdd\"));\n    boolean channelMapping = \"true\".equalsIgnoreCase (urlData.getParameter (\"ChannelMapping\"));\n    boolean deviceSelection = \"true\".equalsIgnoreCase (urlData.getParameter (\"DeviceSelection\"));\n    boolean agentMapping = \"true\".equalsIgnoreCase (urlData.getParameter (\"AgentMapping\"));\n    boolean channels = \"true\".equalsIgnoreCase (urlData.getParameter (\"Channels\"));\n    boolean tasks = \"true\".equalsIgnoreCase (urlData.getParameter (\"Tasks\"));\n    boolean systemProp = \"true\".equalsIgnoreCase (urlData.getParameter (\"SystemProp\"));\n    boolean schedules = \"true\".equalsIgnoreCase (urlData.getParameter (\"Schedules\"));\n    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ();\n    ZipOutputStream out = new ZipOutputStream (bytesOut);\n    out.setComment (\"TV Scheduler Pro Settings file (Version: 1.0)\");\n    if (channels) {\n        out.putNextEntry (new ZipEntry (\"Channels.xml\"));\n        StringBuffer channelData = new StringBuffer ();\n        store.saveChannels (channelData);\n        byte [] channelBytes = channelData.toString ().getBytes (\"UTF-8\");\n        out.write (channelBytes);\n        out.closeEntry ();\n    }\n    if (matchList) {\n        out.putNextEntry (new ZipEntry (\"MatchList.xml\"));\n        StringBuffer matchData = new StringBuffer ();\n        store.saveMatchList (matchData);\n        byte [] matchBytes = matchData.toString ().getBytes (\"UTF-8\");\n        out.write (matchBytes);\n        out.closeEntry ();\n    }\n    if (autoAdd) {\n        out.putNextEntry (new ZipEntry (\"EpgAutoAdd.xml\"));\n        StringBuffer addData = new StringBuffer ();\n        store.saveEpgAutoList (addData);\n        byte [] addBytes = addData.toString ().getBytes (\"UTF-8\");\n        out.write (addBytes);\n        out.closeEntry ();\n    }\n    if (tasks) {\n        out.putNextEntry (new ZipEntry (\"Tasks.xml\"));\n        StringBuffer taskData = new StringBuffer ();\n        store.saveTaskList (taskData);\n        byte [] taskBytes = taskData.toString ().getBytes (\"UTF-8\");\n        out.write (taskBytes);\n        out.closeEntry ();\n    }\n    if (channelMapping) {\n        GuideStore guideStore = GuideStore.getInstance ();\n        out.putNextEntry (new ZipEntry (\"ChannelMap.sof\"));\n        ByteArrayOutputStream chanMapBytes = new ByteArrayOutputStream ();\n        guideStore.saveChannelMap (chanMapBytes);\n        out.write (chanMapBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (deviceSelection) {\n        out.putNextEntry (new ZipEntry (\"CaptureDevices.sof\"));\n        ByteArrayOutputStream deviceBytes = new ByteArrayOutputStream ();\n        devList.saveDeviceList (deviceBytes);\n        out.write (deviceBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (agentMapping) {\n        out.putNextEntry (new ZipEntry (\"AgentMap.sof\"));\n        ByteArrayOutputStream agentMapBytes = new ByteArrayOutputStream ();\n        store.saveAgentToThemeMap (agentMapBytes);\n        out.write (agentMapBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (schedules) {\n        out.putNextEntry (new ZipEntry (\"Times.sof\"));\n        ByteArrayOutputStream timesBytes = new ByteArrayOutputStream ();\n        store.saveSchedule (timesBytes);\n        out.write (timesBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    if (systemProp) {\n        HashMap < String, String > serverProp = new HashMap < String, String > ();\n        serverProp.put (\"Capture.path\", store.getProperty (\"Capture.path\"));\n        serverProp.put (\"Capture.AverageDataRate\", store.getProperty (\"Capture.AverageDataRate\"));\n        serverProp.put (\"Capture.AutoSelectMethod\", store.getProperty (\"Capture.AutoSelectMethod\"));\n        serverProp.put (\"Capture.minSpace\", store.getProperty (\"Capture.minSpace\"));\n        serverProp.put (\"Capture.IncludeCalculatedUsage\", store.getProperty (\"Capture.IncludeCalculatedUsage\"));\n        serverProp.put (\"Capture.deftype\", store.getProperty (\"Capture.deftype\"));\n        serverProp.put (\"Capture.filename.patterns\", store.getProperty (\"Capture.filename.patterns\"));\n        serverProp.put (\"Capture.path.details\", store.getProperty (\"Capture.path.details\"));\n        serverProp.put (\"Capture.CaptureFailedTimeout\", store.getProperty (\"Capture.CaptureFailedTimeout\"));\n        serverProp.put (\"Schedule.buffer.start\", store.getProperty (\"Schedule.buffer.start\"));\n        serverProp.put (\"Schedule.buffer.end\", store.getProperty (\"Schedule.buffer.end\"));\n        serverProp.put (\"Schedule.buffer.end.epg\", store.getProperty (\"Schedule.buffer.end.epg\"));\n        serverProp.put (\"Schedule.wake.system\", store.getProperty (\"Schedule.wake.system\"));\n        serverProp.put (\"sch.autodel.action\", store.getProperty (\"sch.autodel.action\"));\n        serverProp.put (\"sch.autodel.time\", store.getProperty (\"sch.autodel.time\"));\n        serverProp.put (\"guide.source.http.pwd\", store.getProperty (\"guide.source.http.pwd\"));\n        serverProp.put (\"guide.source.xml.channelList\", store.getProperty (\"guide.source.xml.channelList\"));\n        serverProp.put (\"guide.source.type\", store.getProperty (\"guide.source.type\"));\n        serverProp.put (\"guide.source.http\", store.getProperty (\"guide.source.http\"));\n        serverProp.put (\"guide.source.file\", store.getProperty (\"guide.source.file\"));\n        serverProp.put (\"guide.action.name\", store.getProperty (\"guide.action.name\"));\n        serverProp.put (\"guide.source.http.usr\", store.getProperty (\"guide.source.http.usr\"));\n        serverProp.put (\"guide.source.schedule\", store.getProperty (\"guide.source.schedule\"));\n        serverProp.put (\"guide.warn.overlap\", store.getProperty (\"guide.warn.overlap\"));\n        serverProp.put (\"proxy.server\", store.getProperty (\"proxy.server\"));\n        serverProp.put (\"proxy.port\", store.getProperty (\"proxy.port\"));\n        serverProp.put (\"proxy.server.usr\", store.getProperty (\"proxy.server.usr\"));\n        serverProp.put (\"proxy.server.pwd\", store.getProperty (\"proxy.server.pwd\"));\n        serverProp.put (\"email.server\", store.getProperty (\"email.server\"));\n        serverProp.put (\"email.from.name\", store.getProperty (\"email.from.name\"));\n        serverProp.put (\"email.to\", store.getProperty (\"email.to\"));\n        serverProp.put (\"email.from\", store.getProperty (\"email.from\"));\n        serverProp.put (\"Tasks.DefTask\", store.getProperty (\"Tasks.DefTask\"));\n        serverProp.put (\"Tasks.PreTask\", store.getProperty (\"Tasks.PreTask\"));\n        serverProp.put (\"Tasks.NoDataErrorTask\", store.getProperty (\"Tasks.NoDataErrorTask\"));\n        serverProp.put (\"Tasks.StartErrorTask\", store.getProperty (\"Tasks.StartErrorTask\"));\n        serverProp.put (\"filebrowser.DirsAtTop\", store.getProperty (\"filebrowser.DirsAtTop\"));\n        serverProp.put (\"filebrowser.masks\", store.getProperty (\"filebrowser.masks\"));\n        serverProp.put (\"server.kbLED\", store.getProperty (\"server.kbLED\"));\n        ByteArrayOutputStream serverpropBytes = new ByteArrayOutputStream ();\n        ObjectOutputStream oos = new ObjectOutputStream (serverpropBytes);\n        oos.writeObject (serverProp);\n        oos.close ();\n        out.putNextEntry (new ZipEntry (\"ServerProperties.sof\"));\n        out.write (serverpropBytes.toByteArray ());\n        out.closeEntry ();\n    }\n    out.flush ();\n    out.close ();\n    StringBuffer header = new StringBuffer ();\n    header.append (\"HTTP/1.1 200 OK\\n\");\n    header.append (\"Content-Type: application/zip\\n\");\n    header.append (\"Content-Length: \" + bytesOut.size () + \"\\n\");\n    header.append (\"Content-Disposition: attachment; filename=\\\"TV Scheduler Pro Settings.zip\\\"\\n\");\n    DateFormat df = new SimpleDateFormat (\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\", new Locale (\"En\", \"Us\", \"Unix\"));\n    header.append (\"Last-Modified: \" + df.format (new Date ()) + \"\\n\");\n    header.append (\"\\n\");\n    outStream.write (header.toString ().getBytes ());\n    ByteArrayInputStream zipStream = new ByteArrayInputStream (bytesOut.toByteArray ());\n    byte [] bytes = new byte [4096];\n    int read = zipStream.read (bytes);\n    while (read > - 1) {\n        outStream.write (bytes, 0, read);\n        outStream.flush ();\n        read = zipStream.read (bytes);\n    }\n}\n", "code2": "private static void addToZip (ZipOutputStream zout, String file, String code, String currentDirectory) {\n    try {\n        ZipEntry entry = new ZipEntry (currentDirectory + file);\n        zout.putNextEntry (entry);\n        zout.write (code.getBytes (), 0, code.length ());\n        zout.closeEntry ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 181830, "method2_id": 311874, "code1": "public void getResponse (HTTPurl urlData, OutputStream outStream) throws Exception {\n    String action = urlData.getParameter (\"action\");\n    Method m = this.getClass ().getMethod (action, new Class [] {HTTPurl.class, OutputStream.class});\n    Object ret = m.invoke (this, urlData, outStream);\n    outStream.write ((byte []) ret);\n}\n", "code2": "public static void main (String args []) throws Exception {\n    java.io.File lib = new java.io.File (\"lib\");\n    File [] fs = lib.listFiles ();\n    for (int k = 0;\n    k < fs.length; k ++) {\n        if (! fs [k].getName ().toLowerCase ().equals (\"ingeniaseditor.jar\")) addFile (fs [k]);\n        else {\n            System.err.println (fs [k].getName ());\n        }\n    }\n    if (args.length > 0) {\n        if (args [0].toLowerCase ().equals (\"-t\")) {\n            File tfiles = new File (\"tutorial\");\n            File [] tutorials = tfiles.listFiles ();\n            File selected = (File) javax.swing.JOptionPane.showInputDialog (null, \"Select one tutorial\", \"tutorials\", javax.swing.JOptionPane.QUESTION_MESSAGE, null, tutorials, tutorials [0]);\n            if (selected != null) {\n                Player player = new Player (selected.getPath ());\n                player.play ();\n            } else {\n                System.exit (0);\n            }\n        } else {\n            Class c = Class.forName (\"ingenias.editor.IDE\");\n            Method m = c.getMethod (\"main\", new Class [] {String [].class});\n            Object [] argl = new Object [args.length];\n            System.arraycopy (args, 0, argl, 0, args.length);\n            m.invoke (c, new Object [] {new String [0]});\n        }\n    } else {\n        Class c = Class.forName (\"ingenias.editor.IDE\");\n        Method m = c.getMethod (\"main\", new Class [] {String [].class});\n        Object [] argl = new Object [args.length];\n        System.arraycopy (args, 0, argl, 0, args.length);\n        m.invoke (c, new Object [] {new String [0]});\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10158738, "method2_id": 18374478, "code1": "public void add (String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n    try {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection ();\n            conn.setAutoCommit (false);\n            stmt = conn.createStatement ();\n            if (containsTag (stmt, tag) == false) throw new MorphologyTagNotFoundException (tag);\n\n            if (isRuleUnique (stmt, language, tag, root, surface) == false) return;\n\n            int row;\n            if (root.equals (\"*\") == true) row = getAppendRowForTag (stmt, language, tag);\n            else if (root.indexOf ('*') == - 1) row = getFirstRowForTag (stmt, language, tag);\n            else row = getFirstRegularFormForTag (stmt, language, tag);\n\n            boolean use = determineRecognitionUse (root, surface);\n            bumpAllRowsDown (stmt, language, tag, row);\n            String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n            if (use == true) sql = sql + \"TRUE)\";\n            else sql = sql + \"FALSE)\";\n\n            stmt.executeUpdate (sql);\n            conn.commit ();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback ();\n\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close ();\n\n            if (conn != null) conn.close ();\n\n        }\n    } catch (SQLException e) {\n        throw new FidoDatabaseException (e);\n    }\n}\n", "code2": "public void updateUser (final User user) throws IOException {\n    try {\n        Connection conn = null;\n        boolean autoCommit = false;\n        try {\n            conn = pool.getConnection ();\n            autoCommit = conn.getAutoCommit ();\n            conn.setAutoCommit (false);\n            final PreparedStatement updateUser = conn.prepareStatement (\"update users set mainRoleId=? where userId=?\");\n            updateUser.setInt (1, user.getMainRole ().getId ());\n            updateUser.setString (2, user.getUserId ());\n            updateUser.executeUpdate ();\n            final PreparedStatement deleteRoles = conn.prepareStatement (\"delete from userRoles where userId=?\");\n            deleteRoles.setString (1, user.getUserId ());\n            deleteRoles.executeUpdate ();\n            final PreparedStatement insertRoles = conn.prepareStatement (\"insert into userRoles (userId, roleId) values (?,?)\");\n            for (final Role role : user.getRoles ()) {\n                insertRoles.setString (1, user.getUserId ());\n                insertRoles.setInt (2, role.getId ());\n                insertRoles.executeUpdate ();\n            }\n            conn.commit ();\n        } catch (Throwable t) {\n            if (conn != null) conn.rollback ();\n\n            throw new SQLException (t.toString ());\n        } finally {\n            if (conn != null) {\n                conn.setAutoCommit (autoCommit);\n                conn.close ();\n            }\n        }\n    } catch (final SQLException sqle) {\n        log.log (Level.SEVERE, sqle.toString (), sqle);\n        throw new IOException (sqle.toString ());\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 11838691, "method2_id": 13333160, "code1": "private void externalizeFiles (Document doc, File out) throws IOException {\n    File [] files = doc.getImages ();\n    if (files.length > 0) {\n        File dir = new File (out.getParentFile (), out.getName () + \".images\");\n        if (! dir.mkdirs ()) throw new IOException (\"cannot create directory \" + dir);\n\n        if (dir.exists ()) {\n            for (int i = 0;\n            i < files.length; i ++) {\n                File file = files [i];\n                File copy = new File (dir, file.getName ());\n                FileChannel from = null, to = null;\n                long count = - 1;\n                try {\n                    from = new FileInputStream (file).getChannel ();\n                    count = from.size ();\n                    to = new FileOutputStream (copy).getChannel ();\n                    from.transferTo (0, count, to);\n                    doc.setImage (file, dir.getName () + \"/\" + copy.getName ());\n                } catch (Throwable t) {\n                    LOG.log (Level.WARNING, \"Copying '\" + file + \"' to '\" + copy + \"' failed (size=\" + count + \")\", t);\n                } finally {\n                    try {\n                        to.close ();\n                    } catch (Throwable t) {\n                    }\n                    try {\n                        from.close ();\n                    } catch (Throwable t) {\n                    }\n                }\n            }\n        }\n    }\n}\n", "code2": "private void run (Reader xmlIn, OutputStream out) throws IOException, SAXException {\n    Document dom = null;\n    try {\n        DocumentBuilderFactory f = DocumentBuilderFactory.newInstance ();\n        f.setNamespaceAware (false);\n        f.setCoalescing (true);\n        f.setIgnoringComments (true);\n        f.setValidating (false);\n        DocumentBuilder b = f.newDocumentBuilder ();\n        dom = b.parse (new InputSource (xmlIn));\n    } catch (ParserConfigurationException err) {\n        throw new IOException (err);\n    }\n    Element root = dom.getDocumentElement ();\n    if (root == null) throw new SAXException (\"Not root in document\");\n\n    Attr att = root.getAttributeNode (\"label\");\n    if (att == null) root.setAttribute (\"label\", \"Wikipedia\");\n\n    Menu menu = parseMenu (root);\n    menu.id = \"menuWikipedia\";\n    ZipOutputStream zout = new ZipOutputStream (out);\n    String content = ResourceUtils.getContent (XUL4Wikipedia.class, \"chrome.manifest\");\n    addEntry (zout, \"chrome.manifest\", content);\n    content = ResourceUtils.getContent (XUL4Wikipedia.class, \"install.rdf\");\n    addEntry (zout, \"install.rdf\", content);\n    content = ResourceUtils.getContent (XUL4Wikipedia.class, \"library.js\");\n    addDir (zout, \"chrome/\");\n    addDir (zout, \"chrome/content/\");\n    addDir (zout, \"chrome/skin/\");\n    String signal = \"/*INSERT_CMD_HERE*/\";\n    int n = content.indexOf (signal);\n    if (n == - 1) throw new RuntimeException (\"where is \" + signal + \" ??\");\n\n    ZipEntry entry = new ZipEntry (\"chrome/content/library.js\");\n    zout.putNextEntry (entry);\n    PrintWriter pout = new PrintWriter (zout);\n    pout.write (content.substring (0, n));\n    menu.toJS (pout);\n    pout.write (content.substring (n + signal.length ()));\n    pout.flush ();\n    zout.closeEntry ();\n    entry = new ZipEntry (\"chrome/content/menu.xul\");\n    zout.putNextEntry (entry);\n    pout = new PrintWriter (zout);\n    pout.println (\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n    pout.println (\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n    pout.println (\"<script src=\\\"library.js\\\"/>\");\n    pout.println (\"<popup id=\\\"contentAreaContextMenu\\\">\");\n    pout.println (\"<menuseparator/>\");\n    menu.toXUL (pout);\n    pout.println (\"</popup>\");\n    pout.println (\"</overlay>\");\n    pout.flush ();\n    zout.closeEntry ();\n    InputStream png = XUL4Wikipedia.class.getResourceAsStream (\"32px-Wikipedia-logo.png\");\n    if (png == null) throw new IOException (\"Cannot get icon\");\n\n    entry = new ZipEntry (\"chrome/skin/wikipedia.png\");\n    zout.putNextEntry (entry);\n    IOUtils.copyTo (png, zout);\n    zout.closeEntry ();\n    zout.finish ();\n    zout.flush ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 8041989, "method2_id": 8805648, "code1": "@Override\nprotected void doGet (HttpServletRequest req, HttpServletResponse resp) throws ServletException {\n    String requestURI = req.getRequestURI ();\n    logger.info (\"The requested URI: {}\", requestURI);\n    String parameter = requestURI.substring (requestURI.lastIndexOf (ARXIVID_ENTRY) + ARXIVID_ENTRY_LENGTH);\n    int signIndex = parameter.indexOf (StringUtil.ARXIVID_SEGMENTID_DELIMITER);\n    String arxivId = signIndex != - 1 ? parameter.substring (0, signIndex) : parameter;\n    String segmentId = signIndex != - 1 ? parameter.substring (signIndex + 1) : null;\n    if (arxivId == null) {\n        logger.error (\"The request with an empty arxiv id parameter\");\n        return;\n    }\n    String filePath = segmentId == null ? format (\"/opt/mocassin/aux-pdf/%s\" + StringUtil.arxivid2filename (arxivId, \"pdf\")) : \"/opt/mocassin/pdf/\" + StringUtil.segmentid2filename (arxivId, Integer.parseInt (segmentId), \"pdf\");\n    if (! new File (filePath).exists ()) {\n        filePath = format (\"/opt/mocassin/aux-pdf/%s\", StringUtil.arxivid2filename (arxivId, \"pdf\"));\n    }\n    try {\n        FileInputStream fileInputStream = new FileInputStream (filePath);\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ();\n        IOUtils.copy (fileInputStream, byteArrayOutputStream);\n        resp.setContentType (\"application/pdf\");\n        resp.setHeader (\"Content-disposition\", String.format (\"attachment; filename=%s\", StringUtil.arxivid2filename (arxivId, \"pdf\")));\n        ServletOutputStream outputStream = resp.getOutputStream ();\n        outputStream.write (byteArrayOutputStream.toByteArray ());\n        outputStream.close ();\n    } catch (FileNotFoundException e) {\n        logger.error (\"Error while downloading: PDF file= '{}' not found\", filePath);\n    } catch (IOException e) {\n        logger.error (\"Error while downloading the PDF file\", e);\n    }\n}\n", "code2": "public String stringOfUrl (String addr) throws IOException {\n    ByteArrayOutputStream output = new ByteArrayOutputStream ();\n    URL url = new URL (addr);\n    IOUtils.copy (url.openStream (), output);\n    return output.toString ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10140299, "method2_id": 19869683, "code1": "protected static byte [] hashPassword (byte [] saltBytes, String plaintextPassword) throws AssertionError {\n    MessageDigest digest;\n    try {\n        digest = MessageDigest.getInstance (\"MD5\");\n    } catch (NoSuchAlgorithmException ex) {\n        throw (AssertionError) new AssertionError (\"No MD5 message digest supported.\").initCause (ex);\n    }\n    digest.update (saltBytes);\n    try {\n        digest.update (plaintextPassword.getBytes (\"utf-8\"));\n    } catch (UnsupportedEncodingException ex) {\n        throw (AssertionError) new AssertionError (\"No UTF-8 encoding supported.\").initCause (ex);\n    }\n    byte [] passwordBytes = digest.digest ();\n    return passwordBytes;\n}\n", "code2": "public static String MD5 (byte [] data) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    String text = convertToHex (data);\n    MessageDigest md;\n    md = MessageDigest.getInstance (\"MD5\");\n    byte [] md5hash = new byte [32];\n    md.update (text.getBytes (\"iso-8859-1\"), 0, text.length ());\n    md5hash = md.digest ();\n    return convertToHex (md5hash);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4591683, "method2_id": 12626917, "code1": "public static void copyFile (File source, File dest) throws IOException {\n    if (source.equals (dest)) throw new IOException (\"Source and destination cannot be the same file path\");\n\n    FileChannel srcChannel = new FileInputStream (source).getChannel ();\n    if (! dest.exists ()) dest.createNewFile ();\n\n    FileChannel dstChannel = new FileOutputStream (dest).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n", "code2": "public void xtestURL1 () throws Exception {\n    URL url = new URL (IOTest.URL);\n    InputStream inputStream = url.openStream ();\n    OutputStream outputStream = new FileOutputStream (\"C:/Temp/testURL1.mp4\");\n    IOUtils.copy (inputStream, outputStream);\n    inputStream.close ();\n    outputStream.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 232887, "method2_id": 634361, "code1": "public static void main (String args []) throws Exception {\n    Class c = Class.forName (\"tClass\");\n    System.out.println (c);\n    try {\n        Class c_not_found = Class.forName (\"NotAClassSoThrowAnExceptionPlease\");\n    } catch (ClassNotFoundException e) {\n        System.out.println (\"caught ClassNotFoundException\");\n    }\n    if (c.isArray ()) System.out.println (c + \" is an array????\");\n    else System.out.println (c + \" is not an array...good\");\n\n    Constructor ctors [] = c.getConstructors ();\n    Arrays.sort (ctors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + ctors.length + \" visible constructors\");\n    for (int i = 0;\n    i < ctors.length; ++ i) System.out.println (\"   \" + i + \": \" + ctors [i]);\n\n    Constructor declaredCtors [] = c.getDeclaredConstructors ();\n    Arrays.sort (declaredCtors, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has \" + declaredCtors.length + \" declared constructors\");\n    for (int i = 0;\n    i < declaredCtors.length; ++ i) System.out.println (\"   \" + i + \": \" + declaredCtors [i]);\n\n    Method methods [] = c.getMethods ();\n    Method hello = null;\n    Method iello = null;\n    Method lello = null;\n    Method jello = null;\n    Method vello = null;\n    Method declaredMethods [] = c.getDeclaredMethods ();\n    Arrays.sort (declaredMethods, new Comparator () {\n        public int compare (Object x, Object y) {\n            return x.toString ().compareTo (y.toString ());\n        }}\n\n    );\n    System.out.println (c + \" has a total number of methods: \" + methods.length);\n    for (int i = 0;\n    i < methods.length; i ++) {\n        if (methods [i].getName ().equals (\"hello\")) hello = methods [i];\n\n        if (methods [i].getName ().equals (\"iello\")) iello = methods [i];\n\n        if (methods [i].getName ().equals (\"lello\")) lello = methods [i];\n\n        if (methods [i].getName ().equals (\"jello\")) jello = methods [i];\n\n        if (methods [i].getName ().equals (\"vello\")) vello = methods [i];\n\n    }\n    System.out.println (\" Number of declared methods: \" + declaredMethods.length);\n    for (int i = 0;\n    i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);\n\n    if (hello == null) {\n        System.out.println (\"tClass.hello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + hello);\n    }\n    int n_calls = 3;\n    while (n_calls -- > 0) {\n        String hello_args [] = {\"I Say Hello to You!\"};\n        String result = (String) hello.invoke (null, hello_args);\n        System.out.println (result);\n    }\n    if (iello == null) {\n        System.out.println (\"tClass.iello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + iello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object iello_args [] = {\"I Say Iello to You!\", new Integer (99)};\n        Integer result = (Integer) iello.invoke (null, iello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (lello == null) {\n        System.out.println (\"tClass.lello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + lello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object lello_args [] = {\"I Say Lello to You!\", new Long (99)};\n        Long result = (Long) lello.invoke (null, lello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    if (jello == null) {\n        System.out.println (\"tClass.jello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + jello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        Object jello_args [] = {new Integer (99), \"I Say Jello to You!\", new Integer (95), new Integer (94)};\n        Integer result = (Integer) jello.invoke (null, jello_args);\n        System.out.println (\"Does this>\" + result + \"< look like 99?\");\n    }\n    tClass tc = new tClass (\"Hi!\");\n    String initargs [] = {\"I'm dynamic!\"};\n    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);\n    if (vello == null) {\n        System.out.println (\"tClass.vello not found!\");\n        System.exit (1);\n    } else {\n        System.out.println (\"================= READY TO CALL: \" + vello);\n    }\n    n_calls = 3;\n    while (n_calls -- > 0) {\n        String vello_args [] = {\"I Say Vello to You!\"};\n        String result = (String) vello.invoke (tc_dyn, vello_args);\n        System.out.println (result);\n    }\n}\n", "code2": "public void createPalette () {\n    try {\n        String paletteName = demo.getString (getResourceName () + \".palette\");\n        Class paletteClass = Class.forName (paletteName);\n        Constructor paletteConstructor = paletteClass.getConstructor (new Class [] {CGDesktop.class});\n        Object [] args = new Object [] {this};\n        palette = (CGPalette) paletteConstructor.newInstance (args);\n        palette.setLocation (PALETTE_X, PALETTE_Y);\n        palette.show ();\n        add (palette, PALETTE_LAYER);\n    } catch (Exception ex) {\n        getDemo ().setStatus (\"Cannot create palette: \" + ex);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4337044, "method2_id": 5950082, "code1": "public void add (String name, InputStream is, String password) throws IOException, UnsupportedEncodingException {\n    encrypter.init (password, 256);\n    ByteArrayOutputStream bos = new ByteArrayOutputStream ();\n    DeflaterOutputStream dos = new DeflaterOutputStream (bos, new Deflater (9, true), 8 * 1024);\n    int read = 0;\n    long inputLen = 0;\n    byte [] buf = new byte [8 * 1024];\n    while ((read = is.read (buf)) > 0) {\n        inputLen += read;\n        dos.write (buf, 0, read);\n    }\n    dos.close ();\n    byte [] data = bos.toByteArray ();\n    ExtZipEntry entry = new ExtZipEntry (name);\n    entry.setMethod (ZipEntry.DEFLATED);\n    entry.setSize (inputLen);\n    entry.setCompressedSize (data.length + 28);\n    entry.setTime ((new java.util.Date ()).getTime ());\n    entry.initEncryptedEntry ();\n    zipOS.putNextEntry (entry);\n    zipOS.writeBytes (encrypter.getSalt ());\n    zipOS.writeBytes (encrypter.getPwVerification ());\n    encrypter.encrypt (data, data.length);\n    zipOS.writeBytes (data, 0, data.length);\n    byte [] finalAuthentication = encrypter.getFinalAuthentication ();\n    if (LOG.isLoggable (Level.FINE)) {\n        LOG.fine (\"finalAuthentication=\" + Arrays.toString (finalAuthentication) + \" at pos=\" + zipOS.getWritten ());\n    }\n    zipOS.writeBytes (finalAuthentication);\n}\n", "code2": "private static void compress (ZipOutputStream zos, String rootpath, File source) throws IOException {\n    if (source.isFile ()) {\n        ZipEntry zipEntry = new ZipEntry (source.getName ());\n        zos.putNextEntry (zipEntry);\n        FileInputStream fis = new FileInputStream (source);\n        byte [] buffer = new byte [1024];\n        for (int length;\n        (length = fis.read (buffer)) > 0;) {\n            zos.write (buffer, 0, length);\n        }\n        fis.close ();\n        zos.closeEntry ();\n    } else if (source.isDirectory ()) {\n        File [] files = source.listFiles ();\n        for (File file : files) {\n            compress (zos, rootpath, file);\n        }\n    }\n\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3945057, "method2_id": 8209783, "code1": "private boolean streamDownload (URL url, File file) {\n    try {\n        InputStream in = url.openConnection ().getInputStream ();\n        BufferedInputStream bis = new BufferedInputStream (in);\n        OutputStream out = new FileOutputStream (file);\n        BufferedOutputStream bos = new BufferedOutputStream (out);\n        int chunkSize = 63 * 1024;\n        byte [] ba = new byte [chunkSize];\n        while (true) {\n            int bytesRead = readBlocking (bis, ba, 0, chunkSize);\n            if (bytesRead > 0) {\n                if (bos != null) bos.write (ba, 0, bytesRead);\n\n            } else {\n                bos.close ();\n                break;\n            }\n        }\n    } catch (IOException e) {\n        System.out.println (\"Error writing file \" + file);\n        return false;\n    }\n    System.out.println (\"OK writing file \" + file);\n    return true;\n}\n", "code2": "List < String > HttpGet (URL url) throws IOException {\n    List < String > responseList = new ArrayList < String > ();\n    Logger.getInstance ().logInfo (\"HTTP GET: \" + url, null, null);\n    URLConnection con = url.openConnection ();\n    con.setAllowUserInteraction (false);\n    BufferedReader in = new BufferedReader (new InputStreamReader (con.getInputStream ()));\n    String inputLine;\n    while ((inputLine = in.readLine ()) != null) responseList.add (inputLine);\n\n    in.close ();\n    return responseList;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2602105, "method2_id": 4147982, "code1": "public void dumpToFile (File file) throws IOException {\n    OutputStream out = new FileOutputStream (file);\n    if (contentStream != null) {\n        IOUtils.copy (contentStream, out);\n        setPath (file.getAbsolutePath ());\n    } else {\n        IOUtils.write (getContent (), out);\n    }\n    IOUtils.closeQuietly (out);\n}\n", "code2": "public static void fixEol (File fin) throws IOException {\n    File fout = File.createTempFile (fin.getName (), \".fixEol\", fin.getParentFile ());\n    FileChannel in = new FileInputStream (fin).getChannel ();\n    if (0 != in.size ()) {\n        FileChannel out = new FileOutputStream (fout).getChannel ();\n        byte [] eol = AStringUtilities.systemNewLine.getBytes ();\n        ByteBuffer bufOut = ByteBuffer.allocateDirect (1024 * eol.length);\n        boolean previousIsCr = false;\n        ByteBuffer buf = ByteBuffer.allocateDirect (1024);\n        while (in.read (buf) > 0) {\n            buf.limit (buf.position ());\n            buf.position (0);\n            while (buf.remaining () > 0) {\n                byte b = buf.get ();\n                if (b == '\\r') {\n                    previousIsCr = true;\n                    bufOut.put (eol);\n                } else {\n                    if (b == '\\n') {\n                        if (! previousIsCr) bufOut.put (eol);\n\n                    } else bufOut.put (b);\n\n                    previousIsCr = false;\n                }\n            }\n            bufOut.limit (bufOut.position ());\n            bufOut.position (0);\n            out.write (bufOut);\n            bufOut.clear ();\n            buf.clear ();\n        }\n        out.close ();\n    }\n    in.close ();\n    fin.delete ();\n    fout.renameTo (fin);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1597544, "method2_id": 2081254, "code1": "public void handleRequest (XletState desiredState) {\n    XletState targetState = currentState;\n    synchronized (stateGuard) {\n        try {\n            if (desiredState == XletState.LOADED) {\n                if (currentState != XletState.UNLOADED) return;\n\n                targetState = XletState.LOADED;\n                Constructor m = xletClass.getConstructor (new Class [0]);\n                xlet = (Xlet) m.newInstance (new Object [0]);\n            } else if (desiredState == DesiredXletState.INITIALIZE) {\n                if (currentState != XletState.LOADED) return;\n\n                targetState = XletState.PAUSED;\n                try {\n                    xlet.initXlet (context);\n                } catch (XletStateChangeException xsce) {\n                    targetState = XletState.DESTROYED;\n                    xlet.destroyXlet (true);\n                }\n            } else if (desiredState == XletState.ACTIVE) {\n                if (currentState != XletState.PAUSED) return;\n\n                targetState = XletState.ACTIVE;\n                try {\n                    xlet.startXlet ();\n                } catch (XletStateChangeException xsce) {\n                    targetState = currentState;\n                }\n            } else if (desiredState == XletState.PAUSED) {\n                if (currentState != XletState.ACTIVE) return;\n\n                targetState = XletState.PAUSED;\n                xlet.pauseXlet ();\n            } else if (desiredState == DesiredXletState.CONDITIONAL_DESTROY) {\n                if (currentState == XletState.DESTROYED) return;\n\n                targetState = XletState.DESTROYED;\n                try {\n                    xlet.destroyXlet (false);\n                } catch (XletStateChangeException xsce) {\n                    targetState = currentState;\n                }\n            } else if (desiredState == XletState.DESTROYED) {\n                targetState = XletState.DESTROYED;\n                if (currentState == XletState.DESTROYED) return;\n\n                try {\n                    xlet.destroyXlet (true);\n                } catch (XletStateChangeException xsce) {\n                }\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace ();\n            if (targetState != XletState.DESTROYED) {\n                handleRequest (XletState.DESTROYED);\n            }\n        }\n        setState (targetState);\n    }\n}\n", "code2": "public Object run () throws Exception {\n    ClassLoader cl = Thread.currentThread ().getContextClassLoader ();\n    Class c = Class.forName (\"com.ericdaugherty.mail.server.auth.GSSServerMode\", true, cl);\n    Object instance = c.getConstructor (Boolean.class, String.class).newInstance (new Boolean (isSMTP), clientIp);\n    java.lang.reflect.Method mainMethod = c.getMethod (\"negotiateGSSAuthenticationContext\");\n    mainMethod.invoke (instance);\n    return instance;\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 4441118, "method2_id": 10943077, "code1": "private void chopFileDisk () throws IOException {\n    File tempFile = new File (\"\" + logFile + \".tmp\");\n    BufferedInputStream bis = null;\n    BufferedOutputStream bos = null;\n    long startCopyPos;\n    byte readBuffer [] = new byte [2048];\n    int readCount;\n    long totalBytesRead = 0;\n    if (reductionRatio > 0 && logFile.length () > 0) {\n        startCopyPos = logFile.length () / reductionRatio;\n    } else {\n        startCopyPos = 0;\n    }\n    try {\n        bis = new BufferedInputStream (new FileInputStream (logFile));\n        bos = new BufferedOutputStream (new FileOutputStream (tempFile));\n        do {\n            readCount = bis.read (readBuffer, 0, readBuffer.length);\n            if (readCount > 0) {\n                totalBytesRead += readCount;\n                if (totalBytesRead > startCopyPos) {\n                    bos.write (readBuffer, 0, readCount);\n                }\n            }\n        } while (readCount > 0);\n    } finally {\n        if (bos != null) {\n            try {\n                bos.close ();\n            } catch (IOException ex) {\n            }\n        }\n        if (bis != null) {\n            try {\n                bis.close ();\n            } catch (IOException ex) {\n            }\n        }\n    }\n    if (tempFile.isFile ()) {\n        if (! logFile.delete ()) {\n            throw new IOException (\"Error when attempting to delete the \" + logFile + \" file.\");\n        }\n        if (! tempFile.renameTo (logFile)) {\n            throw new IOException (\"Error when renaming the \" + tempFile + \" to \" + logFile + \".\");\n        }\n    }\n}\n", "code2": "private void copy (File fromFile, File toFile) throws IOException {\n    String fromFileName = fromFile.getName ();\n    File tmpFile = new File (fromFileName);\n    String toFileName = toFile.getName ();\n    if (! tmpFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! tmpFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! tmpFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (tmpFile);\n        File toF = new File (toFile.getCanonicalPath ());\n        if (! toF.exists ());\n\n        toF.createNewFile ();\n        if (! SBCMain.DEBUG_MODE) to = new FileOutputStream (toFile);\n        else to = new FileOutputStream (toF);\n\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 12693284, "method2_id": 13666876, "code1": "public static void copyFromInputStreamToOutputStream (InputStream in, OutputStream out) throws IOException {\n    IOUtils.copy (in, out);\n}\n", "code2": "@Override\npublic String transformSingleFile (X3DEditorSupport.X3dEditor xed) {\n    Node [] node = xed.getActivatedNodes ();\n    X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport ().getDataObject ();\n    FileObject mySrc = dob.getPrimaryFile ();\n    File mySrcF = FileUtil.toFile (mySrc);\n    File myOutF = new File (mySrcF.getParentFile (), mySrc.getName () + \".x3dv.gz\");\n    TransformListener co = TransformListener.getInstance ();\n    co.message (NbBundle.getMessage (getClass (), \"Gzip_compression_starting\"));\n    co.message (NbBundle.getMessage (getClass (), \"Saving_as_\") + myOutF.getAbsolutePath ());\n    co.moveToFront ();\n    co.setNode (node [0]);\n    try {\n        String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile (xed);\n        FileInputStream fis = new FileInputStream (new File (x3dvFile));\n        GZIPOutputStream gzos = new GZIPOutputStream (new FileOutputStream (myOutF));\n        byte [] buf = new byte [4096];\n        int ret;\n        while ((ret = fis.read (buf)) > 0) gzos.write (buf, 0, ret);\n\n        gzos.close ();\n    } catch (Exception ex) {\n        co.message (NbBundle.getMessage (getClass (), \"Exception:__\") + ex.getLocalizedMessage ());\n        return null;\n    }\n    co.message (NbBundle.getMessage (getClass (), \"Gzip_compression_complete\"));\n    return myOutF.getAbsolutePath ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 18318816, "method2_id": 21803552, "code1": "public static void invokeMvnArtifact (final IProject project, final IModuleExtension moduleExtension, final String location) throws CoreException, InterruptedException, IOException {\n    final Properties properties = new Properties ();\n    properties.put (\"archetypeGroupId\", \"org.nexopenframework.plugins\");\n    properties.put (\"archetypeArtifactId\", \"openfrwk-archetype-webmodule\");\n    final String version = org.maven.ide.eclipse.ext.Maven2Plugin.getArchetypeVersion ();\n    properties.put (\"archetypeVersion\", version);\n    properties.put (\"artifactId\", moduleExtension.getArtifact ());\n    properties.put (\"groupId\", moduleExtension.getGroup ());\n    properties.put (\"version\", moduleExtension.getVersion ());\n    final ILaunchManager launchManager = DebugPlugin.getDefault ().getLaunchManager ();\n    final ILaunchConfigurationType launchConfigurationType = launchManager.getLaunchConfigurationType (LAUNCH_CONFIGURATION_TYPE_ID);\n    final ILaunchConfigurationWorkingCopy workingCopy = launchConfigurationType.newInstance (null, \"Creating WEB module using Apache Maven archetype\");\n    File archetypePomDirectory = getDefaultArchetypePomDirectory ();\n    try {\n        final String dfPom = getPomFile (moduleExtension.getGroup (), moduleExtension.getArtifact ());\n        final ByteArrayInputStream bais = new ByteArrayInputStream (dfPom.getBytes ());\n        final File f = new File (archetypePomDirectory, \"pom.xml\");\n        OutputStream fous = null;\n        try {\n            fous = new FileOutputStream (f);\n            IOUtils.copy (bais, fous);\n        } finally {\n            try {\n                if (fous != null) {\n                    fous.close ();\n                }\n                if (bais != null) {\n                    bais.close ();\n                }\n            } catch (final IOException e) {\n            }\n        }\n        String goalName = \"archetype:create\";\n        boolean offline = false;\n        try {\n            final Class clazz = Thread.currentThread ().getContextClassLoader ().loadClass (\"org.maven.ide.eclipse.Maven2Plugin\");\n            final Maven2Plugin plugin = (Maven2Plugin) clazz.getMethod (\"getDefault\", new Class [0]).invoke (null, new Object [0]);\n            offline = plugin.getPreferenceStore ().getBoolean (\"eclipse.m2.offline\");\n        } catch (final ClassNotFoundException e) {\n            Logger.logException (\"No class [org.maven.ide.eclipse.ext.Maven2Plugin] in classpath\", e);\n        } catch (final NoSuchMethodException e) {\n            Logger.logException (\"No method getDefault\", e);\n        } catch (final Throwable e) {\n            Logger.logException (e);\n        }\n        if (offline) {\n            goalName = new StringBuffer (goalName).append (\" -o\").toString ();\n        }\n        if (! offline) {\n            final IPreferenceStore ps = Maven2Plugin.getDefault ().getPreferenceStore ();\n            final String repositories = ps.getString (Maven2PreferenceConstants.P_M2_REPOSITORIES);\n            final String [] repos = repositories.split (org.maven.ide.eclipse.ext.Maven2Plugin.REPO_SEPARATOR);\n            final StringBuffer sbRepos = new StringBuffer ();\n            for (int k = 0;\n            k < repos.length; k ++) {\n                sbRepos.append (repos [k]);\n                if (k != repos.length - 1) {\n                    sbRepos.append (\",\");\n                }\n            }\n            properties.put (\"remoteRepositories\", sbRepos.toString ());\n        }\n        workingCopy.setAttribute (ATTR_GOALS, goalName);\n        workingCopy.setAttribute (ATTR_POM_DIR, archetypePomDirectory.getAbsolutePath ());\n        workingCopy.setAttribute (ATTR_PROPERTIES, convertPropertiesToList (properties));\n        final long timeout = org.maven.ide.eclipse.ext.Maven2Plugin.getTimeout ();\n        TimeoutLaunchConfiguration.launchWithTimeout (new NullProgressMonitor (), workingCopy, project, timeout);\n        FileUtils.copyDirectoryStructure (new File (archetypePomDirectory, project.getName ()), new File (location));\n        FileUtils.deleteDirectory (new File (location + \"/src\"));\n        FileUtils.forceDelete (new File (location, \"pom.xml\"));\n        project.refreshLocal (IResource.DEPTH_INFINITE, null);\n    } finally {\n        FileUtils.deleteDirectory (archetypePomDirectory);\n        Logger.log (Logger.INFO, \"Invoked removing of archetype POM directory\");\n    }\n}\n", "code2": "public void doRender () throws IOException {\n    File file = new File (fileName);\n    if (! file.exists ()) {\n        logger.error (\"Static resource not found: \" + fileName);\n        isNotFound = true;\n        return;\n    }\n    if (fileName.endsWith (\"xml\") || fileName.endsWith (\"asp\")) servletResponse.setContentType (\"text/xml\");\n    else if (fileName.endsWith (\"css\")) servletResponse.setContentType (\"text/css\");\n    else if (fileName.endsWith (\"js\")) servletResponse.setContentType (\"text/javascript\");\n\n    InputStream in = null;\n    try {\n        in = new FileInputStream (file);\n        IOUtils.copy (in, servletResponse.getOutputStream ());\n        logger.debug (\"Static resource rendered: \".concat (fileName));\n    } catch (FileNotFoundException e) {\n        logger.error (\"Static resource not found: \" + fileName);\n        isNotFound = true;\n    } finally {\n        IOUtils.closeQuietly (in);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 9265781, "method2_id": 19409751, "code1": "public static void copy (String from_name, String to_name) throws IOException {\n    File from_file = new File (from_name);\n    File to_file = new File (to_name);\n    if (! from_file.exists ()) abort (\"FileCopy: no such source file: \" + from_name);\n\n    if (! from_file.isFile ()) abort (\"FileCopy: can't copy directory: \" + from_name);\n\n    if (! from_file.canRead ()) abort (\"FileCopy: source file is unreadable: \" + from_name);\n\n    if (to_file.isDirectory ()) to_file = new File (to_file, from_file.getName ());\n\n    if (to_file.exists ()) {\n        if (! to_file.canWrite ()) abort (\"FileCopy: destination file is unwriteable: \" + to_name);\n\n    } else {\n        String parent = to_file.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) abort (\"FileCopy: destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) abort (\"FileCopy: destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) abort (\"FileCopy: destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (from_file);\n        to = new FileOutputStream (to_file);\n        byte [] buffer = new byte [4096];\n        int bytes_read;\n        while ((bytes_read = from.read (buffer)) != - 1) to.write (buffer, 0, bytes_read);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n", "code2": "public static void compress (final File zip, final Map < InputStream, String > entries) throws IOException {\n    if (zip == null || entries == null || CollectionUtils.isEmpty (entries.keySet ())) throw new IllegalArgumentException (\"One ore more parameters are empty!\");\n\n    if (zip.exists ()) zip.delete ();\n    else if (! zip.getParentFile ().exists ()) zip.getParentFile ().mkdirs ();\n\n    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (zip)));\n    out.setLevel (Deflater.BEST_COMPRESSION);\n    InputStream in = null;\n    try {\n        for (InputStream inputStream : entries.keySet ()) {\n            in = inputStream;\n            ZipEntry zipEntry = new ZipEntry (skipBeginningSlash (entries.get (in)));\n            out.putNextEntry (zipEntry);\n            IOUtils.copy (in, out);\n            out.closeEntry ();\n            in.close ();\n        }\n    } finally {\n        IOUtils.closeQuietly (in);\n        IOUtils.closeQuietly (out);\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 536614, "method2_id": 11484416, "code1": "private static void readAndRewrite (File inFile, File outFile) throws IOException {\n    ImageInputStream iis = ImageIO.createImageInputStream (new BufferedInputStream (new FileInputStream (inFile)));\n    DcmParser dcmParser = DcmParserFactory.getInstance ().newDcmParser (iis);\n    Dataset ds = DcmObjectFactory.getInstance ().newDataset ();\n    dcmParser.setDcmHandler (ds.getDcmHandler ());\n    dcmParser.parseDcmFile (null, Tags.PixelData);\n    PixelDataReader pdReader = pdFact.newReader (ds, iis, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    System.out.println (\"reading \" + inFile + \"...\");\n    pdReader.readPixelData (false);\n    ImageOutputStream out = ImageIO.createImageOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));\n    DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n    ds.writeDataset (out, dcmEncParam);\n    ds.writeHeader (out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR (), dcmParser.getReadLength ());\n    System.out.println (\"writing \" + outFile + \"...\");\n    PixelDataWriter pdWriter = pdFact.newWriter (pdReader.getPixelDataArray (), false, ds, out, dcmParser.getDcmDecodeParam ().byteOrder, dcmParser.getReadVR ());\n    pdWriter.writePixelData ();\n    out.flush ();\n    out.close ();\n    System.out.println (\"done!\");\n}\n", "code2": "private void moveFile (File orig, File target) throws IOException {\n    byte buffer [] = new byte [1000];\n    int bread = 0;\n    FileInputStream fis = new FileInputStream (orig);\n    FileOutputStream fos = new FileOutputStream (target);\n    while (bread != - 1) {\n        bread = fis.read (buffer);\n        if (bread != - 1) fos.write (buffer, 0, bread);\n\n    }\n    fis.close ();\n    fos.close ();\n    orig.delete ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 762814, "method2_id": 10118200, "code1": "public static void zipFile (String file, String entry) throws IOException {\n    FileInputStream in = new FileInputStream (file);\n    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (file + \".zip\"));\n    out.putNextEntry (new ZipEntry (entry));\n    byte [] buffer = new byte [4096];\n    int bytes_read;\n    while ((bytes_read = in.read (buffer)) != - 1) out.write (buffer, 0, bytes_read);\n\n    in.close ();\n    out.closeEntry ();\n    out.close ();\n    File fin = new File (file);\n    fin.delete ();\n}\n", "code2": "public static final boolean zipExtract (String zipfile, String name, String dest) {\n    boolean f = false;\n    try {\n        InputStream in = new BufferedInputStream (new FileInputStream (zipfile));\n        ZipInputStream zin = new ZipInputStream (in);\n        ZipEntry e;\n        while ((e = zin.getNextEntry ()) != null) {\n            if (e.getName ().equals (name)) {\n                FileOutputStream out = new FileOutputStream (dest);\n                byte b [] = new byte [TEMP_FILE_BUFFER_SIZE];\n                int len = 0;\n                while ((len = zin.read (b)) != - 1) out.write (b, 0, len);\n\n                out.close ();\n                f = true;\n                break;\n            }\n        }\n        zin.close ();\n    } catch (FileNotFoundException e) {\n        MLUtil.runtimeError (e, \"extractZip \" + zipfile + \" \" + name);\n    } catch (IOException e) {\n        MLUtil.runtimeError (e, \"extractZip \" + zipfile + \" \" + name);\n    }\n    return (f);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 19631892, "method2_id": 22821011, "code1": "public static void copyFiles (File src, File dest) throws IOException {\n    if (src.isDirectory ()) {\n        dest.mkdirs ();\n        for (String f : src.list ()) {\n            String df = dest.getPath () + File.separator + f;\n            String sf = src.getPath () + File.separator + f;\n            copyFiles (new File (sf), new File (df));\n        }\n    } else {\n        FileInputStream fin = new FileInputStream (src);\n        FileOutputStream fout = new FileOutputStream (dest);\n        int c;\n        while ((c = fin.read ()) >= 0) fout.write (c);\n\n        fin.close ();\n        fout.close ();\n    }\n}\n", "code2": "public static void main (String [] args) {\n    String command = \"java -jar  \";\n    String linkerJarPath = \"\";\n    String path = \"\";\n    String osName = System.getProperty (\"os.name\");\n    String temp = Launcher.class.getResource (\"\").toString ();\n    int index = temp.indexOf (\".jar\");\n    int start = index - 1;\n    while (Character.isLetter (temp.charAt (start))) {\n        start --;\n    }\n    String jarName = temp.substring (start + 1, index + 4);\n    System.out.println (jarName);\n    if (osName.startsWith (\"Linux\")) {\n        temp = temp.substring (temp.indexOf (\"/\"), temp.indexOf (jarName));\n    } else if (osName.startsWith (\"Windows\")) {\n        temp = temp.substring (temp.indexOf (\"file:\") + 5, temp.indexOf (jarName));\n    } else {\n        System.exit (0);\n    }\n\n    path = path + temp;\n    try {\n        path = java.net.URLDecoder.decode (path, \"utf-8\");\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace ();\n    }\n    File dir = new File (path);\n    File [] files = dir.listFiles ();\n    String exeJarName = null;\n    for (File f : files) {\n        if (f.getName ().endsWith (\".jar\") && ! f.getName ().startsWith (jarName)) {\n            exeJarName = f.getName ();\n            break;\n        }\n    }\n    if (exeJarName == null) {\n        System.out.println (\"no exefile\");\n        System.exit (0);\n    }\n    linkerJarPath = path + exeJarName;\n    String pluginDirPath = path + \"plugin\" + File.separator;\n    File [] plugins = new File (pluginDirPath).listFiles ();\n    StringBuffer pluginNames = new StringBuffer (\"\");\n    for (File plugin : plugins) {\n        if (plugin.getAbsolutePath ().endsWith (\".jar\")) {\n            pluginNames.append (\"plugin/\" + plugin.getName () + \" \");\n        }\n    }\n    String libDirPath = path + \"lib\" + File.separator;\n    File [] libs = new File (libDirPath).listFiles ();\n    StringBuffer libNames = new StringBuffer (\"\");\n    for (File lib : libs) {\n        if (lib.getAbsolutePath ().endsWith (\".jar\")) {\n            libNames.append (\"lib/\" + lib.getName () + \" \");\n        }\n    }\n    try {\n        JarFile jarFile = new JarFile (linkerJarPath);\n        Manifest manifest = jarFile.getManifest ();\n        if (manifest == null) {\n            manifest = new Manifest ();\n        }\n        Attributes attributes = manifest.getMainAttributes ();\n        attributes.putValue (\"Class-Path\", pluginNames.toString () + libNames.toString ());\n        String backupFile = linkerJarPath + \"back\";\n        FileInputStream copyInput = new FileInputStream (linkerJarPath);\n        FileOutputStream copyOutput = new FileOutputStream (backupFile);\n        byte [] buffer = new byte [4096];\n        int s;\n        while ((s = copyInput.read (buffer)) > - 1) {\n            copyOutput.write (buffer, 0, s);\n        }\n        copyOutput.flush ();\n        copyOutput.close ();\n        copyInput.close ();\n        JarOutputStream jarOut = new JarOutputStream (new FileOutputStream (linkerJarPath), manifest);\n        JarInputStream jarIn = new JarInputStream (new FileInputStream (backupFile));\n        byte [] buf = new byte [4096];\n        JarEntry entry;\n        while ((entry = jarIn.getNextJarEntry ()) != null) {\n            if (\"META-INF/MANIFEST.MF\".equals (entry.getName ())) continue;\n\n            jarOut.putNextEntry (entry);\n            int read;\n            while ((read = jarIn.read (buf)) != - 1) {\n                jarOut.write (buf, 0, read);\n            }\n            jarOut.closeEntry ();\n        }\n        jarOut.flush ();\n        jarOut.close ();\n        jarIn.close ();\n        File file = new File (backupFile);\n        if (file.exists ()) {\n            file.delete ();\n        }\n    } catch (IOException e1) {\n        e1.printStackTrace ();\n    }\n    try {\n        if (System.getProperty (\"os.name\").startsWith (\"Linux\")) {\n            Runtime runtime = Runtime.getRuntime ();\n            String [] commands = new String [] {\"java\", \"-jar\", path + exeJarName};\n            runtime.exec (commands);\n        } else {\n            path = path.substring (1);\n            command = command + \"\\\"\" + path + exeJarName + \"\\\"\";\n            System.out.println (command);\n            Runtime.getRuntime ().exec (command);\n        }\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2746011, "method2_id": 9552054, "code1": "@RequestMapping(value=\"/privatefiles/{file_name}\")\npublic void getFile (@PathVariable(\"file_name\")\nString fileName, HttpServletResponse response, Principal principal) {\n    try {\n        Boolean validUser = false;\n        final String currentUser = principal.getName ();\n        Authentication auth = SecurityContextHolder.getContext ().getAuthentication ();\n        if (! auth.getPrincipal ().equals (new String (\"anonymousUser\"))) {\n            MetabolightsUser metabolightsUser = (MetabolightsUser) auth.getPrincipal ();\n            if (metabolightsUser != null && metabolightsUser.isCurator ()) validUser = true;\n\n        }\n        if (currentUser != null) {\n            Study study = studyService.getBiiStudy (fileName, true);\n            Collection < User > users = study.getUsers ();\n            Iterator < User > iter = users.iterator ();\n            while (iter.hasNext ()) {\n                User user = iter.next ();\n                if (user.getUserName ().equals (currentUser)) {\n                    validUser = true;\n                    break;\n                }\n            }\n        }\n        if (! validUser) throw new RuntimeException (PropertyLookup.getMessage (\"Entry.notAuthorised\"));\n\n        try {\n            InputStream is = new FileInputStream (privateFtpDirectory + fileName + \".zip\");\n            response.setContentType (\"application/zip\");\n            IOUtils.copy (is, response.getOutputStream ());\n        } catch (Exception e) {\n            throw new RuntimeException (PropertyLookup.getMessage (\"Entry.fileMissing\"));\n        }\n        response.flushBuffer ();\n    } catch (IOException ex) {\n        logger.info (\"Error writing file to output stream. Filename was '\" + fileName + \"'\");\n        throw new RuntimeException (\"IOError writing file to output stream\");\n    }\n}\n", "code2": "public static void copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) dir.mkdir ();\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 17477953, "method2_id": 23531658, "code1": "public static void createModelZip (String filename, String tempdir, boolean overwrite) throws Exception {\n    FileTools.checkOutput (filename, overwrite);\n    BufferedInputStream origin = null;\n    FileOutputStream dest = new FileOutputStream (filename);\n    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));\n    int BUFFER = 2048;\n    byte data [] = new byte [BUFFER];\n    File f = new File (tempdir);\n    for (File fs : f.listFiles ()) {\n        FileInputStream fi = new FileInputStream (fs.getAbsolutePath ());\n        origin = new BufferedInputStream (fi, BUFFER);\n        ZipEntry entry = new ZipEntry (fs.getName ());\n        out.putNextEntry (entry);\n        int count;\n        while ((count = origin.read (data, 0, BUFFER)) != - 1) out.write (data, 0, count);\n\n        out.closeEntry ();\n        origin.close ();\n    }\n    out.close ();\n}\n", "code2": "public void objectParserAssesmentItem (int file, int currentquestion, Resource resTemp) {\n    NodeList nl = null;\n    Node n = null;\n    NamedNodeMap nnp = null;\n    Node nsrc = null;\n    URL url = null;\n    String sFilename = \"\";\n    String sNewPath = \"\";\n    int indexLastSeparator;\n    String sOldPath = \"\";\n    try {\n        if (file == 1) {\n            nl = doc.getElementsByTagName (\"object\");\n        } else {\n            nl = doc_ [currentquestion].getElementsByTagName (\"object\");\n        }\n        for (int i = 0;\n        i < nl.getLength (); i ++) {\n            n = nl.item (i);\n            nnp = n.getAttributes ();\n            nsrc = nnp.getNamedItem (\"data\");\n            String sTemp = nsrc.getTextContent ();\n            url = new URL (\"file\", \"localhost\", sTemp);\n            sOldPath = url.getFile ();\n            sOldPath = sOldPath.replace ('/', File.separatorChar);\n            indexLastSeparator = sOldPath.lastIndexOf (File.separatorChar);\n            String sSourcePath = sOldPath;\n            sFilename = sOldPath.substring (indexLastSeparator + 1);\n            sNewPath = this.sTempLocation + sFilename;\n            FileChannel in = null;\n            FileChannel out = null;\n            try {\n                in = new FileInputStream (sSourcePath).getChannel ();\n                out = new FileOutputStream (sNewPath).getChannel ();\n                long size = in.size ();\n                MappedByteBuffer buf = in.map (FileChannel.MapMode.READ_ONLY, 0, size);\n                out.write (buf);\n            } finally {\n                if (in != null) in.close ();\n\n                if (out != null) out.close ();\n\n            }\n            if (file == 1) {\n                sXml = sXml.replace (nsrc.getTextContent (), sFilename);\n            } else {\n                sXml_ [currentquestion] = sXml_ [currentquestion].replace (nsrc.getTextContent (), sFilename);\n            }\n            lsImages.add (sFilename);\n            resTemp.addFile (sFilename);\n        }\n    } catch (MalformedURLException e) {\n        e.printStackTrace ();\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 572345, "method2_id": 880167, "code1": "public int runLoad (int requestId, int loadId, int server) throws RemoteException {\n    int ret = 0;\n    try {\n        Process P;\n        System.out.println (\"LINUX: \" + linuxPath + \"/Load1 \" + requestId);\n        System.out.println (\"java \" + linuxPath + \"/LoadId \" + requestId);\n        if (loadId == 1) P = Runtime.getRuntime ().exec (\"cr_run java LoadId \" + requestId);\n        else P = Runtime.getRuntime ().exec (\"cr_run java LoadId \" + requestId);\n\n        StringBuffer strBuf = new StringBuffer ();\n        String strLine = \"\";\n        String strLine1 = \"\";\n        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));\n        while ((strLine = outCommand.readLine ()) != null) {\n            strLine1 = strLine;\n        }\n        P.waitFor ();\n        return ret;\n    } catch (Exception e) {\n        e.printStackTrace ();\n        return - 1;\n    }\n}\n", "code2": "void run () throws Exception {\n    File javaHome = new File (System.getProperty (\"java.home\"));\n    if (javaHome.getName ().equals (\"jre\")) javaHome = javaHome.getParentFile ();\n\n    File javadoc = new File (new File (javaHome, \"bin\"), \"javadoc\");\n    File testSrc = new File (System.getProperty (\"test.src\"));\n    File testClasses = new File (System.getProperty (\"test.classes\"));\n    String thisClassName = TestUserDoclet.class.getName ();\n    Process p = new ProcessBuilder ().command (javadoc.getPath (), \"-J-Xbootclasspath:\" + System.getProperty (\"sun.boot.class.path\"), \"-doclet\", thisClassName, \"-docletpath\", testClasses.getPath (), new File (testSrc, thisClassName + \".java\").getPath ()).redirectErrorStream (true).start ();\n    int actualDocletWarnCount = 0;\n    int reportedDocletWarnCount = 0;\n    BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));\n    try {\n        String line;\n        while ((line = in.readLine ()) != null) {\n            System.err.println (line);\n            if (line.contains (docletWarning)) actualDocletWarnCount ++;\n\n            if (line.matches (\"[0-9]+ warning(s)?\")) reportedDocletWarnCount = Integer.valueOf (line.substring (0, line.indexOf (\" \")));\n\n        }\n    } finally {\n        in.close ();\n    }\n    int rc = p.waitFor ();\n    if (rc != 0) System.err.println (\"javadoc failed, rc:\" + rc);\n\n    int expectedDocletWarnCount = 1;\n    checkEqual (\"actual\", actualDocletWarnCount, \"expected\", expectedDocletWarnCount);\n    checkEqual (\"actual\", actualDocletWarnCount, \"reported\", reportedDocletWarnCount);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 11268952, "method2_id": 12448713, "code1": "public Vector split () {\n    File nextFile = new File (filename);\n    long fileSize = nextFile.length ();\n    long parts = fileSize / splitSize;\n    Vector vec = new Vector (new Long (parts).intValue ());\n    if (debug) {\n        System.out.println (\"File: \" + nextFile.getName () + \"\\nfileSize: \" + fileSize + \"\\nsplitSize: \" + splitSize + \"\\nparts: \" + parts);\n    }\n    if (fileSize % splitSize > 0) {\n        parts ++;\n    }\n    try {\n        FileInputStream fis = new FileInputStream (nextFile);\n        DataInputStream dis = new DataInputStream (fis);\n        long bytesRead = 0;\n        File destinationDirectory = new File (nextFile.getParent ());\n        if (! destinationDirectory.exists ()) {\n            destinationDirectory.mkdir ();\n        }\n        for (long k = 0;\n        k < parts; k ++) {\n            if (debug) {\n                System.out.println (\"Splitting parts: \" + nextFile.getName () + \" into part \" + k);\n            }\n            String filePartName = nextFile.getName ();\n            filePartName = filePartName + \".\" + String.valueOf (k);\n            File outputFile = new File (destinationDirectory, filePartName);\n            FileOutputStream fos = new FileOutputStream (outputFile);\n            DataOutputStream dos = new DataOutputStream (fos);\n            long bytesWritten = 0;\n            while ((bytesWritten < splitSize) && (bytesRead < fileSize)) {\n                dos.writeByte (dis.readByte ());\n                bytesRead ++;\n                bytesWritten ++;\n            }\n            dos.close ();\n            vec.addElement (outputFile.getAbsolutePath ());\n            if (debug) {\n                System.out.println (\"Wrote \" + bytesWritten + \" bytes.\" + outputFile.getName () + \" created.\");\n            }\n        }\n    } catch (FileNotFoundException fnfe) {\n        System.err.println (\"FileNotFoundException: \" + fnfe.getMessage ());\n        vec = null;\n    } catch (IOException ioe) {\n        System.err.println (\"IOException: \" + ioe.getMessage ());\n        vec = null;\n    }\n    return vec;\n}\n", "code2": "private void writeGif (String filename, String outputFile) throws IOException {\n    File file = new File (filename);\n    InputStream in = new FileInputStream (file);\n    FileOutputStream fout = new FileOutputStream (outputFile);\n    int totalRead = 0;\n    int readBytes = 0;\n    int blockSize = 65000;\n    long fileLen = file.length ();\n    byte b [] = new byte [blockSize];\n    while ((long) totalRead < fileLen) {\n        readBytes = in.read (b, 0, blockSize);\n        totalRead += readBytes;\n        fout.write (b, 0, readBytes);\n    }\n    in.close ();\n    fout.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 10195648, "method2_id": 10369570, "code1": "public static void main (String [] args) {\n    if (args.length != 3) {\n        System.out.println (\"Usage: HexStrToBin enc/dec <infileName> <outfilename>\");\n        System.exit (1);\n    }\n    try {\n        ByteArrayOutputStream os = new ByteArrayOutputStream ();\n        InputStream in = new FileInputStream (args [1]);\n        int len = 0;\n        byte buf [] = new byte [1024];\n        while ((len = in.read (buf)) > 0) os.write (buf, 0, len);\n\n        in.close ();\n        os.close ();\n        byte [] data = null;\n        if (args [0].equals (\"dec\")) data = decode (os.toString ());\n        else {\n            String strData = encode (os.toByteArray ());\n            data = strData.getBytes ();\n        }\n        FileOutputStream fos = new FileOutputStream (args [2]);\n        fos.write (data);\n        fos.close ();\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "public static void copy (String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File (fromFileName);\n    File toFile = new File (toFileName);\n    if (! fromFile.exists ()) throw new IOException (\"FileCopy: \" + \"no such source file: \" + fromFileName);\n\n    if (! fromFile.isFile ()) throw new IOException (\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n\n    if (! fromFile.canRead ()) throw new IOException (\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory ()) toFile = new File (toFile, fromFile.getName ());\n\n    if (toFile.exists ()) {\n        if (! toFile.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n\n        System.out.print (\"Overwrite existing file \" + toFile.getName () + \"? (Y/N): \");\n        System.out.flush ();\n        BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n        String response = in.readLine ();\n        if (! response.equals (\"Y\") && ! response.equals (\"y\")) throw new IOException (\"FileCopy: \" + \"existing file was not overwritten.\");\n\n    } else {\n        String parent = toFile.getParent ();\n        if (parent == null) parent = System.getProperty (\"user.dir\");\n\n        File dir = new File (parent);\n        if (! dir.exists ()) throw new IOException (\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n\n        if (dir.isFile ()) throw new IOException (\"FileCopy: \" + \"destination is not a directory: \" + parent);\n\n        if (! dir.canWrite ()) throw new IOException (\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n\n    }\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n        from = new FileInputStream (fromFile);\n        to = new FileOutputStream (toFile);\n        byte [] buffer = new byte [4096];\n        int bytesRead;\n        while ((bytesRead = from.read (buffer)) != - 1) to.write (buffer, 0, bytesRead);\n\n    } finally {\n        if (from != null) try {\n            from.close ();\n        } catch (IOException e) {\n        }\n\n        if (to != null) try {\n            to.close ();\n        } catch (IOException e) {\n        }\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1054944, "method2_id": 1992348, "code1": "public void evaluate () {\n    try {\n        if (evalClass != null && this.selectedModel != null) {\n            Constructor cons = evalClass.getConstructor (new Class [] {RefPackage.class});\n            Object evaluator = cons.newInstance (new Object [] {selectedModel.model});\n            results.clear ();\n            Method getConstraintNames = evaluator.getClass ().getDeclaredMethod (\"getConstraintNames\", null);\n            Method evaluate = evaluator.getClass ().getDeclaredMethod (\"evaluate\", new Class [] {String.class});\n            Object oConstraintNames = getConstraintNames.invoke (evaluator, null);\n            String [] constraintNames = (String []) oConstraintNames;\n            for (int i = 0;\n            i < constraintNames.length; i ++) {\n                Object result = evaluate.invoke (evaluator, new Object [] {constraintNames [i]});\n                results.addRow (constraintNames [i], result);\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "@Override\nprotected Object getDefaultVirtualDataObject (WidgetInfo widget) throws Exception {\n    ClassLoader classLoader = JavaInfoUtils.getClassLoader (this);\n    Class < ? > dataClass = classLoader.loadClass (\"com.gwtext.client.widgets.layout.AnchorLayoutData\");\n    return ReflectionUtils.getConstructor (dataClass, String.class).newInstance (\"100% 0\");\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 67506, "method2_id": 20918911, "code1": "private static StringBuilder deString (String aToken, StringBuilder aPage, String aLangCode, boolean jsEscape) {\n    Pattern p = Pattern.compile (aToken);\n    Matcher m = p.matcher (aPage);\n    String aCultString = \"\";\n    try {\n        BlitzCulture aCulture = (BlitzCulture) BlitzCulture.loadedCultures.get (aLangCode);\n        while (m.find ()) {\n            if (jsEscape) {\n                aCultString = aCulture.getString (m.group (2));\n                aCultString = _jsEscapeValue (aCultString);\n            } else {\n                aCultString = aCulture.getString (m.group (2));\n            }\n            if (BlitzServer.labelStrings == 1) aPage.replace (m.start (1), m.end (1), aCultString + \"[\" + m.group (2) + \"]\");\n            else aPage.replace (m.start (1), m.end (1), aCultString);\n\n        }\n    } catch (Exception e) {\n    }\n    return aPage;\n}\n", "code2": "private static void configureNamedPlugin (String iname) throws ClassNotFoundException {\n    int found = 0;\n    if (! namedPluginClasses.containsKey (iname)) {\n        String namedVal = ConfigurationManager.getProperty (NAMED_PREFIX + iname);\n        if (namedVal != null) {\n            namedVal = namedVal.trim ();\n            log.debug (\"Got Named configuration for interface=\" + iname + \", config=\" + namedVal);\n            Pattern classnameEqual = Pattern.compile (\"([\\\\w\\\\p{Sc}\\\\.]+)\\\\s*\\\\=\");\n            int prevEnd = - 1;\n            String prevClassName = null;\n            Matcher classMatcher = classnameEqual.matcher (namedVal);\n            while (classMatcher.find ()) {\n                if (prevClassName != null) found += installNamedConfigs (iname, prevClassName, namedVal.substring (prevEnd, classMatcher.start ()).trim ().split (\"\\\\s*,\\\\s*\"));\n\n                prevClassName = classMatcher.group (1);\n                prevEnd = classMatcher.end ();\n            }\n            if (prevClassName != null) found += installNamedConfigs (iname, prevClassName, namedVal.substring (prevEnd).trim ().split (\"\\\\s*,\\\\s*\"));\n\n        }\n        String selfNamedVal = ConfigurationManager.getProperty (SELFNAMED_PREFIX + iname);\n        if (selfNamedVal != null) {\n            String classnames [] = selfNamedVal.trim ().split (\"\\\\s*,\\\\s*\");\n            for (int i = 0;\n            i < classnames.length; ++ i) {\n                try {\n                    Class pluginClass = Class.forName (classnames [i]);\n                    String names [] = (String []) pluginClass.getMethod (\"getPluginNames\", null).invoke (null, null);\n                    if (names == null || names.length == 0) log.error (\"Self-named plugin class \\\"\" + classnames [i] + \"\\\" returned null or empty name list!\");\n                    else found += installNamedConfigs (iname, classnames [i], names);\n\n                } catch (NoSuchMethodException e) {\n                    log.error (\"Implementation Class \\\"\" + classnames [i] + \"\\\" is not a subclass of SelfNamedPlugin, it has no getPluginNames() method.\");\n                } catch (Exception e) {\n                    log.error (\"While configuring self-named plugin: \" + e.toString ());\n                }\n            }\n        }\n        namedPluginClasses.put (iname, \"org.dspace.core.marker\");\n        if (found == 0) log.error (\"No named plugins found for interface=\" + iname);\n\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 1082932, "method2_id": 5760098, "code1": "public void outputLogStats (OutputStream outputStream, List < LogStatsDTO > logStats) throws ServiceException, ResourceNotFoundException, ParseErrorException, Exception, MethodInvocationException, IOException {\n    if (outputStream instanceof ZipOutputStream) {\n        ((ZipOutputStream) outputStream).putNextEntry (new ZipEntry (getFileName ()));\n    }\n    DataProviderDTO dataProvider = null;\n    if (providerKey != null) {\n        dataProvider = dataResourceManager.getDataProviderFor (providerKey);\n    }\n    Map < Integer, LogStatsDTO > eventIdProviderStats = new HashMap < Integer, LogStatsDTO > ();\n    for (LogStatsDTO logStat : logStats) {\n        LogStatsDTO providerLogStats = eventIdProviderStats.get (logStat.getEventId ());\n        if (providerLogStats == null) {\n            providerLogStats = new LogStatsDTO ();\n            if (dataProvider == null) {\n                DataResourceDTO dataResource = dataResourceManager.getDataResourceFor (logStat.getEntityKey ());\n                providerLogStats.setEntityKey (dataResource.getDataProviderKey ());\n                providerLogStats.setEntityName (dataResource.getDataProviderName ());\n            } else {\n                providerLogStats.setEntityKey (dataProvider.getKey ());\n                providerLogStats.setEntityName (dataProvider.getName ());\n            }\n            providerLogStats.setEventId (logStat.getEventId ());\n            providerLogStats.setEventName (logStat.getEventName ());\n            providerLogStats.setEventCount (new Integer (0));\n            eventIdProviderStats.put (providerLogStats.getEventId (), providerLogStats);\n        }\n        if (logStat.getEventCount () != null) {\n            providerLogStats.setEventCount (providerLogStats.getEventCount () + logStat.getEventCount ());\n        }\n        if (logStat.getCount () != null) {\n            if (providerLogStats.getCount () == null) {\n                providerLogStats.setCount (logStat.getCount ());\n            } else {\n                providerLogStats.setCount (providerLogStats.getCount () + logStat.getCount ());\n            }\n        }\n    }\n    VelocityContext velocityContext = new VelocityContext ();\n    velocityContext.put (\"logQuery\", this);\n    velocityContext.put (\"date\", new DateFormatUtils ());\n    if (eventIdProviderStats != null) {\n        List < LogStatsDTO > providerStats = new ArrayList < LogStatsDTO > ();\n        for (Integer key : eventIdProviderStats.keySet ()) {\n            providerStats.add (eventIdProviderStats.get (key));\n        }\n        Collections.sort (providerStats, new Comparator < LogStatsDTO > () {\n            public int compare (LogStatsDTO ls1, LogStatsDTO ls2) {\n                if (! ls1.getEntityName ().equals (ls2.getEntityName ())) {\n                    return ls1.getEntityKey ().compareTo (ls2.getEntityName ());\n                } else {\n                    return ls1.getEventId ().compareTo (ls2.getEventId ());\n                }\n            }}\n\n        );\n        velocityContext.put (\"dataProviderStats\", providerStats);\n    }\n    if (dataProvider != null) {\n        velocityContext.put (\"dataProvider\", dataProvider);\n    }\n    velocityContext.put (\"dataResourceStats\", logStats);\n    Template template = Velocity.getTemplate (\"org/gbif/portal/io/logMessageStats.vm\");\n    template.initDocument ();\n    LogEventField lef = new LogEventField ();\n    lef.setFieldName (\"record.eventId\");\n    List < Field > downloadFields = new ArrayList < Field > ();\n    downloadFields.add (lef);\n    FieldFormatter ff = new FieldFormatter (downloadFields, messageSource, null, null);\n    velocityContext.put (\"propertyFormatter\", ff);\n    TemplateUtils tu = new TemplateUtils ();\n    OutputStreamWriter writer = new OutputStreamWriter (outputStream);\n    tu.merge (template, velocityContext, writer);\n    writer.flush ();\n    if (outputStream instanceof ZipOutputStream) {\n        addTemplate (outputStream, velocityContext, tu, \"org/gbif/portal/io/logMessageStatsHTML.vm\", \"log-statistics.html\");\n        addTemplate (outputStream, velocityContext, tu, \"org/gbif/portal/io/logMessageReadme.vm\", \"README.txt\");\n    }\n}\n", "code2": "private static void aggFile (ZipOutputStream out, String strPathOrigine, String nomefile) throws Exception {\n    String separatore = System.getProperty (\"file.separator\");\n    try {\n        FileInputStream fi = new FileInputStream (strPathOrigine + separatore + nomefile);\n        BufferedInputStream origin = new BufferedInputStream (fi, BUFFER);\n        ZipEntry entry = new ZipEntry (nomefile);\n        out.putNextEntry (entry);\n        int count;\n        while ((count = origin.read (data, 0, BUFFER)) != - 1) {\n            out.write (data, 0, count);\n        }\n        origin.close ();\n        origin = null;\n        fi.close ();\n        fi = null;\n    } catch (Exception e) {\n        new Exception (\"\\n aggFile: \" + e.getMessage () + \"\\n\");\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 13221213, "method2_id": 17874922, "code1": "public static Image load (final InputStream input, String format, Point dimension) throws CoreException {\n    MultiStatus status = new MultiStatus (GraphVizActivator.ID, 0, \"Errors occurred while running Graphviz\", null);\n    File dotInput = null, dotOutput = null;\n    ByteArrayOutputStream dotContents = new ByteArrayOutputStream ();\n    try {\n        dotInput = File.createTempFile (TMP_FILE_PREFIX, DOT_EXTENSION);\n        dotOutput = File.createTempFile (TMP_FILE_PREFIX, \".\" + format);\n        dotOutput.delete ();\n        FileOutputStream tmpDotOutputStream = null;\n        try {\n            IOUtils.copy (input, dotContents);\n            tmpDotOutputStream = new FileOutputStream (dotInput);\n            IOUtils.copy (new ByteArrayInputStream (dotContents.toByteArray ()), tmpDotOutputStream);\n        } finally {\n            IOUtils.closeQuietly (tmpDotOutputStream);\n        }\n        IStatus result = runDot (format, dimension, dotInput, dotOutput);\n        status.add (result);\n        status.add (logInput (dotContents));\n        if (dotOutput.isFile ()) {\n            if (! result.isOK () && Platform.inDebugMode ()) LogUtils.log (status);\n\n            ImageLoader loader = new ImageLoader ();\n            ImageData [] imageData = loader.load (dotOutput.getAbsolutePath ());\n            return new Image (Display.getDefault (), imageData [0]);\n        }\n    } catch (SWTException e) {\n        status.add (new Status (IStatus.ERROR, GraphVizActivator.ID, \"\", e));\n    } catch (IOException e) {\n        status.add (new Status (IStatus.ERROR, GraphVizActivator.ID, \"\", e));\n    } finally {\n        dotInput.delete ();\n        dotOutput.delete ();\n        IOUtils.closeQuietly (input);\n    }\n    throw new CoreException (status);\n}\n", "code2": "public static boolean buildPerMovieDiffBinary (String masterFile) {\n    try {\n        File inFile = new File (completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n        FileChannel inC = new FileInputStream (inFile).getChannel ();\n        System.out.println (inC.size ());\n        short movie1, movie2;\n        int count;\n        float diffRating, sumXY, sumX, sumY, sumX2, sumY2, pearsonCorr, adjustedCosineCorr, cosineCorr;\n        long position;\n        for (long i = 1;\n        i < 17770; i ++) {\n            File outFile = new File (\"C:\\\\NetflixData\\\\download\\\\SmartGrape\\\\CFItemToItemStats\\\\Movie--\" + i + \"-MatrixData.txt\");\n            FileChannel outC = new FileOutputStream (outFile, true).getChannel ();\n            ByteBuffer buf = ByteBuffer.allocate (17770 * 44);\n            for (long j = 1;\n            j < i; j ++) {\n                ByteBuffer bbuf = ByteBuffer.allocate (44);\n                position = 0;\n                position += new Long (17769).longValue () * new Long (17770).longValue () * new Long (22).longValue ();\n                position -= new Long ((17769 - (j - 1))).longValue () * new Long ((17770 - (j - 1))).longValue () * new Long (22).longValue ();\n                position += new Long ((i - j - 1) * 44).longValue ();\n                inC.position (position);\n                inC.read (bbuf);\n                bbuf.flip ();\n                buf.putShort (bbuf.getShort ());\n                bbuf.getShort ();\n                buf.putInt (bbuf.getInt ());\n                buf.putFloat (- bbuf.getInt ());\n                buf.putFloat (bbuf.getFloat ());\n                buf.putFloat (bbuf.getFloat ());\n                buf.putFloat (bbuf.getFloat ());\n                buf.putFloat (bbuf.getFloat ());\n                buf.putFloat (bbuf.getFloat ());\n                buf.putFloat (bbuf.getFloat ());\n                buf.putFloat (bbuf.getFloat ());\n                buf.putFloat (bbuf.getFloat ());\n            }\n            buf.putShort (new Long (i).shortValue ());\n            buf.putInt (0);\n            buf.putFloat (0);\n            buf.putFloat (0);\n            buf.putFloat (0);\n            buf.putFloat (0);\n            buf.putFloat (0);\n            buf.putFloat (0);\n            buf.putFloat (0);\n            buf.putFloat (0);\n            buf.putFloat (0);\n            position = 0;\n            position += new Long (17769).longValue () * new Long (17770).longValue () * new Long (22).longValue ();\n            position -= new Long ((17769 - (i - 1))).longValue () * new Long ((17770 - (i - 1))).longValue () * new Long (22).longValue ();\n            ByteBuffer remainingBuf = inC.map (FileChannel.MapMode.READ_ONLY, position, (17770 - i) * 44);\n            while (remainingBuf.hasRemaining ()) {\n                remainingBuf.getShort ();\n                buf.putShort (remainingBuf.getShort ());\n                buf.putInt (remainingBuf.getInt ());\n                buf.putFloat (remainingBuf.getFloat ());\n                buf.putFloat (remainingBuf.getFloat ());\n                buf.putFloat (remainingBuf.getFloat ());\n                buf.putFloat (remainingBuf.getFloat ());\n                buf.putFloat (remainingBuf.getFloat ());\n                buf.putFloat (remainingBuf.getFloat ());\n                buf.putFloat (remainingBuf.getFloat ());\n                buf.putFloat (remainingBuf.getFloat ());\n                buf.putFloat (remainingBuf.getFloat ());\n            }\n            buf.flip ();\n            outC.write (buf);\n            buf.clear ();\n            outC.close ();\n        }\n        return true;\n    } catch (Exception e) {\n        e.printStackTrace ();\n        return false;\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 22572312, "method2_id": 22999026, "code1": "public static byte [] zipEntriesAndFiles (Map < ZipEntry, byte [] > files) throws IOException {\n    ByteArrayOutputStream dest = new ByteArrayOutputStream ();\n    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));\n    byte [] data = new byte [2048];\n    Iterator < Entry < ZipEntry, byte [] > > itr = files.entrySet ().iterator ();\n    while (itr.hasNext ()) {\n        Entry < ZipEntry, byte [] > entry = itr.next ();\n        ByteArrayInputStream bytesIn = new ByteArrayInputStream (entry.getValue ());\n        BufferedInputStream origin = new BufferedInputStream (bytesIn, 2048);\n        out.putNextEntry (entry.getKey ());\n        int count;\n        while ((count = origin.read (data, 0, 2048)) != - 1) {\n            out.write (data, 0, count);\n        }\n        bytesIn.close ();\n        origin.close ();\n    }\n    out.close ();\n    byte [] outBytes = dest.toByteArray ();\n    dest.close ();\n    return outBytes;\n}\n", "code2": "public static void zipCompress (File sourceFile) throws Exception {\n    final int BUFFER_SIZE = 100000;\n    if (sourceFile.getName ().endsWith (\".zip\")) {\n    } else {\n        File targetFile = new File (sourceFile.getAbsolutePath () + \".zip\");\n        FileInputStream fis = new FileInputStream (sourceFile);\n        FileOutputStream fos = new FileOutputStream (targetFile);\n        ZipOutputStream zos = new ZipOutputStream (new BufferedOutputStream (fos));\n        BufferedInputStream bis = new BufferedInputStream (fis, BUFFER_SIZE);\n        ZipEntry entry = new ZipEntry (sourceFile.getName ());\n        zos.putNextEntry (entry);\n        int count;\n        byte data [] = new byte [BUFFER_SIZE];\n        while ((count = bis.read (data, 0, BUFFER_SIZE)) != - 1) {\n            zos.write (data, 0, count);\n        }\n        bis.close ();\n        zos.close ();\n    }\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 3459107, "method2_id": 4591683, "code1": "private static boolean hardCopy (File sourceFile, File destinationFile, StringBuffer errorLog) {\n    boolean result = true;\n    try {\n        notifyCopyStart (destinationFile);\n        destinationFile.getParentFile ().mkdirs ();\n        byte [] buffer = new byte [4096];\n        int len = 0;\n        FileInputStream in = new FileInputStream (sourceFile);\n        FileOutputStream out = new FileOutputStream (destinationFile);\n        while ((len = in.read (buffer)) != - 1) out.write (buffer, 0, len);\n\n        in.close ();\n        out.close ();\n    } catch (Exception e) {\n        result = false;\n        handleException (\"\\n Error in method: copy!\\n\", e, errorLog);\n    } finally {\n        notifyCopyEnd (destinationFile);\n    }\n    return result;\n}\n", "code2": "public static void copyFile (File source, File dest) throws IOException {\n    if (source.equals (dest)) throw new IOException (\"Source and destination cannot be the same file path\");\n\n    FileChannel srcChannel = new FileInputStream (source).getChannel ();\n    if (! dest.exists ()) dest.createNewFile ();\n\n    FileChannel dstChannel = new FileOutputStream (dest).getChannel ();\n    dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());\n    srcChannel.close ();\n    dstChannel.close ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 2195113, "method2_id": 16712484, "code1": "public static void writeProjectToFile (Project p, File proj_file) throws Exception {\n    ZipOutputStream zout = openZipArchive (proj_file);\n    String xml = SerializationHelper.getXMLForProject (p);\n    writeXMLToZipArchive (\"quickvol_project.xml\", xml, zout);\n    if (p.getStack ().getLayers () != null) {\n        for (int a = 0;\n        a < p.getStack ().getLayers ().length; a ++) {\n            String fname = p.getStack ().getLayers () [a].getName ();\n            String entryname = null;\n            if (fname.toLowerCase ().endsWith (\".png\")) entryname = fname;\n            else {\n                entryname = fname + \".png\";\n            }\n            ZipEntry entry = new ZipEntry (entryname);\n            zout.putNextEntry (entry);\n            javax.imageio.ImageIO.write (p.getStack ().getLayers () [a].getOrigImage (), \"png\", zout);\n        }\n    }\n    zout.close ();\n}\n", "code2": "private static void exportMetadataItem (ZipOutputStream aZOS, JStellaGame aMetadata) throws IOException {\n    ZipEntry zEntry = new ZipEntry (aMetadata.getGameFilename ());\n    aZOS.putNextEntry (zEntry);\n    byte [] zData = toByteArray (aMetadata);\n    aZOS.write (zData);\n    aZOS.closeEntry ();\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 212783, "method2_id": 277689, "code1": "public File [] doFilesOpen () {\n    JFileChooser chooser = new JFileChooser ();\n    ArchiveFilter filter = new ArchiveFilter ();\n    filter.addExtension (\"jar\");\n    filter.addExtension (\"zip\");\n    filter.setDescription (\"Jar & Zip Files\");\n    File root = new File (\"/fuegotech3.1.3\");\n    chooser.setCurrentDirectory (root);\n    chooser.setMultiSelectionEnabled (true);\n    chooser.setFileSelectionMode (JFileChooser.FILES_AND_DIRECTORIES);\n    chooser.setFileFilter (filter);\n    int returnVal = chooser.showOpenDialog (_getFrame (this));\n    if (returnVal == JFileChooser.APPROVE_OPTION) {\n        return chooser.getSelectedFiles ();\n    } else {\n        return null;\n    }\n}\n", "code2": "private void miOpenActionPerformed (ActionEvent evt) {\n    JFileChooser chooser = new JFileChooser (dir);\n    chooser.setFileSelectionMode (JFileChooser.FILES_ONLY);\n    ExtensionFileFilter filter = new ExtensionFileFilter (\"grf\", \"GRAPH representation files (*.grf)\");\n    chooser.setFileFilter (filter);\n    int res = chooser.showOpenDialog (this);\n    String filename = chooser.getSelectedFile ().getPath ();\n    try {\n        Document doc = jReport.getDocument ();\n        doc.remove (0, doc.getLength ());\n        Graph graf = new Graph (filename);\n        dir = chooser.getSelectedFile ().getParent ();\n        drawer.setGraph (graf, dir);\n        setTitle (frameName + \" \" + filename);\n    } catch (Graph.GraphConstructorException ex) {\n        jReport.append (\"Error: file <\" + filename + \"> has illegal format or not exist\\n\");\n    } catch (java.io.EOFException ex) {\n        jReport.append (\"Error: \" + ex.getMessage () + \" file format not recognized\\n\");\n    } catch (BadLocationException ex) {\n        System.out.println (ex);\n    }\n    invalidate ();\n    validate ();\n    repaint ();\n    System.out.println (filename);\n}\n"}
{"clone_type": "WT3_T4", "method1_id": 5967901, "method2_id": 12783713, "code1": "public void run () {\n    try {\n        IOUtils.copy (in, out);\n    } catch (IOException e) {\n        e.printStackTrace ();\n    }\n}\n", "code2": "@Override\npublic void sendErrorMessage (String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n    if (query == null) {\n        throw new NotConnectedException ();\n    }\n    ArrayList < String > recipients = query.getUserManager ().getTecMail ();\n    Mail mail = new Mail (recipients);\n    try {\n        ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (\"log/ossobooklog.zip\"));\n        FileInputStream fis = new FileInputStream (\"log/ossobook.log\");\n        ZipEntry entry = new ZipEntry (\"ossobook.log\");\n        zos.putNextEntry (entry);\n        byte [] buffer = new byte [8192];\n        int read = 0;\n        while ((read = fis.read (buffer, 0, 1024)) != - 1) {\n            zos.write (buffer, 0, read);\n        }\n        zos.closeEntry ();\n        fis.close ();\n        zos.close ();\n        mail.sendErrorMessage (message, new File (\"log/ossobooklog.zip\"), getUserName ());\n    } catch (Exception ex) {\n        ex.printStackTrace ();\n    }\n}\n"}
